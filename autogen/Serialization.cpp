
#include <ThreadStruct.hpp>

#include <schema.capnp.h>
using namespace capnp;

#include <Serialization.hpp>
#include <Server.hpp>
#include <Synchronization.hpp>
#include <map>


typedef struct {
    void* pUserData;

uintptr_t PFN_vkFreeFunction;
uintptr_t PFN_vkFaultCallbackFunction;
uintptr_t PFN_vkDebugReportCallbackEXT;
uintptr_t PFN_vkDebugUtilsMessengerCallbackEXT;
uintptr_t PFN_vkDeviceMemoryReportCallbackEXT;
uintptr_t PFN_vkVoidFunction;
uintptr_t PFN_vkInternalAllocationNotification;
uintptr_t PFN_vkAllocationFunction;
uintptr_t PFN_vkGetInstanceProcAddrLUNARG;
uintptr_t PFN_vkReallocationFunction;
uintptr_t PFN_vkInternalFreeNotification;
} pUserData;

void serialize_pNext(stream::PNext::Builder builder, void* member){
    if (member==NULL){
        builder.setNone();
        return;
    }
    
    auto chain=((VkBaseInStructure*)member);
    switch(chain->sType){


    case VK_STRUCTURE_TYPE_APPLICATION_INFO:
        {
        auto temp=builder.getVkApplicationInfo();
        return serialize_struct(temp, ((VkApplicationInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
        {
        auto temp=builder.getVkDeviceQueueCreateInfo();
        return serialize_struct(temp, ((VkDeviceQueueCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
        {
        auto temp=builder.getVkDeviceCreateInfo();
        return serialize_struct(temp, ((VkDeviceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
        {
        auto temp=builder.getVkInstanceCreateInfo();
        return serialize_struct(temp, ((VkInstanceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
        {
        auto temp=builder.getVkMemoryAllocateInfo();
        return serialize_struct(temp, ((VkMemoryAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
        {
        auto temp=builder.getVkMappedMemoryRange();
        return serialize_struct(temp, ((VkMappedMemoryRange*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
        {
        auto temp=builder.getVkWriteDescriptorSet();
        return serialize_struct(temp, ((VkWriteDescriptorSet*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
        {
        auto temp=builder.getVkCopyDescriptorSet();
        return serialize_struct(temp, ((VkCopyDescriptorSet*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkBufferUsageFlags2CreateInfoKHR();
        return serialize_struct(temp, ((VkBufferUsageFlags2CreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
        {
        auto temp=builder.getVkBufferCreateInfo();
        return serialize_struct(temp, ((VkBufferCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
        {
        auto temp=builder.getVkBufferViewCreateInfo();
        return serialize_struct(temp, ((VkBufferViewCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
        {
        auto temp=builder.getVkMemoryBarrier();
        return serialize_struct(temp, ((VkMemoryBarrier*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
        {
        auto temp=builder.getVkBufferMemoryBarrier();
        return serialize_struct(temp, ((VkBufferMemoryBarrier*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
        {
        auto temp=builder.getVkImageMemoryBarrier();
        return serialize_struct(temp, ((VkImageMemoryBarrier*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
        {
        auto temp=builder.getVkImageCreateInfo();
        return serialize_struct(temp, ((VkImageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
        {
        auto temp=builder.getVkImageViewCreateInfo();
        return serialize_struct(temp, ((VkImageViewCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
        {
        auto temp=builder.getVkBindSparseInfo();
        return serialize_struct(temp, ((VkBindSparseInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {
        auto temp=builder.getVkShaderModuleCreateInfo();
        return serialize_struct(temp, ((VkShaderModuleCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
        {
        auto temp=builder.getVkDescriptorSetLayoutCreateInfo();
        return serialize_struct(temp, ((VkDescriptorSetLayoutCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
        {
        auto temp=builder.getVkDescriptorPoolCreateInfo();
        return serialize_struct(temp, ((VkDescriptorPoolCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
        {
        auto temp=builder.getVkDescriptorSetAllocateInfo();
        return serialize_struct(temp, ((VkDescriptorSetAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineShaderStageCreateInfo();
        return serialize_struct(temp, ((VkPipelineShaderStageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
        {
        auto temp=builder.getVkComputePipelineCreateInfo();
        return serialize_struct(temp, ((VkComputePipelineCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
        {
        auto temp=builder.getVkComputePipelineIndirectBufferInfoNV();
        return serialize_struct(temp, ((VkComputePipelineIndirectBufferInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkPipelineCreateFlags2CreateInfoKHR();
        return serialize_struct(temp, ((VkPipelineCreateFlags2CreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineVertexInputStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineVertexInputStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineInputAssemblyStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineInputAssemblyStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineTessellationStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineTessellationStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineViewportStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineViewportStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineRasterizationStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineRasterizationStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineMultisampleStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineMultisampleStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineColorBlendStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineColorBlendStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineDynamicStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineDynamicStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineDepthStencilStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineDepthStencilStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
        {
        auto temp=builder.getVkGraphicsPipelineCreateInfo();
        return serialize_struct(temp, ((VkGraphicsPipelineCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineCacheCreateInfo();
        return serialize_struct(temp, ((VkPipelineCacheCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineLayoutCreateInfo();
        return serialize_struct(temp, ((VkPipelineLayoutCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
        {
        auto temp=builder.getVkSamplerCreateInfo();
        return serialize_struct(temp, ((VkSamplerCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
        {
        auto temp=builder.getVkCommandPoolCreateInfo();
        return serialize_struct(temp, ((VkCommandPoolCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
        {
        auto temp=builder.getVkCommandBufferAllocateInfo();
        return serialize_struct(temp, ((VkCommandBufferAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
        {
        auto temp=builder.getVkCommandBufferInheritanceInfo();
        return serialize_struct(temp, ((VkCommandBufferInheritanceInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
        {
        auto temp=builder.getVkCommandBufferBeginInfo();
        return serialize_struct(temp, ((VkCommandBufferBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
        {
        auto temp=builder.getVkRenderPassBeginInfo();
        return serialize_struct(temp, ((VkRenderPassBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
        {
        auto temp=builder.getVkRenderPassCreateInfo();
        return serialize_struct(temp, ((VkRenderPassCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
        {
        auto temp=builder.getVkEventCreateInfo();
        return serialize_struct(temp, ((VkEventCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
        {
        auto temp=builder.getVkFenceCreateInfo();
        return serialize_struct(temp, ((VkFenceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
        {
        auto temp=builder.getVkSemaphoreCreateInfo();
        return serialize_struct(temp, ((VkSemaphoreCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
        {
        auto temp=builder.getVkQueryPoolCreateInfo();
        return serialize_struct(temp, ((VkQueryPoolCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
        {
        auto temp=builder.getVkFramebufferCreateInfo();
        return serialize_struct(temp, ((VkFramebufferCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBMIT_INFO:
        {
        auto temp=builder.getVkSubmitInfo();
        return serialize_struct(temp, ((VkSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkDisplayModeCreateInfoKHR();
        return serialize_struct(temp, ((VkDisplayModeCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkDisplaySurfaceCreateInfoKHR();
        return serialize_struct(temp, ((VkDisplaySurfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {
        auto temp=builder.getVkDisplayPresentInfoKHR();
        return serialize_struct(temp, ((VkDisplayPresentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkXlibSurfaceCreateInfoKHR();
        return serialize_struct(temp, ((VkXlibSurfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkXcbSurfaceCreateInfoKHR();
        return serialize_struct(temp, ((VkXcbSurfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkSwapchainCreateInfoKHR();
        return serialize_struct(temp, ((VkSwapchainCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
        {
        auto temp=builder.getVkPresentInfoKHR();
        return serialize_struct(temp, ((VkPresentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkDebugReportCallbackCreateInfoEXT();
        return serialize_struct(temp, ((VkDebugReportCallbackCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
        auto temp=builder.getVkValidationFlagsEXT();
        return serialize_struct(temp, ((VkValidationFlagsEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
        auto temp=builder.getVkValidationFeaturesEXT();
        return serialize_struct(temp, ((VkValidationFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
        auto temp=builder.getVkPipelineRasterizationStateRasterizationOrderAMD();
        return serialize_struct(temp, ((VkPipelineRasterizationStateRasterizationOrderAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
        {
        auto temp=builder.getVkDebugMarkerObjectNameInfoEXT();
        return serialize_struct(temp, ((VkDebugMarkerObjectNameInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
        {
        auto temp=builder.getVkDebugMarkerObjectTagInfoEXT();
        return serialize_struct(temp, ((VkDebugMarkerObjectTagInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
        {
        auto temp=builder.getVkDebugMarkerMarkerInfoEXT();
        return serialize_struct(temp, ((VkDebugMarkerMarkerInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkDedicatedAllocationImageCreateInfoNV();
        return serialize_struct(temp, ((VkDedicatedAllocationImageCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
        auto temp=builder.getVkDedicatedAllocationBufferCreateInfoNV();
        return serialize_struct(temp, ((VkDedicatedAllocationBufferCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
        auto temp=builder.getVkDedicatedAllocationMemoryAllocateInfoNV();
        return serialize_struct(temp, ((VkDedicatedAllocationMemoryAllocateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkExternalMemoryImageCreateInfoNV();
        return serialize_struct(temp, ((VkExternalMemoryImageCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {
        auto temp=builder.getVkExportMemoryAllocateInfoNV();
        return serialize_struct(temp, ((VkExportMemoryAllocateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
        auto temp=builder.getVkDevicePrivateDataCreateInfo();
        return serialize_struct(temp, ((VkDevicePrivateDataCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO:
        {
        auto temp=builder.getVkPrivateDataSlotCreateInfo();
        return serialize_struct(temp, ((VkPrivateDataSlotCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
        auto temp=builder.getVkPhysicalDevicePrivateDataFeatures();
        return serialize_struct(temp, ((VkPhysicalDevicePrivateDataFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMultiDrawPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMultiDrawPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV:
        {
        auto temp=builder.getVkGraphicsShaderGroupCreateInfoNV();
        return serialize_struct(temp, ((VkGraphicsShaderGroupCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
        auto temp=builder.getVkGraphicsPipelineShaderGroupsCreateInfoNV();
        return serialize_struct(temp, ((VkGraphicsPipelineShaderGroupsCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV:
        {
        auto temp=builder.getVkIndirectCommandsLayoutTokenNV();
        return serialize_struct(temp, ((VkIndirectCommandsLayoutTokenNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV:
        {
        auto temp=builder.getVkIndirectCommandsLayoutCreateInfoNV();
        return serialize_struct(temp, ((VkIndirectCommandsLayoutCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV:
        {
        auto temp=builder.getVkGeneratedCommandsInfoNV();
        return serialize_struct(temp, ((VkGeneratedCommandsInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV:
        {
        auto temp=builder.getVkGeneratedCommandsMemoryRequirementsInfoNV();
        return serialize_struct(temp, ((VkGeneratedCommandsMemoryRequirementsInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV:
        {
        auto temp=builder.getVkPipelineIndirectDeviceAddressInfoNV();
        return serialize_struct(temp, ((VkPipelineIndirectDeviceAddressInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
        auto temp=builder.getVkPhysicalDeviceFeatures2();
        return serialize_struct(temp, ((VkPhysicalDeviceFeatures2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
        {
        auto temp=builder.getVkPhysicalDeviceProperties2();
        return serialize_struct(temp, ((VkPhysicalDeviceProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
        {
        auto temp=builder.getVkFormatProperties2();
        return serialize_struct(temp, ((VkFormatProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
        {
        auto temp=builder.getVkImageFormatProperties2();
        return serialize_struct(temp, ((VkImageFormatProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
        {
        auto temp=builder.getVkPhysicalDeviceImageFormatInfo2();
        return serialize_struct(temp, ((VkPhysicalDeviceImageFormatInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
        {
        auto temp=builder.getVkQueueFamilyProperties2();
        return serialize_struct(temp, ((VkQueueFamilyProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
        {
        auto temp=builder.getVkPhysicalDeviceMemoryProperties2();
        return serialize_struct(temp, ((VkPhysicalDeviceMemoryProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
        {
        auto temp=builder.getVkSparseImageFormatProperties2();
        return serialize_struct(temp, ((VkSparseImageFormatProperties2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
        {
        auto temp=builder.getVkPhysicalDeviceSparseImageFormatInfo2();
        return serialize_struct(temp, ((VkPhysicalDeviceSparseImageFormatInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDevicePushDescriptorPropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDevicePushDescriptorPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceDriverProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceDriverProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
        auto temp=builder.getVkPresentRegionsKHR();
        return serialize_struct(temp, ((VkPresentRegionsKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceVariablePointersFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceVariablePointersFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
        auto temp=builder.getVkPhysicalDeviceExternalImageFormatInfo();
        return serialize_struct(temp, ((VkPhysicalDeviceExternalImageFormatInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
        auto temp=builder.getVkExternalImageFormatProperties();
        return serialize_struct(temp, ((VkExternalImageFormatProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
        {
        auto temp=builder.getVkPhysicalDeviceExternalBufferInfo();
        return serialize_struct(temp, ((VkPhysicalDeviceExternalBufferInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
        {
        auto temp=builder.getVkExternalBufferProperties();
        return serialize_struct(temp, ((VkExternalBufferProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceIDProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceIDProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
        auto temp=builder.getVkExternalMemoryImageCreateInfo();
        return serialize_struct(temp, ((VkExternalMemoryImageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
        auto temp=builder.getVkExternalMemoryBufferCreateInfo();
        return serialize_struct(temp, ((VkExternalMemoryBufferCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
        auto temp=builder.getVkExportMemoryAllocateInfo();
        return serialize_struct(temp, ((VkExportMemoryAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {
        auto temp=builder.getVkImportMemoryFdInfoKHR();
        return serialize_struct(temp, ((VkImportMemoryFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
        {
        auto temp=builder.getVkMemoryFdPropertiesKHR();
        return serialize_struct(temp, ((VkMemoryFdPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
        {
        auto temp=builder.getVkMemoryGetFdInfoKHR();
        return serialize_struct(temp, ((VkMemoryGetFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
        {
        auto temp=builder.getVkPhysicalDeviceExternalSemaphoreInfo();
        return serialize_struct(temp, ((VkPhysicalDeviceExternalSemaphoreInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
        {
        auto temp=builder.getVkExternalSemaphoreProperties();
        return serialize_struct(temp, ((VkExternalSemaphoreProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
        auto temp=builder.getVkExportSemaphoreCreateInfo();
        return serialize_struct(temp, ((VkExportSemaphoreCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
        {
        auto temp=builder.getVkImportSemaphoreFdInfoKHR();
        return serialize_struct(temp, ((VkImportSemaphoreFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
        {
        auto temp=builder.getVkSemaphoreGetFdInfoKHR();
        return serialize_struct(temp, ((VkSemaphoreGetFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
        {
        auto temp=builder.getVkPhysicalDeviceExternalFenceInfo();
        return serialize_struct(temp, ((VkPhysicalDeviceExternalFenceInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
        {
        auto temp=builder.getVkExternalFenceProperties();
        return serialize_struct(temp, ((VkExternalFenceProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
        auto temp=builder.getVkExportFenceCreateInfo();
        return serialize_struct(temp, ((VkExportFenceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
        {
        auto temp=builder.getVkImportFenceFdInfoKHR();
        return serialize_struct(temp, ((VkImportFenceFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
        {
        auto temp=builder.getVkFenceGetFdInfoKHR();
        return serialize_struct(temp, ((VkFenceGetFdInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceMultiviewFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceMultiviewFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceMultiviewProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceMultiviewProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
        auto temp=builder.getVkRenderPassMultiviewCreateInfo();
        return serialize_struct(temp, ((VkRenderPassMultiviewCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
        {
        auto temp=builder.getVkSurfaceCapabilities2EXT();
        return serialize_struct(temp, ((VkSurfaceCapabilities2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
        {
        auto temp=builder.getVkDisplayPowerInfoEXT();
        return serialize_struct(temp, ((VkDisplayPowerInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
        {
        auto temp=builder.getVkDeviceEventInfoEXT();
        return serialize_struct(temp, ((VkDeviceEventInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
        {
        auto temp=builder.getVkDisplayEventInfoEXT();
        return serialize_struct(temp, ((VkDisplayEventInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkSwapchainCounterCreateInfoEXT();
        return serialize_struct(temp, ((VkSwapchainCounterCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceGroupProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceGroupProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
        auto temp=builder.getVkMemoryAllocateFlagsInfo();
        return serialize_struct(temp, ((VkMemoryAllocateFlagsInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
        {
        auto temp=builder.getVkBindBufferMemoryInfo();
        return serialize_struct(temp, ((VkBindBufferMemoryInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
        auto temp=builder.getVkBindBufferMemoryDeviceGroupInfo();
        return serialize_struct(temp, ((VkBindBufferMemoryDeviceGroupInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
        {
        auto temp=builder.getVkBindImageMemoryInfo();
        return serialize_struct(temp, ((VkBindImageMemoryInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
        auto temp=builder.getVkBindImageMemoryDeviceGroupInfo();
        return serialize_struct(temp, ((VkBindImageMemoryDeviceGroupInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
        auto temp=builder.getVkDeviceGroupRenderPassBeginInfo();
        return serialize_struct(temp, ((VkDeviceGroupRenderPassBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
        auto temp=builder.getVkDeviceGroupCommandBufferBeginInfo();
        return serialize_struct(temp, ((VkDeviceGroupCommandBufferBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
        auto temp=builder.getVkDeviceGroupSubmitInfo();
        return serialize_struct(temp, ((VkDeviceGroupSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
        auto temp=builder.getVkDeviceGroupBindSparseInfo();
        return serialize_struct(temp, ((VkDeviceGroupBindSparseInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
        {
        auto temp=builder.getVkDeviceGroupPresentCapabilitiesKHR();
        return serialize_struct(temp, ((VkDeviceGroupPresentCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkImageSwapchainCreateInfoKHR();
        return serialize_struct(temp, ((VkImageSwapchainCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
        auto temp=builder.getVkBindImageMemorySwapchainInfoKHR();
        return serialize_struct(temp, ((VkBindImageMemorySwapchainInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
        {
        auto temp=builder.getVkAcquireNextImageInfoKHR();
        return serialize_struct(temp, ((VkAcquireNextImageInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
        auto temp=builder.getVkDeviceGroupPresentInfoKHR();
        return serialize_struct(temp, ((VkDeviceGroupPresentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
        auto temp=builder.getVkDeviceGroupDeviceCreateInfo();
        return serialize_struct(temp, ((VkDeviceGroupDeviceCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkDeviceGroupSwapchainCreateInfoKHR();
        return serialize_struct(temp, ((VkDeviceGroupSwapchainCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
        {
        auto temp=builder.getVkDescriptorUpdateTemplateCreateInfo();
        return serialize_struct(temp, ((VkDescriptorUpdateTemplateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDevicePresentIdFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDevicePresentIdFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {
        auto temp=builder.getVkPresentIdKHR();
        return serialize_struct(temp, ((VkPresentIdKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDevicePresentWaitFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDevicePresentWaitFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
        {
        auto temp=builder.getVkHdrMetadataEXT();
        return serialize_struct(temp, ((VkHdrMetadataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {
        auto temp=builder.getVkDisplayNativeHdrSurfaceCapabilitiesAMD();
        return serialize_struct(temp, ((VkDisplayNativeHdrSurfaceCapabilitiesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {
        auto temp=builder.getVkSwapchainDisplayNativeHdrCreateInfoAMD();
        return serialize_struct(temp, ((VkSwapchainDisplayNativeHdrCreateInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {
        auto temp=builder.getVkPresentTimesInfoGOOGLE();
        return serialize_struct(temp, ((VkPresentTimesInfoGOOGLE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineViewportWScalingStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineViewportWScalingStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineViewportSwizzleStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineViewportSwizzleStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDiscardRectanglePropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDiscardRectanglePropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineDiscardRectangleStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineDiscardRectangleStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {
        auto temp=builder.getVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
        return serialize_struct(temp, ((VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
        auto temp=builder.getVkRenderPassInputAttachmentAspectCreateInfo();
        return serialize_struct(temp, ((VkRenderPassInputAttachmentAspectCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceSurfaceInfo2KHR();
        return serialize_struct(temp, ((VkPhysicalDeviceSurfaceInfo2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
        {
        auto temp=builder.getVkSurfaceCapabilities2KHR();
        return serialize_struct(temp, ((VkSurfaceCapabilities2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
        {
        auto temp=builder.getVkSurfaceFormat2KHR();
        return serialize_struct(temp, ((VkSurfaceFormat2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
        {
        auto temp=builder.getVkDisplayProperties2KHR();
        return serialize_struct(temp, ((VkDisplayProperties2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
        {
        auto temp=builder.getVkDisplayPlaneProperties2KHR();
        return serialize_struct(temp, ((VkDisplayPlaneProperties2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
        {
        auto temp=builder.getVkDisplayModeProperties2KHR();
        return serialize_struct(temp, ((VkDisplayModeProperties2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
        {
        auto temp=builder.getVkDisplayPlaneInfo2KHR();
        return serialize_struct(temp, ((VkDisplayPlaneInfo2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
        {
        auto temp=builder.getVkDisplayPlaneCapabilities2KHR();
        return serialize_struct(temp, ((VkDisplayPlaneCapabilities2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {
        auto temp=builder.getVkSharedPresentSurfaceCapabilitiesKHR();
        return serialize_struct(temp, ((VkSharedPresentSurfaceCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
        auto temp=builder.getVkPhysicalDevice16BitStorageFeatures();
        return serialize_struct(temp, ((VkPhysicalDevice16BitStorageFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceSubgroupProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceSubgroupProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
        {
        auto temp=builder.getVkBufferMemoryRequirementsInfo2();
        return serialize_struct(temp, ((VkBufferMemoryRequirementsInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS:
        {
        auto temp=builder.getVkDeviceBufferMemoryRequirements();
        return serialize_struct(temp, ((VkDeviceBufferMemoryRequirements*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
        {
        auto temp=builder.getVkImageMemoryRequirementsInfo2();
        return serialize_struct(temp, ((VkImageMemoryRequirementsInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
        {
        auto temp=builder.getVkImageSparseMemoryRequirementsInfo2();
        return serialize_struct(temp, ((VkImageSparseMemoryRequirementsInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS:
        {
        auto temp=builder.getVkDeviceImageMemoryRequirements();
        return serialize_struct(temp, ((VkDeviceImageMemoryRequirements*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
        {
        auto temp=builder.getVkMemoryRequirements2();
        return serialize_struct(temp, ((VkMemoryRequirements2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
        {
        auto temp=builder.getVkSparseImageMemoryRequirements2();
        return serialize_struct(temp, ((VkSparseImageMemoryRequirements2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDevicePointClippingProperties();
        return serialize_struct(temp, ((VkPhysicalDevicePointClippingProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
        auto temp=builder.getVkMemoryDedicatedRequirements();
        return serialize_struct(temp, ((VkMemoryDedicatedRequirements*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
        auto temp=builder.getVkMemoryDedicatedAllocateInfo();
        return serialize_struct(temp, ((VkMemoryDedicatedAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
        auto temp=builder.getVkImageViewUsageCreateInfo();
        return serialize_struct(temp, ((VkImageViewUsageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkImageViewSlicedCreateInfoEXT();
        return serialize_struct(temp, ((VkImageViewSlicedCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineTessellationDomainOriginStateCreateInfo();
        return serialize_struct(temp, ((VkPipelineTessellationDomainOriginStateCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
        auto temp=builder.getVkSamplerYcbcrConversionInfo();
        return serialize_struct(temp, ((VkSamplerYcbcrConversionInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
        {
        auto temp=builder.getVkSamplerYcbcrConversionCreateInfo();
        return serialize_struct(temp, ((VkSamplerYcbcrConversionCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
        auto temp=builder.getVkBindImagePlaneMemoryInfo();
        return serialize_struct(temp, ((VkBindImagePlaneMemoryInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
        auto temp=builder.getVkImagePlaneMemoryRequirementsInfo();
        return serialize_struct(temp, ((VkImagePlaneMemoryRequirementsInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceSamplerYcbcrConversionFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceSamplerYcbcrConversionFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
        auto temp=builder.getVkSamplerYcbcrConversionImageFormatProperties();
        return serialize_struct(temp, ((VkSamplerYcbcrConversionImageFormatProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
        auto temp=builder.getVkTextureLODGatherFormatPropertiesAMD();
        return serialize_struct(temp, ((VkTextureLODGatherFormatPropertiesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
        {
        auto temp=builder.getVkConditionalRenderingBeginInfoEXT();
        return serialize_struct(temp, ((VkConditionalRenderingBeginInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
        auto temp=builder.getVkProtectedSubmitInfo();
        return serialize_struct(temp, ((VkProtectedSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceProtectedMemoryFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceProtectedMemoryFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceProtectedMemoryProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceProtectedMemoryProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
        {
        auto temp=builder.getVkDeviceQueueInfo2();
        return serialize_struct(temp, ((VkDeviceQueueInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineCoverageToColorStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineCoverageToColorStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceSamplerFilterMinmaxProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceSamplerFilterMinmaxProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
        auto temp=builder.getVkSampleLocationsInfoEXT();
        return serialize_struct(temp, ((VkSampleLocationsInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
        auto temp=builder.getVkRenderPassSampleLocationsBeginInfoEXT();
        return serialize_struct(temp, ((VkRenderPassSampleLocationsBeginInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineSampleLocationsStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineSampleLocationsStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceSampleLocationsPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceSampleLocationsPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
        {
        auto temp=builder.getVkMultisamplePropertiesEXT();
        return serialize_struct(temp, ((VkMultisamplePropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
        auto temp=builder.getVkSamplerReductionModeCreateInfo();
        return serialize_struct(temp, ((VkSamplerReductionModeCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMultiDrawFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMultiDrawFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineColorBlendAdvancedStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineColorBlendAdvancedStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceInlineUniformBlockFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceInlineUniformBlockFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceInlineUniformBlockProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceInlineUniformBlockProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
        {
        auto temp=builder.getVkWriteDescriptorSetInlineUniformBlock();
        return serialize_struct(temp, ((VkWriteDescriptorSetInlineUniformBlock*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
        {
        auto temp=builder.getVkDescriptorPoolInlineUniformBlockCreateInfo();
        return serialize_struct(temp, ((VkDescriptorPoolInlineUniformBlockCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineCoverageModulationStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineCoverageModulationStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
        auto temp=builder.getVkImageFormatListCreateInfo();
        return serialize_struct(temp, ((VkImageFormatListCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkValidationCacheCreateInfoEXT();
        return serialize_struct(temp, ((VkValidationCacheCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkShaderModuleValidationCacheCreateInfoEXT();
        return serialize_struct(temp, ((VkShaderModuleValidationCacheCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceMaintenance3Properties();
        return serialize_struct(temp, ((VkPhysicalDeviceMaintenance3Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceMaintenance4Features();
        return serialize_struct(temp, ((VkPhysicalDeviceMaintenance4Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceMaintenance4Properties();
        return serialize_struct(temp, ((VkPhysicalDeviceMaintenance4Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceMaintenance5FeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceMaintenance5FeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceMaintenance5PropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceMaintenance5PropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR:
        {
        auto temp=builder.getVkRenderingAreaInfoKHR();
        return serialize_struct(temp, ((VkRenderingAreaInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
        {
        auto temp=builder.getVkDescriptorSetLayoutSupport();
        return serialize_struct(temp, ((VkDescriptorSetLayoutSupport*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderDrawParametersFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderDrawParametersFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderFloat16Int8Features();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderFloat16Int8Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceFloatControlsProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceFloatControlsProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceHostQueryResetFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceHostQueryResetFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkDeviceQueueGlobalPriorityCreateInfoKHR();
        return serialize_struct(temp, ((VkDeviceQueueGlobalPriorityCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceGlobalPriorityQueryFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
        {
        auto temp=builder.getVkQueueFamilyGlobalPriorityPropertiesKHR();
        return serialize_struct(temp, ((VkQueueFamilyGlobalPriorityPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {
        auto temp=builder.getVkDebugUtilsObjectNameInfoEXT();
        return serialize_struct(temp, ((VkDebugUtilsObjectNameInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
        {
        auto temp=builder.getVkDebugUtilsObjectTagInfoEXT();
        return serialize_struct(temp, ((VkDebugUtilsObjectTagInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
        {
        auto temp=builder.getVkDebugUtilsLabelEXT();
        return serialize_struct(temp, ((VkDebugUtilsLabelEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkDebugUtilsMessengerCreateInfoEXT();
        return serialize_struct(temp, ((VkDebugUtilsMessengerCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
        {
        auto temp=builder.getVkDebugUtilsMessengerCallbackDataEXT();
        return serialize_struct(temp, ((VkDebugUtilsMessengerCallbackDataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDeviceMemoryReportFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkDeviceDeviceMemoryReportCreateInfoEXT();
        return serialize_struct(temp, ((VkDeviceDeviceMemoryReportCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT:
        {
        auto temp=builder.getVkDeviceMemoryReportCallbackDataEXT();
        return serialize_struct(temp, ((VkDeviceMemoryReportCallbackDataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
        auto temp=builder.getVkImportMemoryHostPointerInfoEXT();
        return serialize_struct(temp, ((VkImportMemoryHostPointerInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
        {
        auto temp=builder.getVkMemoryHostPointerPropertiesEXT();
        return serialize_struct(temp, ((VkMemoryHostPointerPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceExternalMemoryHostPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceExternalMemoryHostPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceConservativeRasterizationPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceConservativeRasterizationPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT:
        {
        auto temp=builder.getVkCalibratedTimestampInfoEXT();
        return serialize_struct(temp, ((VkCalibratedTimestampInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
        auto temp=builder.getVkPhysicalDeviceShaderCorePropertiesAMD();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderCorePropertiesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
        auto temp=builder.getVkPhysicalDeviceShaderCoreProperties2AMD();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderCoreProperties2AMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineRasterizationConservativeStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineRasterizationConservativeStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceDescriptorIndexingFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceDescriptorIndexingFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceDescriptorIndexingProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceDescriptorIndexingProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
        auto temp=builder.getVkDescriptorSetLayoutBindingFlagsCreateInfo();
        return serialize_struct(temp, ((VkDescriptorSetLayoutBindingFlagsCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
        auto temp=builder.getVkDescriptorSetVariableDescriptorCountAllocateInfo();
        return serialize_struct(temp, ((VkDescriptorSetVariableDescriptorCountAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
        auto temp=builder.getVkDescriptorSetVariableDescriptorCountLayoutSupport();
        return serialize_struct(temp, ((VkDescriptorSetVariableDescriptorCountLayoutSupport*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2:
        {
        auto temp=builder.getVkAttachmentDescription2();
        return serialize_struct(temp, ((VkAttachmentDescription2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2:
        {
        auto temp=builder.getVkAttachmentReference2();
        return serialize_struct(temp, ((VkAttachmentReference2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2:
        {
        auto temp=builder.getVkSubpassDescription2();
        return serialize_struct(temp, ((VkSubpassDescription2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2:
        {
        auto temp=builder.getVkSubpassDependency2();
        return serialize_struct(temp, ((VkSubpassDependency2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
        {
        auto temp=builder.getVkRenderPassCreateInfo2();
        return serialize_struct(temp, ((VkRenderPassCreateInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO:
        {
        auto temp=builder.getVkSubpassBeginInfo();
        return serialize_struct(temp, ((VkSubpassBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_END_INFO:
        {
        auto temp=builder.getVkSubpassEndInfo();
        return serialize_struct(temp, ((VkSubpassEndInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceTimelineSemaphoreFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceTimelineSemaphoreFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceTimelineSemaphoreProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceTimelineSemaphoreProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
        auto temp=builder.getVkSemaphoreTypeCreateInfo();
        return serialize_struct(temp, ((VkSemaphoreTypeCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
        auto temp=builder.getVkTimelineSemaphoreSubmitInfo();
        return serialize_struct(temp, ((VkTimelineSemaphoreSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:
        {
        auto temp=builder.getVkSemaphoreWaitInfo();
        return serialize_struct(temp, ((VkSemaphoreWaitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO:
        {
        auto temp=builder.getVkSemaphoreSignalInfo();
        return serialize_struct(temp, ((VkSemaphoreSignalInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineVertexInputDivisorStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineVertexInputDivisorStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePCIBusInfoPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePCIBusInfoPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
        auto temp=builder.getVkCommandBufferInheritanceConditionalRenderingInfoEXT();
        return serialize_struct(temp, ((VkCommandBufferInheritanceConditionalRenderingInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
        auto temp=builder.getVkPhysicalDevice8BitStorageFeatures();
        return serialize_struct(temp, ((VkPhysicalDevice8BitStorageFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceConditionalRenderingFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceConditionalRenderingFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceVulkanMemoryModelFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceVulkanMemoryModelFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderAtomicInt64Features();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderAtomicInt64Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderAtomicFloatFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
        auto temp=builder.getVkQueueFamilyCheckpointPropertiesNV();
        return serialize_struct(temp, ((VkQueueFamilyCheckpointPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
        {
        auto temp=builder.getVkCheckpointDataNV();
        return serialize_struct(temp, ((VkCheckpointDataNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceDepthStencilResolveProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceDepthStencilResolveProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
        auto temp=builder.getVkSubpassDescriptionDepthStencilResolve();
        return serialize_struct(temp, ((VkSubpassDescriptionDepthStencilResolve*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
        auto temp=builder.getVkImageViewASTCDecodeModeEXT();
        return serialize_struct(temp, ((VkImageViewASTCDecodeModeEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceASTCDecodeFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceASTCDecodeFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceTransformFeedbackFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceTransformFeedbackFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceTransformFeedbackPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceTransformFeedbackPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineRasterizationStateStreamCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineRasterizationStateStreamCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineRepresentativeFragmentTestStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceExclusiveScissorFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceExclusiveScissorFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineViewportExclusiveScissorStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineViewportExclusiveScissorStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceCornerSampledImageFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceCornerSampledImageFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceShaderImageFootprintFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderImageFootprintFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceCopyMemoryIndirectFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceCopyMemoryIndirectPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceMemoryDecompressionFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceMemoryDecompressionFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceMemoryDecompressionPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceMemoryDecompressionPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineViewportShadingRateImageStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineViewportShadingRateImageStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceShadingRateImageFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceShadingRateImageFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceShadingRateImagePropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceShadingRateImagePropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
        auto temp=builder.getVkPhysicalDeviceInvocationMaskFeaturesHUAWEI();
        return serialize_struct(temp, ((VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceMeshShaderFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceMeshShaderFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceMeshShaderPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceMeshShaderPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMeshShaderFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMeshShaderFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMeshShaderPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMeshShaderPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
        {
        auto temp=builder.getVkRayTracingShaderGroupCreateInfoNV();
        return serialize_struct(temp, ((VkRayTracingShaderGroupCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkRayTracingShaderGroupCreateInfoKHR();
        return serialize_struct(temp, ((VkRayTracingShaderGroupCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkRayTracingPipelineCreateInfoNV();
        return serialize_struct(temp, ((VkRayTracingPipelineCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkRayTracingPipelineCreateInfoKHR();
        return serialize_struct(temp, ((VkRayTracingPipelineCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
        {
        auto temp=builder.getVkGeometryTrianglesNV();
        return serialize_struct(temp, ((VkGeometryTrianglesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
        {
        auto temp=builder.getVkGeometryAABBNV();
        return serialize_struct(temp, ((VkGeometryAABBNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GEOMETRY_NV:
        {
        auto temp=builder.getVkGeometryNV();
        return serialize_struct(temp, ((VkGeometryNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
        {
        auto temp=builder.getVkAccelerationStructureInfoNV();
        return serialize_struct(temp, ((VkAccelerationStructureInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkAccelerationStructureCreateInfoNV();
        return serialize_struct(temp, ((VkAccelerationStructureCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
        {
        auto temp=builder.getVkBindAccelerationStructureMemoryInfoNV();
        return serialize_struct(temp, ((VkBindAccelerationStructureMemoryInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
        auto temp=builder.getVkWriteDescriptorSetAccelerationStructureKHR();
        return serialize_struct(temp, ((VkWriteDescriptorSetAccelerationStructureKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
        auto temp=builder.getVkWriteDescriptorSetAccelerationStructureNV();
        return serialize_struct(temp, ((VkWriteDescriptorSetAccelerationStructureNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
        {
        auto temp=builder.getVkAccelerationStructureMemoryRequirementsInfoNV();
        return serialize_struct(temp, ((VkAccelerationStructureMemoryRequirementsInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceAccelerationStructureFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceAccelerationStructureFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingPipelineFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceRayQueryFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceRayQueryFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceAccelerationStructurePropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceAccelerationStructurePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingPipelinePropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingPipelinePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {
        auto temp=builder.getVkDrmFormatModifierPropertiesListEXT();
        return serialize_struct(temp, ((VkDrmFormatModifierPropertiesListEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceImageDrmFormatModifierInfoEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceImageDrmFormatModifierInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkImageDrmFormatModifierListCreateInfoEXT();
        return serialize_struct(temp, ((VkImageDrmFormatModifierListCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkImageDrmFormatModifierExplicitCreateInfoEXT();
        return serialize_struct(temp, ((VkImageDrmFormatModifierExplicitCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
        {
        auto temp=builder.getVkImageDrmFormatModifierPropertiesEXT();
        return serialize_struct(temp, ((VkImageDrmFormatModifierPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
        auto temp=builder.getVkImageStencilUsageCreateInfo();
        return serialize_struct(temp, ((VkImageStencilUsageCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
        auto temp=builder.getVkDeviceMemoryOverallocationCreateInfoAMD();
        return serialize_struct(temp, ((VkDeviceMemoryOverallocationCreateInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentDensityMapFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentDensityMap2FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentDensityMapPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentDensityMapPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentDensityMap2PropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkRenderPassFragmentDensityMapCreateInfoEXT();
        return serialize_struct(temp, ((VkRenderPassFragmentDensityMapCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
        {
        auto temp=builder.getVkSubpassFragmentDensityMapOffsetEndInfoQCOM();
        return serialize_struct(temp, ((VkSubpassFragmentDensityMapOffsetEndInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceScalarBlockLayoutFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceScalarBlockLayoutFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {
        auto temp=builder.getVkSurfaceProtectedCapabilitiesKHR();
        return serialize_struct(temp, ((VkSurfaceProtectedCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceUniformBufferStandardLayoutFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDepthClipEnableFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDepthClipEnableFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineRasterizationDepthClipStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineRasterizationDepthClipStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMemoryBudgetPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMemoryBudgetPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMemoryPriorityFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMemoryPriorityFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
        auto temp=builder.getVkMemoryPriorityAllocateInfoEXT();
        return serialize_struct(temp, ((VkMemoryPriorityAllocateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceBufferDeviceAddressFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceBufferDeviceAddressFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceBufferDeviceAddressFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO:
        {
        auto temp=builder.getVkBufferDeviceAddressInfo();
        return serialize_struct(temp, ((VkBufferDeviceAddressInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
        auto temp=builder.getVkBufferOpaqueCaptureAddressCreateInfo();
        return serialize_struct(temp, ((VkBufferOpaqueCaptureAddressCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkBufferDeviceAddressCreateInfoEXT();
        return serialize_struct(temp, ((VkBufferDeviceAddressCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceImageViewImageFormatInfoEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceImageViewImageFormatInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
        auto temp=builder.getVkFilterCubicImageViewImageFormatPropertiesEXT();
        return serialize_struct(temp, ((VkFilterCubicImageViewImageFormatPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceImagelessFramebufferFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceImagelessFramebufferFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
        auto temp=builder.getVkFramebufferAttachmentsCreateInfo();
        return serialize_struct(temp, ((VkFramebufferAttachmentsCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
        {
        auto temp=builder.getVkFramebufferAttachmentImageInfo();
        return serialize_struct(temp, ((VkFramebufferAttachmentImageInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
        auto temp=builder.getVkRenderPassAttachmentBeginInfo();
        return serialize_struct(temp, ((VkRenderPassAttachmentBeginInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceTextureCompressionASTCHDRFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceTextureCompressionASTCHDRFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceCooperativeMatrixFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceCooperativeMatrixFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceCooperativeMatrixPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceCooperativeMatrixPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
        auto temp=builder.getVkCooperativeMatrixPropertiesNV();
        return serialize_struct(temp, ((VkCooperativeMatrixPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceYcbcrImageArraysFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
        {
        auto temp=builder.getVkImageViewHandleInfoNVX();
        return serialize_struct(temp, ((VkImageViewHandleInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX:
        {
        auto temp=builder.getVkImageViewAddressPropertiesNVX();
        return serialize_struct(temp, ((VkImageViewAddressPropertiesNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineCreationFeedbackCreateInfo();
        return serialize_struct(temp, ((VkPipelineCreationFeedbackCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDevicePresentBarrierFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDevicePresentBarrierFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
        {
        auto temp=builder.getVkSurfaceCapabilitiesPresentBarrierNV();
        return serialize_struct(temp, ((VkSurfaceCapabilitiesPresentBarrierNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
        {
        auto temp=builder.getVkSwapchainPresentBarrierCreateInfoNV();
        return serialize_struct(temp, ((VkSwapchainPresentBarrierCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDevicePerformanceQueryFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDevicePerformanceQueryFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDevicePerformanceQueryPropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDevicePerformanceQueryPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR:
        {
        auto temp=builder.getVkPerformanceCounterKHR();
        return serialize_struct(temp, ((VkPerformanceCounterKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR:
        {
        auto temp=builder.getVkPerformanceCounterDescriptionKHR();
        return serialize_struct(temp, ((VkPerformanceCounterDescriptionKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkQueryPoolPerformanceCreateInfoKHR();
        return serialize_struct(temp, ((VkQueryPoolPerformanceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR:
        {
        auto temp=builder.getVkAcquireProfilingLockInfoKHR();
        return serialize_struct(temp, ((VkAcquireProfilingLockInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
        auto temp=builder.getVkPerformanceQuerySubmitInfoKHR();
        return serialize_struct(temp, ((VkPerformanceQuerySubmitInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkHeadlessSurfaceCreateInfoEXT();
        return serialize_struct(temp, ((VkHeadlessSurfaceCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceCoverageReductionModeFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceCoverageReductionModeFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineCoverageReductionStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineCoverageReductionStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
        {
        auto temp=builder.getVkFramebufferMixedSamplesCombinationNV();
        return serialize_struct(temp, ((VkFramebufferMixedSamplesCombinationNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
        auto temp=builder.getVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
        {
        auto temp=builder.getVkInitializePerformanceApiInfoINTEL();
        return serialize_struct(temp, ((VkInitializePerformanceApiInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
        auto temp=builder.getVkQueryPoolPerformanceQueryCreateInfoINTEL();
        return serialize_struct(temp, ((VkQueryPoolPerformanceQueryCreateInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
        {
        auto temp=builder.getVkPerformanceMarkerInfoINTEL();
        return serialize_struct(temp, ((VkPerformanceMarkerInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
        {
        auto temp=builder.getVkPerformanceStreamMarkerInfoINTEL();
        return serialize_struct(temp, ((VkPerformanceStreamMarkerInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
        {
        auto temp=builder.getVkPerformanceOverrideInfoINTEL();
        return serialize_struct(temp, ((VkPerformanceOverrideInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
        {
        auto temp=builder.getVkPerformanceConfigurationAcquireInfoINTEL();
        return serialize_struct(temp, ((VkPerformanceConfigurationAcquireInfoINTEL*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceShaderClockFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderClockFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceIndexTypeUint8FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceIndexTypeUint8FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceShaderSMBuiltinsPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceShaderSMBuiltinsFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
        auto temp=builder.getVkAttachmentReferenceStencilLayout();
        return serialize_struct(temp, ((VkAttachmentReferenceStencilLayout*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
        auto temp=builder.getVkAttachmentDescriptionStencilLayout();
        return serialize_struct(temp, ((VkAttachmentDescriptionStencilLayout*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR:
        {
        auto temp=builder.getVkPipelineInfoKHR();
        return serialize_struct(temp, ((VkPipelineInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPipelineExecutablePropertiesKHR();
        return serialize_struct(temp, ((VkPipelineExecutablePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR:
        {
        auto temp=builder.getVkPipelineExecutableInfoKHR();
        return serialize_struct(temp, ((VkPipelineExecutableInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR:
        {
        auto temp=builder.getVkPipelineExecutableStatisticKHR();
        return serialize_struct(temp, ((VkPipelineExecutableStatisticKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
        {
        auto temp=builder.getVkPipelineExecutableInternalRepresentationKHR();
        return serialize_struct(temp, ((VkPipelineExecutableInternalRepresentationKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceTexelBufferAlignmentProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceTexelBufferAlignmentProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceSubgroupSizeControlFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceSubgroupSizeControlFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceSubgroupSizeControlProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceSubgroupSizeControlProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineShaderStageRequiredSubgroupSizeCreateInfo();
        return serialize_struct(temp, ((VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
        {
        auto temp=builder.getVkSubpassShadingPipelineCreateInfoHUAWEI();
        return serialize_struct(temp, ((VkSubpassShadingPipelineCreateInfoHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
        auto temp=builder.getVkPhysicalDeviceSubpassShadingPropertiesHUAWEI();
        return serialize_struct(temp, ((VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
        {
        auto temp=builder.getVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI();
        return serialize_struct(temp, ((VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
        auto temp=builder.getVkMemoryOpaqueCaptureAddressAllocateInfo();
        return serialize_struct(temp, ((VkMemoryOpaqueCaptureAddressAllocateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
        {
        auto temp=builder.getVkDeviceMemoryOpaqueCaptureAddressInfo();
        return serialize_struct(temp, ((VkDeviceMemoryOpaqueCaptureAddressInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceLineRasterizationFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceLineRasterizationFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceLineRasterizationPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceLineRasterizationPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineRasterizationLineStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineRasterizationLineStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
        auto temp=builder.getVkPhysicalDevicePipelineCreationCacheControlFeatures();
        return serialize_struct(temp, ((VkPhysicalDevicePipelineCreationCacheControlFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceVulkan11Features();
        return serialize_struct(temp, ((VkPhysicalDeviceVulkan11Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceVulkan11Properties();
        return serialize_struct(temp, ((VkPhysicalDeviceVulkan11Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceVulkan12Features();
        return serialize_struct(temp, ((VkPhysicalDeviceVulkan12Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceVulkan12Properties();
        return serialize_struct(temp, ((VkPhysicalDeviceVulkan12Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceVulkan13Features();
        return serialize_struct(temp, ((VkPhysicalDeviceVulkan13Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceVulkan13Properties();
        return serialize_struct(temp, ((VkPhysicalDeviceVulkan13Properties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
        auto temp=builder.getVkPipelineCompilerControlCreateInfoAMD();
        return serialize_struct(temp, ((VkPipelineCompilerControlCreateInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
        auto temp=builder.getVkPhysicalDeviceCoherentMemoryFeaturesAMD();
        return serialize_struct(temp, ((VkPhysicalDeviceCoherentMemoryFeaturesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceToolProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceToolProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkSamplerCustomBorderColorCreateInfoEXT();
        return serialize_struct(temp, ((VkSamplerCustomBorderColorCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceCustomBorderColorPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceCustomBorderColorPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceCustomBorderColorFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceCustomBorderColorFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkSamplerBorderColorComponentMappingCreateInfoEXT();
        return serialize_struct(temp, ((VkSamplerBorderColorComponentMappingCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceBorderColorSwizzleFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:
        {
        auto temp=builder.getVkAccelerationStructureGeometryTrianglesDataKHR();
        return serialize_struct(temp, ((VkAccelerationStructureGeometryTrianglesDataKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:
        {
        auto temp=builder.getVkAccelerationStructureGeometryAabbsDataKHR();
        return serialize_struct(temp, ((VkAccelerationStructureGeometryAabbsDataKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:
        {
        auto temp=builder.getVkAccelerationStructureGeometryInstancesDataKHR();
        return serialize_struct(temp, ((VkAccelerationStructureGeometryInstancesDataKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR:
        {
        auto temp=builder.getVkAccelerationStructureGeometryKHR();
        return serialize_struct(temp, ((VkAccelerationStructureGeometryKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:
        {
        auto temp=builder.getVkAccelerationStructureBuildGeometryInfoKHR();
        return serialize_struct(temp, ((VkAccelerationStructureBuildGeometryInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkAccelerationStructureCreateInfoKHR();
        return serialize_struct(temp, ((VkAccelerationStructureCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:
        {
        auto temp=builder.getVkAccelerationStructureDeviceAddressInfoKHR();
        return serialize_struct(temp, ((VkAccelerationStructureDeviceAddressInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:
        {
        auto temp=builder.getVkAccelerationStructureVersionInfoKHR();
        return serialize_struct(temp, ((VkAccelerationStructureVersionInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR:
        {
        auto temp=builder.getVkCopyAccelerationStructureInfoKHR();
        return serialize_struct(temp, ((VkCopyAccelerationStructureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:
        {
        auto temp=builder.getVkCopyAccelerationStructureToMemoryInfoKHR();
        return serialize_struct(temp, ((VkCopyAccelerationStructureToMemoryInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:
        {
        auto temp=builder.getVkCopyMemoryToAccelerationStructureInfoKHR();
        return serialize_struct(temp, ((VkCopyMemoryToAccelerationStructureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkRayTracingPipelineInterfaceCreateInfoKHR();
        return serialize_struct(temp, ((VkRayTracingPipelineInterfaceCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkPipelineLibraryCreateInfoKHR();
        return serialize_struct(temp, ((VkPipelineLibraryCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceExtendedDynamicStateFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceExtendedDynamicState2FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceExtendedDynamicState3FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceExtendedDynamicState3PropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
        auto temp=builder.getVkRenderPassTransformBeginInfoQCOM();
        return serialize_struct(temp, ((VkRenderPassTransformBeginInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
        auto temp=builder.getVkCopyCommandTransformInfoQCOM();
        return serialize_struct(temp, ((VkCopyCommandTransformInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
        auto temp=builder.getVkCommandBufferInheritanceRenderPassTransformInfoQCOM();
        return serialize_struct(temp, ((VkCommandBufferInheritanceRenderPassTransformInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceDiagnosticsConfigFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
        auto temp=builder.getVkDeviceDiagnosticsConfigCreateInfoNV();
        return serialize_struct(temp, ((VkDeviceDiagnosticsConfigCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceRobustness2FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceRobustness2FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceRobustness2PropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceRobustness2PropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceImageRobustnessFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceImageRobustnessFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevice4444FormatsFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevice4444FormatsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
        auto temp=builder.getVkPhysicalDeviceSubpassShadingFeaturesHUAWEI();
        return serialize_struct(temp, ((VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
        auto temp=builder.getVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI();
        return serialize_struct(temp, ((VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_COPY_2:
        {
        auto temp=builder.getVkBufferCopy2();
        return serialize_struct(temp, ((VkBufferCopy2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COPY_2:
        {
        auto temp=builder.getVkImageCopy2();
        return serialize_struct(temp, ((VkImageCopy2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_BLIT_2:
        {
        auto temp=builder.getVkImageBlit2();
        return serialize_struct(temp, ((VkImageBlit2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2:
        {
        auto temp=builder.getVkBufferImageCopy2();
        return serialize_struct(temp, ((VkBufferImageCopy2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2:
        {
        auto temp=builder.getVkImageResolve2();
        return serialize_struct(temp, ((VkImageResolve2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2:
        {
        auto temp=builder.getVkCopyBufferInfo2();
        return serialize_struct(temp, ((VkCopyBufferInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2:
        {
        auto temp=builder.getVkCopyImageInfo2();
        return serialize_struct(temp, ((VkCopyImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2:
        {
        auto temp=builder.getVkBlitImageInfo2();
        return serialize_struct(temp, ((VkBlitImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2:
        {
        auto temp=builder.getVkCopyBufferToImageInfo2();
        return serialize_struct(temp, ((VkCopyBufferToImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2:
        {
        auto temp=builder.getVkCopyImageToBufferInfo2();
        return serialize_struct(temp, ((VkCopyImageToBufferInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2:
        {
        auto temp=builder.getVkResolveImageInfo2();
        return serialize_struct(temp, ((VkResolveImageInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
        auto temp=builder.getVkFragmentShadingRateAttachmentInfoKHR();
        return serialize_struct(temp, ((VkFragmentShadingRateAttachmentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkPipelineFragmentShadingRateStateCreateInfoKHR();
        return serialize_struct(temp, ((VkPipelineFragmentShadingRateStateCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShadingRateFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShadingRatePropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShadingRatePropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShadingRateKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShadingRateKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderTerminateInvocationFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderTerminateInvocationFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
        auto temp=builder.getVkPipelineFragmentShadingRateEnumStateCreateInfoNV();
        return serialize_struct(temp, ((VkPipelineFragmentShadingRateEnumStateCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:
        {
        auto temp=builder.getVkAccelerationStructureBuildSizesInfoKHR();
        return serialize_struct(temp, ((VkAccelerationStructureBuildSizesInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceImage2DViewOf3DFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkMutableDescriptorTypeCreateInfoEXT();
        return serialize_struct(temp, ((VkMutableDescriptorTypeCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDepthClipControlFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDepthClipControlFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineViewportDepthClipControlCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineViewportDepthClipControlCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceExternalMemoryRDMAFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT:
        {
        auto temp=builder.getVkVertexInputBindingDescription2EXT();
        return serialize_struct(temp, ((VkVertexInputBindingDescription2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT:
        {
        auto temp=builder.getVkVertexInputAttributeDescription2EXT();
        return serialize_struct(temp, ((VkVertexInputAttributeDescription2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceColorWriteEnableFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceColorWriteEnableFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineColorWriteCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineColorWriteCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
        {
        auto temp=builder.getVkMemoryBarrier2();
        return serialize_struct(temp, ((VkMemoryBarrier2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2:
        {
        auto temp=builder.getVkImageMemoryBarrier2();
        return serialize_struct(temp, ((VkImageMemoryBarrier2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2:
        {
        auto temp=builder.getVkBufferMemoryBarrier2();
        return serialize_struct(temp, ((VkBufferMemoryBarrier2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEPENDENCY_INFO:
        {
        auto temp=builder.getVkDependencyInfo();
        return serialize_struct(temp, ((VkDependencyInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO:
        {
        auto temp=builder.getVkSemaphoreSubmitInfo();
        return serialize_struct(temp, ((VkSemaphoreSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO:
        {
        auto temp=builder.getVkCommandBufferSubmitInfo();
        return serialize_struct(temp, ((VkCommandBufferSubmitInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBMIT_INFO_2:
        {
        auto temp=builder.getVkSubmitInfo2();
        return serialize_struct(temp, ((VkSubmitInfo2*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
        auto temp=builder.getVkQueueFamilyCheckpointProperties2NV();
        return serialize_struct(temp, ((VkQueueFamilyCheckpointProperties2NV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV:
        {
        auto temp=builder.getVkCheckpointData2NV();
        return serialize_struct(temp, ((VkCheckpointData2NV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceSynchronization2Features();
        return serialize_struct(temp, ((VkPhysicalDeviceSynchronization2Features*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceHostImageCopyFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceHostImageCopyFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceHostImageCopyPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceHostImageCopyPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT:
        {
        auto temp=builder.getVkMemoryToImageCopyEXT();
        return serialize_struct(temp, ((VkMemoryToImageCopyEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT:
        {
        auto temp=builder.getVkImageToMemoryCopyEXT();
        return serialize_struct(temp, ((VkImageToMemoryCopyEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT:
        {
        auto temp=builder.getVkCopyMemoryToImageInfoEXT();
        return serialize_struct(temp, ((VkCopyMemoryToImageInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT:
        {
        auto temp=builder.getVkCopyImageToMemoryInfoEXT();
        return serialize_struct(temp, ((VkCopyImageToMemoryInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT:
        {
        auto temp=builder.getVkCopyImageToImageInfoEXT();
        return serialize_struct(temp, ((VkCopyImageToImageInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT:
        {
        auto temp=builder.getVkHostImageLayoutTransitionInfoEXT();
        return serialize_struct(temp, ((VkHostImageLayoutTransitionInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT:
        {
        auto temp=builder.getVkSubresourceHostMemcpySizeEXT();
        return serialize_struct(temp, ((VkSubresourceHostMemcpySizeEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT:
        {
        auto temp=builder.getVkHostImageCopyDevicePerformanceQueryEXT();
        return serialize_struct(temp, ((VkHostImageCopyDevicePerformanceQueryEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceLegacyDitheringFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceLegacyDitheringFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
        {
        auto temp=builder.getVkSubpassResolvePerformanceQueryEXT();
        return serialize_struct(temp, ((VkSubpassResolvePerformanceQueryEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
        {
        auto temp=builder.getVkMultisampledRenderToSingleSampledInfoEXT();
        return serialize_struct(temp, ((VkMultisampledRenderToSingleSampledInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePipelineProtectedAccessFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
        {
        auto temp=builder.getVkQueueFamilyVideoPropertiesKHR();
        return serialize_struct(temp, ((VkQueueFamilyVideoPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
        {
        auto temp=builder.getVkQueueFamilyQueryResultStatusPropertiesKHR();
        return serialize_struct(temp, ((VkQueueFamilyQueryResultStatusPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
        auto temp=builder.getVkVideoProfileListInfoKHR();
        return serialize_struct(temp, ((VkVideoProfileListInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceVideoFormatInfoKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceVideoFormatInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR:
        {
        auto temp=builder.getVkVideoFormatPropertiesKHR();
        return serialize_struct(temp, ((VkVideoFormatPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
        {
        auto temp=builder.getVkVideoProfileInfoKHR();
        return serialize_struct(temp, ((VkVideoProfileInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR:
        {
        auto temp=builder.getVkVideoCapabilitiesKHR();
        return serialize_struct(temp, ((VkVideoCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR:
        {
        auto temp=builder.getVkVideoSessionMemoryRequirementsKHR();
        return serialize_struct(temp, ((VkVideoSessionMemoryRequirementsKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR:
        {
        auto temp=builder.getVkBindVideoSessionMemoryInfoKHR();
        return serialize_struct(temp, ((VkBindVideoSessionMemoryInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR:
        {
        auto temp=builder.getVkVideoPictureResourceInfoKHR();
        return serialize_struct(temp, ((VkVideoPictureResourceInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR:
        {
        auto temp=builder.getVkVideoReferenceSlotInfoKHR();
        return serialize_struct(temp, ((VkVideoReferenceSlotInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
        {
        auto temp=builder.getVkVideoDecodeCapabilitiesKHR();
        return serialize_struct(temp, ((VkVideoDecodeCapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeUsageInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeUsageInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH264ProfileInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH264ProfileInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
        {
        auto temp=builder.getVkVideoDecodeH264CapabilitiesKHR();
        return serialize_struct(temp, ((VkVideoDecodeH264CapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH264SessionParametersAddInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH264SessionParametersAddInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH264SessionParametersCreateInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH264SessionParametersCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH264PictureInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH264PictureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH264DpbSlotInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH264DpbSlotInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH265ProfileInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH265ProfileInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR:
        {
        auto temp=builder.getVkVideoDecodeH265CapabilitiesKHR();
        return serialize_struct(temp, ((VkVideoDecodeH265CapabilitiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH265SessionParametersAddInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH265SessionParametersAddInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH265SessionParametersCreateInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH265SessionParametersCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH265PictureInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH265PictureInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR:
        {
        auto temp=builder.getVkVideoDecodeH265DpbSlotInfoKHR();
        return serialize_struct(temp, ((VkVideoDecodeH265DpbSlotInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkVideoSessionCreateInfoKHR();
        return serialize_struct(temp, ((VkVideoSessionCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
        auto temp=builder.getVkVideoSessionParametersCreateInfoKHR();
        return serialize_struct(temp, ((VkVideoSessionParametersCreateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR:
        {
        auto temp=builder.getVkVideoSessionParametersUpdateInfoKHR();
        return serialize_struct(temp, ((VkVideoSessionParametersUpdateInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR:
        {
        auto temp=builder.getVkVideoBeginCodingInfoKHR();
        return serialize_struct(temp, ((VkVideoBeginCodingInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR:
        {
        auto temp=builder.getVkVideoEndCodingInfoKHR();
        return serialize_struct(temp, ((VkVideoEndCodingInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR:
        {
        auto temp=builder.getVkVideoCodingControlInfoKHR();
        return serialize_struct(temp, ((VkVideoCodingControlInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceInheritedViewportScissorFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {
        auto temp=builder.getVkCommandBufferInheritanceViewportScissorInfoNV();
        return serialize_struct(temp, ((VkCommandBufferInheritanceViewportScissorInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceProvokingVertexFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceProvokingVertexFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceProvokingVertexPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceProvokingVertexPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineRasterizationProvokingVertexStateCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX:
        {
        auto temp=builder.getVkCuModuleCreateInfoNVX();
        return serialize_struct(temp, ((VkCuModuleCreateInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX:
        {
        auto temp=builder.getVkCuFunctionCreateInfoNVX();
        return serialize_struct(temp, ((VkCuFunctionCreateInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX:
        {
        auto temp=builder.getVkCuLaunchInfoNVX();
        return serialize_struct(temp, ((VkCuLaunchInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDescriptorBufferFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDescriptorBufferFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDescriptorBufferPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDescriptorBufferPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT:
        {
        auto temp=builder.getVkDescriptorAddressInfoEXT();
        return serialize_struct(temp, ((VkDescriptorAddressInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT:
        {
        auto temp=builder.getVkDescriptorBufferBindingInfoEXT();
        return serialize_struct(temp, ((VkDescriptorBufferBindingInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT:
        {
        auto temp=builder.getVkDescriptorBufferBindingPushDescriptorBufferHandleEXT();
        return serialize_struct(temp, ((VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT:
        {
        auto temp=builder.getVkDescriptorGetInfoEXT();
        return serialize_struct(temp, ((VkDescriptorGetInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto temp=builder.getVkBufferCaptureDescriptorDataInfoEXT();
        return serialize_struct(temp, ((VkBufferCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto temp=builder.getVkImageCaptureDescriptorDataInfoEXT();
        return serialize_struct(temp, ((VkImageCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto temp=builder.getVkImageViewCaptureDescriptorDataInfoEXT();
        return serialize_struct(temp, ((VkImageViewCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto temp=builder.getVkSamplerCaptureDescriptorDataInfoEXT();
        return serialize_struct(temp, ((VkSamplerCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
        {
        auto temp=builder.getVkAccelerationStructureCaptureDescriptorDataInfoEXT();
        return serialize_struct(temp, ((VkAccelerationStructureCaptureDescriptorDataInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkOpaqueCaptureDescriptorDataCreateInfoEXT();
        return serialize_struct(temp, ((VkOpaqueCaptureDescriptorDataCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderIntegerDotProductFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderIntegerDotProductFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
        auto temp=builder.getVkPhysicalDeviceShaderIntegerDotProductProperties();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderIntegerDotProductProperties*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDrmPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDrmPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingMotionBlurFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
        {
        auto temp=builder.getVkAccelerationStructureGeometryMotionTrianglesDataNV();
        return serialize_struct(temp, ((VkAccelerationStructureGeometryMotionTrianglesDataNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
        {
        auto temp=builder.getVkAccelerationStructureMotionInfoNV();
        return serialize_struct(temp, ((VkAccelerationStructureMotionInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV:
        {
        auto temp=builder.getVkMemoryGetRemoteAddressInfoNV();
        return serialize_struct(temp, ((VkMemoryGetRemoteAddressInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
        {
        auto temp=builder.getVkFormatProperties3();
        return serialize_struct(temp, ((VkFormatProperties3*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
        {
        auto temp=builder.getVkDrmFormatModifierPropertiesList2EXT();
        return serialize_struct(temp, ((VkDrmFormatModifierPropertiesList2EXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
        {
        auto temp=builder.getVkPipelineRenderingCreateInfo();
        return serialize_struct(temp, ((VkPipelineRenderingCreateInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_INFO:
        {
        auto temp=builder.getVkRenderingInfo();
        return serialize_struct(temp, ((VkRenderingInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO:
        {
        auto temp=builder.getVkRenderingAttachmentInfo();
        return serialize_struct(temp, ((VkRenderingAttachmentInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
        auto temp=builder.getVkRenderingFragmentShadingRateAttachmentInfoKHR();
        return serialize_struct(temp, ((VkRenderingFragmentShadingRateAttachmentInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
        {
        auto temp=builder.getVkRenderingFragmentDensityMapAttachmentInfoEXT();
        return serialize_struct(temp, ((VkRenderingFragmentDensityMapAttachmentInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
        auto temp=builder.getVkPhysicalDeviceDynamicRenderingFeatures();
        return serialize_struct(temp, ((VkPhysicalDeviceDynamicRenderingFeatures*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
        {
        auto temp=builder.getVkCommandBufferInheritanceRenderingInfo();
        return serialize_struct(temp, ((VkCommandBufferInheritanceRenderingInfo*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
        auto temp=builder.getVkAttachmentSampleCountInfoAMD();
        return serialize_struct(temp, ((VkAttachmentSampleCountInfoAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
        {
        auto temp=builder.getVkMultiviewPerViewAttributesInfoNVX();
        return serialize_struct(temp, ((VkMultiviewPerViewAttributesInfoNVX*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceImageViewMinLodFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceImageViewMinLodFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkImageViewMinLodCreateInfoEXT();
        return serialize_struct(temp, ((VkImageViewMinLodCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceLinearColorAttachmentFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceLinearColorAttachmentFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkGraphicsPipelineLibraryCreateInfoEXT();
        return serialize_struct(temp, ((VkGraphicsPipelineLibraryCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
        auto temp=builder.getVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE();
        return serialize_struct(temp, ((VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE:
        {
        auto temp=builder.getVkDescriptorSetBindingReferenceVALVE();
        return serialize_struct(temp, ((VkDescriptorSetBindingReferenceVALVE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE:
        {
        auto temp=builder.getVkDescriptorSetLayoutHostMappingInfoVALVE();
        return serialize_struct(temp, ((VkDescriptorSetLayoutHostMappingInfoVALVE*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineShaderStageModuleIdentifierCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineShaderStageModuleIdentifierCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT:
        {
        auto temp=builder.getVkShaderModuleIdentifierEXT();
        return serialize_struct(temp, ((VkShaderModuleIdentifierEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
        auto temp=builder.getVkImageCompressionControlEXT();
        return serialize_struct(temp, ((VkImageCompressionControlEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceImageCompressionControlFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceImageCompressionControlFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
        auto temp=builder.getVkImageCompressionPropertiesEXT();
        return serialize_struct(temp, ((VkImageCompressionPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR:
        {
        auto temp=builder.getVkImageSubresource2KHR();
        return serialize_struct(temp, ((VkImageSubresource2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR:
        {
        auto temp=builder.getVkSubresourceLayout2KHR();
        return serialize_struct(temp, ((VkSubresourceLayout2KHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
        {
        auto temp=builder.getVkRenderPassCreationControlEXT();
        return serialize_struct(temp, ((VkRenderPassCreationControlEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkRenderPassCreationFeedbackCreateInfoEXT();
        return serialize_struct(temp, ((VkRenderPassCreationFeedbackCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkRenderPassSubpassFeedbackCreateInfoEXT();
        return serialize_struct(temp, ((VkRenderPassSubpassFeedbackCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT:
        {
        auto temp=builder.getVkMicromapBuildInfoEXT();
        return serialize_struct(temp, ((VkMicromapBuildInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkMicromapCreateInfoEXT();
        return serialize_struct(temp, ((VkMicromapCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT:
        {
        auto temp=builder.getVkMicromapVersionInfoEXT();
        return serialize_struct(temp, ((VkMicromapVersionInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT:
        {
        auto temp=builder.getVkCopyMicromapInfoEXT();
        return serialize_struct(temp, ((VkCopyMicromapInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT:
        {
        auto temp=builder.getVkCopyMicromapToMemoryInfoEXT();
        return serialize_struct(temp, ((VkCopyMicromapToMemoryInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT:
        {
        auto temp=builder.getVkCopyMemoryToMicromapInfoEXT();
        return serialize_struct(temp, ((VkCopyMemoryToMicromapInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT:
        {
        auto temp=builder.getVkMicromapBuildSizesInfoEXT();
        return serialize_struct(temp, ((VkMicromapBuildSizesInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceOpacityMicromapFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceOpacityMicromapFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceOpacityMicromapPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceOpacityMicromapPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
        {
        auto temp=builder.getVkAccelerationStructureTrianglesOpacityMicromapEXT();
        return serialize_struct(temp, ((VkAccelerationStructureTrianglesOpacityMicromapEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT:
        {
        auto temp=builder.getVkPipelinePropertiesIdentifierEXT();
        return serialize_struct(temp, ((VkPipelinePropertiesIdentifierEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePipelinePropertiesFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePipelinePropertiesFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
        auto temp=builder.getVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
        auto temp=builder.getVkExternalMemoryAcquireUnmodifiedEXT();
        return serialize_struct(temp, ((VkExternalMemoryAcquireUnmodifiedEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePipelineRobustnessFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePipelineRobustnessFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkPipelineRobustnessCreateInfoEXT();
        return serialize_struct(temp, ((VkPipelineRobustnessCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePipelineRobustnessPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePipelineRobustnessPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
        {
        auto temp=builder.getVkImageViewSampleWeightCreateInfoQCOM();
        return serialize_struct(temp, ((VkImageViewSampleWeightCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceImageProcessingFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceImageProcessingFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceImageProcessingPropertiesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceImageProcessingPropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceTilePropertiesFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceTilePropertiesFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM:
        {
        auto temp=builder.getVkTilePropertiesQCOM();
        return serialize_struct(temp, ((VkTilePropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
        {
        auto temp=builder.getVkPhysicalDeviceAmigoProfilingFeaturesSEC();
        return serialize_struct(temp, ((VkPhysicalDeviceAmigoProfilingFeaturesSEC*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:
        {
        auto temp=builder.getVkAmigoProfilingSubmitInfoSEC();
        return serialize_struct(temp, ((VkAmigoProfilingSubmitInfoSEC*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDepthClampZeroOneFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceAddressBindingReportFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceAddressBindingReportFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
        {
        auto temp=builder.getVkDeviceAddressBindingCallbackDataEXT();
        return serialize_struct(temp, ((VkDeviceAddressBindingCallbackDataEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceOpticalFlowFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceOpticalFlowFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceOpticalFlowPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceOpticalFlowPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
        auto temp=builder.getVkOpticalFlowImageFormatInfoNV();
        return serialize_struct(temp, ((VkOpticalFlowImageFormatInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV:
        {
        auto temp=builder.getVkOpticalFlowImageFormatPropertiesNV();
        return serialize_struct(temp, ((VkOpticalFlowImageFormatPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV:
        {
        auto temp=builder.getVkOpticalFlowSessionCreateInfoNV();
        return serialize_struct(temp, ((VkOpticalFlowSessionCreateInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
        {
        auto temp=builder.getVkOpticalFlowSessionCreatePrivateDataInfoNV();
        return serialize_struct(temp, ((VkOpticalFlowSessionCreatePrivateDataInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV:
        {
        auto temp=builder.getVkOpticalFlowExecuteInfoNV();
        return serialize_struct(temp, ((VkOpticalFlowExecuteInfoNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceFaultFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceFaultFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT:
        {
        auto temp=builder.getVkDeviceFaultCountsEXT();
        return serialize_struct(temp, ((VkDeviceFaultCountsEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT:
        {
        auto temp=builder.getVkDeviceFaultInfoEXT();
        return serialize_struct(temp, ((VkDeviceFaultInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT:
        {
        auto temp=builder.getVkDepthBiasInfoEXT();
        return serialize_struct(temp, ((VkDepthBiasInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
        {
        auto temp=builder.getVkDepthBiasRepresentationInfoEXT();
        return serialize_struct(temp, ((VkDepthBiasRepresentationInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
        {
        auto temp=builder.getVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
        auto temp=builder.getVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
        auto temp=builder.getVkFrameBoundaryEXT();
        return serialize_struct(temp, ((VkFrameBoundaryEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceFrameBoundaryFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceFrameBoundaryFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
        {
        auto temp=builder.getVkSurfacePresentModeEXT();
        return serialize_struct(temp, ((VkSurfacePresentModeEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
        {
        auto temp=builder.getVkSurfacePresentScalingCapabilitiesEXT();
        return serialize_struct(temp, ((VkSurfacePresentScalingCapabilitiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
        {
        auto temp=builder.getVkSurfacePresentModeCompatibilityEXT();
        return serialize_struct(temp, ((VkSurfacePresentModeCompatibilityEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
        {
        auto temp=builder.getVkSwapchainPresentFenceInfoEXT();
        return serialize_struct(temp, ((VkSwapchainPresentFenceInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkSwapchainPresentModesCreateInfoEXT();
        return serialize_struct(temp, ((VkSwapchainPresentModesCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT:
        {
        auto temp=builder.getVkSwapchainPresentModeInfoEXT();
        return serialize_struct(temp, ((VkSwapchainPresentModeInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkSwapchainPresentScalingCreateInfoEXT();
        return serialize_struct(temp, ((VkSwapchainPresentScalingCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT:
        {
        auto temp=builder.getVkReleaseSwapchainImagesInfoEXT();
        return serialize_struct(temp, ((VkReleaseSwapchainImagesInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceDepthBiasControlFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceDepthBiasControlFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG:
        {
        auto temp=builder.getVkDirectDriverLoadingInfoLUNARG();
        return serialize_struct(temp, ((VkDirectDriverLoadingInfoLUNARG*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG:
        {
        auto temp=builder.getVkDirectDriverLoadingListLUNARG();
        return serialize_struct(temp, ((VkDirectDriverLoadingListLUNARG*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR:
        {
        auto temp=builder.getVkDeviceImageSubresourceInfoKHR();
        return serialize_struct(temp, ((VkDeviceImageSubresourceInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
        {
        auto temp=builder.getVkPhysicalDeviceShaderCorePropertiesARM();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderCorePropertiesARM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
        {
        auto temp=builder.getVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM();
        return serialize_struct(temp, ((VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
        {
        auto temp=builder.getVkQueryLowLatencySupportNV();
        return serialize_struct(temp, ((VkQueryLowLatencySupportNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR:
        {
        auto temp=builder.getVkMemoryMapInfoKHR();
        return serialize_struct(temp, ((VkMemoryMapInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR:
        {
        auto temp=builder.getVkMemoryUnmapInfoKHR();
        return serialize_struct(temp, ((VkMemoryUnmapInfoKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderObjectFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderObjectFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderObjectPropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderObjectPropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT:
        {
        auto temp=builder.getVkShaderCreateInfoEXT();
        return serialize_struct(temp, ((VkShaderCreateInfoEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderTileImageFeaturesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderTileImageFeaturesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
        {
        auto temp=builder.getVkPhysicalDeviceShaderTileImagePropertiesEXT();
        return serialize_struct(temp, ((VkPhysicalDeviceShaderTileImagePropertiesEXT*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceCooperativeMatrixFeaturesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceCooperativeMatrixFeaturesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
        auto temp=builder.getVkCooperativeMatrixPropertiesKHR();
        return serialize_struct(temp, ((VkCooperativeMatrixPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
        auto temp=builder.getVkPhysicalDeviceCooperativeMatrixPropertiesKHR();
        return serialize_struct(temp, ((VkPhysicalDeviceCooperativeMatrixPropertiesKHR*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceCubicClampFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceCubicClampFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceYcbcrDegammaFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
        {
        auto temp=builder.getVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM();
        return serialize_struct(temp, ((VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceCubicWeightsFeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceCubicWeightsFeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
        {
        auto temp=builder.getVkSamplerCubicWeightsCreateInfoQCOM();
        return serialize_struct(temp, ((VkSamplerCubicWeightsCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
        {
        auto temp=builder.getVkBlitImageCubicWeightsInfoQCOM();
        return serialize_struct(temp, ((VkBlitImageCubicWeightsInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceImageProcessing2FeaturesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceImageProcessing2FeaturesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
        {
        auto temp=builder.getVkPhysicalDeviceImageProcessing2PropertiesQCOM();
        return serialize_struct(temp, ((VkPhysicalDeviceImageProcessing2PropertiesQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
        {
        auto temp=builder.getVkSamplerBlockMatchWindowCreateInfoQCOM();
        return serialize_struct(temp, ((VkSamplerBlockMatchWindowCreateInfoQCOM*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
        auto temp=builder.getVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV();
        return serialize_struct(temp, ((VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*)(member))[0]);
        }
    

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
        {
        auto temp=builder.getVkPhysicalDeviceLayeredDriverPropertiesMSFT();
        return serialize_struct(temp, ((VkPhysicalDeviceLayeredDriverPropertiesMSFT*)(member))[0]);
        }
    

default:
    return serialize_pNext(builder, (void*)(chain->pNext)); //Ignore invalid sTypes
}
}


void* deserialize_pNext(stream::PNext::Reader& reader){
    if (reader.isNone()){
        return NULL;
    }
    
    switch (reader.which()){


    case stream::PNext::VK_BASE_OUT_STRUCTURE:
        {
        auto result=(VkBaseOutStructure*)malloc(sizeof(VkBaseOutStructure));
        auto temp_struct=reader.getVkBaseOutStructure();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BASE_IN_STRUCTURE:
        {
        auto result=(VkBaseInStructure*)malloc(sizeof(VkBaseInStructure));
        auto temp_struct=reader.getVkBaseInStructure();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OFFSET2_D:
        {
        auto result=(VkOffset2D*)malloc(sizeof(VkOffset2D));
        auto temp_struct=reader.getVkOffset2D();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OFFSET3_D:
        {
        auto result=(VkOffset3D*)malloc(sizeof(VkOffset3D));
        auto temp_struct=reader.getVkOffset3D();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTENT2_D:
        {
        auto result=(VkExtent2D*)malloc(sizeof(VkExtent2D));
        auto temp_struct=reader.getVkExtent2D();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTENT3_D:
        {
        auto result=(VkExtent3D*)malloc(sizeof(VkExtent3D));
        auto temp_struct=reader.getVkExtent3D();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIEWPORT:
        {
        auto result=(VkViewport*)malloc(sizeof(VkViewport));
        auto temp_struct=reader.getVkViewport();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RECT2_D:
        {
        auto result=(VkRect2D*)malloc(sizeof(VkRect2D));
        auto temp_struct=reader.getVkRect2D();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CLEAR_RECT:
        {
        auto result=(VkClearRect*)malloc(sizeof(VkClearRect));
        auto temp_struct=reader.getVkClearRect();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMPONENT_MAPPING:
        {
        auto result=(VkComponentMapping*)malloc(sizeof(VkComponentMapping));
        auto temp_struct=reader.getVkComponentMapping();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceProperties*)malloc(sizeof(VkPhysicalDeviceProperties));
        auto temp_struct=reader.getVkPhysicalDeviceProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTENSION_PROPERTIES:
        {
        auto result=(VkExtensionProperties*)malloc(sizeof(VkExtensionProperties));
        auto temp_struct=reader.getVkExtensionProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_LAYER_PROPERTIES:
        {
        auto result=(VkLayerProperties*)malloc(sizeof(VkLayerProperties));
        auto temp_struct=reader.getVkLayerProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_APPLICATION_INFO:
        {
        auto result=(VkApplicationInfo*)malloc(sizeof(VkApplicationInfo));
        auto temp_struct=reader.getVkApplicationInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ALLOCATION_CALLBACKS:
        {
        auto result=(VkAllocationCallbacks*)malloc(sizeof(VkAllocationCallbacks));
        auto temp_struct=reader.getVkAllocationCallbacks();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_QUEUE_CREATE_INFO:
        {
        auto result=(VkDeviceQueueCreateInfo*)malloc(sizeof(VkDeviceQueueCreateInfo));
        auto temp_struct=reader.getVkDeviceQueueCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_CREATE_INFO:
        {
        auto result=(VkDeviceCreateInfo*)malloc(sizeof(VkDeviceCreateInfo));
        auto temp_struct=reader.getVkDeviceCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_INSTANCE_CREATE_INFO:
        {
        auto result=(VkInstanceCreateInfo*)malloc(sizeof(VkInstanceCreateInfo));
        auto temp_struct=reader.getVkInstanceCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUEUE_FAMILY_PROPERTIES:
        {
        auto result=(VkQueueFamilyProperties*)malloc(sizeof(VkQueueFamilyProperties));
        auto temp_struct=reader.getVkQueueFamilyProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MEMORY_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceMemoryProperties*)malloc(sizeof(VkPhysicalDeviceMemoryProperties));
        auto temp_struct=reader.getVkPhysicalDeviceMemoryProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_ALLOCATE_INFO:
        {
        auto result=(VkMemoryAllocateInfo*)malloc(sizeof(VkMemoryAllocateInfo));
        auto temp_struct=reader.getVkMemoryAllocateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_REQUIREMENTS:
        {
        auto result=(VkMemoryRequirements*)malloc(sizeof(VkMemoryRequirements));
        auto temp_struct=reader.getVkMemoryRequirements();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_IMAGE_FORMAT_PROPERTIES:
        {
        auto result=(VkSparseImageFormatProperties*)malloc(sizeof(VkSparseImageFormatProperties));
        auto temp_struct=reader.getVkSparseImageFormatProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_IMAGE_MEMORY_REQUIREMENTS:
        {
        auto result=(VkSparseImageMemoryRequirements*)malloc(sizeof(VkSparseImageMemoryRequirements));
        auto temp_struct=reader.getVkSparseImageMemoryRequirements();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_TYPE:
        {
        auto result=(VkMemoryType*)malloc(sizeof(VkMemoryType));
        auto temp_struct=reader.getVkMemoryType();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_HEAP:
        {
        auto result=(VkMemoryHeap*)malloc(sizeof(VkMemoryHeap));
        auto temp_struct=reader.getVkMemoryHeap();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MAPPED_MEMORY_RANGE:
        {
        auto result=(VkMappedMemoryRange*)malloc(sizeof(VkMappedMemoryRange));
        auto temp_struct=reader.getVkMappedMemoryRange();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FORMAT_PROPERTIES:
        {
        auto result=(VkFormatProperties*)malloc(sizeof(VkFormatProperties));
        auto temp_struct=reader.getVkFormatProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_FORMAT_PROPERTIES:
        {
        auto result=(VkImageFormatProperties*)malloc(sizeof(VkImageFormatProperties));
        auto temp_struct=reader.getVkImageFormatProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_BUFFER_INFO:
        {
        auto result=(VkDescriptorBufferInfo*)malloc(sizeof(VkDescriptorBufferInfo));
        auto temp_struct=reader.getVkDescriptorBufferInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_IMAGE_INFO:
        {
        auto result=(VkDescriptorImageInfo*)malloc(sizeof(VkDescriptorImageInfo));
        auto temp_struct=reader.getVkDescriptorImageInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_WRITE_DESCRIPTOR_SET:
        {
        auto result=(VkWriteDescriptorSet*)malloc(sizeof(VkWriteDescriptorSet));
        auto temp_struct=reader.getVkWriteDescriptorSet();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_DESCRIPTOR_SET:
        {
        auto result=(VkCopyDescriptorSet*)malloc(sizeof(VkCopyDescriptorSet));
        auto temp_struct=reader.getVkCopyDescriptorSet();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_USAGE_FLAGS2_CREATE_INFO_K_H_R:
        {
        auto result=(VkBufferUsageFlags2CreateInfoKHR*)malloc(sizeof(VkBufferUsageFlags2CreateInfoKHR));
        auto temp_struct=reader.getVkBufferUsageFlags2CreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_CREATE_INFO:
        {
        auto result=(VkBufferCreateInfo*)malloc(sizeof(VkBufferCreateInfo));
        auto temp_struct=reader.getVkBufferCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_VIEW_CREATE_INFO:
        {
        auto result=(VkBufferViewCreateInfo*)malloc(sizeof(VkBufferViewCreateInfo));
        auto temp_struct=reader.getVkBufferViewCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_SUBRESOURCE:
        {
        auto result=(VkImageSubresource*)malloc(sizeof(VkImageSubresource));
        auto temp_struct=reader.getVkImageSubresource();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_SUBRESOURCE_LAYERS:
        {
        auto result=(VkImageSubresourceLayers*)malloc(sizeof(VkImageSubresourceLayers));
        auto temp_struct=reader.getVkImageSubresourceLayers();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_SUBRESOURCE_RANGE:
        {
        auto result=(VkImageSubresourceRange*)malloc(sizeof(VkImageSubresourceRange));
        auto temp_struct=reader.getVkImageSubresourceRange();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_BARRIER:
        {
        auto result=(VkMemoryBarrier*)malloc(sizeof(VkMemoryBarrier));
        auto temp_struct=reader.getVkMemoryBarrier();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_MEMORY_BARRIER:
        {
        auto result=(VkBufferMemoryBarrier*)malloc(sizeof(VkBufferMemoryBarrier));
        auto temp_struct=reader.getVkBufferMemoryBarrier();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_MEMORY_BARRIER:
        {
        auto result=(VkImageMemoryBarrier*)malloc(sizeof(VkImageMemoryBarrier));
        auto temp_struct=reader.getVkImageMemoryBarrier();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_CREATE_INFO:
        {
        auto result=(VkImageCreateInfo*)malloc(sizeof(VkImageCreateInfo));
        auto temp_struct=reader.getVkImageCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBRESOURCE_LAYOUT:
        {
        auto result=(VkSubresourceLayout*)malloc(sizeof(VkSubresourceLayout));
        auto temp_struct=reader.getVkSubresourceLayout();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_CREATE_INFO:
        {
        auto result=(VkImageViewCreateInfo*)malloc(sizeof(VkImageViewCreateInfo));
        auto temp_struct=reader.getVkImageViewCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_COPY:
        {
        auto result=(VkBufferCopy*)malloc(sizeof(VkBufferCopy));
        auto temp_struct=reader.getVkBufferCopy();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_MEMORY_BIND:
        {
        auto result=(VkSparseMemoryBind*)malloc(sizeof(VkSparseMemoryBind));
        auto temp_struct=reader.getVkSparseMemoryBind();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_IMAGE_MEMORY_BIND:
        {
        auto result=(VkSparseImageMemoryBind*)malloc(sizeof(VkSparseImageMemoryBind));
        auto temp_struct=reader.getVkSparseImageMemoryBind();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_BUFFER_MEMORY_BIND_INFO:
        {
        auto result=(VkSparseBufferMemoryBindInfo*)malloc(sizeof(VkSparseBufferMemoryBindInfo));
        auto temp_struct=reader.getVkSparseBufferMemoryBindInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_IMAGE_OPAQUE_MEMORY_BIND_INFO:
        {
        auto result=(VkSparseImageOpaqueMemoryBindInfo*)malloc(sizeof(VkSparseImageOpaqueMemoryBindInfo));
        auto temp_struct=reader.getVkSparseImageOpaqueMemoryBindInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_IMAGE_MEMORY_BIND_INFO:
        {
        auto result=(VkSparseImageMemoryBindInfo*)malloc(sizeof(VkSparseImageMemoryBindInfo));
        auto temp_struct=reader.getVkSparseImageMemoryBindInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_SPARSE_INFO:
        {
        auto result=(VkBindSparseInfo*)malloc(sizeof(VkBindSparseInfo));
        auto temp_struct=reader.getVkBindSparseInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_COPY:
        {
        auto result=(VkImageCopy*)malloc(sizeof(VkImageCopy));
        auto temp_struct=reader.getVkImageCopy();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_BLIT:
        {
        auto result=(VkImageBlit*)malloc(sizeof(VkImageBlit));
        auto temp_struct=reader.getVkImageBlit();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_IMAGE_COPY:
        {
        auto result=(VkBufferImageCopy*)malloc(sizeof(VkBufferImageCopy));
        auto temp_struct=reader.getVkBufferImageCopy();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_MEMORY_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkCopyMemoryIndirectCommandNV*)malloc(sizeof(VkCopyMemoryIndirectCommandNV));
        auto temp_struct=reader.getVkCopyMemoryIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_MEMORY_TO_IMAGE_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkCopyMemoryToImageIndirectCommandNV*)malloc(sizeof(VkCopyMemoryToImageIndirectCommandNV));
        auto temp_struct=reader.getVkCopyMemoryToImageIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_RESOLVE:
        {
        auto result=(VkImageResolve*)malloc(sizeof(VkImageResolve));
        auto temp_struct=reader.getVkImageResolve();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHADER_MODULE_CREATE_INFO:
        {
        auto result=(VkShaderModuleCreateInfo*)malloc(sizeof(VkShaderModuleCreateInfo));
        auto temp_struct=reader.getVkShaderModuleCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_LAYOUT_BINDING:
        {
        auto result=(VkDescriptorSetLayoutBinding*)malloc(sizeof(VkDescriptorSetLayoutBinding));
        auto temp_struct=reader.getVkDescriptorSetLayoutBinding();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
        {
        auto result=(VkDescriptorSetLayoutCreateInfo*)malloc(sizeof(VkDescriptorSetLayoutCreateInfo));
        auto temp_struct=reader.getVkDescriptorSetLayoutCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_POOL_SIZE:
        {
        auto result=(VkDescriptorPoolSize*)malloc(sizeof(VkDescriptorPoolSize));
        auto temp_struct=reader.getVkDescriptorPoolSize();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_POOL_CREATE_INFO:
        {
        auto result=(VkDescriptorPoolCreateInfo*)malloc(sizeof(VkDescriptorPoolCreateInfo));
        auto temp_struct=reader.getVkDescriptorPoolCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_ALLOCATE_INFO:
        {
        auto result=(VkDescriptorSetAllocateInfo*)malloc(sizeof(VkDescriptorSetAllocateInfo));
        auto temp_struct=reader.getVkDescriptorSetAllocateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPECIALIZATION_MAP_ENTRY:
        {
        auto result=(VkSpecializationMapEntry*)malloc(sizeof(VkSpecializationMapEntry));
        auto temp_struct=reader.getVkSpecializationMapEntry();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPECIALIZATION_INFO:
        {
        auto result=(VkSpecializationInfo*)malloc(sizeof(VkSpecializationInfo));
        auto temp_struct=reader.getVkSpecializationInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_SHADER_STAGE_CREATE_INFO:
        {
        auto result=(VkPipelineShaderStageCreateInfo*)malloc(sizeof(VkPipelineShaderStageCreateInfo));
        auto temp_struct=reader.getVkPipelineShaderStageCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMPUTE_PIPELINE_CREATE_INFO:
        {
        auto result=(VkComputePipelineCreateInfo*)malloc(sizeof(VkComputePipelineCreateInfo));
        auto temp_struct=reader.getVkComputePipelineCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_N_V:
        {
        auto result=(VkComputePipelineIndirectBufferInfoNV*)malloc(sizeof(VkComputePipelineIndirectBufferInfoNV));
        auto temp_struct=reader.getVkComputePipelineIndirectBufferInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_CREATE_FLAGS2_CREATE_INFO_K_H_R:
        {
        auto result=(VkPipelineCreateFlags2CreateInfoKHR*)malloc(sizeof(VkPipelineCreateFlags2CreateInfoKHR));
        auto temp_struct=reader.getVkPipelineCreateFlags2CreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VERTEX_INPUT_BINDING_DESCRIPTION:
        {
        auto result=(VkVertexInputBindingDescription*)malloc(sizeof(VkVertexInputBindingDescription));
        auto temp_struct=reader.getVkVertexInputBindingDescription();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION:
        {
        auto result=(VkVertexInputAttributeDescription*)malloc(sizeof(VkVertexInputAttributeDescription));
        auto temp_struct=reader.getVkVertexInputAttributeDescription();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineVertexInputStateCreateInfo*)malloc(sizeof(VkPipelineVertexInputStateCreateInfo));
        auto temp_struct=reader.getVkPipelineVertexInputStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineInputAssemblyStateCreateInfo*)malloc(sizeof(VkPipelineInputAssemblyStateCreateInfo));
        auto temp_struct=reader.getVkPipelineInputAssemblyStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineTessellationStateCreateInfo*)malloc(sizeof(VkPipelineTessellationStateCreateInfo));
        auto temp_struct=reader.getVkPipelineTessellationStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineViewportStateCreateInfo*)malloc(sizeof(VkPipelineViewportStateCreateInfo));
        auto temp_struct=reader.getVkPipelineViewportStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineRasterizationStateCreateInfo*)malloc(sizeof(VkPipelineRasterizationStateCreateInfo));
        auto temp_struct=reader.getVkPipelineRasterizationStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineMultisampleStateCreateInfo*)malloc(sizeof(VkPipelineMultisampleStateCreateInfo));
        auto temp_struct=reader.getVkPipelineMultisampleStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COLOR_BLEND_ATTACHMENT_STATE:
        {
        auto result=(VkPipelineColorBlendAttachmentState*)malloc(sizeof(VkPipelineColorBlendAttachmentState));
        auto temp_struct=reader.getVkPipelineColorBlendAttachmentState();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineColorBlendStateCreateInfo*)malloc(sizeof(VkPipelineColorBlendStateCreateInfo));
        auto temp_struct=reader.getVkPipelineColorBlendStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineDynamicStateCreateInfo*)malloc(sizeof(VkPipelineDynamicStateCreateInfo));
        auto temp_struct=reader.getVkPipelineDynamicStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_STENCIL_OP_STATE:
        {
        auto result=(VkStencilOpState*)malloc(sizeof(VkStencilOpState));
        auto temp_struct=reader.getVkStencilOpState();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineDepthStencilStateCreateInfo*)malloc(sizeof(VkPipelineDepthStencilStateCreateInfo));
        auto temp_struct=reader.getVkPipelineDepthStencilStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GRAPHICS_PIPELINE_CREATE_INFO:
        {
        auto result=(VkGraphicsPipelineCreateInfo*)malloc(sizeof(VkGraphicsPipelineCreateInfo));
        auto temp_struct=reader.getVkGraphicsPipelineCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_CACHE_CREATE_INFO:
        {
        auto result=(VkPipelineCacheCreateInfo*)malloc(sizeof(VkPipelineCacheCreateInfo));
        auto temp_struct=reader.getVkPipelineCacheCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_CACHE_HEADER_VERSION_ONE:
        {
        auto result=(VkPipelineCacheHeaderVersionOne*)malloc(sizeof(VkPipelineCacheHeaderVersionOne));
        auto temp_struct=reader.getVkPipelineCacheHeaderVersionOne();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PUSH_CONSTANT_RANGE:
        {
        auto result=(VkPushConstantRange*)malloc(sizeof(VkPushConstantRange));
        auto temp_struct=reader.getVkPushConstantRange();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_LAYOUT_CREATE_INFO:
        {
        auto result=(VkPipelineLayoutCreateInfo*)malloc(sizeof(VkPipelineLayoutCreateInfo));
        auto temp_struct=reader.getVkPipelineLayoutCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_CREATE_INFO:
        {
        auto result=(VkSamplerCreateInfo*)malloc(sizeof(VkSamplerCreateInfo));
        auto temp_struct=reader.getVkSamplerCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_POOL_CREATE_INFO:
        {
        auto result=(VkCommandPoolCreateInfo*)malloc(sizeof(VkCommandPoolCreateInfo));
        auto temp_struct=reader.getVkCommandPoolCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_ALLOCATE_INFO:
        {
        auto result=(VkCommandBufferAllocateInfo*)malloc(sizeof(VkCommandBufferAllocateInfo));
        auto temp_struct=reader.getVkCommandBufferAllocateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_INHERITANCE_INFO:
        {
        auto result=(VkCommandBufferInheritanceInfo*)malloc(sizeof(VkCommandBufferInheritanceInfo));
        auto temp_struct=reader.getVkCommandBufferInheritanceInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_BEGIN_INFO:
        {
        auto result=(VkCommandBufferBeginInfo*)malloc(sizeof(VkCommandBufferBeginInfo));
        auto temp_struct=reader.getVkCommandBufferBeginInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_BEGIN_INFO:
        {
        auto result=(VkRenderPassBeginInfo*)malloc(sizeof(VkRenderPassBeginInfo));
        auto temp_struct=reader.getVkRenderPassBeginInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CLEAR_COLOR_VALUE:
        {
        auto result=(VkClearColorValue*)malloc(sizeof(VkClearColorValue));
        auto temp_struct=reader.getVkClearColorValue();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CLEAR_DEPTH_STENCIL_VALUE:
        {
        auto result=(VkClearDepthStencilValue*)malloc(sizeof(VkClearDepthStencilValue));
        auto temp_struct=reader.getVkClearDepthStencilValue();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CLEAR_VALUE:
        {
        auto result=(VkClearValue*)malloc(sizeof(VkClearValue));
        auto temp_struct=reader.getVkClearValue();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CLEAR_ATTACHMENT:
        {
        auto result=(VkClearAttachment*)malloc(sizeof(VkClearAttachment));
        auto temp_struct=reader.getVkClearAttachment();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_DESCRIPTION:
        {
        auto result=(VkAttachmentDescription*)malloc(sizeof(VkAttachmentDescription));
        auto temp_struct=reader.getVkAttachmentDescription();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_REFERENCE:
        {
        auto result=(VkAttachmentReference*)malloc(sizeof(VkAttachmentReference));
        auto temp_struct=reader.getVkAttachmentReference();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_DESCRIPTION:
        {
        auto result=(VkSubpassDescription*)malloc(sizeof(VkSubpassDescription));
        auto temp_struct=reader.getVkSubpassDescription();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_DEPENDENCY:
        {
        auto result=(VkSubpassDependency*)malloc(sizeof(VkSubpassDependency));
        auto temp_struct=reader.getVkSubpassDependency();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_CREATE_INFO:
        {
        auto result=(VkRenderPassCreateInfo*)malloc(sizeof(VkRenderPassCreateInfo));
        auto temp_struct=reader.getVkRenderPassCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EVENT_CREATE_INFO:
        {
        auto result=(VkEventCreateInfo*)malloc(sizeof(VkEventCreateInfo));
        auto temp_struct=reader.getVkEventCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FENCE_CREATE_INFO:
        {
        auto result=(VkFenceCreateInfo*)malloc(sizeof(VkFenceCreateInfo));
        auto temp_struct=reader.getVkFenceCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FEATURES:
        {
        auto result=(VkPhysicalDeviceFeatures*)malloc(sizeof(VkPhysicalDeviceFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SPARSE_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceSparseProperties*)malloc(sizeof(VkPhysicalDeviceSparseProperties));
        auto temp_struct=reader.getVkPhysicalDeviceSparseProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_LIMITS:
        {
        auto result=(VkPhysicalDeviceLimits*)malloc(sizeof(VkPhysicalDeviceLimits));
        auto temp_struct=reader.getVkPhysicalDeviceLimits();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SEMAPHORE_CREATE_INFO:
        {
        auto result=(VkSemaphoreCreateInfo*)malloc(sizeof(VkSemaphoreCreateInfo));
        auto temp_struct=reader.getVkSemaphoreCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUERY_POOL_CREATE_INFO:
        {
        auto result=(VkQueryPoolCreateInfo*)malloc(sizeof(VkQueryPoolCreateInfo));
        auto temp_struct=reader.getVkQueryPoolCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FRAMEBUFFER_CREATE_INFO:
        {
        auto result=(VkFramebufferCreateInfo*)malloc(sizeof(VkFramebufferCreateInfo));
        auto temp_struct=reader.getVkFramebufferCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRAW_INDIRECT_COMMAND:
        {
        auto result=(VkDrawIndirectCommand*)malloc(sizeof(VkDrawIndirectCommand));
        auto temp_struct=reader.getVkDrawIndirectCommand();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRAW_INDEXED_INDIRECT_COMMAND:
        {
        auto result=(VkDrawIndexedIndirectCommand*)malloc(sizeof(VkDrawIndexedIndirectCommand));
        auto temp_struct=reader.getVkDrawIndexedIndirectCommand();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPATCH_INDIRECT_COMMAND:
        {
        auto result=(VkDispatchIndirectCommand*)malloc(sizeof(VkDispatchIndirectCommand));
        auto temp_struct=reader.getVkDispatchIndirectCommand();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MULTI_DRAW_INFO_E_X_T:
        {
        auto result=(VkMultiDrawInfoEXT*)malloc(sizeof(VkMultiDrawInfoEXT));
        auto temp_struct=reader.getVkMultiDrawInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MULTI_DRAW_INDEXED_INFO_E_X_T:
        {
        auto result=(VkMultiDrawIndexedInfoEXT*)malloc(sizeof(VkMultiDrawIndexedInfoEXT));
        auto temp_struct=reader.getVkMultiDrawIndexedInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBMIT_INFO:
        {
        auto result=(VkSubmitInfo*)malloc(sizeof(VkSubmitInfo));
        auto temp_struct=reader.getVkSubmitInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PROPERTIES_K_H_R:
        {
        auto result=(VkDisplayPropertiesKHR*)malloc(sizeof(VkDisplayPropertiesKHR));
        auto temp_struct=reader.getVkDisplayPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PLANE_PROPERTIES_K_H_R:
        {
        auto result=(VkDisplayPlanePropertiesKHR*)malloc(sizeof(VkDisplayPlanePropertiesKHR));
        auto temp_struct=reader.getVkDisplayPlanePropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_MODE_PARAMETERS_K_H_R:
        {
        auto result=(VkDisplayModeParametersKHR*)malloc(sizeof(VkDisplayModeParametersKHR));
        auto temp_struct=reader.getVkDisplayModeParametersKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_MODE_PROPERTIES_K_H_R:
        {
        auto result=(VkDisplayModePropertiesKHR*)malloc(sizeof(VkDisplayModePropertiesKHR));
        auto temp_struct=reader.getVkDisplayModePropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_MODE_CREATE_INFO_K_H_R:
        {
        auto result=(VkDisplayModeCreateInfoKHR*)malloc(sizeof(VkDisplayModeCreateInfoKHR));
        auto temp_struct=reader.getVkDisplayModeCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PLANE_CAPABILITIES_K_H_R:
        {
        auto result=(VkDisplayPlaneCapabilitiesKHR*)malloc(sizeof(VkDisplayPlaneCapabilitiesKHR));
        auto temp_struct=reader.getVkDisplayPlaneCapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_SURFACE_CREATE_INFO_K_H_R:
        {
        auto result=(VkDisplaySurfaceCreateInfoKHR*)malloc(sizeof(VkDisplaySurfaceCreateInfoKHR));
        auto temp_struct=reader.getVkDisplaySurfaceCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PRESENT_INFO_K_H_R:
        {
        auto result=(VkDisplayPresentInfoKHR*)malloc(sizeof(VkDisplayPresentInfoKHR));
        auto temp_struct=reader.getVkDisplayPresentInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_CAPABILITIES_K_H_R:
        {
        auto result=(VkSurfaceCapabilitiesKHR*)malloc(sizeof(VkSurfaceCapabilitiesKHR));
        auto temp_struct=reader.getVkSurfaceCapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_XLIB_SURFACE_CREATE_INFO_K_H_R:
        {
        auto result=(VkXlibSurfaceCreateInfoKHR*)malloc(sizeof(VkXlibSurfaceCreateInfoKHR));
        auto temp_struct=reader.getVkXlibSurfaceCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_XCB_SURFACE_CREATE_INFO_K_H_R:
        {
        auto result=(VkXcbSurfaceCreateInfoKHR*)malloc(sizeof(VkXcbSurfaceCreateInfoKHR));
        auto temp_struct=reader.getVkXcbSurfaceCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_FORMAT_K_H_R:
        {
        auto result=(VkSurfaceFormatKHR*)malloc(sizeof(VkSurfaceFormatKHR));
        auto temp_struct=reader.getVkSurfaceFormatKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_CREATE_INFO_K_H_R:
        {
        auto result=(VkSwapchainCreateInfoKHR*)malloc(sizeof(VkSwapchainCreateInfoKHR));
        auto temp_struct=reader.getVkSwapchainCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PRESENT_INFO_K_H_R:
        {
        auto result=(VkPresentInfoKHR*)malloc(sizeof(VkPresentInfoKHR));
        auto temp_struct=reader.getVkPresentInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_REPORT_CALLBACK_CREATE_INFO_E_X_T:
        {
        auto result=(VkDebugReportCallbackCreateInfoEXT*)malloc(sizeof(VkDebugReportCallbackCreateInfoEXT));
        auto temp_struct=reader.getVkDebugReportCallbackCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VALIDATION_FLAGS_E_X_T:
        {
        auto result=(VkValidationFlagsEXT*)malloc(sizeof(VkValidationFlagsEXT));
        auto temp_struct=reader.getVkValidationFlagsEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VALIDATION_FEATURES_E_X_T:
        {
        auto result=(VkValidationFeaturesEXT*)malloc(sizeof(VkValidationFeaturesEXT));
        auto temp_struct=reader.getVkValidationFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_A_M_D:
        {
        auto result=(VkPipelineRasterizationStateRasterizationOrderAMD*)malloc(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD));
        auto temp_struct=reader.getVkPipelineRasterizationStateRasterizationOrderAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_MARKER_OBJECT_NAME_INFO_E_X_T:
        {
        auto result=(VkDebugMarkerObjectNameInfoEXT*)malloc(sizeof(VkDebugMarkerObjectNameInfoEXT));
        auto temp_struct=reader.getVkDebugMarkerObjectNameInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_MARKER_OBJECT_TAG_INFO_E_X_T:
        {
        auto result=(VkDebugMarkerObjectTagInfoEXT*)malloc(sizeof(VkDebugMarkerObjectTagInfoEXT));
        auto temp_struct=reader.getVkDebugMarkerObjectTagInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_MARKER_MARKER_INFO_E_X_T:
        {
        auto result=(VkDebugMarkerMarkerInfoEXT*)malloc(sizeof(VkDebugMarkerMarkerInfoEXT));
        auto temp_struct=reader.getVkDebugMarkerMarkerInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_N_V:
        {
        auto result=(VkDedicatedAllocationImageCreateInfoNV*)malloc(sizeof(VkDedicatedAllocationImageCreateInfoNV));
        auto temp_struct=reader.getVkDedicatedAllocationImageCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_N_V:
        {
        auto result=(VkDedicatedAllocationBufferCreateInfoNV*)malloc(sizeof(VkDedicatedAllocationBufferCreateInfoNV));
        auto temp_struct=reader.getVkDedicatedAllocationBufferCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_N_V:
        {
        auto result=(VkDedicatedAllocationMemoryAllocateInfoNV*)malloc(sizeof(VkDedicatedAllocationMemoryAllocateInfoNV));
        auto temp_struct=reader.getVkDedicatedAllocationMemoryAllocateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_IMAGE_FORMAT_PROPERTIES_N_V:
        {
        auto result=(VkExternalImageFormatPropertiesNV*)malloc(sizeof(VkExternalImageFormatPropertiesNV));
        auto temp_struct=reader.getVkExternalImageFormatPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_N_V:
        {
        auto result=(VkExternalMemoryImageCreateInfoNV*)malloc(sizeof(VkExternalMemoryImageCreateInfoNV));
        auto temp_struct=reader.getVkExternalMemoryImageCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXPORT_MEMORY_ALLOCATE_INFO_N_V:
        {
        auto result=(VkExportMemoryAllocateInfoNV*)malloc(sizeof(VkExportMemoryAllocateInfoNV));
        auto temp_struct=reader.getVkExportMemoryAllocateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*)malloc(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*)malloc(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
        auto result=(VkDevicePrivateDataCreateInfo*)malloc(sizeof(VkDevicePrivateDataCreateInfo));
        auto temp_struct=reader.getVkDevicePrivateDataCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PRIVATE_DATA_SLOT_CREATE_INFO:
        {
        auto result=(VkPrivateDataSlotCreateInfo*)malloc(sizeof(VkPrivateDataSlotCreateInfo));
        auto temp_struct=reader.getVkPrivateDataSlotCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
        auto result=(VkPhysicalDevicePrivateDataFeatures*)malloc(sizeof(VkPhysicalDevicePrivateDataFeatures));
        auto temp_struct=reader.getVkPhysicalDevicePrivateDataFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*)malloc(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMultiDrawPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMultiDrawPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GRAPHICS_SHADER_GROUP_CREATE_INFO_N_V:
        {
        auto result=(VkGraphicsShaderGroupCreateInfoNV*)malloc(sizeof(VkGraphicsShaderGroupCreateInfoNV));
        auto temp_struct=reader.getVkGraphicsShaderGroupCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_N_V:
        {
        auto result=(VkGraphicsPipelineShaderGroupsCreateInfoNV*)malloc(sizeof(VkGraphicsPipelineShaderGroupsCreateInfoNV));
        auto temp_struct=reader.getVkGraphicsPipelineShaderGroupsCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_SHADER_GROUP_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkBindShaderGroupIndirectCommandNV*)malloc(sizeof(VkBindShaderGroupIndirectCommandNV));
        auto temp_struct=reader.getVkBindShaderGroupIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_INDEX_BUFFER_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkBindIndexBufferIndirectCommandNV*)malloc(sizeof(VkBindIndexBufferIndirectCommandNV));
        auto temp_struct=reader.getVkBindIndexBufferIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_VERTEX_BUFFER_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkBindVertexBufferIndirectCommandNV*)malloc(sizeof(VkBindVertexBufferIndirectCommandNV));
        auto temp_struct=reader.getVkBindVertexBufferIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SET_STATE_FLAGS_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkSetStateFlagsIndirectCommandNV*)malloc(sizeof(VkSetStateFlagsIndirectCommandNV));
        auto temp_struct=reader.getVkSetStateFlagsIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_INDIRECT_COMMANDS_STREAM_N_V:
        {
        auto result=(VkIndirectCommandsStreamNV*)malloc(sizeof(VkIndirectCommandsStreamNV));
        auto temp_struct=reader.getVkIndirectCommandsStreamNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_INDIRECT_COMMANDS_LAYOUT_TOKEN_N_V:
        {
        auto result=(VkIndirectCommandsLayoutTokenNV*)malloc(sizeof(VkIndirectCommandsLayoutTokenNV));
        auto temp_struct=reader.getVkIndirectCommandsLayoutTokenNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_N_V:
        {
        auto result=(VkIndirectCommandsLayoutCreateInfoNV*)malloc(sizeof(VkIndirectCommandsLayoutCreateInfoNV));
        auto temp_struct=reader.getVkIndirectCommandsLayoutCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GENERATED_COMMANDS_INFO_N_V:
        {
        auto result=(VkGeneratedCommandsInfoNV*)malloc(sizeof(VkGeneratedCommandsInfoNV));
        auto temp_struct=reader.getVkGeneratedCommandsInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_N_V:
        {
        auto result=(VkGeneratedCommandsMemoryRequirementsInfoNV*)malloc(sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV));
        auto temp_struct=reader.getVkGeneratedCommandsMemoryRequirementsInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_N_V:
        {
        auto result=(VkPipelineIndirectDeviceAddressInfoNV*)malloc(sizeof(VkPipelineIndirectDeviceAddressInfoNV));
        auto temp_struct=reader.getVkPipelineIndirectDeviceAddressInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_PIPELINE_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkBindPipelineIndirectCommandNV*)malloc(sizeof(VkBindPipelineIndirectCommandNV));
        auto temp_struct=reader.getVkBindPipelineIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FEATURES2:
        {
        auto result=(VkPhysicalDeviceFeatures2*)malloc(sizeof(VkPhysicalDeviceFeatures2));
        auto temp_struct=reader.getVkPhysicalDeviceFeatures2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PROPERTIES2:
        {
        auto result=(VkPhysicalDeviceProperties2*)malloc(sizeof(VkPhysicalDeviceProperties2));
        auto temp_struct=reader.getVkPhysicalDeviceProperties2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FORMAT_PROPERTIES2:
        {
        auto result=(VkFormatProperties2*)malloc(sizeof(VkFormatProperties2));
        auto temp_struct=reader.getVkFormatProperties2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_FORMAT_PROPERTIES2:
        {
        auto result=(VkImageFormatProperties2*)malloc(sizeof(VkImageFormatProperties2));
        auto temp_struct=reader.getVkImageFormatProperties2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO2:
        {
        auto result=(VkPhysicalDeviceImageFormatInfo2*)malloc(sizeof(VkPhysicalDeviceImageFormatInfo2));
        auto temp_struct=reader.getVkPhysicalDeviceImageFormatInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUEUE_FAMILY_PROPERTIES2:
        {
        auto result=(VkQueueFamilyProperties2*)malloc(sizeof(VkQueueFamilyProperties2));
        auto temp_struct=reader.getVkQueueFamilyProperties2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MEMORY_PROPERTIES2:
        {
        auto result=(VkPhysicalDeviceMemoryProperties2*)malloc(sizeof(VkPhysicalDeviceMemoryProperties2));
        auto temp_struct=reader.getVkPhysicalDeviceMemoryProperties2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_IMAGE_FORMAT_PROPERTIES2:
        {
        auto result=(VkSparseImageFormatProperties2*)malloc(sizeof(VkSparseImageFormatProperties2));
        auto temp_struct=reader.getVkSparseImageFormatProperties2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO2:
        {
        auto result=(VkPhysicalDeviceSparseImageFormatInfo2*)malloc(sizeof(VkPhysicalDeviceSparseImageFormatInfo2));
        auto temp_struct=reader.getVkPhysicalDeviceSparseImageFormatInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDevicePushDescriptorPropertiesKHR*)malloc(sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDevicePushDescriptorPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CONFORMANCE_VERSION:
        {
        auto result=(VkConformanceVersion*)malloc(sizeof(VkConformanceVersion));
        auto temp_struct=reader.getVkConformanceVersion();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceDriverProperties*)malloc(sizeof(VkPhysicalDeviceDriverProperties));
        auto temp_struct=reader.getVkPhysicalDeviceDriverProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PRESENT_REGIONS_K_H_R:
        {
        auto result=(VkPresentRegionsKHR*)malloc(sizeof(VkPresentRegionsKHR));
        auto temp_struct=reader.getVkPresentRegionsKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PRESENT_REGION_K_H_R:
        {
        auto result=(VkPresentRegionKHR*)malloc(sizeof(VkPresentRegionKHR));
        auto temp_struct=reader.getVkPresentRegionKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RECT_LAYER_K_H_R:
        {
        auto result=(VkRectLayerKHR*)malloc(sizeof(VkRectLayerKHR));
        auto temp_struct=reader.getVkRectLayerKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
        auto result=(VkPhysicalDeviceVariablePointersFeatures*)malloc(sizeof(VkPhysicalDeviceVariablePointersFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceVariablePointersFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_MEMORY_PROPERTIES:
        {
        auto result=(VkExternalMemoryProperties*)malloc(sizeof(VkExternalMemoryProperties));
        auto temp_struct=reader.getVkExternalMemoryProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
        auto result=(VkPhysicalDeviceExternalImageFormatInfo*)malloc(sizeof(VkPhysicalDeviceExternalImageFormatInfo));
        auto temp_struct=reader.getVkPhysicalDeviceExternalImageFormatInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
        auto result=(VkExternalImageFormatProperties*)malloc(sizeof(VkExternalImageFormatProperties));
        auto temp_struct=reader.getVkExternalImageFormatProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
        {
        auto result=(VkPhysicalDeviceExternalBufferInfo*)malloc(sizeof(VkPhysicalDeviceExternalBufferInfo));
        auto temp_struct=reader.getVkPhysicalDeviceExternalBufferInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_BUFFER_PROPERTIES:
        {
        auto result=(VkExternalBufferProperties*)malloc(sizeof(VkExternalBufferProperties));
        auto temp_struct=reader.getVkExternalBufferProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_I_D_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceIDProperties*)malloc(sizeof(VkPhysicalDeviceIDProperties));
        auto temp_struct=reader.getVkPhysicalDeviceIDProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
        auto result=(VkExternalMemoryImageCreateInfo*)malloc(sizeof(VkExternalMemoryImageCreateInfo));
        auto temp_struct=reader.getVkExternalMemoryImageCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
        auto result=(VkExternalMemoryBufferCreateInfo*)malloc(sizeof(VkExternalMemoryBufferCreateInfo));
        auto temp_struct=reader.getVkExternalMemoryBufferCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXPORT_MEMORY_ALLOCATE_INFO:
        {
        auto result=(VkExportMemoryAllocateInfo*)malloc(sizeof(VkExportMemoryAllocateInfo));
        auto temp_struct=reader.getVkExportMemoryAllocateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMPORT_MEMORY_FD_INFO_K_H_R:
        {
        auto result=(VkImportMemoryFdInfoKHR*)malloc(sizeof(VkImportMemoryFdInfoKHR));
        auto temp_struct=reader.getVkImportMemoryFdInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_FD_PROPERTIES_K_H_R:
        {
        auto result=(VkMemoryFdPropertiesKHR*)malloc(sizeof(VkMemoryFdPropertiesKHR));
        auto temp_struct=reader.getVkMemoryFdPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_GET_FD_INFO_K_H_R:
        {
        auto result=(VkMemoryGetFdInfoKHR*)malloc(sizeof(VkMemoryGetFdInfoKHR));
        auto temp_struct=reader.getVkMemoryGetFdInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
        {
        auto result=(VkPhysicalDeviceExternalSemaphoreInfo*)malloc(sizeof(VkPhysicalDeviceExternalSemaphoreInfo));
        auto temp_struct=reader.getVkPhysicalDeviceExternalSemaphoreInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_SEMAPHORE_PROPERTIES:
        {
        auto result=(VkExternalSemaphoreProperties*)malloc(sizeof(VkExternalSemaphoreProperties));
        auto temp_struct=reader.getVkExternalSemaphoreProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXPORT_SEMAPHORE_CREATE_INFO:
        {
        auto result=(VkExportSemaphoreCreateInfo*)malloc(sizeof(VkExportSemaphoreCreateInfo));
        auto temp_struct=reader.getVkExportSemaphoreCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMPORT_SEMAPHORE_FD_INFO_K_H_R:
        {
        auto result=(VkImportSemaphoreFdInfoKHR*)malloc(sizeof(VkImportSemaphoreFdInfoKHR));
        auto temp_struct=reader.getVkImportSemaphoreFdInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SEMAPHORE_GET_FD_INFO_K_H_R:
        {
        auto result=(VkSemaphoreGetFdInfoKHR*)malloc(sizeof(VkSemaphoreGetFdInfoKHR));
        auto temp_struct=reader.getVkSemaphoreGetFdInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
        {
        auto result=(VkPhysicalDeviceExternalFenceInfo*)malloc(sizeof(VkPhysicalDeviceExternalFenceInfo));
        auto temp_struct=reader.getVkPhysicalDeviceExternalFenceInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_FENCE_PROPERTIES:
        {
        auto result=(VkExternalFenceProperties*)malloc(sizeof(VkExternalFenceProperties));
        auto temp_struct=reader.getVkExternalFenceProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXPORT_FENCE_CREATE_INFO:
        {
        auto result=(VkExportFenceCreateInfo*)malloc(sizeof(VkExportFenceCreateInfo));
        auto temp_struct=reader.getVkExportFenceCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMPORT_FENCE_FD_INFO_K_H_R:
        {
        auto result=(VkImportFenceFdInfoKHR*)malloc(sizeof(VkImportFenceFdInfoKHR));
        auto temp_struct=reader.getVkImportFenceFdInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FENCE_GET_FD_INFO_K_H_R:
        {
        auto result=(VkFenceGetFdInfoKHR*)malloc(sizeof(VkFenceGetFdInfoKHR));
        auto temp_struct=reader.getVkFenceGetFdInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
        auto result=(VkPhysicalDeviceMultiviewFeatures*)malloc(sizeof(VkPhysicalDeviceMultiviewFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceMultiviewFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceMultiviewProperties*)malloc(sizeof(VkPhysicalDeviceMultiviewProperties));
        auto temp_struct=reader.getVkPhysicalDeviceMultiviewProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
        auto result=(VkRenderPassMultiviewCreateInfo*)malloc(sizeof(VkRenderPassMultiviewCreateInfo));
        auto temp_struct=reader.getVkRenderPassMultiviewCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_CAPABILITIES2_E_X_T:
        {
        auto result=(VkSurfaceCapabilities2EXT*)malloc(sizeof(VkSurfaceCapabilities2EXT));
        auto temp_struct=reader.getVkSurfaceCapabilities2EXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_POWER_INFO_E_X_T:
        {
        auto result=(VkDisplayPowerInfoEXT*)malloc(sizeof(VkDisplayPowerInfoEXT));
        auto temp_struct=reader.getVkDisplayPowerInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_EVENT_INFO_E_X_T:
        {
        auto result=(VkDeviceEventInfoEXT*)malloc(sizeof(VkDeviceEventInfoEXT));
        auto temp_struct=reader.getVkDeviceEventInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_EVENT_INFO_E_X_T:
        {
        auto result=(VkDisplayEventInfoEXT*)malloc(sizeof(VkDisplayEventInfoEXT));
        auto temp_struct=reader.getVkDisplayEventInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_COUNTER_CREATE_INFO_E_X_T:
        {
        auto result=(VkSwapchainCounterCreateInfoEXT*)malloc(sizeof(VkSwapchainCounterCreateInfoEXT));
        auto temp_struct=reader.getVkSwapchainCounterCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_GROUP_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceGroupProperties*)malloc(sizeof(VkPhysicalDeviceGroupProperties));
        auto temp_struct=reader.getVkPhysicalDeviceGroupProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_ALLOCATE_FLAGS_INFO:
        {
        auto result=(VkMemoryAllocateFlagsInfo*)malloc(sizeof(VkMemoryAllocateFlagsInfo));
        auto temp_struct=reader.getVkMemoryAllocateFlagsInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_BUFFER_MEMORY_INFO:
        {
        auto result=(VkBindBufferMemoryInfo*)malloc(sizeof(VkBindBufferMemoryInfo));
        auto temp_struct=reader.getVkBindBufferMemoryInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
        auto result=(VkBindBufferMemoryDeviceGroupInfo*)malloc(sizeof(VkBindBufferMemoryDeviceGroupInfo));
        auto temp_struct=reader.getVkBindBufferMemoryDeviceGroupInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_IMAGE_MEMORY_INFO:
        {
        auto result=(VkBindImageMemoryInfo*)malloc(sizeof(VkBindImageMemoryInfo));
        auto temp_struct=reader.getVkBindImageMemoryInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
        auto result=(VkBindImageMemoryDeviceGroupInfo*)malloc(sizeof(VkBindImageMemoryDeviceGroupInfo));
        auto temp_struct=reader.getVkBindImageMemoryDeviceGroupInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
        auto result=(VkDeviceGroupRenderPassBeginInfo*)malloc(sizeof(VkDeviceGroupRenderPassBeginInfo));
        auto temp_struct=reader.getVkDeviceGroupRenderPassBeginInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
        auto result=(VkDeviceGroupCommandBufferBeginInfo*)malloc(sizeof(VkDeviceGroupCommandBufferBeginInfo));
        auto temp_struct=reader.getVkDeviceGroupCommandBufferBeginInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_SUBMIT_INFO:
        {
        auto result=(VkDeviceGroupSubmitInfo*)malloc(sizeof(VkDeviceGroupSubmitInfo));
        auto temp_struct=reader.getVkDeviceGroupSubmitInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
        auto result=(VkDeviceGroupBindSparseInfo*)malloc(sizeof(VkDeviceGroupBindSparseInfo));
        auto temp_struct=reader.getVkDeviceGroupBindSparseInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_PRESENT_CAPABILITIES_K_H_R:
        {
        auto result=(VkDeviceGroupPresentCapabilitiesKHR*)malloc(sizeof(VkDeviceGroupPresentCapabilitiesKHR));
        auto temp_struct=reader.getVkDeviceGroupPresentCapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_SWAPCHAIN_CREATE_INFO_K_H_R:
        {
        auto result=(VkImageSwapchainCreateInfoKHR*)malloc(sizeof(VkImageSwapchainCreateInfoKHR));
        auto temp_struct=reader.getVkImageSwapchainCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_K_H_R:
        {
        auto result=(VkBindImageMemorySwapchainInfoKHR*)malloc(sizeof(VkBindImageMemorySwapchainInfoKHR));
        auto temp_struct=reader.getVkBindImageMemorySwapchainInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACQUIRE_NEXT_IMAGE_INFO_K_H_R:
        {
        auto result=(VkAcquireNextImageInfoKHR*)malloc(sizeof(VkAcquireNextImageInfoKHR));
        auto temp_struct=reader.getVkAcquireNextImageInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_PRESENT_INFO_K_H_R:
        {
        auto result=(VkDeviceGroupPresentInfoKHR*)malloc(sizeof(VkDeviceGroupPresentInfoKHR));
        auto temp_struct=reader.getVkDeviceGroupPresentInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
        auto result=(VkDeviceGroupDeviceCreateInfo*)malloc(sizeof(VkDeviceGroupDeviceCreateInfo));
        auto temp_struct=reader.getVkDeviceGroupDeviceCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_K_H_R:
        {
        auto result=(VkDeviceGroupSwapchainCreateInfoKHR*)malloc(sizeof(VkDeviceGroupSwapchainCreateInfoKHR));
        auto temp_struct=reader.getVkDeviceGroupSwapchainCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_UPDATE_TEMPLATE_ENTRY:
        {
        auto result=(VkDescriptorUpdateTemplateEntry*)malloc(sizeof(VkDescriptorUpdateTemplateEntry));
        auto temp_struct=reader.getVkDescriptorUpdateTemplateEntry();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
        {
        auto result=(VkDescriptorUpdateTemplateCreateInfo*)malloc(sizeof(VkDescriptorUpdateTemplateCreateInfo));
        auto temp_struct=reader.getVkDescriptorUpdateTemplateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_X_Y_COLOR_E_X_T:
        {
        auto result=(VkXYColorEXT*)malloc(sizeof(VkXYColorEXT));
        auto temp_struct=reader.getVkXYColorEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDevicePresentIdFeaturesKHR*)malloc(sizeof(VkPhysicalDevicePresentIdFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDevicePresentIdFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PRESENT_ID_K_H_R:
        {
        auto result=(VkPresentIdKHR*)malloc(sizeof(VkPresentIdKHR));
        auto temp_struct=reader.getVkPresentIdKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDevicePresentWaitFeaturesKHR*)malloc(sizeof(VkPhysicalDevicePresentWaitFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDevicePresentWaitFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_HDR_METADATA_E_X_T:
        {
        auto result=(VkHdrMetadataEXT*)malloc(sizeof(VkHdrMetadataEXT));
        auto temp_struct=reader.getVkHdrMetadataEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_A_M_D:
        {
        auto result=(VkDisplayNativeHdrSurfaceCapabilitiesAMD*)malloc(sizeof(VkDisplayNativeHdrSurfaceCapabilitiesAMD));
        auto temp_struct=reader.getVkDisplayNativeHdrSurfaceCapabilitiesAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_A_M_D:
        {
        auto result=(VkSwapchainDisplayNativeHdrCreateInfoAMD*)malloc(sizeof(VkSwapchainDisplayNativeHdrCreateInfoAMD));
        auto temp_struct=reader.getVkSwapchainDisplayNativeHdrCreateInfoAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_REFRESH_CYCLE_DURATION_G_O_O_G_L_E:
        {
        auto result=(VkRefreshCycleDurationGOOGLE*)malloc(sizeof(VkRefreshCycleDurationGOOGLE));
        auto temp_struct=reader.getVkRefreshCycleDurationGOOGLE();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PAST_PRESENTATION_TIMING_G_O_O_G_L_E:
        {
        auto result=(VkPastPresentationTimingGOOGLE*)malloc(sizeof(VkPastPresentationTimingGOOGLE));
        auto temp_struct=reader.getVkPastPresentationTimingGOOGLE();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PRESENT_TIMES_INFO_G_O_O_G_L_E:
        {
        auto result=(VkPresentTimesInfoGOOGLE*)malloc(sizeof(VkPresentTimesInfoGOOGLE));
        auto temp_struct=reader.getVkPresentTimesInfoGOOGLE();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PRESENT_TIME_G_O_O_G_L_E:
        {
        auto result=(VkPresentTimeGOOGLE*)malloc(sizeof(VkPresentTimeGOOGLE));
        auto temp_struct=reader.getVkPresentTimeGOOGLE();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIEWPORT_W_SCALING_N_V:
        {
        auto result=(VkViewportWScalingNV*)malloc(sizeof(VkViewportWScalingNV));
        auto temp_struct=reader.getVkViewportWScalingNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineViewportWScalingStateCreateInfoNV*)malloc(sizeof(VkPipelineViewportWScalingStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineViewportWScalingStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIEWPORT_SWIZZLE_N_V:
        {
        auto result=(VkViewportSwizzleNV*)malloc(sizeof(VkViewportSwizzleNV));
        auto temp_struct=reader.getVkViewportSwizzleNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineViewportSwizzleStateCreateInfoNV*)malloc(sizeof(VkPipelineViewportSwizzleStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineViewportSwizzleStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDiscardRectanglePropertiesEXT*)malloc(sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDiscardRectanglePropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineDiscardRectangleStateCreateInfoEXT*)malloc(sizeof(VkPipelineDiscardRectangleStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineDiscardRectangleStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_N_V_X:
        {
        auto result=(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*)malloc(sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX));
        auto temp_struct=reader.getVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_INPUT_ATTACHMENT_ASPECT_REFERENCE:
        {
        auto result=(VkInputAttachmentAspectReference*)malloc(sizeof(VkInputAttachmentAspectReference));
        auto temp_struct=reader.getVkInputAttachmentAspectReference();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
        auto result=(VkRenderPassInputAttachmentAspectCreateInfo*)malloc(sizeof(VkRenderPassInputAttachmentAspectCreateInfo));
        auto temp_struct=reader.getVkRenderPassInputAttachmentAspectCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SURFACE_INFO2_K_H_R:
        {
        auto result=(VkPhysicalDeviceSurfaceInfo2KHR*)malloc(sizeof(VkPhysicalDeviceSurfaceInfo2KHR));
        auto temp_struct=reader.getVkPhysicalDeviceSurfaceInfo2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_CAPABILITIES2_K_H_R:
        {
        auto result=(VkSurfaceCapabilities2KHR*)malloc(sizeof(VkSurfaceCapabilities2KHR));
        auto temp_struct=reader.getVkSurfaceCapabilities2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_FORMAT2_K_H_R:
        {
        auto result=(VkSurfaceFormat2KHR*)malloc(sizeof(VkSurfaceFormat2KHR));
        auto temp_struct=reader.getVkSurfaceFormat2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PROPERTIES2_K_H_R:
        {
        auto result=(VkDisplayProperties2KHR*)malloc(sizeof(VkDisplayProperties2KHR));
        auto temp_struct=reader.getVkDisplayProperties2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PLANE_PROPERTIES2_K_H_R:
        {
        auto result=(VkDisplayPlaneProperties2KHR*)malloc(sizeof(VkDisplayPlaneProperties2KHR));
        auto temp_struct=reader.getVkDisplayPlaneProperties2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_MODE_PROPERTIES2_K_H_R:
        {
        auto result=(VkDisplayModeProperties2KHR*)malloc(sizeof(VkDisplayModeProperties2KHR));
        auto temp_struct=reader.getVkDisplayModeProperties2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PLANE_INFO2_K_H_R:
        {
        auto result=(VkDisplayPlaneInfo2KHR*)malloc(sizeof(VkDisplayPlaneInfo2KHR));
        auto temp_struct=reader.getVkDisplayPlaneInfo2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DISPLAY_PLANE_CAPABILITIES2_K_H_R:
        {
        auto result=(VkDisplayPlaneCapabilities2KHR*)malloc(sizeof(VkDisplayPlaneCapabilities2KHR));
        auto temp_struct=reader.getVkDisplayPlaneCapabilities2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHARED_PRESENT_SURFACE_CAPABILITIES_K_H_R:
        {
        auto result=(VkSharedPresentSurfaceCapabilitiesKHR*)malloc(sizeof(VkSharedPresentSurfaceCapabilitiesKHR));
        auto temp_struct=reader.getVkSharedPresentSurfaceCapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE16_BIT_STORAGE_FEATURES:
        {
        auto result=(VkPhysicalDevice16BitStorageFeatures*)malloc(sizeof(VkPhysicalDevice16BitStorageFeatures));
        auto temp_struct=reader.getVkPhysicalDevice16BitStorageFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceSubgroupProperties*)malloc(sizeof(VkPhysicalDeviceSubgroupProperties));
        auto temp_struct=reader.getVkPhysicalDeviceSubgroupProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
        auto result=(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*)malloc(sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_MEMORY_REQUIREMENTS_INFO2:
        {
        auto result=(VkBufferMemoryRequirementsInfo2*)malloc(sizeof(VkBufferMemoryRequirementsInfo2));
        auto temp_struct=reader.getVkBufferMemoryRequirementsInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_BUFFER_MEMORY_REQUIREMENTS:
        {
        auto result=(VkDeviceBufferMemoryRequirements*)malloc(sizeof(VkDeviceBufferMemoryRequirements));
        auto temp_struct=reader.getVkDeviceBufferMemoryRequirements();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_MEMORY_REQUIREMENTS_INFO2:
        {
        auto result=(VkImageMemoryRequirementsInfo2*)malloc(sizeof(VkImageMemoryRequirementsInfo2));
        auto temp_struct=reader.getVkImageMemoryRequirementsInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO2:
        {
        auto result=(VkImageSparseMemoryRequirementsInfo2*)malloc(sizeof(VkImageSparseMemoryRequirementsInfo2));
        auto temp_struct=reader.getVkImageSparseMemoryRequirementsInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_IMAGE_MEMORY_REQUIREMENTS:
        {
        auto result=(VkDeviceImageMemoryRequirements*)malloc(sizeof(VkDeviceImageMemoryRequirements));
        auto temp_struct=reader.getVkDeviceImageMemoryRequirements();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_REQUIREMENTS2:
        {
        auto result=(VkMemoryRequirements2*)malloc(sizeof(VkMemoryRequirements2));
        auto temp_struct=reader.getVkMemoryRequirements2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SPARSE_IMAGE_MEMORY_REQUIREMENTS2:
        {
        auto result=(VkSparseImageMemoryRequirements2*)malloc(sizeof(VkSparseImageMemoryRequirements2));
        auto temp_struct=reader.getVkSparseImageMemoryRequirements2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
        auto result=(VkPhysicalDevicePointClippingProperties*)malloc(sizeof(VkPhysicalDevicePointClippingProperties));
        auto temp_struct=reader.getVkPhysicalDevicePointClippingProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_DEDICATED_REQUIREMENTS:
        {
        auto result=(VkMemoryDedicatedRequirements*)malloc(sizeof(VkMemoryDedicatedRequirements));
        auto temp_struct=reader.getVkMemoryDedicatedRequirements();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
        auto result=(VkMemoryDedicatedAllocateInfo*)malloc(sizeof(VkMemoryDedicatedAllocateInfo));
        auto temp_struct=reader.getVkMemoryDedicatedAllocateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
        auto result=(VkImageViewUsageCreateInfo*)malloc(sizeof(VkImageViewUsageCreateInfo));
        auto temp_struct=reader.getVkImageViewUsageCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_SLICED_CREATE_INFO_E_X_T:
        {
        auto result=(VkImageViewSlicedCreateInfoEXT*)malloc(sizeof(VkImageViewSlicedCreateInfoEXT));
        auto temp_struct=reader.getVkImageViewSlicedCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
        auto result=(VkPipelineTessellationDomainOriginStateCreateInfo*)malloc(sizeof(VkPipelineTessellationDomainOriginStateCreateInfo));
        auto temp_struct=reader.getVkPipelineTessellationDomainOriginStateCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_YCBCR_CONVERSION_INFO:
        {
        auto result=(VkSamplerYcbcrConversionInfo*)malloc(sizeof(VkSamplerYcbcrConversionInfo));
        auto temp_struct=reader.getVkSamplerYcbcrConversionInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
        {
        auto result=(VkSamplerYcbcrConversionCreateInfo*)malloc(sizeof(VkSamplerYcbcrConversionCreateInfo));
        auto temp_struct=reader.getVkSamplerYcbcrConversionCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
        auto result=(VkBindImagePlaneMemoryInfo*)malloc(sizeof(VkBindImagePlaneMemoryInfo));
        auto temp_struct=reader.getVkBindImagePlaneMemoryInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
        auto result=(VkImagePlaneMemoryRequirementsInfo*)malloc(sizeof(VkImagePlaneMemoryRequirementsInfo));
        auto temp_struct=reader.getVkImagePlaneMemoryRequirementsInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
        auto result=(VkPhysicalDeviceSamplerYcbcrConversionFeatures*)malloc(sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceSamplerYcbcrConversionFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
        auto result=(VkSamplerYcbcrConversionImageFormatProperties*)malloc(sizeof(VkSamplerYcbcrConversionImageFormatProperties));
        auto temp_struct=reader.getVkSamplerYcbcrConversionImageFormatProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_TEXTURE_L_O_D_GATHER_FORMAT_PROPERTIES_A_M_D:
        {
        auto result=(VkTextureLODGatherFormatPropertiesAMD*)malloc(sizeof(VkTextureLODGatherFormatPropertiesAMD));
        auto temp_struct=reader.getVkTextureLODGatherFormatPropertiesAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CONDITIONAL_RENDERING_BEGIN_INFO_E_X_T:
        {
        auto result=(VkConditionalRenderingBeginInfoEXT*)malloc(sizeof(VkConditionalRenderingBeginInfoEXT));
        auto temp_struct=reader.getVkConditionalRenderingBeginInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PROTECTED_SUBMIT_INFO:
        {
        auto result=(VkProtectedSubmitInfo*)malloc(sizeof(VkProtectedSubmitInfo));
        auto temp_struct=reader.getVkProtectedSubmitInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
        auto result=(VkPhysicalDeviceProtectedMemoryFeatures*)malloc(sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceProtectedMemoryFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceProtectedMemoryProperties*)malloc(sizeof(VkPhysicalDeviceProtectedMemoryProperties));
        auto temp_struct=reader.getVkPhysicalDeviceProtectedMemoryProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_QUEUE_INFO2:
        {
        auto result=(VkDeviceQueueInfo2*)malloc(sizeof(VkDeviceQueueInfo2));
        auto temp_struct=reader.getVkDeviceQueueInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineCoverageToColorStateCreateInfoNV*)malloc(sizeof(VkPipelineCoverageToColorStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineCoverageToColorStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceSamplerFilterMinmaxProperties*)malloc(sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties));
        auto temp_struct=reader.getVkPhysicalDeviceSamplerFilterMinmaxProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLE_LOCATION_E_X_T:
        {
        auto result=(VkSampleLocationEXT*)malloc(sizeof(VkSampleLocationEXT));
        auto temp_struct=reader.getVkSampleLocationEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLE_LOCATIONS_INFO_E_X_T:
        {
        auto result=(VkSampleLocationsInfoEXT*)malloc(sizeof(VkSampleLocationsInfoEXT));
        auto temp_struct=reader.getVkSampleLocationsInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_SAMPLE_LOCATIONS_E_X_T:
        {
        auto result=(VkAttachmentSampleLocationsEXT*)malloc(sizeof(VkAttachmentSampleLocationsEXT));
        auto temp_struct=reader.getVkAttachmentSampleLocationsEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_SAMPLE_LOCATIONS_E_X_T:
        {
        auto result=(VkSubpassSampleLocationsEXT*)malloc(sizeof(VkSubpassSampleLocationsEXT));
        auto temp_struct=reader.getVkSubpassSampleLocationsEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_E_X_T:
        {
        auto result=(VkRenderPassSampleLocationsBeginInfoEXT*)malloc(sizeof(VkRenderPassSampleLocationsBeginInfoEXT));
        auto temp_struct=reader.getVkRenderPassSampleLocationsBeginInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineSampleLocationsStateCreateInfoEXT*)malloc(sizeof(VkPipelineSampleLocationsStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineSampleLocationsStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceSampleLocationsPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceSampleLocationsPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MULTISAMPLE_PROPERTIES_E_X_T:
        {
        auto result=(VkMultisamplePropertiesEXT*)malloc(sizeof(VkMultisamplePropertiesEXT));
        auto temp_struct=reader.getVkMultisamplePropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
        auto result=(VkSamplerReductionModeCreateInfo*)malloc(sizeof(VkSamplerReductionModeCreateInfo));
        auto temp_struct=reader.getVkSamplerReductionModeCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMultiDrawFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMultiDrawFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineColorBlendAdvancedStateCreateInfoEXT*)malloc(sizeof(VkPipelineColorBlendAdvancedStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineColorBlendAdvancedStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
        auto result=(VkPhysicalDeviceInlineUniformBlockFeatures*)malloc(sizeof(VkPhysicalDeviceInlineUniformBlockFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceInlineUniformBlockFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceInlineUniformBlockProperties*)malloc(sizeof(VkPhysicalDeviceInlineUniformBlockProperties));
        auto temp_struct=reader.getVkPhysicalDeviceInlineUniformBlockProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
        {
        auto result=(VkWriteDescriptorSetInlineUniformBlock*)malloc(sizeof(VkWriteDescriptorSetInlineUniformBlock));
        auto temp_struct=reader.getVkWriteDescriptorSetInlineUniformBlock();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
        {
        auto result=(VkDescriptorPoolInlineUniformBlockCreateInfo*)malloc(sizeof(VkDescriptorPoolInlineUniformBlockCreateInfo));
        auto temp_struct=reader.getVkDescriptorPoolInlineUniformBlockCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineCoverageModulationStateCreateInfoNV*)malloc(sizeof(VkPipelineCoverageModulationStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineCoverageModulationStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
        auto result=(VkImageFormatListCreateInfo*)malloc(sizeof(VkImageFormatListCreateInfo));
        auto temp_struct=reader.getVkImageFormatListCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VALIDATION_CACHE_CREATE_INFO_E_X_T:
        {
        auto result=(VkValidationCacheCreateInfoEXT*)malloc(sizeof(VkValidationCacheCreateInfoEXT));
        auto temp_struct=reader.getVkValidationCacheCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_E_X_T:
        {
        auto result=(VkShaderModuleValidationCacheCreateInfoEXT*)malloc(sizeof(VkShaderModuleValidationCacheCreateInfoEXT));
        auto temp_struct=reader.getVkShaderModuleValidationCacheCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MAINTENANCE3_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceMaintenance3Properties*)malloc(sizeof(VkPhysicalDeviceMaintenance3Properties));
        auto temp_struct=reader.getVkPhysicalDeviceMaintenance3Properties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MAINTENANCE4_FEATURES:
        {
        auto result=(VkPhysicalDeviceMaintenance4Features*)malloc(sizeof(VkPhysicalDeviceMaintenance4Features));
        auto temp_struct=reader.getVkPhysicalDeviceMaintenance4Features();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MAINTENANCE4_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceMaintenance4Properties*)malloc(sizeof(VkPhysicalDeviceMaintenance4Properties));
        auto temp_struct=reader.getVkPhysicalDeviceMaintenance4Properties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MAINTENANCE5_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceMaintenance5FeaturesKHR*)malloc(sizeof(VkPhysicalDeviceMaintenance5FeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceMaintenance5FeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MAINTENANCE5_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDeviceMaintenance5PropertiesKHR*)malloc(sizeof(VkPhysicalDeviceMaintenance5PropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceMaintenance5PropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDERING_AREA_INFO_K_H_R:
        {
        auto result=(VkRenderingAreaInfoKHR*)malloc(sizeof(VkRenderingAreaInfoKHR));
        auto temp_struct=reader.getVkRenderingAreaInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_LAYOUT_SUPPORT:
        {
        auto result=(VkDescriptorSetLayoutSupport*)malloc(sizeof(VkDescriptorSetLayoutSupport));
        auto temp_struct=reader.getVkDescriptorSetLayoutSupport();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
        auto result=(VkPhysicalDeviceShaderDrawParametersFeatures*)malloc(sizeof(VkPhysicalDeviceShaderDrawParametersFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceShaderDrawParametersFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
        auto result=(VkPhysicalDeviceShaderFloat16Int8Features*)malloc(sizeof(VkPhysicalDeviceShaderFloat16Int8Features));
        auto temp_struct=reader.getVkPhysicalDeviceShaderFloat16Int8Features();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceFloatControlsProperties*)malloc(sizeof(VkPhysicalDeviceFloatControlsProperties));
        auto temp_struct=reader.getVkPhysicalDeviceFloatControlsProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
        auto result=(VkPhysicalDeviceHostQueryResetFeatures*)malloc(sizeof(VkPhysicalDeviceHostQueryResetFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceHostQueryResetFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHADER_RESOURCE_USAGE_A_M_D:
        {
        auto result=(VkShaderResourceUsageAMD*)malloc(sizeof(VkShaderResourceUsageAMD));
        auto temp_struct=reader.getVkShaderResourceUsageAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHADER_STATISTICS_INFO_A_M_D:
        {
        auto result=(VkShaderStatisticsInfoAMD*)malloc(sizeof(VkShaderStatisticsInfoAMD));
        auto temp_struct=reader.getVkShaderStatisticsInfoAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_K_H_R:
        {
        auto result=(VkDeviceQueueGlobalPriorityCreateInfoKHR*)malloc(sizeof(VkDeviceQueueGlobalPriorityCreateInfoKHR));
        auto temp_struct=reader.getVkDeviceQueueGlobalPriorityCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceGlobalPriorityQueryFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_K_H_R:
        {
        auto result=(VkQueueFamilyGlobalPriorityPropertiesKHR*)malloc(sizeof(VkQueueFamilyGlobalPriorityPropertiesKHR));
        auto temp_struct=reader.getVkQueueFamilyGlobalPriorityPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_UTILS_OBJECT_NAME_INFO_E_X_T:
        {
        auto result=(VkDebugUtilsObjectNameInfoEXT*)malloc(sizeof(VkDebugUtilsObjectNameInfoEXT));
        auto temp_struct=reader.getVkDebugUtilsObjectNameInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_UTILS_OBJECT_TAG_INFO_E_X_T:
        {
        auto result=(VkDebugUtilsObjectTagInfoEXT*)malloc(sizeof(VkDebugUtilsObjectTagInfoEXT));
        auto temp_struct=reader.getVkDebugUtilsObjectTagInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_UTILS_LABEL_E_X_T:
        {
        auto result=(VkDebugUtilsLabelEXT*)malloc(sizeof(VkDebugUtilsLabelEXT));
        auto temp_struct=reader.getVkDebugUtilsLabelEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_UTILS_MESSENGER_CREATE_INFO_E_X_T:
        {
        auto result=(VkDebugUtilsMessengerCreateInfoEXT*)malloc(sizeof(VkDebugUtilsMessengerCreateInfoEXT));
        auto temp_struct=reader.getVkDebugUtilsMessengerCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_E_X_T:
        {
        auto result=(VkDebugUtilsMessengerCallbackDataEXT*)malloc(sizeof(VkDebugUtilsMessengerCallbackDataEXT));
        auto temp_struct=reader.getVkDebugUtilsMessengerCallbackDataEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDeviceMemoryReportFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_E_X_T:
        {
        auto result=(VkDeviceDeviceMemoryReportCreateInfoEXT*)malloc(sizeof(VkDeviceDeviceMemoryReportCreateInfoEXT));
        auto temp_struct=reader.getVkDeviceDeviceMemoryReportCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_MEMORY_REPORT_CALLBACK_DATA_E_X_T:
        {
        auto result=(VkDeviceMemoryReportCallbackDataEXT*)malloc(sizeof(VkDeviceMemoryReportCallbackDataEXT));
        auto temp_struct=reader.getVkDeviceMemoryReportCallbackDataEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMPORT_MEMORY_HOST_POINTER_INFO_E_X_T:
        {
        auto result=(VkImportMemoryHostPointerInfoEXT*)malloc(sizeof(VkImportMemoryHostPointerInfoEXT));
        auto temp_struct=reader.getVkImportMemoryHostPointerInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_HOST_POINTER_PROPERTIES_E_X_T:
        {
        auto result=(VkMemoryHostPointerPropertiesEXT*)malloc(sizeof(VkMemoryHostPointerPropertiesEXT));
        auto temp_struct=reader.getVkMemoryHostPointerPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceExternalMemoryHostPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceExternalMemoryHostPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceConservativeRasterizationPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceConservativeRasterizationPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CALIBRATED_TIMESTAMP_INFO_E_X_T:
        {
        auto result=(VkCalibratedTimestampInfoEXT*)malloc(sizeof(VkCalibratedTimestampInfoEXT));
        auto temp_struct=reader.getVkCalibratedTimestampInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_A_M_D:
        {
        auto result=(VkPhysicalDeviceShaderCorePropertiesAMD*)malloc(sizeof(VkPhysicalDeviceShaderCorePropertiesAMD));
        auto temp_struct=reader.getVkPhysicalDeviceShaderCorePropertiesAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES2_A_M_D:
        {
        auto result=(VkPhysicalDeviceShaderCoreProperties2AMD*)malloc(sizeof(VkPhysicalDeviceShaderCoreProperties2AMD));
        auto temp_struct=reader.getVkPhysicalDeviceShaderCoreProperties2AMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineRasterizationConservativeStateCreateInfoEXT*)malloc(sizeof(VkPipelineRasterizationConservativeStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineRasterizationConservativeStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
        auto result=(VkPhysicalDeviceDescriptorIndexingFeatures*)malloc(sizeof(VkPhysicalDeviceDescriptorIndexingFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceDescriptorIndexingFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceDescriptorIndexingProperties*)malloc(sizeof(VkPhysicalDeviceDescriptorIndexingProperties));
        auto temp_struct=reader.getVkPhysicalDeviceDescriptorIndexingProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
        auto result=(VkDescriptorSetLayoutBindingFlagsCreateInfo*)malloc(sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfo));
        auto temp_struct=reader.getVkDescriptorSetLayoutBindingFlagsCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
        auto result=(VkDescriptorSetVariableDescriptorCountAllocateInfo*)malloc(sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfo));
        auto temp_struct=reader.getVkDescriptorSetVariableDescriptorCountAllocateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
        auto result=(VkDescriptorSetVariableDescriptorCountLayoutSupport*)malloc(sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupport));
        auto temp_struct=reader.getVkDescriptorSetVariableDescriptorCountLayoutSupport();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_DESCRIPTION2:
        {
        auto result=(VkAttachmentDescription2*)malloc(sizeof(VkAttachmentDescription2));
        auto temp_struct=reader.getVkAttachmentDescription2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_REFERENCE2:
        {
        auto result=(VkAttachmentReference2*)malloc(sizeof(VkAttachmentReference2));
        auto temp_struct=reader.getVkAttachmentReference2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_DESCRIPTION2:
        {
        auto result=(VkSubpassDescription2*)malloc(sizeof(VkSubpassDescription2));
        auto temp_struct=reader.getVkSubpassDescription2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_DEPENDENCY2:
        {
        auto result=(VkSubpassDependency2*)malloc(sizeof(VkSubpassDependency2));
        auto temp_struct=reader.getVkSubpassDependency2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_CREATE_INFO2:
        {
        auto result=(VkRenderPassCreateInfo2*)malloc(sizeof(VkRenderPassCreateInfo2));
        auto temp_struct=reader.getVkRenderPassCreateInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_BEGIN_INFO:
        {
        auto result=(VkSubpassBeginInfo*)malloc(sizeof(VkSubpassBeginInfo));
        auto temp_struct=reader.getVkSubpassBeginInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_END_INFO:
        {
        auto result=(VkSubpassEndInfo*)malloc(sizeof(VkSubpassEndInfo));
        auto temp_struct=reader.getVkSubpassEndInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
        auto result=(VkPhysicalDeviceTimelineSemaphoreFeatures*)malloc(sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceTimelineSemaphoreFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceTimelineSemaphoreProperties*)malloc(sizeof(VkPhysicalDeviceTimelineSemaphoreProperties));
        auto temp_struct=reader.getVkPhysicalDeviceTimelineSemaphoreProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SEMAPHORE_TYPE_CREATE_INFO:
        {
        auto result=(VkSemaphoreTypeCreateInfo*)malloc(sizeof(VkSemaphoreTypeCreateInfo));
        auto temp_struct=reader.getVkSemaphoreTypeCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
        auto result=(VkTimelineSemaphoreSubmitInfo*)malloc(sizeof(VkTimelineSemaphoreSubmitInfo));
        auto temp_struct=reader.getVkTimelineSemaphoreSubmitInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SEMAPHORE_WAIT_INFO:
        {
        auto result=(VkSemaphoreWaitInfo*)malloc(sizeof(VkSemaphoreWaitInfo));
        auto temp_struct=reader.getVkSemaphoreWaitInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SEMAPHORE_SIGNAL_INFO:
        {
        auto result=(VkSemaphoreSignalInfo*)malloc(sizeof(VkSemaphoreSignalInfo));
        auto temp_struct=reader.getVkSemaphoreSignalInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VERTEX_INPUT_BINDING_DIVISOR_DESCRIPTION_E_X_T:
        {
        auto result=(VkVertexInputBindingDivisorDescriptionEXT*)malloc(sizeof(VkVertexInputBindingDivisorDescriptionEXT));
        auto temp_struct=reader.getVkVertexInputBindingDivisorDescriptionEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineVertexInputDivisorStateCreateInfoEXT*)malloc(sizeof(VkPipelineVertexInputDivisorStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineVertexInputDivisorStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_P_C_I_BUS_INFO_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDevicePCIBusInfoPropertiesEXT*)malloc(sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePCIBusInfoPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_E_X_T:
        {
        auto result=(VkCommandBufferInheritanceConditionalRenderingInfoEXT*)malloc(sizeof(VkCommandBufferInheritanceConditionalRenderingInfoEXT));
        auto temp_struct=reader.getVkCommandBufferInheritanceConditionalRenderingInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE8_BIT_STORAGE_FEATURES:
        {
        auto result=(VkPhysicalDevice8BitStorageFeatures*)malloc(sizeof(VkPhysicalDevice8BitStorageFeatures));
        auto temp_struct=reader.getVkPhysicalDevice8BitStorageFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceConditionalRenderingFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceConditionalRenderingFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
        auto result=(VkPhysicalDeviceVulkanMemoryModelFeatures*)malloc(sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceVulkanMemoryModelFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
        auto result=(VkPhysicalDeviceShaderAtomicInt64Features*)malloc(sizeof(VkPhysicalDeviceShaderAtomicInt64Features));
        auto temp_struct=reader.getVkPhysicalDeviceShaderAtomicInt64Features();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderAtomicFloatFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT2_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_N_V:
        {
        auto result=(VkQueueFamilyCheckpointPropertiesNV*)malloc(sizeof(VkQueueFamilyCheckpointPropertiesNV));
        auto temp_struct=reader.getVkQueueFamilyCheckpointPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CHECKPOINT_DATA_N_V:
        {
        auto result=(VkCheckpointDataNV*)malloc(sizeof(VkCheckpointDataNV));
        auto temp_struct=reader.getVkCheckpointDataNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceDepthStencilResolveProperties*)malloc(sizeof(VkPhysicalDeviceDepthStencilResolveProperties));
        auto temp_struct=reader.getVkPhysicalDeviceDepthStencilResolveProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
        auto result=(VkSubpassDescriptionDepthStencilResolve*)malloc(sizeof(VkSubpassDescriptionDepthStencilResolve));
        auto temp_struct=reader.getVkSubpassDescriptionDepthStencilResolve();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_A_S_T_C_DECODE_MODE_E_X_T:
        {
        auto result=(VkImageViewASTCDecodeModeEXT*)malloc(sizeof(VkImageViewASTCDecodeModeEXT));
        auto temp_struct=reader.getVkImageViewASTCDecodeModeEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_A_S_T_C_DECODE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceASTCDecodeFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceASTCDecodeFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceTransformFeedbackFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceTransformFeedbackFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceTransformFeedbackPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceTransformFeedbackPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceTransformFeedbackPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineRasterizationStateStreamCreateInfoEXT*)malloc(sizeof(VkPipelineRasterizationStateStreamCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineRasterizationStateStreamCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*)malloc(sizeof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineRepresentativeFragmentTestStateCreateInfoNV*)malloc(sizeof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineRepresentativeFragmentTestStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceExclusiveScissorFeaturesNV*)malloc(sizeof(VkPhysicalDeviceExclusiveScissorFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceExclusiveScissorFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineViewportExclusiveScissorStateCreateInfoNV*)malloc(sizeof(VkPipelineViewportExclusiveScissorStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineViewportExclusiveScissorStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceCornerSampledImageFeaturesNV*)malloc(sizeof(VkPhysicalDeviceCornerSampledImageFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceCornerSampledImageFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*)malloc(sizeof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceShaderImageFootprintFeaturesNV*)malloc(sizeof(VkPhysicalDeviceShaderImageFootprintFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceShaderImageFootprintFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*)malloc(sizeof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*)malloc(sizeof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceCopyMemoryIndirectFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*)malloc(sizeof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceCopyMemoryIndirectPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceMemoryDecompressionFeaturesNV*)malloc(sizeof(VkPhysicalDeviceMemoryDecompressionFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceMemoryDecompressionFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceMemoryDecompressionPropertiesNV*)malloc(sizeof(VkPhysicalDeviceMemoryDecompressionPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceMemoryDecompressionPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHADING_RATE_PALETTE_N_V:
        {
        auto result=(VkShadingRatePaletteNV*)malloc(sizeof(VkShadingRatePaletteNV));
        auto temp_struct=reader.getVkShadingRatePaletteNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineViewportShadingRateImageStateCreateInfoNV*)malloc(sizeof(VkPipelineViewportShadingRateImageStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineViewportShadingRateImageStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceShadingRateImageFeaturesNV*)malloc(sizeof(VkPhysicalDeviceShadingRateImageFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceShadingRateImageFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceShadingRateImagePropertiesNV*)malloc(sizeof(VkPhysicalDeviceShadingRateImagePropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceShadingRateImagePropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_H_U_A_W_E_I:
        {
        auto result=(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*)malloc(sizeof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI));
        auto temp_struct=reader.getVkPhysicalDeviceInvocationMaskFeaturesHUAWEI();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COARSE_SAMPLE_LOCATION_N_V:
        {
        auto result=(VkCoarseSampleLocationNV*)malloc(sizeof(VkCoarseSampleLocationNV));
        auto temp_struct=reader.getVkCoarseSampleLocationNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COARSE_SAMPLE_ORDER_CUSTOM_N_V:
        {
        auto result=(VkCoarseSampleOrderCustomNV*)malloc(sizeof(VkCoarseSampleOrderCustomNV));
        auto temp_struct=reader.getVkCoarseSampleOrderCustomNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*)malloc(sizeof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceMeshShaderFeaturesNV*)malloc(sizeof(VkPhysicalDeviceMeshShaderFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceMeshShaderFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceMeshShaderPropertiesNV*)malloc(sizeof(VkPhysicalDeviceMeshShaderPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceMeshShaderPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRAW_MESH_TASKS_INDIRECT_COMMAND_N_V:
        {
        auto result=(VkDrawMeshTasksIndirectCommandNV*)malloc(sizeof(VkDrawMeshTasksIndirectCommandNV));
        auto temp_struct=reader.getVkDrawMeshTasksIndirectCommandNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMeshShaderFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceMeshShaderFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMeshShaderFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMeshShaderPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceMeshShaderPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMeshShaderPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRAW_MESH_TASKS_INDIRECT_COMMAND_E_X_T:
        {
        auto result=(VkDrawMeshTasksIndirectCommandEXT*)malloc(sizeof(VkDrawMeshTasksIndirectCommandEXT));
        auto temp_struct=reader.getVkDrawMeshTasksIndirectCommandEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RAY_TRACING_SHADER_GROUP_CREATE_INFO_N_V:
        {
        auto result=(VkRayTracingShaderGroupCreateInfoNV*)malloc(sizeof(VkRayTracingShaderGroupCreateInfoNV));
        auto temp_struct=reader.getVkRayTracingShaderGroupCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RAY_TRACING_SHADER_GROUP_CREATE_INFO_K_H_R:
        {
        auto result=(VkRayTracingShaderGroupCreateInfoKHR*)malloc(sizeof(VkRayTracingShaderGroupCreateInfoKHR));
        auto temp_struct=reader.getVkRayTracingShaderGroupCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RAY_TRACING_PIPELINE_CREATE_INFO_N_V:
        {
        auto result=(VkRayTracingPipelineCreateInfoNV*)malloc(sizeof(VkRayTracingPipelineCreateInfoNV));
        auto temp_struct=reader.getVkRayTracingPipelineCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RAY_TRACING_PIPELINE_CREATE_INFO_K_H_R:
        {
        auto result=(VkRayTracingPipelineCreateInfoKHR*)malloc(sizeof(VkRayTracingPipelineCreateInfoKHR));
        auto temp_struct=reader.getVkRayTracingPipelineCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GEOMETRY_TRIANGLES_N_V:
        {
        auto result=(VkGeometryTrianglesNV*)malloc(sizeof(VkGeometryTrianglesNV));
        auto temp_struct=reader.getVkGeometryTrianglesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GEOMETRY_A_A_B_B_N_V:
        {
        auto result=(VkGeometryAABBNV*)malloc(sizeof(VkGeometryAABBNV));
        auto temp_struct=reader.getVkGeometryAABBNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GEOMETRY_DATA_N_V:
        {
        auto result=(VkGeometryDataNV*)malloc(sizeof(VkGeometryDataNV));
        auto temp_struct=reader.getVkGeometryDataNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GEOMETRY_N_V:
        {
        auto result=(VkGeometryNV*)malloc(sizeof(VkGeometryNV));
        auto temp_struct=reader.getVkGeometryNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_INFO_N_V:
        {
        auto result=(VkAccelerationStructureInfoNV*)malloc(sizeof(VkAccelerationStructureInfoNV));
        auto temp_struct=reader.getVkAccelerationStructureInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_CREATE_INFO_N_V:
        {
        auto result=(VkAccelerationStructureCreateInfoNV*)malloc(sizeof(VkAccelerationStructureCreateInfoNV));
        auto temp_struct=reader.getVkAccelerationStructureCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_N_V:
        {
        auto result=(VkBindAccelerationStructureMemoryInfoNV*)malloc(sizeof(VkBindAccelerationStructureMemoryInfoNV));
        auto temp_struct=reader.getVkBindAccelerationStructureMemoryInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_K_H_R:
        {
        auto result=(VkWriteDescriptorSetAccelerationStructureKHR*)malloc(sizeof(VkWriteDescriptorSetAccelerationStructureKHR));
        auto temp_struct=reader.getVkWriteDescriptorSetAccelerationStructureKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_N_V:
        {
        auto result=(VkWriteDescriptorSetAccelerationStructureNV*)malloc(sizeof(VkWriteDescriptorSetAccelerationStructureNV));
        auto temp_struct=reader.getVkWriteDescriptorSetAccelerationStructureNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_N_V:
        {
        auto result=(VkAccelerationStructureMemoryRequirementsInfoNV*)malloc(sizeof(VkAccelerationStructureMemoryRequirementsInfoNV));
        auto temp_struct=reader.getVkAccelerationStructureMemoryRequirementsInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceAccelerationStructureFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceAccelerationStructureFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceRayTracingPipelineFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingPipelineFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceRayQueryFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceRayQueryFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceRayQueryFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDeviceAccelerationStructurePropertiesKHR*)malloc(sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceAccelerationStructurePropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDeviceRayTracingPipelinePropertiesKHR*)malloc(sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingPipelinePropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceRayTracingPropertiesNV*)malloc(sizeof(VkPhysicalDeviceRayTracingPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_STRIDED_DEVICE_ADDRESS_REGION_K_H_R:
        {
        auto result=(VkStridedDeviceAddressRegionKHR*)malloc(sizeof(VkStridedDeviceAddressRegionKHR));
        auto temp_struct=reader.getVkStridedDeviceAddressRegionKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_TRACE_RAYS_INDIRECT_COMMAND_K_H_R:
        {
        auto result=(VkTraceRaysIndirectCommandKHR*)malloc(sizeof(VkTraceRaysIndirectCommandKHR));
        auto temp_struct=reader.getVkTraceRaysIndirectCommandKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_TRACE_RAYS_INDIRECT_COMMAND2_K_H_R:
        {
        auto result=(VkTraceRaysIndirectCommand2KHR*)malloc(sizeof(VkTraceRaysIndirectCommand2KHR));
        auto temp_struct=reader.getVkTraceRaysIndirectCommand2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE1_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*)malloc(sizeof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_E_X_T:
        {
        auto result=(VkDrmFormatModifierPropertiesListEXT*)malloc(sizeof(VkDrmFormatModifierPropertiesListEXT));
        auto temp_struct=reader.getVkDrmFormatModifierPropertiesListEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRM_FORMAT_MODIFIER_PROPERTIES_E_X_T:
        {
        auto result=(VkDrmFormatModifierPropertiesEXT*)malloc(sizeof(VkDrmFormatModifierPropertiesEXT));
        auto temp_struct=reader.getVkDrmFormatModifierPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_E_X_T:
        {
        auto result=(VkPhysicalDeviceImageDrmFormatModifierInfoEXT*)malloc(sizeof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT));
        auto temp_struct=reader.getVkPhysicalDeviceImageDrmFormatModifierInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_E_X_T:
        {
        auto result=(VkImageDrmFormatModifierListCreateInfoEXT*)malloc(sizeof(VkImageDrmFormatModifierListCreateInfoEXT));
        auto temp_struct=reader.getVkImageDrmFormatModifierListCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_E_X_T:
        {
        auto result=(VkImageDrmFormatModifierExplicitCreateInfoEXT*)malloc(sizeof(VkImageDrmFormatModifierExplicitCreateInfoEXT));
        auto temp_struct=reader.getVkImageDrmFormatModifierExplicitCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_E_X_T:
        {
        auto result=(VkImageDrmFormatModifierPropertiesEXT*)malloc(sizeof(VkImageDrmFormatModifierPropertiesEXT));
        auto temp_struct=reader.getVkImageDrmFormatModifierPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
        auto result=(VkImageStencilUsageCreateInfo*)malloc(sizeof(VkImageStencilUsageCreateInfo));
        auto temp_struct=reader.getVkImageStencilUsageCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_A_M_D:
        {
        auto result=(VkDeviceMemoryOverallocationCreateInfoAMD*)malloc(sizeof(VkDeviceMemoryOverallocationCreateInfoAMD));
        auto temp_struct=reader.getVkDeviceMemoryOverallocationCreateInfoAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceFragmentDensityMapFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentDensityMapFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentDensityMap2FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceFragmentDensityMapPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentDensityMapPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*)malloc(sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentDensityMap2PropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*)malloc(sizeof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_E_X_T:
        {
        auto result=(VkRenderPassFragmentDensityMapCreateInfoEXT*)malloc(sizeof(VkRenderPassFragmentDensityMapCreateInfoEXT));
        auto temp_struct=reader.getVkRenderPassFragmentDensityMapCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_Q_C_O_M:
        {
        auto result=(VkSubpassFragmentDensityMapOffsetEndInfoQCOM*)malloc(sizeof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM));
        auto temp_struct=reader.getVkSubpassFragmentDensityMapOffsetEndInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
        auto result=(VkPhysicalDeviceScalarBlockLayoutFeatures*)malloc(sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceScalarBlockLayoutFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_PROTECTED_CAPABILITIES_K_H_R:
        {
        auto result=(VkSurfaceProtectedCapabilitiesKHR*)malloc(sizeof(VkSurfaceProtectedCapabilitiesKHR));
        auto temp_struct=reader.getVkSurfaceProtectedCapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
        auto result=(VkPhysicalDeviceUniformBufferStandardLayoutFeatures*)malloc(sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceUniformBufferStandardLayoutFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDepthClipEnableFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDepthClipEnableFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineRasterizationDepthClipStateCreateInfoEXT*)malloc(sizeof(VkPipelineRasterizationDepthClipStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineRasterizationDepthClipStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMemoryBudgetPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceMemoryBudgetPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMemoryBudgetPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMemoryPriorityFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMemoryPriorityFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_PRIORITY_ALLOCATE_INFO_E_X_T:
        {
        auto result=(VkMemoryPriorityAllocateInfoEXT*)malloc(sizeof(VkMemoryPriorityAllocateInfoEXT));
        auto temp_struct=reader.getVkMemoryPriorityAllocateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*)malloc(sizeof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
        auto result=(VkPhysicalDeviceBufferDeviceAddressFeatures*)malloc(sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceBufferDeviceAddressFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceBufferDeviceAddressFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_DEVICE_ADDRESS_INFO:
        {
        auto result=(VkBufferDeviceAddressInfo*)malloc(sizeof(VkBufferDeviceAddressInfo));
        auto temp_struct=reader.getVkBufferDeviceAddressInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
        auto result=(VkBufferOpaqueCaptureAddressCreateInfo*)malloc(sizeof(VkBufferOpaqueCaptureAddressCreateInfo));
        auto temp_struct=reader.getVkBufferOpaqueCaptureAddressCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_DEVICE_ADDRESS_CREATE_INFO_E_X_T:
        {
        auto result=(VkBufferDeviceAddressCreateInfoEXT*)malloc(sizeof(VkBufferDeviceAddressCreateInfoEXT));
        auto temp_struct=reader.getVkBufferDeviceAddressCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_E_X_T:
        {
        auto result=(VkPhysicalDeviceImageViewImageFormatInfoEXT*)malloc(sizeof(VkPhysicalDeviceImageViewImageFormatInfoEXT));
        auto temp_struct=reader.getVkPhysicalDeviceImageViewImageFormatInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_E_X_T:
        {
        auto result=(VkFilterCubicImageViewImageFormatPropertiesEXT*)malloc(sizeof(VkFilterCubicImageViewImageFormatPropertiesEXT));
        auto temp_struct=reader.getVkFilterCubicImageViewImageFormatPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
        auto result=(VkPhysicalDeviceImagelessFramebufferFeatures*)malloc(sizeof(VkPhysicalDeviceImagelessFramebufferFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceImagelessFramebufferFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
        auto result=(VkFramebufferAttachmentsCreateInfo*)malloc(sizeof(VkFramebufferAttachmentsCreateInfo));
        auto temp_struct=reader.getVkFramebufferAttachmentsCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
        {
        auto result=(VkFramebufferAttachmentImageInfo*)malloc(sizeof(VkFramebufferAttachmentImageInfo));
        auto temp_struct=reader.getVkFramebufferAttachmentImageInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
        auto result=(VkRenderPassAttachmentBeginInfo*)malloc(sizeof(VkRenderPassAttachmentBeginInfo));
        auto temp_struct=reader.getVkRenderPassAttachmentBeginInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_A_S_T_C_H_D_R_FEATURES:
        {
        auto result=(VkPhysicalDeviceTextureCompressionASTCHDRFeatures*)malloc(sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceTextureCompressionASTCHDRFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceCooperativeMatrixFeaturesNV*)malloc(sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceCooperativeMatrixFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceCooperativeMatrixPropertiesNV*)malloc(sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceCooperativeMatrixPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COOPERATIVE_MATRIX_PROPERTIES_N_V:
        {
        auto result=(VkCooperativeMatrixPropertiesNV*)malloc(sizeof(VkCooperativeMatrixPropertiesNV));
        auto temp_struct=reader.getVkCooperativeMatrixPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceYcbcrImageArraysFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_HANDLE_INFO_N_V_X:
        {
        auto result=(VkImageViewHandleInfoNVX*)malloc(sizeof(VkImageViewHandleInfoNVX));
        auto temp_struct=reader.getVkImageViewHandleInfoNVX();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_ADDRESS_PROPERTIES_N_V_X:
        {
        auto result=(VkImageViewAddressPropertiesNVX*)malloc(sizeof(VkImageViewAddressPropertiesNVX));
        auto temp_struct=reader.getVkImageViewAddressPropertiesNVX();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_CREATION_FEEDBACK:
        {
        auto result=(VkPipelineCreationFeedback*)malloc(sizeof(VkPipelineCreationFeedback));
        auto temp_struct=reader.getVkPipelineCreationFeedback();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
        auto result=(VkPipelineCreationFeedbackCreateInfo*)malloc(sizeof(VkPipelineCreationFeedbackCreateInfo));
        auto temp_struct=reader.getVkPipelineCreationFeedbackCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_N_V:
        {
        auto result=(VkPhysicalDevicePresentBarrierFeaturesNV*)malloc(sizeof(VkPhysicalDevicePresentBarrierFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDevicePresentBarrierFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_CAPABILITIES_PRESENT_BARRIER_N_V:
        {
        auto result=(VkSurfaceCapabilitiesPresentBarrierNV*)malloc(sizeof(VkSurfaceCapabilitiesPresentBarrierNV));
        auto temp_struct=reader.getVkSurfaceCapabilitiesPresentBarrierNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_N_V:
        {
        auto result=(VkSwapchainPresentBarrierCreateInfoNV*)malloc(sizeof(VkSwapchainPresentBarrierCreateInfoNV));
        auto temp_struct=reader.getVkSwapchainPresentBarrierCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDevicePerformanceQueryFeaturesKHR*)malloc(sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDevicePerformanceQueryFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDevicePerformanceQueryPropertiesKHR*)malloc(sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDevicePerformanceQueryPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_COUNTER_K_H_R:
        {
        auto result=(VkPerformanceCounterKHR*)malloc(sizeof(VkPerformanceCounterKHR));
        auto temp_struct=reader.getVkPerformanceCounterKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_COUNTER_DESCRIPTION_K_H_R:
        {
        auto result=(VkPerformanceCounterDescriptionKHR*)malloc(sizeof(VkPerformanceCounterDescriptionKHR));
        auto temp_struct=reader.getVkPerformanceCounterDescriptionKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUERY_POOL_PERFORMANCE_CREATE_INFO_K_H_R:
        {
        auto result=(VkQueryPoolPerformanceCreateInfoKHR*)malloc(sizeof(VkQueryPoolPerformanceCreateInfoKHR));
        auto temp_struct=reader.getVkQueryPoolPerformanceCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_COUNTER_RESULT_K_H_R:
        {
        auto result=(VkPerformanceCounterResultKHR*)malloc(sizeof(VkPerformanceCounterResultKHR));
        auto temp_struct=reader.getVkPerformanceCounterResultKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACQUIRE_PROFILING_LOCK_INFO_K_H_R:
        {
        auto result=(VkAcquireProfilingLockInfoKHR*)malloc(sizeof(VkAcquireProfilingLockInfoKHR));
        auto temp_struct=reader.getVkAcquireProfilingLockInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_QUERY_SUBMIT_INFO_K_H_R:
        {
        auto result=(VkPerformanceQuerySubmitInfoKHR*)malloc(sizeof(VkPerformanceQuerySubmitInfoKHR));
        auto temp_struct=reader.getVkPerformanceQuerySubmitInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_HEADLESS_SURFACE_CREATE_INFO_E_X_T:
        {
        auto result=(VkHeadlessSurfaceCreateInfoEXT*)malloc(sizeof(VkHeadlessSurfaceCreateInfoEXT));
        auto temp_struct=reader.getVkHeadlessSurfaceCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceCoverageReductionModeFeaturesNV*)malloc(sizeof(VkPhysicalDeviceCoverageReductionModeFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceCoverageReductionModeFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineCoverageReductionStateCreateInfoNV*)malloc(sizeof(VkPipelineCoverageReductionStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineCoverageReductionStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_N_V:
        {
        auto result=(VkFramebufferMixedSamplesCombinationNV*)malloc(sizeof(VkFramebufferMixedSamplesCombinationNV));
        auto temp_struct=reader.getVkFramebufferMixedSamplesCombinationNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2_FEATURES_I_N_T_E_L:
        {
        auto result=(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*)malloc(sizeof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL));
        auto temp_struct=reader.getVkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_VALUE_DATA_I_N_T_E_L:
        {
        auto result=(VkPerformanceValueDataINTEL*)malloc(sizeof(VkPerformanceValueDataINTEL));
        auto temp_struct=reader.getVkPerformanceValueDataINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_VALUE_I_N_T_E_L:
        {
        auto result=(VkPerformanceValueINTEL*)malloc(sizeof(VkPerformanceValueINTEL));
        auto temp_struct=reader.getVkPerformanceValueINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_INITIALIZE_PERFORMANCE_API_INFO_I_N_T_E_L:
        {
        auto result=(VkInitializePerformanceApiInfoINTEL*)malloc(sizeof(VkInitializePerformanceApiInfoINTEL));
        auto temp_struct=reader.getVkInitializePerformanceApiInfoINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_I_N_T_E_L:
        {
        auto result=(VkQueryPoolPerformanceQueryCreateInfoINTEL*)malloc(sizeof(VkQueryPoolPerformanceQueryCreateInfoINTEL));
        auto temp_struct=reader.getVkQueryPoolPerformanceQueryCreateInfoINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_MARKER_INFO_I_N_T_E_L:
        {
        auto result=(VkPerformanceMarkerInfoINTEL*)malloc(sizeof(VkPerformanceMarkerInfoINTEL));
        auto temp_struct=reader.getVkPerformanceMarkerInfoINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_STREAM_MARKER_INFO_I_N_T_E_L:
        {
        auto result=(VkPerformanceStreamMarkerInfoINTEL*)malloc(sizeof(VkPerformanceStreamMarkerInfoINTEL));
        auto temp_struct=reader.getVkPerformanceStreamMarkerInfoINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_OVERRIDE_INFO_I_N_T_E_L:
        {
        auto result=(VkPerformanceOverrideInfoINTEL*)malloc(sizeof(VkPerformanceOverrideInfoINTEL));
        auto temp_struct=reader.getVkPerformanceOverrideInfoINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_I_N_T_E_L:
        {
        auto result=(VkPerformanceConfigurationAcquireInfoINTEL*)malloc(sizeof(VkPerformanceConfigurationAcquireInfoINTEL));
        auto temp_struct=reader.getVkPerformanceConfigurationAcquireInfoINTEL();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceShaderClockFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceShaderClockFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceShaderClockFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceIndexTypeUint8FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceIndexTypeUint8FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_S_M_BUILTINS_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*)malloc(sizeof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceShaderSMBuiltinsPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_S_M_BUILTINS_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*)malloc(sizeof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceShaderSMBuiltinsFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
        auto result=(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*)malloc(sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
        auto result=(VkAttachmentReferenceStencilLayout*)malloc(sizeof(VkAttachmentReferenceStencilLayout));
        auto temp_struct=reader.getVkAttachmentReferenceStencilLayout();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*)malloc(sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
        auto result=(VkAttachmentDescriptionStencilLayout*)malloc(sizeof(VkAttachmentDescriptionStencilLayout));
        auto temp_struct=reader.getVkAttachmentDescriptionStencilLayout();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*)malloc(sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_INFO_K_H_R:
        {
        auto result=(VkPipelineInfoKHR*)malloc(sizeof(VkPipelineInfoKHR));
        auto temp_struct=reader.getVkPipelineInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_EXECUTABLE_PROPERTIES_K_H_R:
        {
        auto result=(VkPipelineExecutablePropertiesKHR*)malloc(sizeof(VkPipelineExecutablePropertiesKHR));
        auto temp_struct=reader.getVkPipelineExecutablePropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_EXECUTABLE_INFO_K_H_R:
        {
        auto result=(VkPipelineExecutableInfoKHR*)malloc(sizeof(VkPipelineExecutableInfoKHR));
        auto temp_struct=reader.getVkPipelineExecutableInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_EXECUTABLE_STATISTIC_VALUE_K_H_R:
        {
        auto result=(VkPipelineExecutableStatisticValueKHR*)malloc(sizeof(VkPipelineExecutableStatisticValueKHR));
        auto temp_struct=reader.getVkPipelineExecutableStatisticValueKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_EXECUTABLE_STATISTIC_K_H_R:
        {
        auto result=(VkPipelineExecutableStatisticKHR*)malloc(sizeof(VkPipelineExecutableStatisticKHR));
        auto temp_struct=reader.getVkPipelineExecutableStatisticKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_K_H_R:
        {
        auto result=(VkPipelineExecutableInternalRepresentationKHR*)malloc(sizeof(VkPipelineExecutableInternalRepresentationKHR));
        auto temp_struct=reader.getVkPipelineExecutableInternalRepresentationKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
        auto result=(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*)malloc(sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceTexelBufferAlignmentProperties*)malloc(sizeof(VkPhysicalDeviceTexelBufferAlignmentProperties));
        auto temp_struct=reader.getVkPhysicalDeviceTexelBufferAlignmentProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
        auto result=(VkPhysicalDeviceSubgroupSizeControlFeatures*)malloc(sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceSubgroupSizeControlFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceSubgroupSizeControlProperties*)malloc(sizeof(VkPhysicalDeviceSubgroupSizeControlProperties));
        auto temp_struct=reader.getVkPhysicalDeviceSubgroupSizeControlProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
        auto result=(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*)malloc(sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo));
        auto temp_struct=reader.getVkPipelineShaderStageRequiredSubgroupSizeCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_SHADING_PIPELINE_CREATE_INFO_H_U_A_W_E_I:
        {
        auto result=(VkSubpassShadingPipelineCreateInfoHUAWEI*)malloc(sizeof(VkSubpassShadingPipelineCreateInfoHUAWEI));
        auto temp_struct=reader.getVkSubpassShadingPipelineCreateInfoHUAWEI();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_H_U_A_W_E_I:
        {
        auto result=(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*)malloc(sizeof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI));
        auto temp_struct=reader.getVkPhysicalDeviceSubpassShadingPropertiesHUAWEI();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_H_U_A_W_E_I:
        {
        auto result=(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*)malloc(sizeof(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI));
        auto temp_struct=reader.getVkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
        auto result=(VkMemoryOpaqueCaptureAddressAllocateInfo*)malloc(sizeof(VkMemoryOpaqueCaptureAddressAllocateInfo));
        auto temp_struct=reader.getVkMemoryOpaqueCaptureAddressAllocateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
        {
        auto result=(VkDeviceMemoryOpaqueCaptureAddressInfo*)malloc(sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo));
        auto temp_struct=reader.getVkDeviceMemoryOpaqueCaptureAddressInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceLineRasterizationFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceLineRasterizationFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceLineRasterizationPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceLineRasterizationPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineRasterizationLineStateCreateInfoEXT*)malloc(sizeof(VkPipelineRasterizationLineStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineRasterizationLineStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
        auto result=(VkPhysicalDevicePipelineCreationCacheControlFeatures*)malloc(sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures));
        auto temp_struct=reader.getVkPhysicalDevicePipelineCreationCacheControlFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VULKAN11_FEATURES:
        {
        auto result=(VkPhysicalDeviceVulkan11Features*)malloc(sizeof(VkPhysicalDeviceVulkan11Features));
        auto temp_struct=reader.getVkPhysicalDeviceVulkan11Features();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VULKAN11_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceVulkan11Properties*)malloc(sizeof(VkPhysicalDeviceVulkan11Properties));
        auto temp_struct=reader.getVkPhysicalDeviceVulkan11Properties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VULKAN12_FEATURES:
        {
        auto result=(VkPhysicalDeviceVulkan12Features*)malloc(sizeof(VkPhysicalDeviceVulkan12Features));
        auto temp_struct=reader.getVkPhysicalDeviceVulkan12Features();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VULKAN12_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceVulkan12Properties*)malloc(sizeof(VkPhysicalDeviceVulkan12Properties));
        auto temp_struct=reader.getVkPhysicalDeviceVulkan12Properties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VULKAN13_FEATURES:
        {
        auto result=(VkPhysicalDeviceVulkan13Features*)malloc(sizeof(VkPhysicalDeviceVulkan13Features));
        auto temp_struct=reader.getVkPhysicalDeviceVulkan13Features();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VULKAN13_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceVulkan13Properties*)malloc(sizeof(VkPhysicalDeviceVulkan13Properties));
        auto temp_struct=reader.getVkPhysicalDeviceVulkan13Properties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COMPILER_CONTROL_CREATE_INFO_A_M_D:
        {
        auto result=(VkPipelineCompilerControlCreateInfoAMD*)malloc(sizeof(VkPipelineCompilerControlCreateInfoAMD));
        auto temp_struct=reader.getVkPipelineCompilerControlCreateInfoAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_A_M_D:
        {
        auto result=(VkPhysicalDeviceCoherentMemoryFeaturesAMD*)malloc(sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD));
        auto temp_struct=reader.getVkPhysicalDeviceCoherentMemoryFeaturesAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TOOL_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceToolProperties*)malloc(sizeof(VkPhysicalDeviceToolProperties));
        auto temp_struct=reader.getVkPhysicalDeviceToolProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_E_X_T:
        {
        auto result=(VkSamplerCustomBorderColorCreateInfoEXT*)malloc(sizeof(VkSamplerCustomBorderColorCreateInfoEXT));
        auto temp_struct=reader.getVkSamplerCustomBorderColorCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceCustomBorderColorPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceCustomBorderColorPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceCustomBorderColorFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceCustomBorderColorFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_E_X_T:
        {
        auto result=(VkSamplerBorderColorComponentMappingCreateInfoEXT*)malloc(sizeof(VkSamplerBorderColorComponentMappingCreateInfoEXT));
        auto temp_struct=reader.getVkSamplerBorderColorComponentMappingCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceBorderColorSwizzleFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_OR_HOST_ADDRESS_K_H_R:
        {
        auto result=(VkDeviceOrHostAddressKHR*)malloc(sizeof(VkDeviceOrHostAddressKHR));
        auto temp_struct=reader.getVkDeviceOrHostAddressKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_OR_HOST_ADDRESS_CONST_K_H_R:
        {
        auto result=(VkDeviceOrHostAddressConstKHR*)malloc(sizeof(VkDeviceOrHostAddressConstKHR));
        auto temp_struct=reader.getVkDeviceOrHostAddressConstKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_K_H_R:
        {
        auto result=(VkAccelerationStructureGeometryTrianglesDataKHR*)malloc(sizeof(VkAccelerationStructureGeometryTrianglesDataKHR));
        auto temp_struct=reader.getVkAccelerationStructureGeometryTrianglesDataKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_K_H_R:
        {
        auto result=(VkAccelerationStructureGeometryAabbsDataKHR*)malloc(sizeof(VkAccelerationStructureGeometryAabbsDataKHR));
        auto temp_struct=reader.getVkAccelerationStructureGeometryAabbsDataKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_K_H_R:
        {
        auto result=(VkAccelerationStructureGeometryInstancesDataKHR*)malloc(sizeof(VkAccelerationStructureGeometryInstancesDataKHR));
        auto temp_struct=reader.getVkAccelerationStructureGeometryInstancesDataKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_GEOMETRY_DATA_K_H_R:
        {
        auto result=(VkAccelerationStructureGeometryDataKHR*)malloc(sizeof(VkAccelerationStructureGeometryDataKHR));
        auto temp_struct=reader.getVkAccelerationStructureGeometryDataKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_GEOMETRY_K_H_R:
        {
        auto result=(VkAccelerationStructureGeometryKHR*)malloc(sizeof(VkAccelerationStructureGeometryKHR));
        auto temp_struct=reader.getVkAccelerationStructureGeometryKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_K_H_R:
        {
        auto result=(VkAccelerationStructureBuildGeometryInfoKHR*)malloc(sizeof(VkAccelerationStructureBuildGeometryInfoKHR));
        auto temp_struct=reader.getVkAccelerationStructureBuildGeometryInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_BUILD_RANGE_INFO_K_H_R:
        {
        auto result=(VkAccelerationStructureBuildRangeInfoKHR*)malloc(sizeof(VkAccelerationStructureBuildRangeInfoKHR));
        auto temp_struct=reader.getVkAccelerationStructureBuildRangeInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_CREATE_INFO_K_H_R:
        {
        auto result=(VkAccelerationStructureCreateInfoKHR*)malloc(sizeof(VkAccelerationStructureCreateInfoKHR));
        auto temp_struct=reader.getVkAccelerationStructureCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_AABB_POSITIONS_K_H_R:
        {
        auto result=(VkAabbPositionsKHR*)malloc(sizeof(VkAabbPositionsKHR));
        auto temp_struct=reader.getVkAabbPositionsKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_TRANSFORM_MATRIX_K_H_R:
        {
        auto result=(VkTransformMatrixKHR*)malloc(sizeof(VkTransformMatrixKHR));
        auto temp_struct=reader.getVkTransformMatrixKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_INSTANCE_K_H_R:
        {
        auto result=(VkAccelerationStructureInstanceKHR*)malloc(sizeof(VkAccelerationStructureInstanceKHR));
        auto temp_struct=reader.getVkAccelerationStructureInstanceKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_K_H_R:
        {
        auto result=(VkAccelerationStructureDeviceAddressInfoKHR*)malloc(sizeof(VkAccelerationStructureDeviceAddressInfoKHR));
        auto temp_struct=reader.getVkAccelerationStructureDeviceAddressInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_VERSION_INFO_K_H_R:
        {
        auto result=(VkAccelerationStructureVersionInfoKHR*)malloc(sizeof(VkAccelerationStructureVersionInfoKHR));
        auto temp_struct=reader.getVkAccelerationStructureVersionInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_ACCELERATION_STRUCTURE_INFO_K_H_R:
        {
        auto result=(VkCopyAccelerationStructureInfoKHR*)malloc(sizeof(VkCopyAccelerationStructureInfoKHR));
        auto temp_struct=reader.getVkCopyAccelerationStructureInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_K_H_R:
        {
        auto result=(VkCopyAccelerationStructureToMemoryInfoKHR*)malloc(sizeof(VkCopyAccelerationStructureToMemoryInfoKHR));
        auto temp_struct=reader.getVkCopyAccelerationStructureToMemoryInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_K_H_R:
        {
        auto result=(VkCopyMemoryToAccelerationStructureInfoKHR*)malloc(sizeof(VkCopyMemoryToAccelerationStructureInfoKHR));
        auto temp_struct=reader.getVkCopyMemoryToAccelerationStructureInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_K_H_R:
        {
        auto result=(VkRayTracingPipelineInterfaceCreateInfoKHR*)malloc(sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR));
        auto temp_struct=reader.getVkRayTracingPipelineInterfaceCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_LIBRARY_CREATE_INFO_K_H_R:
        {
        auto result=(VkPipelineLibraryCreateInfoKHR*)malloc(sizeof(VkPipelineLibraryCreateInfoKHR));
        auto temp_struct=reader.getVkPipelineLibraryCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceExtendedDynamicStateFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE2_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceExtendedDynamicState2FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE3_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceExtendedDynamicState3FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE3_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*)malloc(sizeof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceExtendedDynamicState3PropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COLOR_BLEND_EQUATION_E_X_T:
        {
        auto result=(VkColorBlendEquationEXT*)malloc(sizeof(VkColorBlendEquationEXT));
        auto temp_struct=reader.getVkColorBlendEquationEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COLOR_BLEND_ADVANCED_E_X_T:
        {
        auto result=(VkColorBlendAdvancedEXT*)malloc(sizeof(VkColorBlendAdvancedEXT));
        auto temp_struct=reader.getVkColorBlendAdvancedEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_TRANSFORM_BEGIN_INFO_Q_C_O_M:
        {
        auto result=(VkRenderPassTransformBeginInfoQCOM*)malloc(sizeof(VkRenderPassTransformBeginInfoQCOM));
        auto temp_struct=reader.getVkRenderPassTransformBeginInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_COMMAND_TRANSFORM_INFO_Q_C_O_M:
        {
        auto result=(VkCopyCommandTransformInfoQCOM*)malloc(sizeof(VkCopyCommandTransformInfoQCOM));
        auto temp_struct=reader.getVkCopyCommandTransformInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_Q_C_O_M:
        {
        auto result=(VkCommandBufferInheritanceRenderPassTransformInfoQCOM*)malloc(sizeof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM));
        auto temp_struct=reader.getVkCommandBufferInheritanceRenderPassTransformInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceDiagnosticsConfigFeaturesNV*)malloc(sizeof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceDiagnosticsConfigFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_N_V:
        {
        auto result=(VkDeviceDiagnosticsConfigCreateInfoNV*)malloc(sizeof(VkDeviceDiagnosticsConfigCreateInfoNV));
        auto temp_struct=reader.getVkDeviceDiagnosticsConfigCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
        auto result=(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*)malloc(sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ROBUSTNESS2_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceRobustness2FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceRobustness2FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceRobustness2FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ROBUSTNESS2_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceRobustness2PropertiesEXT*)malloc(sizeof(VkPhysicalDeviceRobustness2PropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceRobustness2PropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
        auto result=(VkPhysicalDeviceImageRobustnessFeatures*)malloc(sizeof(VkPhysicalDeviceImageRobustnessFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceImageRobustnessFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE4444_FORMATS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevice4444FormatsFeaturesEXT*)malloc(sizeof(VkPhysicalDevice4444FormatsFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevice4444FormatsFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_H_U_A_W_E_I:
        {
        auto result=(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*)malloc(sizeof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI));
        auto temp_struct=reader.getVkPhysicalDeviceSubpassShadingFeaturesHUAWEI();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_H_U_A_W_E_I:
        {
        auto result=(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*)malloc(sizeof(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI));
        auto temp_struct=reader.getVkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_COPY2:
        {
        auto result=(VkBufferCopy2*)malloc(sizeof(VkBufferCopy2));
        auto temp_struct=reader.getVkBufferCopy2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_COPY2:
        {
        auto result=(VkImageCopy2*)malloc(sizeof(VkImageCopy2));
        auto temp_struct=reader.getVkImageCopy2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_BLIT2:
        {
        auto result=(VkImageBlit2*)malloc(sizeof(VkImageBlit2));
        auto temp_struct=reader.getVkImageBlit2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_IMAGE_COPY2:
        {
        auto result=(VkBufferImageCopy2*)malloc(sizeof(VkBufferImageCopy2));
        auto temp_struct=reader.getVkBufferImageCopy2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_RESOLVE2:
        {
        auto result=(VkImageResolve2*)malloc(sizeof(VkImageResolve2));
        auto temp_struct=reader.getVkImageResolve2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_BUFFER_INFO2:
        {
        auto result=(VkCopyBufferInfo2*)malloc(sizeof(VkCopyBufferInfo2));
        auto temp_struct=reader.getVkCopyBufferInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_IMAGE_INFO2:
        {
        auto result=(VkCopyImageInfo2*)malloc(sizeof(VkCopyImageInfo2));
        auto temp_struct=reader.getVkCopyImageInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BLIT_IMAGE_INFO2:
        {
        auto result=(VkBlitImageInfo2*)malloc(sizeof(VkBlitImageInfo2));
        auto temp_struct=reader.getVkBlitImageInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_BUFFER_TO_IMAGE_INFO2:
        {
        auto result=(VkCopyBufferToImageInfo2*)malloc(sizeof(VkCopyBufferToImageInfo2));
        auto temp_struct=reader.getVkCopyBufferToImageInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_IMAGE_TO_BUFFER_INFO2:
        {
        auto result=(VkCopyImageToBufferInfo2*)malloc(sizeof(VkCopyImageToBufferInfo2));
        auto temp_struct=reader.getVkCopyImageToBufferInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RESOLVE_IMAGE_INFO2:
        {
        auto result=(VkResolveImageInfo2*)malloc(sizeof(VkResolveImageInfo2));
        auto temp_struct=reader.getVkResolveImageInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_K_H_R:
        {
        auto result=(VkFragmentShadingRateAttachmentInfoKHR*)malloc(sizeof(VkFragmentShadingRateAttachmentInfoKHR));
        auto temp_struct=reader.getVkFragmentShadingRateAttachmentInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_K_H_R:
        {
        auto result=(VkPipelineFragmentShadingRateStateCreateInfoKHR*)malloc(sizeof(VkPipelineFragmentShadingRateStateCreateInfoKHR));
        auto temp_struct=reader.getVkPipelineFragmentShadingRateStateCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceFragmentShadingRateFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShadingRateFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDeviceFragmentShadingRatePropertiesKHR*)malloc(sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShadingRatePropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_K_H_R:
        {
        auto result=(VkPhysicalDeviceFragmentShadingRateKHR*)malloc(sizeof(VkPhysicalDeviceFragmentShadingRateKHR));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShadingRateKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
        auto result=(VkPhysicalDeviceShaderTerminateInvocationFeatures*)malloc(sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceShaderTerminateInvocationFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*)malloc(sizeof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*)malloc(sizeof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_N_V:
        {
        auto result=(VkPipelineFragmentShadingRateEnumStateCreateInfoNV*)malloc(sizeof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV));
        auto temp_struct=reader.getVkPipelineFragmentShadingRateEnumStateCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_K_H_R:
        {
        auto result=(VkAccelerationStructureBuildSizesInfoKHR*)malloc(sizeof(VkAccelerationStructureBuildSizesInfoKHR));
        auto temp_struct=reader.getVkAccelerationStructureBuildSizesInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE2_D_VIEW_OF3_D_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceImage2DViewOf3DFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF3_D_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MUTABLE_DESCRIPTOR_TYPE_LIST_E_X_T:
        {
        auto result=(VkMutableDescriptorTypeListEXT*)malloc(sizeof(VkMutableDescriptorTypeListEXT));
        auto temp_struct=reader.getVkMutableDescriptorTypeListEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_E_X_T:
        {
        auto result=(VkMutableDescriptorTypeCreateInfoEXT*)malloc(sizeof(VkMutableDescriptorTypeCreateInfoEXT));
        auto temp_struct=reader.getVkMutableDescriptorTypeCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDepthClipControlFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceDepthClipControlFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDepthClipControlFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineViewportDepthClipControlCreateInfoEXT*)malloc(sizeof(VkPipelineViewportDepthClipControlCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineViewportDepthClipControlCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_EXTERNAL_MEMORY_R_D_M_A_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*)malloc(sizeof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceExternalMemoryRDMAFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VERTEX_INPUT_BINDING_DESCRIPTION2_E_X_T:
        {
        auto result=(VkVertexInputBindingDescription2EXT*)malloc(sizeof(VkVertexInputBindingDescription2EXT));
        auto temp_struct=reader.getVkVertexInputBindingDescription2EXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION2_E_X_T:
        {
        auto result=(VkVertexInputAttributeDescription2EXT*)malloc(sizeof(VkVertexInputAttributeDescription2EXT));
        auto temp_struct=reader.getVkVertexInputAttributeDescription2EXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceColorWriteEnableFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceColorWriteEnableFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_COLOR_WRITE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineColorWriteCreateInfoEXT*)malloc(sizeof(VkPipelineColorWriteCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineColorWriteCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_BARRIER2:
        {
        auto result=(VkMemoryBarrier2*)malloc(sizeof(VkMemoryBarrier2));
        auto temp_struct=reader.getVkMemoryBarrier2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_MEMORY_BARRIER2:
        {
        auto result=(VkImageMemoryBarrier2*)malloc(sizeof(VkImageMemoryBarrier2));
        auto temp_struct=reader.getVkImageMemoryBarrier2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_MEMORY_BARRIER2:
        {
        auto result=(VkBufferMemoryBarrier2*)malloc(sizeof(VkBufferMemoryBarrier2));
        auto temp_struct=reader.getVkBufferMemoryBarrier2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEPENDENCY_INFO:
        {
        auto result=(VkDependencyInfo*)malloc(sizeof(VkDependencyInfo));
        auto temp_struct=reader.getVkDependencyInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SEMAPHORE_SUBMIT_INFO:
        {
        auto result=(VkSemaphoreSubmitInfo*)malloc(sizeof(VkSemaphoreSubmitInfo));
        auto temp_struct=reader.getVkSemaphoreSubmitInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_SUBMIT_INFO:
        {
        auto result=(VkCommandBufferSubmitInfo*)malloc(sizeof(VkCommandBufferSubmitInfo));
        auto temp_struct=reader.getVkCommandBufferSubmitInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBMIT_INFO2:
        {
        auto result=(VkSubmitInfo2*)malloc(sizeof(VkSubmitInfo2));
        auto temp_struct=reader.getVkSubmitInfo2();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUEUE_FAMILY_CHECKPOINT_PROPERTIES2_N_V:
        {
        auto result=(VkQueueFamilyCheckpointProperties2NV*)malloc(sizeof(VkQueueFamilyCheckpointProperties2NV));
        auto temp_struct=reader.getVkQueueFamilyCheckpointProperties2NV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CHECKPOINT_DATA2_N_V:
        {
        auto result=(VkCheckpointData2NV*)malloc(sizeof(VkCheckpointData2NV));
        auto temp_struct=reader.getVkCheckpointData2NV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SYNCHRONIZATION2_FEATURES:
        {
        auto result=(VkPhysicalDeviceSynchronization2Features*)malloc(sizeof(VkPhysicalDeviceSynchronization2Features));
        auto temp_struct=reader.getVkPhysicalDeviceSynchronization2Features();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceHostImageCopyFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceHostImageCopyFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceHostImageCopyFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceHostImageCopyPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceHostImageCopyPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceHostImageCopyPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_TO_IMAGE_COPY_E_X_T:
        {
        auto result=(VkMemoryToImageCopyEXT*)malloc(sizeof(VkMemoryToImageCopyEXT));
        auto temp_struct=reader.getVkMemoryToImageCopyEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_TO_MEMORY_COPY_E_X_T:
        {
        auto result=(VkImageToMemoryCopyEXT*)malloc(sizeof(VkImageToMemoryCopyEXT));
        auto temp_struct=reader.getVkImageToMemoryCopyEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_MEMORY_TO_IMAGE_INFO_E_X_T:
        {
        auto result=(VkCopyMemoryToImageInfoEXT*)malloc(sizeof(VkCopyMemoryToImageInfoEXT));
        auto temp_struct=reader.getVkCopyMemoryToImageInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_IMAGE_TO_MEMORY_INFO_E_X_T:
        {
        auto result=(VkCopyImageToMemoryInfoEXT*)malloc(sizeof(VkCopyImageToMemoryInfoEXT));
        auto temp_struct=reader.getVkCopyImageToMemoryInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_IMAGE_TO_IMAGE_INFO_E_X_T:
        {
        auto result=(VkCopyImageToImageInfoEXT*)malloc(sizeof(VkCopyImageToImageInfoEXT));
        auto temp_struct=reader.getVkCopyImageToImageInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_HOST_IMAGE_LAYOUT_TRANSITION_INFO_E_X_T:
        {
        auto result=(VkHostImageLayoutTransitionInfoEXT*)malloc(sizeof(VkHostImageLayoutTransitionInfoEXT));
        auto temp_struct=reader.getVkHostImageLayoutTransitionInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBRESOURCE_HOST_MEMCPY_SIZE_E_X_T:
        {
        auto result=(VkSubresourceHostMemcpySizeEXT*)malloc(sizeof(VkSubresourceHostMemcpySizeEXT));
        auto temp_struct=reader.getVkSubresourceHostMemcpySizeEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_E_X_T:
        {
        auto result=(VkHostImageCopyDevicePerformanceQueryEXT*)malloc(sizeof(VkHostImageCopyDevicePerformanceQueryEXT));
        auto temp_struct=reader.getVkHostImageCopyDevicePerformanceQueryEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*)malloc(sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceLegacyDitheringFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceLegacyDitheringFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceLegacyDitheringFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBPASS_RESOLVE_PERFORMANCE_QUERY_E_X_T:
        {
        auto result=(VkSubpassResolvePerformanceQueryEXT*)malloc(sizeof(VkSubpassResolvePerformanceQueryEXT));
        auto temp_struct=reader.getVkSubpassResolvePerformanceQueryEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_E_X_T:
        {
        auto result=(VkMultisampledRenderToSingleSampledInfoEXT*)malloc(sizeof(VkMultisampledRenderToSingleSampledInfoEXT));
        auto temp_struct=reader.getVkMultisampledRenderToSingleSampledInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*)malloc(sizeof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePipelineProtectedAccessFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUEUE_FAMILY_VIDEO_PROPERTIES_K_H_R:
        {
        auto result=(VkQueueFamilyVideoPropertiesKHR*)malloc(sizeof(VkQueueFamilyVideoPropertiesKHR));
        auto temp_struct=reader.getVkQueueFamilyVideoPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_K_H_R:
        {
        auto result=(VkQueueFamilyQueryResultStatusPropertiesKHR*)malloc(sizeof(VkQueueFamilyQueryResultStatusPropertiesKHR));
        auto temp_struct=reader.getVkQueueFamilyQueryResultStatusPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_PROFILE_LIST_INFO_K_H_R:
        {
        auto result=(VkVideoProfileListInfoKHR*)malloc(sizeof(VkVideoProfileListInfoKHR));
        auto temp_struct=reader.getVkVideoProfileListInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_K_H_R:
        {
        auto result=(VkPhysicalDeviceVideoFormatInfoKHR*)malloc(sizeof(VkPhysicalDeviceVideoFormatInfoKHR));
        auto temp_struct=reader.getVkPhysicalDeviceVideoFormatInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_FORMAT_PROPERTIES_K_H_R:
        {
        auto result=(VkVideoFormatPropertiesKHR*)malloc(sizeof(VkVideoFormatPropertiesKHR));
        auto temp_struct=reader.getVkVideoFormatPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_PROFILE_INFO_K_H_R:
        {
        auto result=(VkVideoProfileInfoKHR*)malloc(sizeof(VkVideoProfileInfoKHR));
        auto temp_struct=reader.getVkVideoProfileInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_CAPABILITIES_K_H_R:
        {
        auto result=(VkVideoCapabilitiesKHR*)malloc(sizeof(VkVideoCapabilitiesKHR));
        auto temp_struct=reader.getVkVideoCapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_SESSION_MEMORY_REQUIREMENTS_K_H_R:
        {
        auto result=(VkVideoSessionMemoryRequirementsKHR*)malloc(sizeof(VkVideoSessionMemoryRequirementsKHR));
        auto temp_struct=reader.getVkVideoSessionMemoryRequirementsKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BIND_VIDEO_SESSION_MEMORY_INFO_K_H_R:
        {
        auto result=(VkBindVideoSessionMemoryInfoKHR*)malloc(sizeof(VkBindVideoSessionMemoryInfoKHR));
        auto temp_struct=reader.getVkBindVideoSessionMemoryInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_PICTURE_RESOURCE_INFO_K_H_R:
        {
        auto result=(VkVideoPictureResourceInfoKHR*)malloc(sizeof(VkVideoPictureResourceInfoKHR));
        auto temp_struct=reader.getVkVideoPictureResourceInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_REFERENCE_SLOT_INFO_K_H_R:
        {
        auto result=(VkVideoReferenceSlotInfoKHR*)malloc(sizeof(VkVideoReferenceSlotInfoKHR));
        auto temp_struct=reader.getVkVideoReferenceSlotInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_CAPABILITIES_K_H_R:
        {
        auto result=(VkVideoDecodeCapabilitiesKHR*)malloc(sizeof(VkVideoDecodeCapabilitiesKHR));
        auto temp_struct=reader.getVkVideoDecodeCapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_USAGE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeUsageInfoKHR*)malloc(sizeof(VkVideoDecodeUsageInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeUsageInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeInfoKHR*)malloc(sizeof(VkVideoDecodeInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H264_PROFILE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH264ProfileInfoKHR*)malloc(sizeof(VkVideoDecodeH264ProfileInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH264ProfileInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H264_CAPABILITIES_K_H_R:
        {
        auto result=(VkVideoDecodeH264CapabilitiesKHR*)malloc(sizeof(VkVideoDecodeH264CapabilitiesKHR));
        auto temp_struct=reader.getVkVideoDecodeH264CapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH264SessionParametersAddInfoKHR*)malloc(sizeof(VkVideoDecodeH264SessionParametersAddInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH264SessionParametersAddInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH264SessionParametersCreateInfoKHR*)malloc(sizeof(VkVideoDecodeH264SessionParametersCreateInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH264SessionParametersCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H264_PICTURE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH264PictureInfoKHR*)malloc(sizeof(VkVideoDecodeH264PictureInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH264PictureInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H264_DPB_SLOT_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH264DpbSlotInfoKHR*)malloc(sizeof(VkVideoDecodeH264DpbSlotInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH264DpbSlotInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H265_PROFILE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH265ProfileInfoKHR*)malloc(sizeof(VkVideoDecodeH265ProfileInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH265ProfileInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H265_CAPABILITIES_K_H_R:
        {
        auto result=(VkVideoDecodeH265CapabilitiesKHR*)malloc(sizeof(VkVideoDecodeH265CapabilitiesKHR));
        auto temp_struct=reader.getVkVideoDecodeH265CapabilitiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH265SessionParametersAddInfoKHR*)malloc(sizeof(VkVideoDecodeH265SessionParametersAddInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH265SessionParametersAddInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH265SessionParametersCreateInfoKHR*)malloc(sizeof(VkVideoDecodeH265SessionParametersCreateInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH265SessionParametersCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H265_PICTURE_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH265PictureInfoKHR*)malloc(sizeof(VkVideoDecodeH265PictureInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH265PictureInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_DECODE_H265_DPB_SLOT_INFO_K_H_R:
        {
        auto result=(VkVideoDecodeH265DpbSlotInfoKHR*)malloc(sizeof(VkVideoDecodeH265DpbSlotInfoKHR));
        auto temp_struct=reader.getVkVideoDecodeH265DpbSlotInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_SESSION_CREATE_INFO_K_H_R:
        {
        auto result=(VkVideoSessionCreateInfoKHR*)malloc(sizeof(VkVideoSessionCreateInfoKHR));
        auto temp_struct=reader.getVkVideoSessionCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_SESSION_PARAMETERS_CREATE_INFO_K_H_R:
        {
        auto result=(VkVideoSessionParametersCreateInfoKHR*)malloc(sizeof(VkVideoSessionParametersCreateInfoKHR));
        auto temp_struct=reader.getVkVideoSessionParametersCreateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_K_H_R:
        {
        auto result=(VkVideoSessionParametersUpdateInfoKHR*)malloc(sizeof(VkVideoSessionParametersUpdateInfoKHR));
        auto temp_struct=reader.getVkVideoSessionParametersUpdateInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_BEGIN_CODING_INFO_K_H_R:
        {
        auto result=(VkVideoBeginCodingInfoKHR*)malloc(sizeof(VkVideoBeginCodingInfoKHR));
        auto temp_struct=reader.getVkVideoBeginCodingInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_END_CODING_INFO_K_H_R:
        {
        auto result=(VkVideoEndCodingInfoKHR*)malloc(sizeof(VkVideoEndCodingInfoKHR));
        auto temp_struct=reader.getVkVideoEndCodingInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_VIDEO_CODING_CONTROL_INFO_K_H_R:
        {
        auto result=(VkVideoCodingControlInfoKHR*)malloc(sizeof(VkVideoCodingControlInfoKHR));
        auto temp_struct=reader.getVkVideoCodingControlInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceInheritedViewportScissorFeaturesNV*)malloc(sizeof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceInheritedViewportScissorFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_N_V:
        {
        auto result=(VkCommandBufferInheritanceViewportScissorInfoNV*)malloc(sizeof(VkCommandBufferInheritanceViewportScissorInfoNV));
        auto temp_struct=reader.getVkCommandBufferInheritanceViewportScissorInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_YCBCR2_PLANE444_FORMATS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceProvokingVertexFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceProvokingVertexFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceProvokingVertexPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceProvokingVertexPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*)malloc(sizeof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineRasterizationProvokingVertexStateCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CU_MODULE_CREATE_INFO_N_V_X:
        {
        auto result=(VkCuModuleCreateInfoNVX*)malloc(sizeof(VkCuModuleCreateInfoNVX));
        auto temp_struct=reader.getVkCuModuleCreateInfoNVX();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CU_FUNCTION_CREATE_INFO_N_V_X:
        {
        auto result=(VkCuFunctionCreateInfoNVX*)malloc(sizeof(VkCuFunctionCreateInfoNVX));
        auto temp_struct=reader.getVkCuFunctionCreateInfoNVX();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_CU_LAUNCH_INFO_N_V_X:
        {
        auto result=(VkCuLaunchInfoNVX*)malloc(sizeof(VkCuLaunchInfoNVX));
        auto temp_struct=reader.getVkCuLaunchInfoNVX();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDescriptorBufferFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceDescriptorBufferFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDescriptorBufferFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDescriptorBufferPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceDescriptorBufferPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDescriptorBufferPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_ADDRESS_INFO_E_X_T:
        {
        auto result=(VkDescriptorAddressInfoEXT*)malloc(sizeof(VkDescriptorAddressInfoEXT));
        auto temp_struct=reader.getVkDescriptorAddressInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_BUFFER_BINDING_INFO_E_X_T:
        {
        auto result=(VkDescriptorBufferBindingInfoEXT*)malloc(sizeof(VkDescriptorBufferBindingInfoEXT));
        auto temp_struct=reader.getVkDescriptorBufferBindingInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_E_X_T:
        {
        auto result=(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*)malloc(sizeof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT));
        auto temp_struct=reader.getVkDescriptorBufferBindingPushDescriptorBufferHandleEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_DATA_E_X_T:
        {
        auto result=(VkDescriptorDataEXT*)malloc(sizeof(VkDescriptorDataEXT));
        auto temp_struct=reader.getVkDescriptorDataEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_GET_INFO_E_X_T:
        {
        auto result=(VkDescriptorGetInfoEXT*)malloc(sizeof(VkDescriptorGetInfoEXT));
        auto temp_struct=reader.getVkDescriptorGetInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_E_X_T:
        {
        auto result=(VkBufferCaptureDescriptorDataInfoEXT*)malloc(sizeof(VkBufferCaptureDescriptorDataInfoEXT));
        auto temp_struct=reader.getVkBufferCaptureDescriptorDataInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_E_X_T:
        {
        auto result=(VkImageCaptureDescriptorDataInfoEXT*)malloc(sizeof(VkImageCaptureDescriptorDataInfoEXT));
        auto temp_struct=reader.getVkImageCaptureDescriptorDataInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_E_X_T:
        {
        auto result=(VkImageViewCaptureDescriptorDataInfoEXT*)malloc(sizeof(VkImageViewCaptureDescriptorDataInfoEXT));
        auto temp_struct=reader.getVkImageViewCaptureDescriptorDataInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_E_X_T:
        {
        auto result=(VkSamplerCaptureDescriptorDataInfoEXT*)malloc(sizeof(VkSamplerCaptureDescriptorDataInfoEXT));
        auto temp_struct=reader.getVkSamplerCaptureDescriptorDataInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_E_X_T:
        {
        auto result=(VkAccelerationStructureCaptureDescriptorDataInfoEXT*)malloc(sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT));
        auto temp_struct=reader.getVkAccelerationStructureCaptureDescriptorDataInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_E_X_T:
        {
        auto result=(VkOpaqueCaptureDescriptorDataCreateInfoEXT*)malloc(sizeof(VkOpaqueCaptureDescriptorDataCreateInfoEXT));
        auto temp_struct=reader.getVkOpaqueCaptureDescriptorDataCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
        auto result=(VkPhysicalDeviceShaderIntegerDotProductFeatures*)malloc(sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceShaderIntegerDotProductFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
        auto result=(VkPhysicalDeviceShaderIntegerDotProductProperties*)malloc(sizeof(VkPhysicalDeviceShaderIntegerDotProductProperties));
        auto temp_struct=reader.getVkPhysicalDeviceShaderIntegerDotProductProperties();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DRM_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDrmPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceDrmPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDrmPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*)malloc(sizeof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*)malloc(sizeof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingMotionBlurFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_N_V:
        {
        auto result=(VkAccelerationStructureGeometryMotionTrianglesDataNV*)malloc(sizeof(VkAccelerationStructureGeometryMotionTrianglesDataNV));
        auto temp_struct=reader.getVkAccelerationStructureGeometryMotionTrianglesDataNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_MOTION_INFO_N_V:
        {
        auto result=(VkAccelerationStructureMotionInfoNV*)malloc(sizeof(VkAccelerationStructureMotionInfoNV));
        auto temp_struct=reader.getVkAccelerationStructureMotionInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_S_R_T_DATA_N_V:
        {
        auto result=(VkSRTDataNV*)malloc(sizeof(VkSRTDataNV));
        auto temp_struct=reader.getVkSRTDataNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_S_R_T_MOTION_INSTANCE_N_V:
        {
        auto result=(VkAccelerationStructureSRTMotionInstanceNV*)malloc(sizeof(VkAccelerationStructureSRTMotionInstanceNV));
        auto temp_struct=reader.getVkAccelerationStructureSRTMotionInstanceNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_MATRIX_MOTION_INSTANCE_N_V:
        {
        auto result=(VkAccelerationStructureMatrixMotionInstanceNV*)malloc(sizeof(VkAccelerationStructureMatrixMotionInstanceNV));
        auto temp_struct=reader.getVkAccelerationStructureMatrixMotionInstanceNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_DATA_N_V:
        {
        auto result=(VkAccelerationStructureMotionInstanceDataNV*)malloc(sizeof(VkAccelerationStructureMotionInstanceDataNV));
        auto temp_struct=reader.getVkAccelerationStructureMotionInstanceDataNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_N_V:
        {
        auto result=(VkAccelerationStructureMotionInstanceNV*)malloc(sizeof(VkAccelerationStructureMotionInstanceNV));
        auto temp_struct=reader.getVkAccelerationStructureMotionInstanceNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_GET_REMOTE_ADDRESS_INFO_N_V:
        {
        auto result=(VkMemoryGetRemoteAddressInfoNV*)malloc(sizeof(VkMemoryGetRemoteAddressInfoNV));
        auto temp_struct=reader.getVkMemoryGetRemoteAddressInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_R_G_B_A10_X6_FORMATS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FORMAT_PROPERTIES3:
        {
        auto result=(VkFormatProperties3*)malloc(sizeof(VkFormatProperties3));
        auto temp_struct=reader.getVkFormatProperties3();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRM_FORMAT_MODIFIER_PROPERTIES_LIST2_E_X_T:
        {
        auto result=(VkDrmFormatModifierPropertiesList2EXT*)malloc(sizeof(VkDrmFormatModifierPropertiesList2EXT));
        auto temp_struct=reader.getVkDrmFormatModifierPropertiesList2EXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DRM_FORMAT_MODIFIER_PROPERTIES2_E_X_T:
        {
        auto result=(VkDrmFormatModifierProperties2EXT*)malloc(sizeof(VkDrmFormatModifierProperties2EXT));
        auto temp_struct=reader.getVkDrmFormatModifierProperties2EXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_RENDERING_CREATE_INFO:
        {
        auto result=(VkPipelineRenderingCreateInfo*)malloc(sizeof(VkPipelineRenderingCreateInfo));
        auto temp_struct=reader.getVkPipelineRenderingCreateInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDERING_INFO:
        {
        auto result=(VkRenderingInfo*)malloc(sizeof(VkRenderingInfo));
        auto temp_struct=reader.getVkRenderingInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDERING_ATTACHMENT_INFO:
        {
        auto result=(VkRenderingAttachmentInfo*)malloc(sizeof(VkRenderingAttachmentInfo));
        auto temp_struct=reader.getVkRenderingAttachmentInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_K_H_R:
        {
        auto result=(VkRenderingFragmentShadingRateAttachmentInfoKHR*)malloc(sizeof(VkRenderingFragmentShadingRateAttachmentInfoKHR));
        auto temp_struct=reader.getVkRenderingFragmentShadingRateAttachmentInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_E_X_T:
        {
        auto result=(VkRenderingFragmentDensityMapAttachmentInfoEXT*)malloc(sizeof(VkRenderingFragmentDensityMapAttachmentInfoEXT));
        auto temp_struct=reader.getVkRenderingFragmentDensityMapAttachmentInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
        auto result=(VkPhysicalDeviceDynamicRenderingFeatures*)malloc(sizeof(VkPhysicalDeviceDynamicRenderingFeatures));
        auto temp_struct=reader.getVkPhysicalDeviceDynamicRenderingFeatures();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
        {
        auto result=(VkCommandBufferInheritanceRenderingInfo*)malloc(sizeof(VkCommandBufferInheritanceRenderingInfo));
        auto temp_struct=reader.getVkCommandBufferInheritanceRenderingInfo();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ATTACHMENT_SAMPLE_COUNT_INFO_A_M_D:
        {
        auto result=(VkAttachmentSampleCountInfoAMD*)malloc(sizeof(VkAttachmentSampleCountInfoAMD));
        auto temp_struct=reader.getVkAttachmentSampleCountInfoAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_N_V_X:
        {
        auto result=(VkMultiviewPerViewAttributesInfoNVX*)malloc(sizeof(VkMultiviewPerViewAttributesInfoNVX));
        auto temp_struct=reader.getVkMultiviewPerViewAttributesInfoNVX();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceImageViewMinLodFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceImageViewMinLodFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceImageViewMinLodFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_MIN_LOD_CREATE_INFO_E_X_T:
        {
        auto result=(VkImageViewMinLodCreateInfoEXT*)malloc(sizeof(VkImageViewMinLodCreateInfoEXT));
        auto temp_struct=reader.getVkImageViewMinLodCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceLinearColorAttachmentFeaturesNV*)malloc(sizeof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceLinearColorAttachmentFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_E_X_T:
        {
        auto result=(VkGraphicsPipelineLibraryCreateInfoEXT*)malloc(sizeof(VkGraphicsPipelineLibraryCreateInfoEXT));
        auto temp_struct=reader.getVkGraphicsPipelineLibraryCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_V_A_L_V_E:
        {
        auto result=(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*)malloc(sizeof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE));
        auto temp_struct=reader.getVkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_BINDING_REFERENCE_V_A_L_V_E:
        {
        auto result=(VkDescriptorSetBindingReferenceVALVE*)malloc(sizeof(VkDescriptorSetBindingReferenceVALVE));
        auto temp_struct=reader.getVkDescriptorSetBindingReferenceVALVE();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_V_A_L_V_E:
        {
        auto result=(VkDescriptorSetLayoutHostMappingInfoVALVE*)malloc(sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE));
        auto temp_struct=reader.getVkDescriptorSetLayoutHostMappingInfoVALVE();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineShaderStageModuleIdentifierCreateInfoEXT*)malloc(sizeof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineShaderStageModuleIdentifierCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHADER_MODULE_IDENTIFIER_E_X_T:
        {
        auto result=(VkShaderModuleIdentifierEXT*)malloc(sizeof(VkShaderModuleIdentifierEXT));
        auto temp_struct=reader.getVkShaderModuleIdentifierEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_COMPRESSION_CONTROL_E_X_T:
        {
        auto result=(VkImageCompressionControlEXT*)malloc(sizeof(VkImageCompressionControlEXT));
        auto temp_struct=reader.getVkImageCompressionControlEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceImageCompressionControlFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceImageCompressionControlFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceImageCompressionControlFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_COMPRESSION_PROPERTIES_E_X_T:
        {
        auto result=(VkImageCompressionPropertiesEXT*)malloc(sizeof(VkImageCompressionPropertiesEXT));
        auto temp_struct=reader.getVkImageCompressionPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_SUBRESOURCE2_K_H_R:
        {
        auto result=(VkImageSubresource2KHR*)malloc(sizeof(VkImageSubresource2KHR));
        auto temp_struct=reader.getVkImageSubresource2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SUBRESOURCE_LAYOUT2_K_H_R:
        {
        auto result=(VkSubresourceLayout2KHR*)malloc(sizeof(VkSubresourceLayout2KHR));
        auto temp_struct=reader.getVkSubresourceLayout2KHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_CREATION_CONTROL_E_X_T:
        {
        auto result=(VkRenderPassCreationControlEXT*)malloc(sizeof(VkRenderPassCreationControlEXT));
        auto temp_struct=reader.getVkRenderPassCreationControlEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_CREATION_FEEDBACK_INFO_E_X_T:
        {
        auto result=(VkRenderPassCreationFeedbackInfoEXT*)malloc(sizeof(VkRenderPassCreationFeedbackInfoEXT));
        auto temp_struct=reader.getVkRenderPassCreationFeedbackInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_E_X_T:
        {
        auto result=(VkRenderPassCreationFeedbackCreateInfoEXT*)malloc(sizeof(VkRenderPassCreationFeedbackCreateInfoEXT));
        auto temp_struct=reader.getVkRenderPassCreationFeedbackCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_SUBPASS_FEEDBACK_INFO_E_X_T:
        {
        auto result=(VkRenderPassSubpassFeedbackInfoEXT*)malloc(sizeof(VkRenderPassSubpassFeedbackInfoEXT));
        auto temp_struct=reader.getVkRenderPassSubpassFeedbackInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_E_X_T:
        {
        auto result=(VkRenderPassSubpassFeedbackCreateInfoEXT*)malloc(sizeof(VkRenderPassSubpassFeedbackCreateInfoEXT));
        auto temp_struct=reader.getVkRenderPassSubpassFeedbackCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MICROMAP_BUILD_INFO_E_X_T:
        {
        auto result=(VkMicromapBuildInfoEXT*)malloc(sizeof(VkMicromapBuildInfoEXT));
        auto temp_struct=reader.getVkMicromapBuildInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MICROMAP_CREATE_INFO_E_X_T:
        {
        auto result=(VkMicromapCreateInfoEXT*)malloc(sizeof(VkMicromapCreateInfoEXT));
        auto temp_struct=reader.getVkMicromapCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MICROMAP_VERSION_INFO_E_X_T:
        {
        auto result=(VkMicromapVersionInfoEXT*)malloc(sizeof(VkMicromapVersionInfoEXT));
        auto temp_struct=reader.getVkMicromapVersionInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_MICROMAP_INFO_E_X_T:
        {
        auto result=(VkCopyMicromapInfoEXT*)malloc(sizeof(VkCopyMicromapInfoEXT));
        auto temp_struct=reader.getVkCopyMicromapInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_MICROMAP_TO_MEMORY_INFO_E_X_T:
        {
        auto result=(VkCopyMicromapToMemoryInfoEXT*)malloc(sizeof(VkCopyMicromapToMemoryInfoEXT));
        auto temp_struct=reader.getVkCopyMicromapToMemoryInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COPY_MEMORY_TO_MICROMAP_INFO_E_X_T:
        {
        auto result=(VkCopyMemoryToMicromapInfoEXT*)malloc(sizeof(VkCopyMemoryToMicromapInfoEXT));
        auto temp_struct=reader.getVkCopyMemoryToMicromapInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MICROMAP_BUILD_SIZES_INFO_E_X_T:
        {
        auto result=(VkMicromapBuildSizesInfoEXT*)malloc(sizeof(VkMicromapBuildSizesInfoEXT));
        auto temp_struct=reader.getVkMicromapBuildSizesInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MICROMAP_USAGE_E_X_T:
        {
        auto result=(VkMicromapUsageEXT*)malloc(sizeof(VkMicromapUsageEXT));
        auto temp_struct=reader.getVkMicromapUsageEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MICROMAP_TRIANGLE_E_X_T:
        {
        auto result=(VkMicromapTriangleEXT*)malloc(sizeof(VkMicromapTriangleEXT));
        auto temp_struct=reader.getVkMicromapTriangleEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceOpacityMicromapFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceOpacityMicromapFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceOpacityMicromapFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceOpacityMicromapPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceOpacityMicromapPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceOpacityMicromapPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_E_X_T:
        {
        auto result=(VkAccelerationStructureTrianglesOpacityMicromapEXT*)malloc(sizeof(VkAccelerationStructureTrianglesOpacityMicromapEXT));
        auto temp_struct=reader.getVkAccelerationStructureTrianglesOpacityMicromapEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_PROPERTIES_IDENTIFIER_E_X_T:
        {
        auto result=(VkPipelinePropertiesIdentifierEXT*)malloc(sizeof(VkPipelinePropertiesIdentifierEXT));
        auto temp_struct=reader.getVkPipelinePropertiesIdentifierEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevicePipelinePropertiesFeaturesEXT*)malloc(sizeof(VkPhysicalDevicePipelinePropertiesFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePipelinePropertiesFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_A_M_D:
        {
        auto result=(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*)malloc(sizeof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD));
        auto temp_struct=reader.getVkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_E_X_T:
        {
        auto result=(VkExternalMemoryAcquireUnmodifiedEXT*)malloc(sizeof(VkExternalMemoryAcquireUnmodifiedEXT));
        auto temp_struct=reader.getVkExternalMemoryAcquireUnmodifiedEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevicePipelineRobustnessFeaturesEXT*)malloc(sizeof(VkPhysicalDevicePipelineRobustnessFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePipelineRobustnessFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PIPELINE_ROBUSTNESS_CREATE_INFO_E_X_T:
        {
        auto result=(VkPipelineRobustnessCreateInfoEXT*)malloc(sizeof(VkPipelineRobustnessCreateInfoEXT));
        auto temp_struct=reader.getVkPipelineRobustnessCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDevicePipelineRobustnessPropertiesEXT*)malloc(sizeof(VkPhysicalDevicePipelineRobustnessPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePipelineRobustnessPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_Q_C_O_M:
        {
        auto result=(VkImageViewSampleWeightCreateInfoQCOM*)malloc(sizeof(VkImageViewSampleWeightCreateInfoQCOM));
        auto temp_struct=reader.getVkImageViewSampleWeightCreateInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceImageProcessingFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceImageProcessingFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceImageProcessingFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceImageProcessingPropertiesQCOM*)malloc(sizeof(VkPhysicalDeviceImageProcessingPropertiesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceImageProcessingPropertiesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceTilePropertiesFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceTilePropertiesFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceTilePropertiesFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_TILE_PROPERTIES_Q_C_O_M:
        {
        auto result=(VkTilePropertiesQCOM*)malloc(sizeof(VkTilePropertiesQCOM));
        auto temp_struct=reader.getVkTilePropertiesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_S_E_C:
        {
        auto result=(VkPhysicalDeviceAmigoProfilingFeaturesSEC*)malloc(sizeof(VkPhysicalDeviceAmigoProfilingFeaturesSEC));
        auto temp_struct=reader.getVkPhysicalDeviceAmigoProfilingFeaturesSEC();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_AMIGO_PROFILING_SUBMIT_INFO_S_E_C:
        {
        auto result=(VkAmigoProfilingSubmitInfoSEC*)malloc(sizeof(VkAmigoProfilingSubmitInfoSEC));
        auto temp_struct=reader.getVkAmigoProfilingSubmitInfoSEC();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDepthClampZeroOneFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceAddressBindingReportFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceAddressBindingReportFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceAddressBindingReportFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_E_X_T:
        {
        auto result=(VkDeviceAddressBindingCallbackDataEXT*)malloc(sizeof(VkDeviceAddressBindingCallbackDataEXT));
        auto temp_struct=reader.getVkDeviceAddressBindingCallbackDataEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceOpticalFlowFeaturesNV*)malloc(sizeof(VkPhysicalDeviceOpticalFlowFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceOpticalFlowFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceOpticalFlowPropertiesNV*)malloc(sizeof(VkPhysicalDeviceOpticalFlowPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceOpticalFlowPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OPTICAL_FLOW_IMAGE_FORMAT_INFO_N_V:
        {
        auto result=(VkOpticalFlowImageFormatInfoNV*)malloc(sizeof(VkOpticalFlowImageFormatInfoNV));
        auto temp_struct=reader.getVkOpticalFlowImageFormatInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_N_V:
        {
        auto result=(VkOpticalFlowImageFormatPropertiesNV*)malloc(sizeof(VkOpticalFlowImageFormatPropertiesNV));
        auto temp_struct=reader.getVkOpticalFlowImageFormatPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OPTICAL_FLOW_SESSION_CREATE_INFO_N_V:
        {
        auto result=(VkOpticalFlowSessionCreateInfoNV*)malloc(sizeof(VkOpticalFlowSessionCreateInfoNV));
        auto temp_struct=reader.getVkOpticalFlowSessionCreateInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_N_V:
        {
        auto result=(VkOpticalFlowSessionCreatePrivateDataInfoNV*)malloc(sizeof(VkOpticalFlowSessionCreatePrivateDataInfoNV));
        auto temp_struct=reader.getVkOpticalFlowSessionCreatePrivateDataInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_OPTICAL_FLOW_EXECUTE_INFO_N_V:
        {
        auto result=(VkOpticalFlowExecuteInfoNV*)malloc(sizeof(VkOpticalFlowExecuteInfoNV));
        auto temp_struct=reader.getVkOpticalFlowExecuteInfoNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FAULT_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceFaultFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceFaultFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceFaultFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_FAULT_ADDRESS_INFO_E_X_T:
        {
        auto result=(VkDeviceFaultAddressInfoEXT*)malloc(sizeof(VkDeviceFaultAddressInfoEXT));
        auto temp_struct=reader.getVkDeviceFaultAddressInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_FAULT_VENDOR_INFO_E_X_T:
        {
        auto result=(VkDeviceFaultVendorInfoEXT*)malloc(sizeof(VkDeviceFaultVendorInfoEXT));
        auto temp_struct=reader.getVkDeviceFaultVendorInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_FAULT_COUNTS_E_X_T:
        {
        auto result=(VkDeviceFaultCountsEXT*)malloc(sizeof(VkDeviceFaultCountsEXT));
        auto temp_struct=reader.getVkDeviceFaultCountsEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_FAULT_INFO_E_X_T:
        {
        auto result=(VkDeviceFaultInfoEXT*)malloc(sizeof(VkDeviceFaultInfoEXT));
        auto temp_struct=reader.getVkDeviceFaultInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_E_X_T:
        {
        auto result=(VkDeviceFaultVendorBinaryHeaderVersionOneEXT*)malloc(sizeof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT));
        auto temp_struct=reader.getVkDeviceFaultVendorBinaryHeaderVersionOneEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*)malloc(sizeof(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEPTH_BIAS_INFO_E_X_T:
        {
        auto result=(VkDepthBiasInfoEXT*)malloc(sizeof(VkDepthBiasInfoEXT));
        auto temp_struct=reader.getVkDepthBiasInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEPTH_BIAS_REPRESENTATION_INFO_E_X_T:
        {
        auto result=(VkDepthBiasRepresentationInfoEXT*)malloc(sizeof(VkDepthBiasRepresentationInfoEXT));
        auto temp_struct=reader.getVkDepthBiasRepresentationInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DECOMPRESS_MEMORY_REGION_N_V:
        {
        auto result=(VkDecompressMemoryRegionNV*)malloc(sizeof(VkDecompressMemoryRegionNV));
        auto temp_struct=reader.getVkDecompressMemoryRegionNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_A_R_M:
        {
        auto result=(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*)malloc(sizeof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM));
        auto temp_struct=reader.getVkPhysicalDeviceShaderCoreBuiltinsPropertiesARM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_A_R_M:
        {
        auto result=(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*)malloc(sizeof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM));
        auto temp_struct=reader.getVkPhysicalDeviceShaderCoreBuiltinsFeaturesARM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_FRAME_BOUNDARY_E_X_T:
        {
        auto result=(VkFrameBoundaryEXT*)malloc(sizeof(VkFrameBoundaryEXT));
        auto temp_struct=reader.getVkFrameBoundaryEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceFrameBoundaryFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceFrameBoundaryFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceFrameBoundaryFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_PRESENT_MODE_E_X_T:
        {
        auto result=(VkSurfacePresentModeEXT*)malloc(sizeof(VkSurfacePresentModeEXT));
        auto temp_struct=reader.getVkSurfacePresentModeEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_PRESENT_SCALING_CAPABILITIES_E_X_T:
        {
        auto result=(VkSurfacePresentScalingCapabilitiesEXT*)malloc(sizeof(VkSurfacePresentScalingCapabilitiesEXT));
        auto temp_struct=reader.getVkSurfacePresentScalingCapabilitiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SURFACE_PRESENT_MODE_COMPATIBILITY_E_X_T:
        {
        auto result=(VkSurfacePresentModeCompatibilityEXT*)malloc(sizeof(VkSurfacePresentModeCompatibilityEXT));
        auto temp_struct=reader.getVkSurfacePresentModeCompatibilityEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE1_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*)malloc(sizeof(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_PRESENT_FENCE_INFO_E_X_T:
        {
        auto result=(VkSwapchainPresentFenceInfoEXT*)malloc(sizeof(VkSwapchainPresentFenceInfoEXT));
        auto temp_struct=reader.getVkSwapchainPresentFenceInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_E_X_T:
        {
        auto result=(VkSwapchainPresentModesCreateInfoEXT*)malloc(sizeof(VkSwapchainPresentModesCreateInfoEXT));
        auto temp_struct=reader.getVkSwapchainPresentModesCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_PRESENT_MODE_INFO_E_X_T:
        {
        auto result=(VkSwapchainPresentModeInfoEXT*)malloc(sizeof(VkSwapchainPresentModeInfoEXT));
        auto temp_struct=reader.getVkSwapchainPresentModeInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_E_X_T:
        {
        auto result=(VkSwapchainPresentScalingCreateInfoEXT*)malloc(sizeof(VkSwapchainPresentScalingCreateInfoEXT));
        auto temp_struct=reader.getVkSwapchainPresentScalingCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_RELEASE_SWAPCHAIN_IMAGES_INFO_E_X_T:
        {
        auto result=(VkReleaseSwapchainImagesInfoEXT*)malloc(sizeof(VkReleaseSwapchainImagesInfoEXT));
        auto temp_struct=reader.getVkReleaseSwapchainImagesInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceDepthBiasControlFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceDepthBiasControlFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceDepthBiasControlFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*)malloc(sizeof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingInvocationReorderFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_N_V:
        {
        auto result=(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*)malloc(sizeof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingInvocationReorderPropertiesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DIRECT_DRIVER_LOADING_INFO_L_U_N_A_R_G:
        {
        auto result=(VkDirectDriverLoadingInfoLUNARG*)malloc(sizeof(VkDirectDriverLoadingInfoLUNARG));
        auto temp_struct=reader.getVkDirectDriverLoadingInfoLUNARG();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DIRECT_DRIVER_LOADING_LIST_L_U_N_A_R_G:
        {
        auto result=(VkDirectDriverLoadingListLUNARG*)malloc(sizeof(VkDirectDriverLoadingListLUNARG));
        auto temp_struct=reader.getVkDirectDriverLoadingListLUNARG();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceRayTracingPositionFetchFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_DEVICE_IMAGE_SUBRESOURCE_INFO_K_H_R:
        {
        auto result=(VkDeviceImageSubresourceInfoKHR*)malloc(sizeof(VkDeviceImageSubresourceInfoKHR));
        auto temp_struct=reader.getVkDeviceImageSubresourceInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_A_R_M:
        {
        auto result=(VkPhysicalDeviceShaderCorePropertiesARM*)malloc(sizeof(VkPhysicalDeviceShaderCorePropertiesARM));
        auto temp_struct=reader.getVkPhysicalDeviceShaderCorePropertiesARM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_Q_C_O_M:
        {
        auto result=(VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*)malloc(sizeof(VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM));
        auto temp_struct=reader.getVkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_QUERY_LOW_LATENCY_SUPPORT_N_V:
        {
        auto result=(VkQueryLowLatencySupportNV*)malloc(sizeof(VkQueryLowLatencySupportNV));
        auto temp_struct=reader.getVkQueryLowLatencySupportNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_MAP_INFO_K_H_R:
        {
        auto result=(VkMemoryMapInfoKHR*)malloc(sizeof(VkMemoryMapInfoKHR));
        auto temp_struct=reader.getVkMemoryMapInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_MEMORY_UNMAP_INFO_K_H_R:
        {
        auto result=(VkMemoryUnmapInfoKHR*)malloc(sizeof(VkMemoryUnmapInfoKHR));
        auto temp_struct=reader.getVkMemoryUnmapInfoKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderObjectFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceShaderObjectFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderObjectFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderObjectPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceShaderObjectPropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderObjectPropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SHADER_CREATE_INFO_E_X_T:
        {
        auto result=(VkShaderCreateInfoEXT*)malloc(sizeof(VkShaderCreateInfoEXT));
        auto temp_struct=reader.getVkShaderCreateInfoEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderTileImageFeaturesEXT*)malloc(sizeof(VkPhysicalDeviceShaderTileImageFeaturesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderTileImageFeaturesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_E_X_T:
        {
        auto result=(VkPhysicalDeviceShaderTileImagePropertiesEXT*)malloc(sizeof(VkPhysicalDeviceShaderTileImagePropertiesEXT));
        auto temp_struct=reader.getVkPhysicalDeviceShaderTileImagePropertiesEXT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_K_H_R:
        {
        auto result=(VkPhysicalDeviceCooperativeMatrixFeaturesKHR*)malloc(sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceCooperativeMatrixFeaturesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_COOPERATIVE_MATRIX_PROPERTIES_K_H_R:
        {
        auto result=(VkCooperativeMatrixPropertiesKHR*)malloc(sizeof(VkCooperativeMatrixPropertiesKHR));
        auto temp_struct=reader.getVkCooperativeMatrixPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_K_H_R:
        {
        auto result=(VkPhysicalDeviceCooperativeMatrixPropertiesKHR*)malloc(sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR));
        auto temp_struct=reader.getVkPhysicalDeviceCooperativeMatrixPropertiesKHR();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceCubicClampFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceCubicClampFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceCubicClampFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceYcbcrDegammaFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_Q_C_O_M:
        {
        auto result=(VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*)malloc(sizeof(VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM));
        auto temp_struct=reader.getVkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceCubicWeightsFeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceCubicWeightsFeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceCubicWeightsFeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_Q_C_O_M:
        {
        auto result=(VkSamplerCubicWeightsCreateInfoQCOM*)malloc(sizeof(VkSamplerCubicWeightsCreateInfoQCOM));
        auto temp_struct=reader.getVkSamplerCubicWeightsCreateInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_Q_C_O_M:
        {
        auto result=(VkBlitImageCubicWeightsInfoQCOM*)malloc(sizeof(VkBlitImageCubicWeightsInfoQCOM));
        auto temp_struct=reader.getVkBlitImageCubicWeightsInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_PROCESSING2_FEATURES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceImageProcessing2FeaturesQCOM*)malloc(sizeof(VkPhysicalDeviceImageProcessing2FeaturesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceImageProcessing2FeaturesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_IMAGE_PROCESSING2_PROPERTIES_Q_C_O_M:
        {
        auto result=(VkPhysicalDeviceImageProcessing2PropertiesQCOM*)malloc(sizeof(VkPhysicalDeviceImageProcessing2PropertiesQCOM));
        auto temp_struct=reader.getVkPhysicalDeviceImageProcessing2PropertiesQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_Q_C_O_M:
        {
        auto result=(VkSamplerBlockMatchWindowCreateInfoQCOM*)malloc(sizeof(VkSamplerBlockMatchWindowCreateInfoQCOM));
        auto temp_struct=reader.getVkSamplerBlockMatchWindowCreateInfoQCOM();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_N_V:
        {
        auto result=(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*)malloc(sizeof(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV));
        auto temp_struct=reader.getVkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    

    case stream::PNext::VK_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_M_S_F_T:
        {
        auto result=(VkPhysicalDeviceLayeredDriverPropertiesMSFT*)malloc(sizeof(VkPhysicalDeviceLayeredDriverPropertiesMSFT));
        auto temp_struct=reader.getVkPhysicalDeviceLayeredDriverPropertiesMSFT();
        result[0]=deserialize_struct(temp_struct);
        return result;
        }
    
}}
std::map<VkStructureType, size_t> structure_type_to_size={
{VK_STRUCTURE_TYPE_APPLICATION_INFO, sizeof(VkApplicationInfo) },
{VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, sizeof(VkDeviceQueueCreateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, sizeof(VkDeviceCreateInfo) },
{VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, sizeof(VkInstanceCreateInfo) },
{VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, sizeof(VkMemoryAllocateInfo) },
{VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE, sizeof(VkMappedMemoryRange) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, sizeof(VkWriteDescriptorSet) },
{VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET, sizeof(VkCopyDescriptorSet) },
{VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR, sizeof(VkBufferUsageFlags2CreateInfoKHR) },
{VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, sizeof(VkBufferCreateInfo) },
{VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO, sizeof(VkBufferViewCreateInfo) },
{VK_STRUCTURE_TYPE_MEMORY_BARRIER, sizeof(VkMemoryBarrier) },
{VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER, sizeof(VkBufferMemoryBarrier) },
{VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, sizeof(VkImageMemoryBarrier) },
{VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, sizeof(VkImageCreateInfo) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, sizeof(VkImageViewCreateInfo) },
{VK_STRUCTURE_TYPE_BIND_SPARSE_INFO, sizeof(VkBindSparseInfo) },
{VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, sizeof(VkShaderModuleCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, sizeof(VkDescriptorSetLayoutCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, sizeof(VkDescriptorPoolCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, sizeof(VkDescriptorSetAllocateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, sizeof(VkPipelineShaderStageCreateInfo) },
{VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, sizeof(VkComputePipelineCreateInfo) },
{VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV, sizeof(VkComputePipelineIndirectBufferInfoNV) },
{VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR, sizeof(VkPipelineCreateFlags2CreateInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, sizeof(VkPipelineVertexInputStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, sizeof(VkPipelineInputAssemblyStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO, sizeof(VkPipelineTessellationStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, sizeof(VkPipelineViewportStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, sizeof(VkPipelineRasterizationStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, sizeof(VkPipelineMultisampleStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, sizeof(VkPipelineColorBlendStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, sizeof(VkPipelineDynamicStateCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, sizeof(VkPipelineDepthStencilStateCreateInfo) },
{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, sizeof(VkGraphicsPipelineCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO, sizeof(VkPipelineCacheCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, sizeof(VkPipelineLayoutCreateInfo) },
{VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, sizeof(VkSamplerCreateInfo) },
{VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, sizeof(VkCommandPoolCreateInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, sizeof(VkCommandBufferAllocateInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO, sizeof(VkCommandBufferInheritanceInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, sizeof(VkCommandBufferBeginInfo) },
{VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO, sizeof(VkRenderPassBeginInfo) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, sizeof(VkRenderPassCreateInfo) },
{VK_STRUCTURE_TYPE_EVENT_CREATE_INFO, sizeof(VkEventCreateInfo) },
{VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, sizeof(VkFenceCreateInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO, sizeof(VkSemaphoreCreateInfo) },
{VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO, sizeof(VkQueryPoolCreateInfo) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, sizeof(VkFramebufferCreateInfo) },
{VK_STRUCTURE_TYPE_SUBMIT_INFO, sizeof(VkSubmitInfo) },
{VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR, sizeof(VkDisplayModeCreateInfoKHR) },
{VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR, sizeof(VkDisplaySurfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR, sizeof(VkDisplayPresentInfoKHR) },
{VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR, sizeof(VkXlibSurfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR, sizeof(VkXcbSurfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, sizeof(VkSwapchainCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PRESENT_INFO_KHR, sizeof(VkPresentInfoKHR) },
{VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, sizeof(VkDebugReportCallbackCreateInfoEXT) },
{VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT, sizeof(VkValidationFlagsEXT) },
{VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT, sizeof(VkValidationFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD, sizeof(VkPipelineRasterizationStateRasterizationOrderAMD) },
{VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT, sizeof(VkDebugMarkerObjectNameInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT, sizeof(VkDebugMarkerObjectTagInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, sizeof(VkDebugMarkerMarkerInfoEXT) },
{VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, sizeof(VkDedicatedAllocationImageCreateInfoNV) },
{VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV, sizeof(VkDedicatedAllocationBufferCreateInfoNV) },
{VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV, sizeof(VkDedicatedAllocationMemoryAllocateInfoNV) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV, sizeof(VkExternalMemoryImageCreateInfoNV) },
{VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV, sizeof(VkExportMemoryAllocateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV) },
{VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO, sizeof(VkDevicePrivateDataCreateInfo) },
{VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO, sizeof(VkPrivateDataSlotCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES, sizeof(VkPhysicalDevicePrivateDataFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV, sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT, sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT) },
{VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV, sizeof(VkGraphicsShaderGroupCreateInfoNV) },
{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV, sizeof(VkGraphicsPipelineShaderGroupsCreateInfoNV) },
{VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV, sizeof(VkIndirectCommandsLayoutTokenNV) },
{VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV, sizeof(VkIndirectCommandsLayoutCreateInfoNV) },
{VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV, sizeof(VkGeneratedCommandsInfoNV) },
{VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV, sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV) },
{VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV, sizeof(VkPipelineIndirectDeviceAddressInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, sizeof(VkPhysicalDeviceFeatures2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2, sizeof(VkPhysicalDeviceProperties2) },
{VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, sizeof(VkFormatProperties2) },
{VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, sizeof(VkImageFormatProperties2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2, sizeof(VkPhysicalDeviceImageFormatInfo2) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2, sizeof(VkQueueFamilyProperties2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, sizeof(VkPhysicalDeviceMemoryProperties2) },
{VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, sizeof(VkSparseImageFormatProperties2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2, sizeof(VkPhysicalDeviceSparseImageFormatInfo2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR, sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES, sizeof(VkPhysicalDeviceDriverProperties) },
{VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR, sizeof(VkPresentRegionsKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES, sizeof(VkPhysicalDeviceVariablePointersFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO, sizeof(VkPhysicalDeviceExternalImageFormatInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES, sizeof(VkExternalImageFormatProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO, sizeof(VkPhysicalDeviceExternalBufferInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, sizeof(VkExternalBufferProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES, sizeof(VkPhysicalDeviceIDProperties) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO, sizeof(VkExternalMemoryImageCreateInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO, sizeof(VkExternalMemoryBufferCreateInfo) },
{VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO, sizeof(VkExportMemoryAllocateInfo) },
{VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR, sizeof(VkImportMemoryFdInfoKHR) },
{VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR, sizeof(VkMemoryFdPropertiesKHR) },
{VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, sizeof(VkMemoryGetFdInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO, sizeof(VkPhysicalDeviceExternalSemaphoreInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, sizeof(VkExternalSemaphoreProperties) },
{VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO, sizeof(VkExportSemaphoreCreateInfo) },
{VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR, sizeof(VkImportSemaphoreFdInfoKHR) },
{VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, sizeof(VkSemaphoreGetFdInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO, sizeof(VkPhysicalDeviceExternalFenceInfo) },
{VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, sizeof(VkExternalFenceProperties) },
{VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO, sizeof(VkExportFenceCreateInfo) },
{VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR, sizeof(VkImportFenceFdInfoKHR) },
{VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, sizeof(VkFenceGetFdInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES, sizeof(VkPhysicalDeviceMultiviewFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES, sizeof(VkPhysicalDeviceMultiviewProperties) },
{VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO, sizeof(VkRenderPassMultiviewCreateInfo) },
{VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT, sizeof(VkSurfaceCapabilities2EXT) },
{VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT, sizeof(VkDisplayPowerInfoEXT) },
{VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT, sizeof(VkDeviceEventInfoEXT) },
{VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT, sizeof(VkDisplayEventInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT, sizeof(VkSwapchainCounterCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, sizeof(VkPhysicalDeviceGroupProperties) },
{VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO, sizeof(VkMemoryAllocateFlagsInfo) },
{VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO, sizeof(VkBindBufferMemoryInfo) },
{VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO, sizeof(VkBindBufferMemoryDeviceGroupInfo) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO, sizeof(VkBindImageMemoryInfo) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO, sizeof(VkBindImageMemoryDeviceGroupInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO, sizeof(VkDeviceGroupRenderPassBeginInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO, sizeof(VkDeviceGroupCommandBufferBeginInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO, sizeof(VkDeviceGroupSubmitInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO, sizeof(VkDeviceGroupBindSparseInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR, sizeof(VkDeviceGroupPresentCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR, sizeof(VkImageSwapchainCreateInfoKHR) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR, sizeof(VkBindImageMemorySwapchainInfoKHR) },
{VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR, sizeof(VkAcquireNextImageInfoKHR) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR, sizeof(VkDeviceGroupPresentInfoKHR) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO, sizeof(VkDeviceGroupDeviceCreateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR, sizeof(VkDeviceGroupSwapchainCreateInfoKHR) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO, sizeof(VkDescriptorUpdateTemplateCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR, sizeof(VkPhysicalDevicePresentIdFeaturesKHR) },
{VK_STRUCTURE_TYPE_PRESENT_ID_KHR, sizeof(VkPresentIdKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR, sizeof(VkPhysicalDevicePresentWaitFeaturesKHR) },
{VK_STRUCTURE_TYPE_HDR_METADATA_EXT, sizeof(VkHdrMetadataEXT) },
{VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD, sizeof(VkDisplayNativeHdrSurfaceCapabilitiesAMD) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD, sizeof(VkSwapchainDisplayNativeHdrCreateInfoAMD) },
{VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE, sizeof(VkPresentTimesInfoGOOGLE) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportWScalingStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportSwizzleStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT, sizeof(VkPipelineDiscardRectangleStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX, sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) },
{VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO, sizeof(VkRenderPassInputAttachmentAspectCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR, sizeof(VkPhysicalDeviceSurfaceInfo2KHR) },
{VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR, sizeof(VkSurfaceCapabilities2KHR) },
{VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR, sizeof(VkSurfaceFormat2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR, sizeof(VkDisplayProperties2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR, sizeof(VkDisplayPlaneProperties2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR, sizeof(VkDisplayModeProperties2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR, sizeof(VkDisplayPlaneInfo2KHR) },
{VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR, sizeof(VkDisplayPlaneCapabilities2KHR) },
{VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR, sizeof(VkSharedPresentSurfaceCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES, sizeof(VkPhysicalDevice16BitStorageFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES, sizeof(VkPhysicalDeviceSubgroupProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) },
{VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2, sizeof(VkBufferMemoryRequirementsInfo2) },
{VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS, sizeof(VkDeviceBufferMemoryRequirements) },
{VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, sizeof(VkImageMemoryRequirementsInfo2) },
{VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2, sizeof(VkImageSparseMemoryRequirementsInfo2) },
{VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS, sizeof(VkDeviceImageMemoryRequirements) },
{VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, sizeof(VkMemoryRequirements2) },
{VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, sizeof(VkSparseImageMemoryRequirements2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES, sizeof(VkPhysicalDevicePointClippingProperties) },
{VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS, sizeof(VkMemoryDedicatedRequirements) },
{VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO, sizeof(VkMemoryDedicatedAllocateInfo) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO, sizeof(VkImageViewUsageCreateInfo) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT, sizeof(VkImageViewSlicedCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO, sizeof(VkPipelineTessellationDomainOriginStateCreateInfo) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO, sizeof(VkSamplerYcbcrConversionInfo) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO, sizeof(VkSamplerYcbcrConversionCreateInfo) },
{VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO, sizeof(VkBindImagePlaneMemoryInfo) },
{VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO, sizeof(VkImagePlaneMemoryRequirementsInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES, sizeof(VkSamplerYcbcrConversionImageFormatProperties) },
{VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD, sizeof(VkTextureLODGatherFormatPropertiesAMD) },
{VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT, sizeof(VkConditionalRenderingBeginInfoEXT) },
{VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO, sizeof(VkProtectedSubmitInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES, sizeof(VkPhysicalDeviceProtectedMemoryFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES, sizeof(VkPhysicalDeviceProtectedMemoryProperties) },
{VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2, sizeof(VkDeviceQueueInfo2) },
{VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV, sizeof(VkPipelineCoverageToColorStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES, sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties) },
{VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT, sizeof(VkSampleLocationsInfoEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT, sizeof(VkRenderPassSampleLocationsBeginInfoEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT, sizeof(VkPipelineSampleLocationsStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT, sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT) },
{VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT, sizeof(VkMultisamplePropertiesEXT) },
{VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO, sizeof(VkSamplerReductionModeCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT, sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT, sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT, sizeof(VkPipelineColorBlendAdvancedStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES, sizeof(VkPhysicalDeviceInlineUniformBlockFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES, sizeof(VkPhysicalDeviceInlineUniformBlockProperties) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK, sizeof(VkWriteDescriptorSetInlineUniformBlock) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO, sizeof(VkDescriptorPoolInlineUniformBlockCreateInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV, sizeof(VkPipelineCoverageModulationStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO, sizeof(VkImageFormatListCreateInfo) },
{VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT, sizeof(VkValidationCacheCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT, sizeof(VkShaderModuleValidationCacheCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES, sizeof(VkPhysicalDeviceMaintenance3Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES, sizeof(VkPhysicalDeviceMaintenance4Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES, sizeof(VkPhysicalDeviceMaintenance4Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR, sizeof(VkPhysicalDeviceMaintenance5FeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR, sizeof(VkPhysicalDeviceMaintenance5PropertiesKHR) },
{VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR, sizeof(VkRenderingAreaInfoKHR) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, sizeof(VkDescriptorSetLayoutSupport) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES, sizeof(VkPhysicalDeviceShaderDrawParametersFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES, sizeof(VkPhysicalDeviceShaderFloat16Int8Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES, sizeof(VkPhysicalDeviceFloatControlsProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES, sizeof(VkPhysicalDeviceHostQueryResetFeatures) },
{VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR, sizeof(VkDeviceQueueGlobalPriorityCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR, sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR, sizeof(VkQueueFamilyGlobalPriorityPropertiesKHR) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, sizeof(VkDebugUtilsObjectNameInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT, sizeof(VkDebugUtilsObjectTagInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT, sizeof(VkDebugUtilsLabelEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT, sizeof(VkDebugUtilsMessengerCreateInfoEXT) },
{VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT, sizeof(VkDebugUtilsMessengerCallbackDataEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT, sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT, sizeof(VkDeviceDeviceMemoryReportCreateInfoEXT) },
{VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT, sizeof(VkDeviceMemoryReportCallbackDataEXT) },
{VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT, sizeof(VkImportMemoryHostPointerInfoEXT) },
{VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT, sizeof(VkMemoryHostPointerPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT, sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT, sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT) },
{VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT, sizeof(VkCalibratedTimestampInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD, sizeof(VkPhysicalDeviceShaderCorePropertiesAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD, sizeof(VkPhysicalDeviceShaderCoreProperties2AMD) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationConservativeStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES, sizeof(VkPhysicalDeviceDescriptorIndexingFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES, sizeof(VkPhysicalDeviceDescriptorIndexingProperties) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO, sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO, sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfo) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT, sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupport) },
{VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, sizeof(VkAttachmentDescription2) },
{VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, sizeof(VkAttachmentReference2) },
{VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, sizeof(VkSubpassDescription2) },
{VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, sizeof(VkSubpassDependency2) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, sizeof(VkRenderPassCreateInfo2) },
{VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO, sizeof(VkSubpassBeginInfo) },
{VK_STRUCTURE_TYPE_SUBPASS_END_INFO, sizeof(VkSubpassEndInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES, sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES, sizeof(VkPhysicalDeviceTimelineSemaphoreProperties) },
{VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO, sizeof(VkSemaphoreTypeCreateInfo) },
{VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO, sizeof(VkTimelineSemaphoreSubmitInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO, sizeof(VkSemaphoreWaitInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO, sizeof(VkSemaphoreSignalInfo) },
{VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT, sizeof(VkPipelineVertexInputDivisorStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT, sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT, sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT, sizeof(VkCommandBufferInheritanceConditionalRenderingInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES, sizeof(VkPhysicalDevice8BitStorageFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT, sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES, sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES, sizeof(VkPhysicalDeviceShaderAtomicInt64Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT, sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV, sizeof(VkQueueFamilyCheckpointPropertiesNV) },
{VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV, sizeof(VkCheckpointDataNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES, sizeof(VkPhysicalDeviceDepthStencilResolveProperties) },
{VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE, sizeof(VkSubpassDescriptionDepthStencilResolve) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT, sizeof(VkImageViewASTCDecodeModeEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT, sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT, sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT, sizeof(VkPhysicalDeviceTransformFeedbackPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationStateStreamCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV, sizeof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV, sizeof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV, sizeof(VkPhysicalDeviceExclusiveScissorFeaturesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportExclusiveScissorStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV, sizeof(VkPhysicalDeviceCornerSampledImageFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV, sizeof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV, sizeof(VkPhysicalDeviceShaderImageFootprintFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV, sizeof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV, sizeof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV, sizeof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV, sizeof(VkPhysicalDeviceMemoryDecompressionFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV, sizeof(VkPhysicalDeviceMemoryDecompressionPropertiesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportShadingRateImageStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV, sizeof(VkPhysicalDeviceShadingRateImageFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV, sizeof(VkPhysicalDeviceShadingRateImagePropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI, sizeof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV, sizeof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV, sizeof(VkPhysicalDeviceMeshShaderFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV, sizeof(VkPhysicalDeviceMeshShaderPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT, sizeof(VkPhysicalDeviceMeshShaderFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT, sizeof(VkPhysicalDeviceMeshShaderPropertiesEXT) },
{VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV, sizeof(VkRayTracingShaderGroupCreateInfoNV) },
{VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR, sizeof(VkRayTracingShaderGroupCreateInfoKHR) },
{VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV, sizeof(VkRayTracingPipelineCreateInfoNV) },
{VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR, sizeof(VkRayTracingPipelineCreateInfoKHR) },
{VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV, sizeof(VkGeometryTrianglesNV) },
{VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV, sizeof(VkGeometryAABBNV) },
{VK_STRUCTURE_TYPE_GEOMETRY_NV, sizeof(VkGeometryNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV, sizeof(VkAccelerationStructureInfoNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV, sizeof(VkAccelerationStructureCreateInfoNV) },
{VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV, sizeof(VkBindAccelerationStructureMemoryInfoNV) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR, sizeof(VkWriteDescriptorSetAccelerationStructureKHR) },
{VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV, sizeof(VkWriteDescriptorSetAccelerationStructureNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV, sizeof(VkAccelerationStructureMemoryRequirementsInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR, sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR, sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR, sizeof(VkPhysicalDeviceRayQueryFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR, sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR, sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV, sizeof(VkPhysicalDeviceRayTracingPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR, sizeof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR) },
{VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT, sizeof(VkDrmFormatModifierPropertiesListEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT, sizeof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT, sizeof(VkImageDrmFormatModifierListCreateInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT, sizeof(VkImageDrmFormatModifierExplicitCreateInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT, sizeof(VkImageDrmFormatModifierPropertiesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO, sizeof(VkImageStencilUsageCreateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD, sizeof(VkDeviceMemoryOverallocationCreateInfoAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM, sizeof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT, sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM, sizeof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM) },
{VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT, sizeof(VkRenderPassFragmentDensityMapCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM, sizeof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES, sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures) },
{VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR, sizeof(VkSurfaceProtectedCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationDepthClipStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT, sizeof(VkPhysicalDeviceMemoryBudgetPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT, sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT) },
{VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT, sizeof(VkMemoryPriorityAllocateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT, sizeof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES, sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT, sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) },
{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO, sizeof(VkBufferDeviceAddressInfo) },
{VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO, sizeof(VkBufferOpaqueCaptureAddressCreateInfo) },
{VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT, sizeof(VkBufferDeviceAddressCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT, sizeof(VkPhysicalDeviceImageViewImageFormatInfoEXT) },
{VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT, sizeof(VkFilterCubicImageViewImageFormatPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES, sizeof(VkPhysicalDeviceImagelessFramebufferFeatures) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO, sizeof(VkFramebufferAttachmentsCreateInfo) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO, sizeof(VkFramebufferAttachmentImageInfo) },
{VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO, sizeof(VkRenderPassAttachmentBeginInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES, sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV, sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV, sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesNV) },
{VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV, sizeof(VkCooperativeMatrixPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT, sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX, sizeof(VkImageViewHandleInfoNVX) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX, sizeof(VkImageViewAddressPropertiesNVX) },
{VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO, sizeof(VkPipelineCreationFeedbackCreateInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV, sizeof(VkPhysicalDevicePresentBarrierFeaturesNV) },
{VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV, sizeof(VkSurfaceCapabilitiesPresentBarrierNV) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV, sizeof(VkSwapchainPresentBarrierCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR, sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR, sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR) },
{VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR, sizeof(VkPerformanceCounterKHR) },
{VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR, sizeof(VkPerformanceCounterDescriptionKHR) },
{VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR, sizeof(VkQueryPoolPerformanceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR, sizeof(VkAcquireProfilingLockInfoKHR) },
{VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR, sizeof(VkPerformanceQuerySubmitInfoKHR) },
{VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT, sizeof(VkHeadlessSurfaceCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV, sizeof(VkPhysicalDeviceCoverageReductionModeFeaturesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV, sizeof(VkPipelineCoverageReductionStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV, sizeof(VkFramebufferMixedSamplesCombinationNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL, sizeof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) },
{VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL, sizeof(VkInitializePerformanceApiInfoINTEL) },
{VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL, sizeof(VkQueryPoolPerformanceQueryCreateInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL, sizeof(VkPerformanceMarkerInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL, sizeof(VkPerformanceStreamMarkerInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL, sizeof(VkPerformanceOverrideInfoINTEL) },
{VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL, sizeof(VkPerformanceConfigurationAcquireInfoINTEL) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR, sizeof(VkPhysicalDeviceShaderClockFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT, sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV, sizeof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV, sizeof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT, sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) },
{VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT, sizeof(VkAttachmentReferenceStencilLayout) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT, sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) },
{VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT, sizeof(VkAttachmentDescriptionStencilLayout) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR, sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR, sizeof(VkPipelineInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR, sizeof(VkPipelineExecutablePropertiesKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR, sizeof(VkPipelineExecutableInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR, sizeof(VkPipelineExecutableStatisticKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR, sizeof(VkPipelineExecutableInternalRepresentationKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES, sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT, sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES, sizeof(VkPhysicalDeviceTexelBufferAlignmentProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES, sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES, sizeof(VkPhysicalDeviceSubgroupSizeControlProperties) },
{VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO, sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo) },
{VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI, sizeof(VkSubpassShadingPipelineCreateInfoHUAWEI) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI, sizeof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI, sizeof(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI) },
{VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO, sizeof(VkMemoryOpaqueCaptureAddressAllocateInfo) },
{VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO, sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT, sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT, sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationLineStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES, sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES, sizeof(VkPhysicalDeviceVulkan11Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES, sizeof(VkPhysicalDeviceVulkan11Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES, sizeof(VkPhysicalDeviceVulkan12Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES, sizeof(VkPhysicalDeviceVulkan12Properties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES, sizeof(VkPhysicalDeviceVulkan13Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES, sizeof(VkPhysicalDeviceVulkan13Properties) },
{VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD, sizeof(VkPipelineCompilerControlCreateInfoAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD, sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, sizeof(VkPhysicalDeviceToolProperties) },
{VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT, sizeof(VkSamplerCustomBorderColorCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT, sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT, sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT) },
{VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT, sizeof(VkSamplerBorderColorComponentMappingCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT, sizeof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR, sizeof(VkAccelerationStructureGeometryTrianglesDataKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR, sizeof(VkAccelerationStructureGeometryAabbsDataKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR, sizeof(VkAccelerationStructureGeometryInstancesDataKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR, sizeof(VkAccelerationStructureGeometryKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR, sizeof(VkAccelerationStructureBuildGeometryInfoKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR, sizeof(VkAccelerationStructureCreateInfoKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR, sizeof(VkAccelerationStructureDeviceAddressInfoKHR) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR, sizeof(VkAccelerationStructureVersionInfoKHR) },
{VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR, sizeof(VkCopyAccelerationStructureInfoKHR) },
{VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR, sizeof(VkCopyAccelerationStructureToMemoryInfoKHR) },
{VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR, sizeof(VkCopyMemoryToAccelerationStructureInfoKHR) },
{VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR, sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR, sizeof(VkPipelineLibraryCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT, sizeof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM, sizeof(VkRenderPassTransformBeginInfoQCOM) },
{VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM, sizeof(VkCopyCommandTransformInfoQCOM) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM, sizeof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV, sizeof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV) },
{VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV, sizeof(VkDeviceDiagnosticsConfigCreateInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES, sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR, sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT, sizeof(VkPhysicalDeviceRobustness2FeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT, sizeof(VkPhysicalDeviceRobustness2PropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES, sizeof(VkPhysicalDeviceImageRobustnessFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR, sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT, sizeof(VkPhysicalDevice4444FormatsFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI, sizeof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI, sizeof(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI) },
{VK_STRUCTURE_TYPE_BUFFER_COPY_2, sizeof(VkBufferCopy2) },
{VK_STRUCTURE_TYPE_IMAGE_COPY_2, sizeof(VkImageCopy2) },
{VK_STRUCTURE_TYPE_IMAGE_BLIT_2, sizeof(VkImageBlit2) },
{VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2, sizeof(VkBufferImageCopy2) },
{VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2, sizeof(VkImageResolve2) },
{VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2, sizeof(VkCopyBufferInfo2) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2, sizeof(VkCopyImageInfo2) },
{VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2, sizeof(VkBlitImageInfo2) },
{VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2, sizeof(VkCopyBufferToImageInfo2) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2, sizeof(VkCopyImageToBufferInfo2) },
{VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2, sizeof(VkResolveImageInfo2) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) },
{VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR, sizeof(VkFragmentShadingRateAttachmentInfoKHR) },
{VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR, sizeof(VkPipelineFragmentShadingRateStateCreateInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR, sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR, sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR, sizeof(VkPhysicalDeviceFragmentShadingRateKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES, sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV, sizeof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV, sizeof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV) },
{VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV, sizeof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR, sizeof(VkAccelerationStructureBuildSizesInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT, sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT, sizeof(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT, sizeof(VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT, sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT) },
{VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT, sizeof(VkMutableDescriptorTypeCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthClipControlFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT, sizeof(VkPipelineViewportDepthClipControlCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT, sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV, sizeof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV) },
{VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT, sizeof(VkVertexInputBindingDescription2EXT) },
{VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT, sizeof(VkVertexInputAttributeDescription2EXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT, sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT, sizeof(VkPipelineColorWriteCreateInfoEXT) },
{VK_STRUCTURE_TYPE_MEMORY_BARRIER_2, sizeof(VkMemoryBarrier2) },
{VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2, sizeof(VkImageMemoryBarrier2) },
{VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2, sizeof(VkBufferMemoryBarrier2) },
{VK_STRUCTURE_TYPE_DEPENDENCY_INFO, sizeof(VkDependencyInfo) },
{VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO, sizeof(VkSemaphoreSubmitInfo) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO, sizeof(VkCommandBufferSubmitInfo) },
{VK_STRUCTURE_TYPE_SUBMIT_INFO_2, sizeof(VkSubmitInfo2) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV, sizeof(VkQueueFamilyCheckpointProperties2NV) },
{VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV, sizeof(VkCheckpointData2NV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES, sizeof(VkPhysicalDeviceSynchronization2Features) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT, sizeof(VkPhysicalDeviceHostImageCopyFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT, sizeof(VkPhysicalDeviceHostImageCopyPropertiesEXT) },
{VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT, sizeof(VkMemoryToImageCopyEXT) },
{VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT, sizeof(VkImageToMemoryCopyEXT) },
{VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT, sizeof(VkCopyMemoryToImageInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT, sizeof(VkCopyImageToMemoryInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT, sizeof(VkCopyImageToImageInfoEXT) },
{VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT, sizeof(VkHostImageLayoutTransitionInfoEXT) },
{VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT, sizeof(VkSubresourceHostMemcpySizeEXT) },
{VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT, sizeof(VkHostImageCopyDevicePerformanceQueryEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT, sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT, sizeof(VkPhysicalDeviceLegacyDitheringFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT, sizeof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT) },
{VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT, sizeof(VkSubpassResolvePerformanceQueryEXT) },
{VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT, sizeof(VkMultisampledRenderToSingleSampledInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT, sizeof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR, sizeof(VkQueueFamilyVideoPropertiesKHR) },
{VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR, sizeof(VkQueueFamilyQueryResultStatusPropertiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR, sizeof(VkVideoProfileListInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR, sizeof(VkPhysicalDeviceVideoFormatInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR, sizeof(VkVideoFormatPropertiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR, sizeof(VkVideoProfileInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR, sizeof(VkVideoCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR, sizeof(VkVideoSessionMemoryRequirementsKHR) },
{VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR, sizeof(VkBindVideoSessionMemoryInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR, sizeof(VkVideoPictureResourceInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR, sizeof(VkVideoReferenceSlotInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR, sizeof(VkVideoDecodeCapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR, sizeof(VkVideoDecodeUsageInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR, sizeof(VkVideoDecodeInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR, sizeof(VkVideoDecodeH264ProfileInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR, sizeof(VkVideoDecodeH264CapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR, sizeof(VkVideoDecodeH264SessionParametersAddInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR, sizeof(VkVideoDecodeH264SessionParametersCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR, sizeof(VkVideoDecodeH264PictureInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR, sizeof(VkVideoDecodeH264DpbSlotInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR, sizeof(VkVideoDecodeH265ProfileInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR, sizeof(VkVideoDecodeH265CapabilitiesKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR, sizeof(VkVideoDecodeH265SessionParametersAddInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR, sizeof(VkVideoDecodeH265SessionParametersCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR, sizeof(VkVideoDecodeH265PictureInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR, sizeof(VkVideoDecodeH265DpbSlotInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR, sizeof(VkVideoSessionCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR, sizeof(VkVideoSessionParametersCreateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR, sizeof(VkVideoSessionParametersUpdateInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR, sizeof(VkVideoBeginCodingInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR, sizeof(VkVideoEndCodingInfoKHR) },
{VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR, sizeof(VkVideoCodingControlInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV, sizeof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV, sizeof(VkCommandBufferInheritanceViewportScissorInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT, sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT, sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT, sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT, sizeof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT) },
{VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX, sizeof(VkCuModuleCreateInfoNVX) },
{VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX, sizeof(VkCuFunctionCreateInfoNVX) },
{VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX, sizeof(VkCuLaunchInfoNVX) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT, sizeof(VkPhysicalDeviceDescriptorBufferFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDescriptorBufferPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT, sizeof(VkDescriptorAddressInfoEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT, sizeof(VkDescriptorBufferBindingInfoEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT, sizeof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT, sizeof(VkDescriptorGetInfoEXT) },
{VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkBufferCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkImageCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkImageViewCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkSamplerCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT, sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT) },
{VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT, sizeof(VkOpaqueCaptureDescriptorDataCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES, sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES, sizeof(VkPhysicalDeviceShaderIntegerDotProductProperties) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT, sizeof(VkPhysicalDeviceDrmPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR, sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR, sizeof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV, sizeof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV, sizeof(VkAccelerationStructureGeometryMotionTrianglesDataNV) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV, sizeof(VkAccelerationStructureMotionInfoNV) },
{VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV, sizeof(VkMemoryGetRemoteAddressInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT, sizeof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT) },
{VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3, sizeof(VkFormatProperties3) },
{VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT, sizeof(VkDrmFormatModifierPropertiesList2EXT) },
{VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO, sizeof(VkPipelineRenderingCreateInfo) },
{VK_STRUCTURE_TYPE_RENDERING_INFO, sizeof(VkRenderingInfo) },
{VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO, sizeof(VkRenderingAttachmentInfo) },
{VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR, sizeof(VkRenderingFragmentShadingRateAttachmentInfoKHR) },
{VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT, sizeof(VkRenderingFragmentDensityMapAttachmentInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES, sizeof(VkPhysicalDeviceDynamicRenderingFeatures) },
{VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO, sizeof(VkCommandBufferInheritanceRenderingInfo) },
{VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD, sizeof(VkAttachmentSampleCountInfoAMD) },
{VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX, sizeof(VkMultiviewPerViewAttributesInfoNVX) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT, sizeof(VkPhysicalDeviceImageViewMinLodFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT, sizeof(VkImageViewMinLodCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT, sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV, sizeof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT, sizeof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT, sizeof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT) },
{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT, sizeof(VkGraphicsPipelineLibraryCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE, sizeof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE, sizeof(VkDescriptorSetBindingReferenceVALVE) },
{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE, sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT, sizeof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT, sizeof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, sizeof(VkShaderModuleIdentifierEXT) },
{VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT, sizeof(VkImageCompressionControlEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT, sizeof(VkPhysicalDeviceImageCompressionControlFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT, sizeof(VkImageCompressionPropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT, sizeof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR, sizeof(VkImageSubresource2KHR) },
{VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, sizeof(VkSubresourceLayout2KHR) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT, sizeof(VkRenderPassCreationControlEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT, sizeof(VkRenderPassCreationFeedbackCreateInfoEXT) },
{VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT, sizeof(VkRenderPassSubpassFeedbackCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT, sizeof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT, sizeof(VkMicromapBuildInfoEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT, sizeof(VkMicromapCreateInfoEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT, sizeof(VkMicromapVersionInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT, sizeof(VkCopyMicromapInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT, sizeof(VkCopyMicromapToMemoryInfoEXT) },
{VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT, sizeof(VkCopyMemoryToMicromapInfoEXT) },
{VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT, sizeof(VkMicromapBuildSizesInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT, sizeof(VkPhysicalDeviceOpacityMicromapFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT, sizeof(VkPhysicalDeviceOpacityMicromapPropertiesEXT) },
{VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT, sizeof(VkAccelerationStructureTrianglesOpacityMicromapEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT, sizeof(VkPipelinePropertiesIdentifierEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT, sizeof(VkPhysicalDevicePipelinePropertiesFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD, sizeof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD) },
{VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT, sizeof(VkExternalMemoryAcquireUnmodifiedEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT, sizeof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT, sizeof(VkPhysicalDevicePipelineRobustnessFeaturesEXT) },
{VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT, sizeof(VkPipelineRobustnessCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT, sizeof(VkPhysicalDevicePipelineRobustnessPropertiesEXT) },
{VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM, sizeof(VkImageViewSampleWeightCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM, sizeof(VkPhysicalDeviceImageProcessingFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM, sizeof(VkPhysicalDeviceImageProcessingPropertiesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM, sizeof(VkPhysicalDeviceTilePropertiesFeaturesQCOM) },
{VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, sizeof(VkTilePropertiesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC, sizeof(VkPhysicalDeviceAmigoProfilingFeaturesSEC) },
{VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC, sizeof(VkAmigoProfilingSubmitInfoSEC) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT, sizeof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT, sizeof(VkPhysicalDeviceAddressBindingReportFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT, sizeof(VkDeviceAddressBindingCallbackDataEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV, sizeof(VkPhysicalDeviceOpticalFlowFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV, sizeof(VkPhysicalDeviceOpticalFlowPropertiesNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV, sizeof(VkOpticalFlowImageFormatInfoNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV, sizeof(VkOpticalFlowImageFormatPropertiesNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV, sizeof(VkOpticalFlowSessionCreateInfoNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV, sizeof(VkOpticalFlowSessionCreatePrivateDataInfoNV) },
{VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV, sizeof(VkOpticalFlowExecuteInfoNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT, sizeof(VkPhysicalDeviceFaultFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT, sizeof(VkDeviceFaultCountsEXT) },
{VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT, sizeof(VkDeviceFaultInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT, sizeof(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT) },
{VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT, sizeof(VkDepthBiasInfoEXT) },
{VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT, sizeof(VkDepthBiasRepresentationInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM, sizeof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM, sizeof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM) },
{VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT, sizeof(VkFrameBoundaryEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT, sizeof(VkPhysicalDeviceFrameBoundaryFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT, sizeof(VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT) },
{VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT, sizeof(VkSurfacePresentModeEXT) },
{VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT, sizeof(VkSurfacePresentScalingCapabilitiesEXT) },
{VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT, sizeof(VkSurfacePresentModeCompatibilityEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT, sizeof(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT, sizeof(VkSwapchainPresentFenceInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT, sizeof(VkSwapchainPresentModesCreateInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT, sizeof(VkSwapchainPresentModeInfoEXT) },
{VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT, sizeof(VkSwapchainPresentScalingCreateInfoEXT) },
{VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT, sizeof(VkReleaseSwapchainImagesInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT, sizeof(VkPhysicalDeviceDepthBiasControlFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV, sizeof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV, sizeof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV) },
{VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG, sizeof(VkDirectDriverLoadingInfoLUNARG) },
{VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG, sizeof(VkDirectDriverLoadingListLUNARG) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM, sizeof(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR, sizeof(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR) },
{VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR, sizeof(VkDeviceImageSubresourceInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM, sizeof(VkPhysicalDeviceShaderCorePropertiesARM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM, sizeof(VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM) },
{VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM, sizeof(VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM) },
{VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV, sizeof(VkQueryLowLatencySupportNV) },
{VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR, sizeof(VkMemoryMapInfoKHR) },
{VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR, sizeof(VkMemoryUnmapInfoKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderObjectFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT, sizeof(VkPhysicalDeviceShaderObjectPropertiesEXT) },
{VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT, sizeof(VkShaderCreateInfoEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT, sizeof(VkPhysicalDeviceShaderTileImageFeaturesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT, sizeof(VkPhysicalDeviceShaderTileImagePropertiesEXT) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR, sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesKHR) },
{VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR, sizeof(VkCooperativeMatrixPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR, sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM, sizeof(VkPhysicalDeviceCubicClampFeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM, sizeof(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM) },
{VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM, sizeof(VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM, sizeof(VkPhysicalDeviceCubicWeightsFeaturesQCOM) },
{VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM, sizeof(VkSamplerCubicWeightsCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM, sizeof(VkBlitImageCubicWeightsInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM, sizeof(VkPhysicalDeviceImageProcessing2FeaturesQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM, sizeof(VkPhysicalDeviceImageProcessing2PropertiesQCOM) },
{VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM, sizeof(VkSamplerBlockMatchWindowCreateInfoQCOM) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV, sizeof(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV) },
{VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT, sizeof(VkPhysicalDeviceLayeredDriverPropertiesMSFT) },
};

void* memdup(const void* mem, size_t size) { 
   void* out = malloc(size);

   if(out != NULL)
       memcpy(out, mem, size);

   return out;
}


void* copyVkStruct (const void* data){
    auto curr=data;
    while (true){
        if (curr==NULL){
        return NULL;
        }
        auto structure_type=((StreamStructure*)curr)->sType;
        if (!structure_type_to_size.contains(structure_type)){
            curr=((StreamStructure*)curr)->pNext;
            continue;
        }
        
        auto struct_size=structure_type_to_size[structure_type];
        auto result=memdup(curr, struct_size);
        
        return result;
    }
    
}


    void serialize_struct(stream::VkBaseOutStructure::Builder& builder, VkBaseOutStructure member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            if ((member.pNext)==NULL){
                builder.initPNext(0);
            return; }
        auto proto_arr=builder.initPNext(1);
        for(int kpmyioI=0; kpmyioI < 1; kpmyioI++){
            [&](){
            auto temp=proto_arr[kpmyioI];
            return serialize_struct(temp, ((member.pNext)[kpmyioI]));
            }();
        }
        }();
}

    VkBaseOutStructure deserialize_struct(stream::VkBaseOutStructure::Reader reader){
        auto result=VkBaseOutStructure();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            if (!reader.getPNext().size()==0){
                (result.pNext)=NULL;
            return; }{native_concat()}=(VkBaseOutStructure*)malloc(1*sizeof(VkBaseOutStructure));
        auto proto_arr=reader.getPNext(1);
        for(int kpmyioI=0; kpmyioI < 1; kpmyioI++){
            [&](){
            auto temp=proto_arr[kpmyioI];
            ((result.pNext)[kpmyioI])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBaseOutStructure member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBaseOutStructure member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBaseInStructure::Builder& builder, VkBaseInStructure member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            if ((member.pNext)==NULL){
                builder.initPNext(0);
            return; }
        auto proto_arr=builder.initPNext(1);
        for(int zewiUOi=0; zewiUOi < 1; zewiUOi++){
            [&](){
            auto temp=proto_arr[zewiUOi];
            return serialize_struct(temp, ((member.pNext)[zewiUOi]));
            }();
        }
        }();
}

    VkBaseInStructure deserialize_struct(stream::VkBaseInStructure::Reader reader){
        auto result=VkBaseInStructure();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ struct VkBaseInStructure* temp_dxnEHeC[&](){
            if (!reader.getPNext().size()==0){
                (result.pNext)=NULL;
            return; }{native_concat()}=(VkBaseInStructure*)malloc(1*sizeof(VkBaseInStructure));
        auto proto_arr=reader.getPNext(1);
        for(int JabJMHC=0; JabJMHC < 1; JabJMHC++){
            [&](){
            auto temp=proto_arr[JabJMHC];
            ((result.pNext)[JabJMHC])=deserialize_struct(temp);
            }();
        }
        }();(result.pNext)=temp_dxnEHeC;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBaseInStructure member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBaseInStructure member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOffset2D::Builder& builder, VkOffset2D member){
        
    
[&](){return builder.setX((member.x));}();
[&](){return builder.setY((member.y));}();
}

    VkOffset2D deserialize_struct(stream::VkOffset2D::Reader reader){
        auto result=VkOffset2D();
    
[&](){(result.x)=reader.getX();}();
[&](){(result.y)=reader.getY();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOffset2D member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOffset2D member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOffset3D::Builder& builder, VkOffset3D member){
        
    
[&](){return builder.setX((member.x));}();
[&](){return builder.setY((member.y));}();
[&](){return builder.setZ((member.z));}();
}

    VkOffset3D deserialize_struct(stream::VkOffset3D::Reader reader){
        auto result=VkOffset3D();
    
[&](){(result.x)=reader.getX();}();
[&](){(result.y)=reader.getY();}();
[&](){(result.z)=reader.getZ();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOffset3D member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOffset3D member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExtent2D::Builder& builder, VkExtent2D member){
        
    
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
}

    VkExtent2D deserialize_struct(stream::VkExtent2D::Reader reader){
        auto result=VkExtent2D();
    
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExtent2D member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExtent2D member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExtent3D::Builder& builder, VkExtent3D member){
        
    
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
[&](){return builder.setDepth((member.depth));}();
}

    VkExtent3D deserialize_struct(stream::VkExtent3D::Reader reader){
        auto result=VkExtent3D();
    
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
[&](){(result.depth)=reader.getDepth();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExtent3D member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExtent3D member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkViewport::Builder& builder, VkViewport member){
        
    
[&](){return builder.setX((member.x));}();
[&](){return builder.setY((member.y));}();
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
[&](){return builder.setMinDepth((member.minDepth));}();
[&](){return builder.setMaxDepth((member.maxDepth));}();
}

    VkViewport deserialize_struct(stream::VkViewport::Reader reader){
        auto result=VkViewport();
    
[&](){(result.x)=reader.getX();}();
[&](){(result.y)=reader.getY();}();
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
[&](){(result.minDepth)=reader.getMinDepth();}();
[&](){(result.maxDepth)=reader.getMaxDepth();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkViewport member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkViewport member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRect2D::Builder& builder, VkRect2D member){
        
    
[&](){
            auto temp=builder.initOffset(offset);
            return serialize_struct(temp, (member.offset));
            }();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
}

    VkRect2D deserialize_struct(stream::VkRect2D::Reader reader){
        auto result=VkRect2D();
    
[&](){
            auto temp=reader.getOffset();
            (result.offset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRect2D member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRect2D member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkClearRect::Builder& builder, VkClearRect member){
        
    
[&](){
            auto temp=builder.initRect(rect);
            return serialize_struct(temp, (member.rect));
            }();
[&](){return builder.setBaseArrayLayer((member.baseArrayLayer));}();
[&](){return builder.setLayerCount((member.layerCount));}();
}

    VkClearRect deserialize_struct(stream::VkClearRect::Reader reader){
        auto result=VkClearRect();
    
[&](){
            auto temp=reader.getRect();
            (result.rect)=deserialize_struct(temp);
            }();
[&](){(result.baseArrayLayer)=reader.getBaseArrayLayer();}();
[&](){(result.layerCount)=reader.getLayerCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkClearRect member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkClearRect member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkComponentMapping::Builder& builder, VkComponentMapping member){
        
    
[&](){[&](){[&](){return builder.setR((member.r));}();}();}();
[&](){[&](){[&](){return builder.setG((member.g));}();}();}();
[&](){[&](){[&](){return builder.setB((member.b));}();}();}();
[&](){[&](){[&](){return builder.setA((member.a));}();}();}();
}

    VkComponentMapping deserialize_struct(stream::VkComponentMapping::Reader reader){
        auto result=VkComponentMapping();
    
[&](){[&](){[&](){(result.r)=reader.getR();}();}();}();
[&](){[&](){[&](){(result.g)=reader.getG();}();}();}();
[&](){[&](){[&](){(result.b)=reader.getB();}();}();}();
[&](){[&](){[&](){(result.a)=reader.getA();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkComponentMapping member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkComponentMapping member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceProperties::Builder& builder, VkPhysicalDeviceProperties member){
        
    
[&](){return builder.setApiVersion((member.apiVersion));}();
[&](){return builder.setDriverVersion((member.driverVersion));}();
[&](){return builder.setVendorID((member.vendorID));}();
[&](){return builder.setDeviceID((member.deviceID));}();
[&](){[&](){[&](){return builder.setDeviceType((member.deviceType));}();}();}();
[&](){
        auto proto_arr=builder.initDeviceName(VK_MAX_PHYSICAL_DEVICE_NAME_SIZE);
        for(int XalWwmc=0; XalWwmc < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; XalWwmc++){
            [&](){return proto_arr.set(XalWwmc,((member.deviceName)[XalWwmc]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initPipelineCacheUUID(VK_UUID_SIZE);
        for(int pKnzMjr=0; pKnzMjr < VK_UUID_SIZE; pKnzMjr++){
            [&](){return proto_arr.set(pKnzMjr,((member.pipelineCacheUUID)[pKnzMjr]));}();
        }
        }();
[&](){
            auto temp=builder.initLimits(limits);
            return serialize_struct(temp, (member.limits));
            }();
[&](){
            auto temp=builder.initSparseProperties(sparseProperties);
            return serialize_struct(temp, (member.sparseProperties));
            }();
}

    VkPhysicalDeviceProperties deserialize_struct(stream::VkPhysicalDeviceProperties::Reader reader){
        auto result=VkPhysicalDeviceProperties();
    
[&](){(result.apiVersion)=reader.getApiVersion();}();
[&](){(result.driverVersion)=reader.getDriverVersion();}();
[&](){(result.vendorID)=reader.getVendorID();}();
[&](){(result.deviceID)=reader.getDeviceID();}();
[&](){[&](){[&](){(result.deviceType)=reader.getDeviceType();}();}();}();
[&](){
        auto proto_arr=reader.getDeviceName(VK_MAX_PHYSICAL_DEVICE_NAME_SIZE);
        for(int XalWwmc=0; XalWwmc < VK_MAX_PHYSICAL_DEVICE_NAME_SIZE; XalWwmc++){
            [&](){((result.deviceName)[XalWwmc])=proto_arr[XalWwmc];}();
        }
        }();
[&](){
        auto proto_arr=reader.getPipelineCacheUUID(VK_UUID_SIZE);
        for(int pKnzMjr=0; pKnzMjr < VK_UUID_SIZE; pKnzMjr++){
            [&](){((result.pipelineCacheUUID)[pKnzMjr])=proto_arr[pKnzMjr];}();
        }
        }();
[&](){
            auto temp=reader.getLimits();
            (result.limits)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSparseProperties();
            (result.sparseProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExtensionProperties::Builder& builder, VkExtensionProperties member){
        
    
[&](){
        auto proto_arr=builder.initExtensionName(VK_MAX_EXTENSION_NAME_SIZE);
        for(int XIWGMoc=0; XIWGMoc < VK_MAX_EXTENSION_NAME_SIZE; XIWGMoc++){
            [&](){return proto_arr.set(XIWGMoc,((member.extensionName)[XIWGMoc]));}();
        }
        }();
[&](){return builder.setSpecVersion((member.specVersion));}();
}

    VkExtensionProperties deserialize_struct(stream::VkExtensionProperties::Reader reader){
        auto result=VkExtensionProperties();
    
[&](){
        auto proto_arr=reader.getExtensionName(VK_MAX_EXTENSION_NAME_SIZE);
        for(int XIWGMoc=0; XIWGMoc < VK_MAX_EXTENSION_NAME_SIZE; XIWGMoc++){
            [&](){((result.extensionName)[XIWGMoc])=proto_arr[XIWGMoc];}();
        }
        }();
[&](){(result.specVersion)=reader.getSpecVersion();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExtensionProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExtensionProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkLayerProperties::Builder& builder, VkLayerProperties member){
        
    
[&](){
        auto proto_arr=builder.initLayerName(VK_MAX_EXTENSION_NAME_SIZE);
        for(int IKkuigH=0; IKkuigH < VK_MAX_EXTENSION_NAME_SIZE; IKkuigH++){
            [&](){return proto_arr.set(IKkuigH,((member.layerName)[IKkuigH]));}();
        }
        }();
[&](){return builder.setSpecVersion((member.specVersion));}();
[&](){return builder.setImplementationVersion((member.implementationVersion));}();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
}

    VkLayerProperties deserialize_struct(stream::VkLayerProperties::Reader reader){
        auto result=VkLayerProperties();
    
[&](){
        auto proto_arr=reader.getLayerName(VK_MAX_EXTENSION_NAME_SIZE);
        for(int IKkuigH=0; IKkuigH < VK_MAX_EXTENSION_NAME_SIZE; IKkuigH++){
            [&](){((result.layerName)[IKkuigH])=proto_arr[IKkuigH];}();
        }
        }();
[&](){(result.specVersion)=reader.getSpecVersion();}();
[&](){(result.implementationVersion)=reader.getImplementationVersion();}();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkLayerProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkLayerProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkApplicationInfo::Builder& builder, VkApplicationInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pApplicationName)==NULL){
                builder.initPApplicationName(0);
            return; }
        auto proto_arr=builder.initPApplicationName(strlen((member.pApplicationName))+1);
        for(int ljeveAN=0; ljeveAN < strlen((member.pApplicationName))+1; ljeveAN++){
            [&](){return proto_arr.set(ljeveAN,((member.pApplicationName)[ljeveAN]));}();
        }
        }();
[&](){return builder.setApplicationVersion((member.applicationVersion));}();
[&](){
            if ((member.pEngineName)==NULL){
                builder.initPEngineName(0);
            return; }
        auto proto_arr=builder.initPEngineName(strlen((member.pEngineName))+1);
        for(int VZCarDF=0; VZCarDF < strlen((member.pEngineName))+1; VZCarDF++){
            [&](){return proto_arr.set(VZCarDF,((member.pEngineName)[VZCarDF]));}();
        }
        }();
[&](){return builder.setEngineVersion((member.engineVersion));}();
[&](){return builder.setApiVersion((member.apiVersion));}();
}

    VkApplicationInfo deserialize_struct(stream::VkApplicationInfo::Reader reader){
        auto result=VkApplicationInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ char* temp_ITGZlxN[&](){
            if (!reader.getPApplicationName().size()==0){
                (result.pApplicationName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPApplicationName().size();*sizeof(char));
        auto proto_arr=reader.getPApplicationName(reader.getPApplicationName().size(););
        for(int zWUmIFj=0; zWUmIFj < reader.getPApplicationName().size();; zWUmIFj++){
            [&](){((result.pApplicationName)[zWUmIFj])=proto_arr[zWUmIFj];}();
        }
        }();(result.pApplicationName)=temp_ITGZlxN;}();
[&](){(result.applicationVersion)=reader.getApplicationVersion();}();
[&](){ char* temp_QLKspfD[&](){
            if (!reader.getPEngineName().size()==0){
                (result.pEngineName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPEngineName().size();*sizeof(char));
        auto proto_arr=reader.getPEngineName(reader.getPEngineName().size(););
        for(int nQADTdz=0; nQADTdz < reader.getPEngineName().size();; nQADTdz++){
            [&](){((result.pEngineName)[nQADTdz])=proto_arr[nQADTdz];}();
        }
        }();(result.pEngineName)=temp_QLKspfD;}();
[&](){(result.engineVersion)=reader.getEngineVersion();}();
[&](){(result.apiVersion)=reader.getApiVersion();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkApplicationInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkApplicationInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAllocationCallbacks::Builder& builder, VkAllocationCallbacks member){
        
    
[&](){
            auto temp=builder.initPUserData(pUserData);
            return serialize_struct(temp, (member.pUserData));
            }();
[&](){
            auto temp=builder.initPfnAllocation(pfnAllocation);
            return serialize_funcpointer(temp, (member.pfnAllocation));
            }();
[&](){
            auto temp=builder.initPfnReallocation(pfnReallocation);
            return serialize_funcpointer(temp, (member.pfnReallocation));
            }();
[&](){
            auto temp=builder.initPfnFree(pfnFree);
            return serialize_funcpointer(temp, (member.pfnFree));
            }();
[&](){
            auto temp=builder.initPfnInternalAllocation(pfnInternalAllocation);
            return serialize_funcpointer(temp, (member.pfnInternalAllocation));
            }();
[&](){
            auto temp=builder.initPfnInternalFree(pfnInternalFree);
            return serialize_funcpointer(temp, (member.pfnInternalFree));
            }();
}

    VkAllocationCallbacks deserialize_struct(stream::VkAllocationCallbacks::Reader reader){
        auto result=VkAllocationCallbacks();
    
[&](){
            auto temp=reader.getPUserData();
            (result.pUserData)=deserialize_struct(temp);
            }();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnAllocation();
            (result.pfnAllocation)=deserialize_funcpointer(temp);
            #endif
}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnReallocation();
            (result.pfnReallocation)=deserialize_funcpointer(temp);
            #endif
}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnFree();
            (result.pfnFree)=deserialize_funcpointer(temp);
            #endif
}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnInternalAllocation();
            (result.pfnInternalAllocation)=deserialize_funcpointer(temp);
            #endif
}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnInternalFree();
            (result.pfnInternalFree)=deserialize_funcpointer(temp);
            #endif
}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAllocationCallbacks member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
builder.setPFN_vkAllocationFunction((uintptr_t)(member.pfnAllocation));
builder.setPFN_vkReallocationFunction((uintptr_t)(member.pfnReallocation));
builder.setPFN_vkFreeFunction((uintptr_t)(member.pfnFree));
builder.setPFN_vkInternalAllocationNotification((uintptr_t)(member.pfnInternalAllocation));
builder.setPFN_vkInternalFreeNotification((uintptr_t)(member.pfnInternalFree));
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAllocationCallbacks member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();
result.pfnAllocation=reader.getPFN_vkAllocationFunction();
result.pfnReallocation=reader.getPFN_vkReallocationFunction();
result.pfnFree=reader.getPFN_vkFreeFunction();
result.pfnInternalAllocation=reader.getPFN_vkInternalAllocationNotification();
result.pfnInternalFree=reader.getPFN_vkInternalFreeNotification();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceQueueCreateInfo::Builder& builder, VkDeviceQueueCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setQueueFamilyIndex((member.queueFamilyIndex));}();
[&](){return builder.setQueueCount((member.queueCount));}();
[&](){
            if ((member.pQueuePriorities)==NULL){
                builder.initPQueuePriorities(0);
            return; }
        auto proto_arr=builder.initPQueuePriorities(member.queueCount);
        for(int WPvLdwr=0; WPvLdwr < member.queueCount; WPvLdwr++){
            [&](){return proto_arr.set(WPvLdwr,((member.pQueuePriorities)[WPvLdwr]));}();
        }
        }();
}

    VkDeviceQueueCreateInfo deserialize_struct(stream::VkDeviceQueueCreateInfo::Reader reader){
        auto result=VkDeviceQueueCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.queueFamilyIndex)=reader.getQueueFamilyIndex();}();
[&](){(result.queueCount)=reader.getQueueCount();}();
[&](){ float* temp_mzKviIi[&](){
            if (!reader.getPQueuePriorities().size()==0){
                (result.pQueuePriorities)=NULL;
            return; }{native_concat()}=(float*)malloc(result.queueCount*sizeof(float));
        auto proto_arr=reader.getPQueuePriorities(result.queueCount);
        for(int kxeXVtw=0; kxeXVtw < result.queueCount; kxeXVtw++){
            [&](){((result.pQueuePriorities)[kxeXVtw])=proto_arr[kxeXVtw];}();
        }
        }();(result.pQueuePriorities)=temp_mzKviIi;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceQueueCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceQueueCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceCreateInfo::Builder& builder, VkDeviceCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setQueueCreateInfoCount((member.queueCreateInfoCount));}();
[&](){
            if ((member.pQueueCreateInfos)==NULL){
                builder.initPQueueCreateInfos(0);
            return; }
        auto proto_arr=builder.initPQueueCreateInfos(member.queueCreateInfoCount);
        for(int YssfcdP=0; YssfcdP < member.queueCreateInfoCount; YssfcdP++){
            [&](){
            auto temp=proto_arr[YssfcdP];
            return serialize_struct(temp, ((member.pQueueCreateInfos)[YssfcdP]));
            }();
        }
        }();
[&](){return builder.setEnabledLayerCount((member.enabledLayerCount));}();
[&](){
            if ((member.ppEnabledLayerNames)==NULL){
                builder.initPpEnabledLayerNames(0);
            return; }
        auto proto_arr=builder.initPpEnabledLayerNames(member.enabledLayerCount);
        for(int pbCJWPr=0; pbCJWPr < member.enabledLayerCount; pbCJWPr++){
            [&](){
            if (((member.ppEnabledLayerNames)[pbCJWPr])==NULL){
                proto_arr.init(pbCJWPr,0);
            return; }
        auto proto_arr=proto_arr[pbCJWPr];
        for(int aJorhVj=0; aJorhVj < strlen(((member.ppEnabledLayerNames)[pbCJWPr]))+1; aJorhVj++){
            [&](){return proto_arr.set(aJorhVj,(((member.ppEnabledLayerNames)[pbCJWPr])[aJorhVj]));}();
        }
        }();
        }
        }();
[&](){return builder.setEnabledExtensionCount((member.enabledExtensionCount));}();
[&](){
            if ((member.ppEnabledExtensionNames)==NULL){
                builder.initPpEnabledExtensionNames(0);
            return; }
        auto proto_arr=builder.initPpEnabledExtensionNames(member.enabledExtensionCount);
        for(int JSZSZLT=0; JSZSZLT < member.enabledExtensionCount; JSZSZLT++){
            [&](){
            if (((member.ppEnabledExtensionNames)[JSZSZLT])==NULL){
                proto_arr.init(JSZSZLT,0);
            return; }
        auto proto_arr=proto_arr[JSZSZLT];
        for(int IuPNAip=0; IuPNAip < strlen(((member.ppEnabledExtensionNames)[JSZSZLT]))+1; IuPNAip++){
            [&](){return proto_arr.set(IuPNAip,(((member.ppEnabledExtensionNames)[JSZSZLT])[IuPNAip]));}();
        }
        }();
        }
        }();
[&](){
            if ((member.pEnabledFeatures)==NULL){
                builder.initPEnabledFeatures(0);
            return; }
        auto proto_arr=builder.initPEnabledFeatures(1);
        for(int cHCoRqz=0; cHCoRqz < 1; cHCoRqz++){
            [&](){
            auto temp=proto_arr[cHCoRqz];
            return serialize_struct(temp, ((member.pEnabledFeatures)[cHCoRqz]));
            }();
        }
        }();
}

    VkDeviceCreateInfo deserialize_struct(stream::VkDeviceCreateInfo::Reader reader){
        auto result=VkDeviceCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.queueCreateInfoCount)=reader.getQueueCreateInfoCount();}();
[&](){ VkDeviceQueueCreateInfo* temp_JwCqEvb[&](){
            if (!reader.getPQueueCreateInfos().size()==0){
                (result.pQueueCreateInfos)=NULL;
            return; }{native_concat()}=(VkDeviceQueueCreateInfo*)malloc(result.queueCreateInfoCount*sizeof(VkDeviceQueueCreateInfo));
        auto proto_arr=reader.getPQueueCreateInfos(result.queueCreateInfoCount);
        for(int xSivxym=0; xSivxym < result.queueCreateInfoCount; xSivxym++){
            [&](){
            auto temp=proto_arr[xSivxym];
            ((result.pQueueCreateInfos)[xSivxym])=deserialize_struct(temp);
            }();
        }
        }();(result.pQueueCreateInfos)=temp_JwCqEvb;}();
[&](){(result.enabledLayerCount)=reader.getEnabledLayerCount();}();
[&](){ char* * temp_GHyKyGS[&](){
            if (!reader.getPpEnabledLayerNames().size()==0){
                (result.ppEnabledLayerNames)=NULL;
            return; }{native_concat()}=(char**)malloc(result.enabledLayerCount*sizeof(char*));
        auto proto_arr=reader.getPpEnabledLayerNames(result.enabledLayerCount);
        for(int SnzIzcs=0; SnzIzcs < result.enabledLayerCount; SnzIzcs++){
            [&](){
            if (!proto_arr[SnzIzcs].size()==0){
                ((result.ppEnabledLayerNames)[SnzIzcs])=NULL;
            return; }{native_concat()}=(char*)malloc(proto_arr[SnzIzcs].size();*sizeof(char));
        auto proto_arr=proto_arr[SnzIzcs];
        for(int nGDPFvA=0; nGDPFvA < proto_arr[SnzIzcs].size();; nGDPFvA++){
            [&](){(((result.ppEnabledLayerNames)[SnzIzcs])[nGDPFvA])=proto_arr[nGDPFvA];}();
        }
        }();
        }
        }();(result.ppEnabledLayerNames)=temp_GHyKyGS;}();
[&](){(result.enabledExtensionCount)=reader.getEnabledExtensionCount();}();
[&](){ char* * temp_RhCaHys[&](){
            if (!reader.getPpEnabledExtensionNames().size()==0){
                (result.ppEnabledExtensionNames)=NULL;
            return; }{native_concat()}=(char**)malloc(result.enabledExtensionCount*sizeof(char*));
        auto proto_arr=reader.getPpEnabledExtensionNames(result.enabledExtensionCount);
        for(int aUXPvjC=0; aUXPvjC < result.enabledExtensionCount; aUXPvjC++){
            [&](){
            if (!proto_arr[aUXPvjC].size()==0){
                ((result.ppEnabledExtensionNames)[aUXPvjC])=NULL;
            return; }{native_concat()}=(char*)malloc(proto_arr[aUXPvjC].size();*sizeof(char));
        auto proto_arr=proto_arr[aUXPvjC];
        for(int Lpzmtcv=0; Lpzmtcv < proto_arr[aUXPvjC].size();; Lpzmtcv++){
            [&](){(((result.ppEnabledExtensionNames)[aUXPvjC])[Lpzmtcv])=proto_arr[Lpzmtcv];}();
        }
        }();
        }
        }();(result.ppEnabledExtensionNames)=temp_RhCaHys;}();
[&](){ VkPhysicalDeviceFeatures* temp_vaqmebP[&](){
            if (!reader.getPEnabledFeatures().size()==0){
                (result.pEnabledFeatures)=NULL;
            return; }{native_concat()}=(VkPhysicalDeviceFeatures*)malloc(1*sizeof(VkPhysicalDeviceFeatures));
        auto proto_arr=reader.getPEnabledFeatures(1);
        for(int XDDQdol=0; XDDQdol < 1; XDDQdol++){
            [&](){
            auto temp=proto_arr[XDDQdol];
            ((result.pEnabledFeatures)[XDDQdol])=deserialize_struct(temp);
            }();
        }
        }();(result.pEnabledFeatures)=temp_vaqmebP;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkInstanceCreateInfo::Builder& builder, VkInstanceCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            if ((member.pApplicationInfo)==NULL){
                builder.initPApplicationInfo(0);
            return; }
        auto proto_arr=builder.initPApplicationInfo(1);
        for(int KcjBZRF=0; KcjBZRF < 1; KcjBZRF++){
            [&](){
            auto temp=proto_arr[KcjBZRF];
            return serialize_struct(temp, ((member.pApplicationInfo)[KcjBZRF]));
            }();
        }
        }();
[&](){return builder.setEnabledLayerCount((member.enabledLayerCount));}();
[&](){
            if ((member.ppEnabledLayerNames)==NULL){
                builder.initPpEnabledLayerNames(0);
            return; }
        auto proto_arr=builder.initPpEnabledLayerNames(member.enabledLayerCount);
        for(int pbCJWPr=0; pbCJWPr < member.enabledLayerCount; pbCJWPr++){
            [&](){
            if (((member.ppEnabledLayerNames)[pbCJWPr])==NULL){
                proto_arr.init(pbCJWPr,0);
            return; }
        auto proto_arr=proto_arr[pbCJWPr];
        for(int aJorhVj=0; aJorhVj < strlen(((member.ppEnabledLayerNames)[pbCJWPr]))+1; aJorhVj++){
            [&](){return proto_arr.set(aJorhVj,(((member.ppEnabledLayerNames)[pbCJWPr])[aJorhVj]));}();
        }
        }();
        }
        }();
[&](){return builder.setEnabledExtensionCount((member.enabledExtensionCount));}();
[&](){
            if ((member.ppEnabledExtensionNames)==NULL){
                builder.initPpEnabledExtensionNames(0);
            return; }
        auto proto_arr=builder.initPpEnabledExtensionNames(member.enabledExtensionCount);
        for(int JSZSZLT=0; JSZSZLT < member.enabledExtensionCount; JSZSZLT++){
            [&](){
            if (((member.ppEnabledExtensionNames)[JSZSZLT])==NULL){
                proto_arr.init(JSZSZLT,0);
            return; }
        auto proto_arr=proto_arr[JSZSZLT];
        for(int IuPNAip=0; IuPNAip < strlen(((member.ppEnabledExtensionNames)[JSZSZLT]))+1; IuPNAip++){
            [&](){return proto_arr.set(IuPNAip,(((member.ppEnabledExtensionNames)[JSZSZLT])[IuPNAip]));}();
        }
        }();
        }
        }();
}

    VkInstanceCreateInfo deserialize_struct(stream::VkInstanceCreateInfo::Reader reader){
        auto result=VkInstanceCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){ VkApplicationInfo* temp_szpthba[&](){
            if (!reader.getPApplicationInfo().size()==0){
                (result.pApplicationInfo)=NULL;
            return; }{native_concat()}=(VkApplicationInfo*)malloc(1*sizeof(VkApplicationInfo));
        auto proto_arr=reader.getPApplicationInfo(1);
        for(int ihjOJvT=0; ihjOJvT < 1; ihjOJvT++){
            [&](){
            auto temp=proto_arr[ihjOJvT];
            ((result.pApplicationInfo)[ihjOJvT])=deserialize_struct(temp);
            }();
        }
        }();(result.pApplicationInfo)=temp_szpthba;}();
[&](){(result.enabledLayerCount)=reader.getEnabledLayerCount();}();
[&](){ char* * temp_GHyKyGS[&](){
            if (!reader.getPpEnabledLayerNames().size()==0){
                (result.ppEnabledLayerNames)=NULL;
            return; }{native_concat()}=(char**)malloc(result.enabledLayerCount*sizeof(char*));
        auto proto_arr=reader.getPpEnabledLayerNames(result.enabledLayerCount);
        for(int SnzIzcs=0; SnzIzcs < result.enabledLayerCount; SnzIzcs++){
            [&](){
            if (!proto_arr[SnzIzcs].size()==0){
                ((result.ppEnabledLayerNames)[SnzIzcs])=NULL;
            return; }{native_concat()}=(char*)malloc(proto_arr[SnzIzcs].size();*sizeof(char));
        auto proto_arr=proto_arr[SnzIzcs];
        for(int nGDPFvA=0; nGDPFvA < proto_arr[SnzIzcs].size();; nGDPFvA++){
            [&](){(((result.ppEnabledLayerNames)[SnzIzcs])[nGDPFvA])=proto_arr[nGDPFvA];}();
        }
        }();
        }
        }();(result.ppEnabledLayerNames)=temp_GHyKyGS;}();
[&](){(result.enabledExtensionCount)=reader.getEnabledExtensionCount();}();
[&](){ char* * temp_RhCaHys[&](){
            if (!reader.getPpEnabledExtensionNames().size()==0){
                (result.ppEnabledExtensionNames)=NULL;
            return; }{native_concat()}=(char**)malloc(result.enabledExtensionCount*sizeof(char*));
        auto proto_arr=reader.getPpEnabledExtensionNames(result.enabledExtensionCount);
        for(int aUXPvjC=0; aUXPvjC < result.enabledExtensionCount; aUXPvjC++){
            [&](){
            if (!proto_arr[aUXPvjC].size()==0){
                ((result.ppEnabledExtensionNames)[aUXPvjC])=NULL;
            return; }{native_concat()}=(char*)malloc(proto_arr[aUXPvjC].size();*sizeof(char));
        auto proto_arr=proto_arr[aUXPvjC];
        for(int Lpzmtcv=0; Lpzmtcv < proto_arr[aUXPvjC].size();; Lpzmtcv++){
            [&](){(((result.ppEnabledExtensionNames)[aUXPvjC])[Lpzmtcv])=proto_arr[Lpzmtcv];}();
        }
        }();
        }
        }();(result.ppEnabledExtensionNames)=temp_RhCaHys;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkInstanceCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkInstanceCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueueFamilyProperties::Builder& builder, VkQueueFamilyProperties member){
        
    
[&](){[&](){[&](){return builder.setQueueFlags((member.queueFlags));}();}();}();
[&](){return builder.setQueueCount((member.queueCount));}();
[&](){return builder.setTimestampValidBits((member.timestampValidBits));}();
[&](){
            auto temp=builder.initMinImageTransferGranularity(minImageTransferGranularity);
            return serialize_struct(temp, (member.minImageTransferGranularity));
            }();
}

    VkQueueFamilyProperties deserialize_struct(stream::VkQueueFamilyProperties::Reader reader){
        auto result=VkQueueFamilyProperties();
    
[&](){[&](){[&](){(result.queueFlags)=reader.getQueueFlags();}();}();}();
[&](){(result.queueCount)=reader.getQueueCount();}();
[&](){(result.timestampValidBits)=reader.getTimestampValidBits();}();
[&](){
            auto temp=reader.getMinImageTransferGranularity();
            (result.minImageTransferGranularity)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueueFamilyProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueueFamilyProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMemoryProperties::Builder& builder, VkPhysicalDeviceMemoryProperties member){
        
    
[&](){return builder.setMemoryTypeCount((member.memoryTypeCount));}();
[&](){
        auto proto_arr=builder.initMemoryTypes(VK_MAX_MEMORY_TYPES);
        for(int PfmqQVb=0; PfmqQVb < VK_MAX_MEMORY_TYPES; PfmqQVb++){
            [&](){
            auto temp=proto_arr[PfmqQVb];
            return serialize_struct(temp, ((member.memoryTypes)[PfmqQVb]));
            }();
        }
        }();
[&](){return builder.setMemoryHeapCount((member.memoryHeapCount));}();
[&](){
        auto proto_arr=builder.initMemoryHeaps(VK_MAX_MEMORY_HEAPS);
        for(int HzUoGww=0; HzUoGww < VK_MAX_MEMORY_HEAPS; HzUoGww++){
            [&](){
            auto temp=proto_arr[HzUoGww];
            return serialize_struct(temp, ((member.memoryHeaps)[HzUoGww]));
            }();
        }
        }();
}

    VkPhysicalDeviceMemoryProperties deserialize_struct(stream::VkPhysicalDeviceMemoryProperties::Reader reader){
        auto result=VkPhysicalDeviceMemoryProperties();
    
[&](){(result.memoryTypeCount)=reader.getMemoryTypeCount();}();
[&](){
        auto proto_arr=reader.getMemoryTypes(VK_MAX_MEMORY_TYPES);
        for(int PfmqQVb=0; PfmqQVb < VK_MAX_MEMORY_TYPES; PfmqQVb++){
            [&](){
            auto temp=proto_arr[PfmqQVb];
            ((result.memoryTypes)[PfmqQVb])=deserialize_struct(temp);
            }();
        }
        }();
[&](){(result.memoryHeapCount)=reader.getMemoryHeapCount();}();
[&](){
        auto proto_arr=reader.getMemoryHeaps(VK_MAX_MEMORY_HEAPS);
        for(int HzUoGww=0; HzUoGww < VK_MAX_MEMORY_HEAPS; HzUoGww++){
            [&](){
            auto temp=proto_arr[HzUoGww];
            ((result.memoryHeaps)[HzUoGww])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMemoryProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMemoryProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryAllocateInfo::Builder& builder, VkMemoryAllocateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAllocationSize((member.allocationSize));}();}();
[&](){return builder.setMemoryTypeIndex((member.memoryTypeIndex));}();
}

    VkMemoryAllocateInfo deserialize_struct(stream::VkMemoryAllocateInfo::Reader reader){
        auto result=VkMemoryAllocateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.allocationSize)=reader.getAllocationSize();}();}();
[&](){(result.memoryTypeIndex)=reader.getMemoryTypeIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryAllocateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryAllocateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryRequirements::Builder& builder, VkMemoryRequirements member){
        
    
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){return builder.setAlignment((member.alignment));}();}();
[&](){return builder.setMemoryTypeBits((member.memoryTypeBits));}();
}

    VkMemoryRequirements deserialize_struct(stream::VkMemoryRequirements::Reader reader){
        auto result=VkMemoryRequirements();
    
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){(result.alignment)=reader.getAlignment();}();}();
[&](){(result.memoryTypeBits)=reader.getMemoryTypeBits();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryRequirements member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryRequirements member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseImageFormatProperties::Builder& builder, VkSparseImageFormatProperties member){
        
    
[&](){[&](){[&](){return builder.setAspectMask((member.aspectMask));}();}();}();
[&](){
            auto temp=builder.initImageGranularity(imageGranularity);
            return serialize_struct(temp, (member.imageGranularity));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkSparseImageFormatProperties deserialize_struct(stream::VkSparseImageFormatProperties::Reader reader){
        auto result=VkSparseImageFormatProperties();
    
[&](){[&](){[&](){(result.aspectMask)=reader.getAspectMask();}();}();}();
[&](){
            auto temp=reader.getImageGranularity();
            (result.imageGranularity)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseImageFormatProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseImageFormatProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseImageMemoryRequirements::Builder& builder, VkSparseImageMemoryRequirements member){
        
    
[&](){
            auto temp=builder.initFormatProperties(formatProperties);
            return serialize_struct(temp, (member.formatProperties));
            }();
[&](){return builder.setImageMipTailFirstLod((member.imageMipTailFirstLod));}();
[&](){[&](){return builder.setImageMipTailSize((member.imageMipTailSize));}();}();
[&](){[&](){return builder.setImageMipTailOffset((member.imageMipTailOffset));}();}();
[&](){[&](){return builder.setImageMipTailStride((member.imageMipTailStride));}();}();
}

    VkSparseImageMemoryRequirements deserialize_struct(stream::VkSparseImageMemoryRequirements::Reader reader){
        auto result=VkSparseImageMemoryRequirements();
    
[&](){
            auto temp=reader.getFormatProperties();
            (result.formatProperties)=deserialize_struct(temp);
            }();
[&](){(result.imageMipTailFirstLod)=reader.getImageMipTailFirstLod();}();
[&](){[&](){(result.imageMipTailSize)=reader.getImageMipTailSize();}();}();
[&](){[&](){(result.imageMipTailOffset)=reader.getImageMipTailOffset();}();}();
[&](){[&](){(result.imageMipTailStride)=reader.getImageMipTailStride();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseImageMemoryRequirements member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseImageMemoryRequirements member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryType::Builder& builder, VkMemoryType member){
        
    
[&](){[&](){[&](){return builder.setPropertyFlags((member.propertyFlags));}();}();}();
[&](){return builder.setHeapIndex((member.heapIndex));}();
}

    VkMemoryType deserialize_struct(stream::VkMemoryType::Reader reader){
        auto result=VkMemoryType();
    
[&](){[&](){[&](){(result.propertyFlags)=reader.getPropertyFlags();}();}();}();
[&](){(result.heapIndex)=reader.getHeapIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryType member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryType member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryHeap::Builder& builder, VkMemoryHeap member){
        
    
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkMemoryHeap deserialize_struct(stream::VkMemoryHeap::Reader reader){
        auto result=VkMemoryHeap();
    
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryHeap member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryHeap member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMappedMemoryRange::Builder& builder, VkMappedMemoryRange member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkMappedMemoryRange deserialize_struct(stream::VkMappedMemoryRange::Reader reader){
        auto result=VkMappedMemoryRange();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMappedMemoryRange member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMappedMemoryRange member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFormatProperties::Builder& builder, VkFormatProperties member){
        
    
[&](){[&](){[&](){return builder.setLinearTilingFeatures((member.linearTilingFeatures));}();}();}();
[&](){[&](){[&](){return builder.setOptimalTilingFeatures((member.optimalTilingFeatures));}();}();}();
[&](){[&](){[&](){return builder.setBufferFeatures((member.bufferFeatures));}();}();}();
}

    VkFormatProperties deserialize_struct(stream::VkFormatProperties::Reader reader){
        auto result=VkFormatProperties();
    
[&](){[&](){[&](){(result.linearTilingFeatures)=reader.getLinearTilingFeatures();}();}();}();
[&](){[&](){[&](){(result.optimalTilingFeatures)=reader.getOptimalTilingFeatures();}();}();}();
[&](){[&](){[&](){(result.bufferFeatures)=reader.getBufferFeatures();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFormatProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFormatProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageFormatProperties::Builder& builder, VkImageFormatProperties member){
        
    
[&](){
            auto temp=builder.initMaxExtent(maxExtent);
            return serialize_struct(temp, (member.maxExtent));
            }();
[&](){return builder.setMaxMipLevels((member.maxMipLevels));}();
[&](){return builder.setMaxArrayLayers((member.maxArrayLayers));}();
[&](){[&](){[&](){return builder.setSampleCounts((member.sampleCounts));}();}();}();
[&](){[&](){return builder.setMaxResourceSize((member.maxResourceSize));}();}();
}

    VkImageFormatProperties deserialize_struct(stream::VkImageFormatProperties::Reader reader){
        auto result=VkImageFormatProperties();
    
[&](){
            auto temp=reader.getMaxExtent();
            (result.maxExtent)=deserialize_struct(temp);
            }();
[&](){(result.maxMipLevels)=reader.getMaxMipLevels();}();
[&](){(result.maxArrayLayers)=reader.getMaxArrayLayers();}();
[&](){[&](){[&](){(result.sampleCounts)=reader.getSampleCounts();}();}();}();
[&](){[&](){(result.maxResourceSize)=reader.getMaxResourceSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageFormatProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageFormatProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorBufferInfo::Builder& builder, VkDescriptorBufferInfo member){
        
    
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setRange((member.range));}();}();
}

    VkDescriptorBufferInfo deserialize_struct(stream::VkDescriptorBufferInfo::Reader reader){
        auto result=VkDescriptorBufferInfo();
    
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.range)=reader.getRange();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorBufferInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorBufferInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorImageInfo::Builder& builder, VkDescriptorImageInfo member){
        
    
[&](){return builder.setSampler(serialize_handle(member.sampler));}();
[&](){return builder.setImageView(serialize_handle(member.imageView));}();
[&](){[&](){[&](){return builder.setImageLayout((member.imageLayout));}();}();}();
}

    VkDescriptorImageInfo deserialize_struct(stream::VkDescriptorImageInfo::Reader reader){
        auto result=VkDescriptorImageInfo();
    
[&](){(result.sampler)=deserialize_VkSampler(reader.getSampler());}();
[&](){(result.imageView)=deserialize_VkImageView(reader.getImageView());}();
[&](){[&](){[&](){(result.imageLayout)=reader.getImageLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorImageInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorImageInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkWriteDescriptorSet::Builder& builder, VkWriteDescriptorSet member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDstSet(serialize_handle(member.dstSet));}();
[&](){return builder.setDstBinding((member.dstBinding));}();
[&](){return builder.setDstArrayElement((member.dstArrayElement));}();
[&](){return builder.setDescriptorCount((member.descriptorCount));}();
[&](){[&](){[&](){return builder.setDescriptorType((member.descriptorType));}();}();}();
[&](){
            if ((member.pImageInfo)==NULL){
                builder.initPImageInfo(0);
            return; }
        auto proto_arr=builder.initPImageInfo(member.descriptorCount);
        for(int RAArEkL=0; RAArEkL < member.descriptorCount; RAArEkL++){
            [&](){
            auto temp=proto_arr[RAArEkL];
            return serialize_struct(temp, ((member.pImageInfo)[RAArEkL]));
            }();
        }
        }();
[&](){
            if ((member.pBufferInfo)==NULL){
                builder.initPBufferInfo(0);
            return; }
        auto proto_arr=builder.initPBufferInfo(member.descriptorCount);
        for(int wdqHwXo=0; wdqHwXo < member.descriptorCount; wdqHwXo++){
            [&](){
            auto temp=proto_arr[wdqHwXo];
            return serialize_struct(temp, ((member.pBufferInfo)[wdqHwXo]));
            }();
        }
        }();
[&](){
            if ((member.pTexelBufferView)==NULL){
                builder.initPTexelBufferView(0);
            return; }
        auto proto_arr=builder.initPTexelBufferView(member.descriptorCount);
        for(int eTpfpkN=0; eTpfpkN < member.descriptorCount; eTpfpkN++){
            [&](){return proto_arr.set(eTpfpkN,serialize_handle((member.pTexelBufferView)[eTpfpkN]));}();
        }
        }();
}

    VkWriteDescriptorSet deserialize_struct(stream::VkWriteDescriptorSet::Reader reader){
        auto result=VkWriteDescriptorSet();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.dstSet)=deserialize_VkDescriptorSet(reader.getDstSet());}();
[&](){(result.dstBinding)=reader.getDstBinding();}();
[&](){(result.dstArrayElement)=reader.getDstArrayElement();}();
[&](){(result.descriptorCount)=reader.getDescriptorCount();}();
[&](){[&](){[&](){(result.descriptorType)=reader.getDescriptorType();}();}();}();
[&](){ VkDescriptorImageInfo* temp_XhzdiaG[&](){
            if (!reader.getPImageInfo().size()==0){
                (result.pImageInfo)=NULL;
            return; }{native_concat()}=(VkDescriptorImageInfo*)malloc(result.descriptorCount*sizeof(VkDescriptorImageInfo));
        auto proto_arr=reader.getPImageInfo(result.descriptorCount);
        for(int sQwJhaj=0; sQwJhaj < result.descriptorCount; sQwJhaj++){
            [&](){
            auto temp=proto_arr[sQwJhaj];
            ((result.pImageInfo)[sQwJhaj])=deserialize_struct(temp);
            }();
        }
        }();(result.pImageInfo)=temp_XhzdiaG;}();
[&](){ VkDescriptorBufferInfo* temp_znnrSKk[&](){
            if (!reader.getPBufferInfo().size()==0){
                (result.pBufferInfo)=NULL;
            return; }{native_concat()}=(VkDescriptorBufferInfo*)malloc(result.descriptorCount*sizeof(VkDescriptorBufferInfo));
        auto proto_arr=reader.getPBufferInfo(result.descriptorCount);
        for(int LhnoBjF=0; LhnoBjF < result.descriptorCount; LhnoBjF++){
            [&](){
            auto temp=proto_arr[LhnoBjF];
            ((result.pBufferInfo)[LhnoBjF])=deserialize_struct(temp);
            }();
        }
        }();(result.pBufferInfo)=temp_znnrSKk;}();
[&](){ VkBufferView* temp_HNSEONB[&](){
            if (!reader.getPTexelBufferView().size()==0){
                (result.pTexelBufferView)=NULL;
            return; }{native_concat()}=(VkBufferView*)malloc(result.descriptorCount*sizeof(VkBufferView));
        auto proto_arr=reader.getPTexelBufferView(result.descriptorCount);
        for(int WHRJRXx=0; WHRJRXx < result.descriptorCount; WHRJRXx++){
            [&](){((result.pTexelBufferView)[WHRJRXx])=deserialize_VkBufferView(proto_arr[WHRJRXx]);}();
        }
        }();(result.pTexelBufferView)=temp_HNSEONB;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkWriteDescriptorSet member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkWriteDescriptorSet member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyDescriptorSet::Builder& builder, VkCopyDescriptorSet member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcSet(serialize_handle(member.srcSet));}();
[&](){return builder.setSrcBinding((member.srcBinding));}();
[&](){return builder.setSrcArrayElement((member.srcArrayElement));}();
[&](){return builder.setDstSet(serialize_handle(member.dstSet));}();
[&](){return builder.setDstBinding((member.dstBinding));}();
[&](){return builder.setDstArrayElement((member.dstArrayElement));}();
[&](){return builder.setDescriptorCount((member.descriptorCount));}();
}

    VkCopyDescriptorSet deserialize_struct(stream::VkCopyDescriptorSet::Reader reader){
        auto result=VkCopyDescriptorSet();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcSet)=deserialize_VkDescriptorSet(reader.getSrcSet());}();
[&](){(result.srcBinding)=reader.getSrcBinding();}();
[&](){(result.srcArrayElement)=reader.getSrcArrayElement();}();
[&](){(result.dstSet)=deserialize_VkDescriptorSet(reader.getDstSet());}();
[&](){(result.dstBinding)=reader.getDstBinding();}();
[&](){(result.dstArrayElement)=reader.getDstArrayElement();}();
[&](){(result.descriptorCount)=reader.getDescriptorCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyDescriptorSet member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyDescriptorSet member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferUsageFlags2CreateInfoKHR::Builder& builder, VkBufferUsageFlags2CreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
}

    VkBufferUsageFlags2CreateInfoKHR deserialize_struct(stream::VkBufferUsageFlags2CreateInfoKHR::Reader reader){
        auto result=VkBufferUsageFlags2CreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferUsageFlags2CreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferUsageFlags2CreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferCreateInfo::Builder& builder, VkBufferCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
[&](){[&](){[&](){return builder.setSharingMode((member.sharingMode));}();}();}();
[&](){return builder.setQueueFamilyIndexCount((member.queueFamilyIndexCount));}();
[&](){
            if ((member.pQueueFamilyIndices)==NULL){
                builder.initPQueueFamilyIndices(0);
            return; }
        auto proto_arr=builder.initPQueueFamilyIndices(member.queueFamilyIndexCount);
        for(int rqZQqua=0; rqZQqua < member.queueFamilyIndexCount; rqZQqua++){
            [&](){return proto_arr.set(rqZQqua,((member.pQueueFamilyIndices)[rqZQqua]));}();
        }
        }();
}

    VkBufferCreateInfo deserialize_struct(stream::VkBufferCreateInfo::Reader reader){
        auto result=VkBufferCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
[&](){[&](){[&](){(result.sharingMode)=reader.getSharingMode();}();}();}();
[&](){(result.queueFamilyIndexCount)=reader.getQueueFamilyIndexCount();}();
[&](){ uint32_t* temp_NzZliok[&](){
            if (!reader.getPQueueFamilyIndices().size()==0){
                (result.pQueueFamilyIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.queueFamilyIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPQueueFamilyIndices(result.queueFamilyIndexCount);
        for(int JEqKTnG=0; JEqKTnG < result.queueFamilyIndexCount; JEqKTnG++){
            [&](){((result.pQueueFamilyIndices)[JEqKTnG])=proto_arr[JEqKTnG];}();
        }
        }();(result.pQueueFamilyIndices)=temp_NzZliok;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferViewCreateInfo::Builder& builder, VkBufferViewCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setRange((member.range));}();}();
}

    VkBufferViewCreateInfo deserialize_struct(stream::VkBufferViewCreateInfo::Reader reader){
        auto result=VkBufferViewCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.range)=reader.getRange();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferViewCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferViewCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageSubresource::Builder& builder, VkImageSubresource member){
        
    
[&](){[&](){[&](){return builder.setAspectMask((member.aspectMask));}();}();}();
[&](){return builder.setMipLevel((member.mipLevel));}();
[&](){return builder.setArrayLayer((member.arrayLayer));}();
}

    VkImageSubresource deserialize_struct(stream::VkImageSubresource::Reader reader){
        auto result=VkImageSubresource();
    
[&](){[&](){[&](){(result.aspectMask)=reader.getAspectMask();}();}();}();
[&](){(result.mipLevel)=reader.getMipLevel();}();
[&](){(result.arrayLayer)=reader.getArrayLayer();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageSubresource member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageSubresource member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageSubresourceLayers::Builder& builder, VkImageSubresourceLayers member){
        
    
[&](){[&](){[&](){return builder.setAspectMask((member.aspectMask));}();}();}();
[&](){return builder.setMipLevel((member.mipLevel));}();
[&](){return builder.setBaseArrayLayer((member.baseArrayLayer));}();
[&](){return builder.setLayerCount((member.layerCount));}();
}

    VkImageSubresourceLayers deserialize_struct(stream::VkImageSubresourceLayers::Reader reader){
        auto result=VkImageSubresourceLayers();
    
[&](){[&](){[&](){(result.aspectMask)=reader.getAspectMask();}();}();}();
[&](){(result.mipLevel)=reader.getMipLevel();}();
[&](){(result.baseArrayLayer)=reader.getBaseArrayLayer();}();
[&](){(result.layerCount)=reader.getLayerCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageSubresourceLayers member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageSubresourceLayers member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageSubresourceRange::Builder& builder, VkImageSubresourceRange member){
        
    
[&](){[&](){[&](){return builder.setAspectMask((member.aspectMask));}();}();}();
[&](){return builder.setBaseMipLevel((member.baseMipLevel));}();
[&](){return builder.setLevelCount((member.levelCount));}();
[&](){return builder.setBaseArrayLayer((member.baseArrayLayer));}();
[&](){return builder.setLayerCount((member.layerCount));}();
}

    VkImageSubresourceRange deserialize_struct(stream::VkImageSubresourceRange::Reader reader){
        auto result=VkImageSubresourceRange();
    
[&](){[&](){[&](){(result.aspectMask)=reader.getAspectMask();}();}();}();
[&](){(result.baseMipLevel)=reader.getBaseMipLevel();}();
[&](){(result.levelCount)=reader.getLevelCount();}();
[&](){(result.baseArrayLayer)=reader.getBaseArrayLayer();}();
[&](){(result.layerCount)=reader.getLayerCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageSubresourceRange member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageSubresourceRange member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryBarrier::Builder& builder, VkMemoryBarrier member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
}

    VkMemoryBarrier deserialize_struct(stream::VkMemoryBarrier::Reader reader){
        auto result=VkMemoryBarrier();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryBarrier member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryBarrier member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferMemoryBarrier::Builder& builder, VkBufferMemoryBarrier member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
[&](){return builder.setSrcQueueFamilyIndex((member.srcQueueFamilyIndex));}();
[&](){return builder.setDstQueueFamilyIndex((member.dstQueueFamilyIndex));}();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkBufferMemoryBarrier deserialize_struct(stream::VkBufferMemoryBarrier::Reader reader){
        auto result=VkBufferMemoryBarrier();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
[&](){(result.srcQueueFamilyIndex)=reader.getSrcQueueFamilyIndex();}();
[&](){(result.dstQueueFamilyIndex)=reader.getDstQueueFamilyIndex();}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferMemoryBarrier member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferMemoryBarrier member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageMemoryBarrier::Builder& builder, VkImageMemoryBarrier member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setOldLayout((member.oldLayout));}();}();}();
[&](){[&](){[&](){return builder.setNewLayout((member.newLayout));}();}();}();
[&](){return builder.setSrcQueueFamilyIndex((member.srcQueueFamilyIndex));}();
[&](){return builder.setDstQueueFamilyIndex((member.dstQueueFamilyIndex));}();
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){
            auto temp=builder.initSubresourceRange(subresourceRange);
            return serialize_struct(temp, (member.subresourceRange));
            }();
}

    VkImageMemoryBarrier deserialize_struct(stream::VkImageMemoryBarrier::Reader reader){
        auto result=VkImageMemoryBarrier();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
[&](){[&](){[&](){(result.oldLayout)=reader.getOldLayout();}();}();}();
[&](){[&](){[&](){(result.newLayout)=reader.getNewLayout();}();}();}();
[&](){(result.srcQueueFamilyIndex)=reader.getSrcQueueFamilyIndex();}();
[&](){(result.dstQueueFamilyIndex)=reader.getDstQueueFamilyIndex();}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){
            auto temp=reader.getSubresourceRange();
            (result.subresourceRange)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageMemoryBarrier member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageMemoryBarrier member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageCreateInfo::Builder& builder, VkImageCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setImageType((member.imageType));}();}();}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
[&](){return builder.setMipLevels((member.mipLevels));}();
[&](){return builder.setArrayLayers((member.arrayLayers));}();
[&](){[&](){[&](){return builder.setSamples((member.samples));}();}();}();
[&](){[&](){[&](){return builder.setTiling((member.tiling));}();}();}();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
[&](){[&](){[&](){return builder.setSharingMode((member.sharingMode));}();}();}();
[&](){return builder.setQueueFamilyIndexCount((member.queueFamilyIndexCount));}();
[&](){
            if ((member.pQueueFamilyIndices)==NULL){
                builder.initPQueueFamilyIndices(0);
            return; }
        auto proto_arr=builder.initPQueueFamilyIndices(member.queueFamilyIndexCount);
        for(int rqZQqua=0; rqZQqua < member.queueFamilyIndexCount; rqZQqua++){
            [&](){return proto_arr.set(rqZQqua,((member.pQueueFamilyIndices)[rqZQqua]));}();
        }
        }();
[&](){[&](){[&](){return builder.setInitialLayout((member.initialLayout));}();}();}();
}

    VkImageCreateInfo deserialize_struct(stream::VkImageCreateInfo::Reader reader){
        auto result=VkImageCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.imageType)=reader.getImageType();}();}();}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
[&](){(result.mipLevels)=reader.getMipLevels();}();
[&](){(result.arrayLayers)=reader.getArrayLayers();}();
[&](){[&](){[&](){(result.samples)=reader.getSamples();}();}();}();
[&](){[&](){[&](){(result.tiling)=reader.getTiling();}();}();}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
[&](){[&](){[&](){(result.sharingMode)=reader.getSharingMode();}();}();}();
[&](){(result.queueFamilyIndexCount)=reader.getQueueFamilyIndexCount();}();
[&](){ uint32_t* temp_NzZliok[&](){
            if (!reader.getPQueueFamilyIndices().size()==0){
                (result.pQueueFamilyIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.queueFamilyIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPQueueFamilyIndices(result.queueFamilyIndexCount);
        for(int JEqKTnG=0; JEqKTnG < result.queueFamilyIndexCount; JEqKTnG++){
            [&](){((result.pQueueFamilyIndices)[JEqKTnG])=proto_arr[JEqKTnG];}();
        }
        }();(result.pQueueFamilyIndices)=temp_NzZliok;}();
[&](){[&](){[&](){(result.initialLayout)=reader.getInitialLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubresourceLayout::Builder& builder, VkSubresourceLayout member){
        
    
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){return builder.setRowPitch((member.rowPitch));}();}();
[&](){[&](){return builder.setArrayPitch((member.arrayPitch));}();}();
[&](){[&](){return builder.setDepthPitch((member.depthPitch));}();}();
}

    VkSubresourceLayout deserialize_struct(stream::VkSubresourceLayout::Reader reader){
        auto result=VkSubresourceLayout();
    
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){(result.rowPitch)=reader.getRowPitch();}();}();
[&](){[&](){(result.arrayPitch)=reader.getArrayPitch();}();}();
[&](){[&](){(result.depthPitch)=reader.getDepthPitch();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubresourceLayout member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubresourceLayout member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewCreateInfo::Builder& builder, VkImageViewCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){[&](){[&](){return builder.setViewType((member.viewType));}();}();}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){
            auto temp=builder.initComponents(components);
            return serialize_struct(temp, (member.components));
            }();
[&](){
            auto temp=builder.initSubresourceRange(subresourceRange);
            return serialize_struct(temp, (member.subresourceRange));
            }();
}

    VkImageViewCreateInfo deserialize_struct(stream::VkImageViewCreateInfo::Reader reader){
        auto result=VkImageViewCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){[&](){[&](){(result.viewType)=reader.getViewType();}();}();}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){
            auto temp=reader.getComponents();
            (result.components)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSubresourceRange();
            (result.subresourceRange)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferCopy::Builder& builder, VkBufferCopy member){
        
    
[&](){[&](){return builder.setSrcOffset((member.srcOffset));}();}();
[&](){[&](){return builder.setDstOffset((member.dstOffset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkBufferCopy deserialize_struct(stream::VkBufferCopy::Reader reader){
        auto result=VkBufferCopy();
    
[&](){[&](){(result.srcOffset)=reader.getSrcOffset();}();}();
[&](){[&](){(result.dstOffset)=reader.getDstOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferCopy member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferCopy member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseMemoryBind::Builder& builder, VkSparseMemoryBind member){
        
    
[&](){[&](){return builder.setResourceOffset((member.resourceOffset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setMemoryOffset((member.memoryOffset));}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkSparseMemoryBind deserialize_struct(stream::VkSparseMemoryBind::Reader reader){
        auto result=VkSparseMemoryBind();
    
[&](){[&](){(result.resourceOffset)=reader.getResourceOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.memoryOffset)=reader.getMemoryOffset();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseMemoryBind member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseMemoryBind member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseImageMemoryBind::Builder& builder, VkSparseImageMemoryBind member){
        
    
[&](){
            auto temp=builder.initSubresource(subresource);
            return serialize_struct(temp, (member.subresource));
            }();
[&](){
            auto temp=builder.initOffset(offset);
            return serialize_struct(temp, (member.offset));
            }();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setMemoryOffset((member.memoryOffset));}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkSparseImageMemoryBind deserialize_struct(stream::VkSparseImageMemoryBind::Reader reader){
        auto result=VkSparseImageMemoryBind();
    
[&](){
            auto temp=reader.getSubresource();
            (result.subresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getOffset();
            (result.offset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.memoryOffset)=reader.getMemoryOffset();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseImageMemoryBind member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseImageMemoryBind member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseBufferMemoryBindInfo::Builder& builder, VkSparseBufferMemoryBindInfo member){
        
    
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){return builder.setBindCount((member.bindCount));}();
[&](){
            if ((member.pBinds)==NULL){
                builder.initPBinds(0);
            return; }
        auto proto_arr=builder.initPBinds(member.bindCount);
        for(int HwvIdVs=0; HwvIdVs < member.bindCount; HwvIdVs++){
            [&](){
            auto temp=proto_arr[HwvIdVs];
            return serialize_struct(temp, ((member.pBinds)[HwvIdVs]));
            }();
        }
        }();
}

    VkSparseBufferMemoryBindInfo deserialize_struct(stream::VkSparseBufferMemoryBindInfo::Reader reader){
        auto result=VkSparseBufferMemoryBindInfo();
    
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){(result.bindCount)=reader.getBindCount();}();
[&](){ VkSparseMemoryBind* temp_wcimaFG[&](){
            if (!reader.getPBinds().size()==0){
                (result.pBinds)=NULL;
            return; }{native_concat()}=(VkSparseMemoryBind*)malloc(result.bindCount*sizeof(VkSparseMemoryBind));
        auto proto_arr=reader.getPBinds(result.bindCount);
        for(int FqSYJtl=0; FqSYJtl < result.bindCount; FqSYJtl++){
            [&](){
            auto temp=proto_arr[FqSYJtl];
            ((result.pBinds)[FqSYJtl])=deserialize_struct(temp);
            }();
        }
        }();(result.pBinds)=temp_wcimaFG;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseBufferMemoryBindInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseBufferMemoryBindInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseImageOpaqueMemoryBindInfo::Builder& builder, VkSparseImageOpaqueMemoryBindInfo member){
        
    
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){return builder.setBindCount((member.bindCount));}();
[&](){
            if ((member.pBinds)==NULL){
                builder.initPBinds(0);
            return; }
        auto proto_arr=builder.initPBinds(member.bindCount);
        for(int HwvIdVs=0; HwvIdVs < member.bindCount; HwvIdVs++){
            [&](){
            auto temp=proto_arr[HwvIdVs];
            return serialize_struct(temp, ((member.pBinds)[HwvIdVs]));
            }();
        }
        }();
}

    VkSparseImageOpaqueMemoryBindInfo deserialize_struct(stream::VkSparseImageOpaqueMemoryBindInfo::Reader reader){
        auto result=VkSparseImageOpaqueMemoryBindInfo();
    
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){(result.bindCount)=reader.getBindCount();}();
[&](){ VkSparseMemoryBind* temp_wcimaFG[&](){
            if (!reader.getPBinds().size()==0){
                (result.pBinds)=NULL;
            return; }{native_concat()}=(VkSparseMemoryBind*)malloc(result.bindCount*sizeof(VkSparseMemoryBind));
        auto proto_arr=reader.getPBinds(result.bindCount);
        for(int FqSYJtl=0; FqSYJtl < result.bindCount; FqSYJtl++){
            [&](){
            auto temp=proto_arr[FqSYJtl];
            ((result.pBinds)[FqSYJtl])=deserialize_struct(temp);
            }();
        }
        }();(result.pBinds)=temp_wcimaFG;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseImageOpaqueMemoryBindInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseImageOpaqueMemoryBindInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseImageMemoryBindInfo::Builder& builder, VkSparseImageMemoryBindInfo member){
        
    
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){return builder.setBindCount((member.bindCount));}();
[&](){
            if ((member.pBinds)==NULL){
                builder.initPBinds(0);
            return; }
        auto proto_arr=builder.initPBinds(member.bindCount);
        for(int JvNztWs=0; JvNztWs < member.bindCount; JvNztWs++){
            [&](){
            auto temp=proto_arr[JvNztWs];
            return serialize_struct(temp, ((member.pBinds)[JvNztWs]));
            }();
        }
        }();
}

    VkSparseImageMemoryBindInfo deserialize_struct(stream::VkSparseImageMemoryBindInfo::Reader reader){
        auto result=VkSparseImageMemoryBindInfo();
    
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){(result.bindCount)=reader.getBindCount();}();
[&](){ VkSparseImageMemoryBind* temp_OclWdaB[&](){
            if (!reader.getPBinds().size()==0){
                (result.pBinds)=NULL;
            return; }{native_concat()}=(VkSparseImageMemoryBind*)malloc(result.bindCount*sizeof(VkSparseImageMemoryBind));
        auto proto_arr=reader.getPBinds(result.bindCount);
        for(int HjYbXsd=0; HjYbXsd < result.bindCount; HjYbXsd++){
            [&](){
            auto temp=proto_arr[HjYbXsd];
            ((result.pBinds)[HjYbXsd])=deserialize_struct(temp);
            }();
        }
        }();(result.pBinds)=temp_OclWdaB;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseImageMemoryBindInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseImageMemoryBindInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindSparseInfo::Builder& builder, VkBindSparseInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setWaitSemaphoreCount((member.waitSemaphoreCount));}();
[&](){
            if ((member.pWaitSemaphores)==NULL){
                builder.initPWaitSemaphores(0);
            return; }
        auto proto_arr=builder.initPWaitSemaphores(member.waitSemaphoreCount);
        for(int UPuCjkG=0; UPuCjkG < member.waitSemaphoreCount; UPuCjkG++){
            [&](){return proto_arr.set(UPuCjkG,serialize_handle((member.pWaitSemaphores)[UPuCjkG]));}();
        }
        }();
[&](){return builder.setBufferBindCount((member.bufferBindCount));}();
[&](){
            if ((member.pBufferBinds)==NULL){
                builder.initPBufferBinds(0);
            return; }
        auto proto_arr=builder.initPBufferBinds(member.bufferBindCount);
        for(int RRvLWWb=0; RRvLWWb < member.bufferBindCount; RRvLWWb++){
            [&](){
            auto temp=proto_arr[RRvLWWb];
            return serialize_struct(temp, ((member.pBufferBinds)[RRvLWWb]));
            }();
        }
        }();
[&](){return builder.setImageOpaqueBindCount((member.imageOpaqueBindCount));}();
[&](){
            if ((member.pImageOpaqueBinds)==NULL){
                builder.initPImageOpaqueBinds(0);
            return; }
        auto proto_arr=builder.initPImageOpaqueBinds(member.imageOpaqueBindCount);
        for(int AUtqPDZ=0; AUtqPDZ < member.imageOpaqueBindCount; AUtqPDZ++){
            [&](){
            auto temp=proto_arr[AUtqPDZ];
            return serialize_struct(temp, ((member.pImageOpaqueBinds)[AUtqPDZ]));
            }();
        }
        }();
[&](){return builder.setImageBindCount((member.imageBindCount));}();
[&](){
            if ((member.pImageBinds)==NULL){
                builder.initPImageBinds(0);
            return; }
        auto proto_arr=builder.initPImageBinds(member.imageBindCount);
        for(int iNNUNSt=0; iNNUNSt < member.imageBindCount; iNNUNSt++){
            [&](){
            auto temp=proto_arr[iNNUNSt];
            return serialize_struct(temp, ((member.pImageBinds)[iNNUNSt]));
            }();
        }
        }();
[&](){return builder.setSignalSemaphoreCount((member.signalSemaphoreCount));}();
[&](){
            if ((member.pSignalSemaphores)==NULL){
                builder.initPSignalSemaphores(0);
            return; }
        auto proto_arr=builder.initPSignalSemaphores(member.signalSemaphoreCount);
        for(int NKFlfkK=0; NKFlfkK < member.signalSemaphoreCount; NKFlfkK++){
            [&](){return proto_arr.set(NKFlfkK,serialize_handle((member.pSignalSemaphores)[NKFlfkK]));}();
        }
        }();
}

    VkBindSparseInfo deserialize_struct(stream::VkBindSparseInfo::Reader reader){
        auto result=VkBindSparseInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.waitSemaphoreCount)=reader.getWaitSemaphoreCount();}();
[&](){ VkSemaphore* temp_vxBhExF[&](){
            if (!reader.getPWaitSemaphores().size()==0){
                (result.pWaitSemaphores)=NULL;
            return; }{native_concat()}=(VkSemaphore*)malloc(result.waitSemaphoreCount*sizeof(VkSemaphore));
        auto proto_arr=reader.getPWaitSemaphores(result.waitSemaphoreCount);
        for(int eowObQx=0; eowObQx < result.waitSemaphoreCount; eowObQx++){
            [&](){((result.pWaitSemaphores)[eowObQx])=deserialize_VkSemaphore(proto_arr[eowObQx]);}();
        }
        }();(result.pWaitSemaphores)=temp_vxBhExF;}();
[&](){(result.bufferBindCount)=reader.getBufferBindCount();}();
[&](){ VkSparseBufferMemoryBindInfo* temp_uzqeCmo[&](){
            if (!reader.getPBufferBinds().size()==0){
                (result.pBufferBinds)=NULL;
            return; }{native_concat()}=(VkSparseBufferMemoryBindInfo*)malloc(result.bufferBindCount*sizeof(VkSparseBufferMemoryBindInfo));
        auto proto_arr=reader.getPBufferBinds(result.bufferBindCount);
        for(int pTBYvkA=0; pTBYvkA < result.bufferBindCount; pTBYvkA++){
            [&](){
            auto temp=proto_arr[pTBYvkA];
            ((result.pBufferBinds)[pTBYvkA])=deserialize_struct(temp);
            }();
        }
        }();(result.pBufferBinds)=temp_uzqeCmo;}();
[&](){(result.imageOpaqueBindCount)=reader.getImageOpaqueBindCount();}();
[&](){ VkSparseImageOpaqueMemoryBindInfo* temp_bplMtAB[&](){
            if (!reader.getPImageOpaqueBinds().size()==0){
                (result.pImageOpaqueBinds)=NULL;
            return; }{native_concat()}=(VkSparseImageOpaqueMemoryBindInfo*)malloc(result.imageOpaqueBindCount*sizeof(VkSparseImageOpaqueMemoryBindInfo));
        auto proto_arr=reader.getPImageOpaqueBinds(result.imageOpaqueBindCount);
        for(int KjNYabZ=0; KjNYabZ < result.imageOpaqueBindCount; KjNYabZ++){
            [&](){
            auto temp=proto_arr[KjNYabZ];
            ((result.pImageOpaqueBinds)[KjNYabZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pImageOpaqueBinds)=temp_bplMtAB;}();
[&](){(result.imageBindCount)=reader.getImageBindCount();}();
[&](){ VkSparseImageMemoryBindInfo* temp_jkVDUZF[&](){
            if (!reader.getPImageBinds().size()==0){
                (result.pImageBinds)=NULL;
            return; }{native_concat()}=(VkSparseImageMemoryBindInfo*)malloc(result.imageBindCount*sizeof(VkSparseImageMemoryBindInfo));
        auto proto_arr=reader.getPImageBinds(result.imageBindCount);
        for(int WzrwjrD=0; WzrwjrD < result.imageBindCount; WzrwjrD++){
            [&](){
            auto temp=proto_arr[WzrwjrD];
            ((result.pImageBinds)[WzrwjrD])=deserialize_struct(temp);
            }();
        }
        }();(result.pImageBinds)=temp_jkVDUZF;}();
[&](){(result.signalSemaphoreCount)=reader.getSignalSemaphoreCount();}();
[&](){ VkSemaphore* temp_rruuqWC[&](){
            if (!reader.getPSignalSemaphores().size()==0){
                (result.pSignalSemaphores)=NULL;
            return; }{native_concat()}=(VkSemaphore*)malloc(result.signalSemaphoreCount*sizeof(VkSemaphore));
        auto proto_arr=reader.getPSignalSemaphores(result.signalSemaphoreCount);
        for(int rsHNIbT=0; rsHNIbT < result.signalSemaphoreCount; rsHNIbT++){
            [&](){((result.pSignalSemaphores)[rsHNIbT])=deserialize_VkSemaphore(proto_arr[rsHNIbT]);}();
        }
        }();(result.pSignalSemaphores)=temp_rruuqWC;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindSparseInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindSparseInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageCopy::Builder& builder, VkImageCopy member){
        
    
[&](){
            auto temp=builder.initSrcSubresource(srcSubresource);
            return serialize_struct(temp, (member.srcSubresource));
            }();
[&](){
            auto temp=builder.initSrcOffset(srcOffset);
            return serialize_struct(temp, (member.srcOffset));
            }();
[&](){
            auto temp=builder.initDstSubresource(dstSubresource);
            return serialize_struct(temp, (member.dstSubresource));
            }();
[&](){
            auto temp=builder.initDstOffset(dstOffset);
            return serialize_struct(temp, (member.dstOffset));
            }();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
}

    VkImageCopy deserialize_struct(stream::VkImageCopy::Reader reader){
        auto result=VkImageCopy();
    
[&](){
            auto temp=reader.getSrcSubresource();
            (result.srcSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSrcOffset();
            (result.srcOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstSubresource();
            (result.dstSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstOffset();
            (result.dstOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageCopy member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageCopy member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageBlit::Builder& builder, VkImageBlit member){
        
    
[&](){
            auto temp=builder.initSrcSubresource(srcSubresource);
            return serialize_struct(temp, (member.srcSubresource));
            }();
[&](){
        auto proto_arr=builder.initSrcOffsets(2);
        for(int jRYlQCC=0; jRYlQCC < 2; jRYlQCC++){
            [&](){
            auto temp=proto_arr[jRYlQCC];
            return serialize_struct(temp, ((member.srcOffsets)[jRYlQCC]));
            }();
        }
        }();
[&](){
            auto temp=builder.initDstSubresource(dstSubresource);
            return serialize_struct(temp, (member.dstSubresource));
            }();
[&](){
        auto proto_arr=builder.initDstOffsets(2);
        for(int dYmXuSG=0; dYmXuSG < 2; dYmXuSG++){
            [&](){
            auto temp=proto_arr[dYmXuSG];
            return serialize_struct(temp, ((member.dstOffsets)[dYmXuSG]));
            }();
        }
        }();
}

    VkImageBlit deserialize_struct(stream::VkImageBlit::Reader reader){
        auto result=VkImageBlit();
    
[&](){
            auto temp=reader.getSrcSubresource();
            (result.srcSubresource)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getSrcOffsets(2);
        for(int jRYlQCC=0; jRYlQCC < 2; jRYlQCC++){
            [&](){
            auto temp=proto_arr[jRYlQCC];
            ((result.srcOffsets)[jRYlQCC])=deserialize_struct(temp);
            }();
        }
        }();
[&](){
            auto temp=reader.getDstSubresource();
            (result.dstSubresource)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getDstOffsets(2);
        for(int dYmXuSG=0; dYmXuSG < 2; dYmXuSG++){
            [&](){
            auto temp=proto_arr[dYmXuSG];
            ((result.dstOffsets)[dYmXuSG])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageBlit member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageBlit member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferImageCopy::Builder& builder, VkBufferImageCopy member){
        
    
[&](){[&](){return builder.setBufferOffset((member.bufferOffset));}();}();
[&](){return builder.setBufferRowLength((member.bufferRowLength));}();
[&](){return builder.setBufferImageHeight((member.bufferImageHeight));}();
[&](){
            auto temp=builder.initImageSubresource(imageSubresource);
            return serialize_struct(temp, (member.imageSubresource));
            }();
[&](){
            auto temp=builder.initImageOffset(imageOffset);
            return serialize_struct(temp, (member.imageOffset));
            }();
[&](){
            auto temp=builder.initImageExtent(imageExtent);
            return serialize_struct(temp, (member.imageExtent));
            }();
}

    VkBufferImageCopy deserialize_struct(stream::VkBufferImageCopy::Reader reader){
        auto result=VkBufferImageCopy();
    
[&](){[&](){(result.bufferOffset)=reader.getBufferOffset();}();}();
[&](){(result.bufferRowLength)=reader.getBufferRowLength();}();
[&](){(result.bufferImageHeight)=reader.getBufferImageHeight();}();
[&](){
            auto temp=reader.getImageSubresource();
            (result.imageSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageOffset();
            (result.imageOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageExtent();
            (result.imageExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferImageCopy member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferImageCopy member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyMemoryIndirectCommandNV::Builder& builder, VkCopyMemoryIndirectCommandNV member){
        
    
[&](){[&](){return builder.setSrcAddress((member.srcAddress));}();}();
[&](){[&](){return builder.setDstAddress((member.dstAddress));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkCopyMemoryIndirectCommandNV deserialize_struct(stream::VkCopyMemoryIndirectCommandNV::Reader reader){
        auto result=VkCopyMemoryIndirectCommandNV();
    
[&](){[&](){(result.srcAddress)=reader.getSrcAddress();}();}();
[&](){[&](){(result.dstAddress)=reader.getDstAddress();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyMemoryIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyMemoryIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyMemoryToImageIndirectCommandNV::Builder& builder, VkCopyMemoryToImageIndirectCommandNV member){
        
    
[&](){[&](){return builder.setSrcAddress((member.srcAddress));}();}();
[&](){return builder.setBufferRowLength((member.bufferRowLength));}();
[&](){return builder.setBufferImageHeight((member.bufferImageHeight));}();
[&](){
            auto temp=builder.initImageSubresource(imageSubresource);
            return serialize_struct(temp, (member.imageSubresource));
            }();
[&](){
            auto temp=builder.initImageOffset(imageOffset);
            return serialize_struct(temp, (member.imageOffset));
            }();
[&](){
            auto temp=builder.initImageExtent(imageExtent);
            return serialize_struct(temp, (member.imageExtent));
            }();
}

    VkCopyMemoryToImageIndirectCommandNV deserialize_struct(stream::VkCopyMemoryToImageIndirectCommandNV::Reader reader){
        auto result=VkCopyMemoryToImageIndirectCommandNV();
    
[&](){[&](){(result.srcAddress)=reader.getSrcAddress();}();}();
[&](){(result.bufferRowLength)=reader.getBufferRowLength();}();
[&](){(result.bufferImageHeight)=reader.getBufferImageHeight();}();
[&](){
            auto temp=reader.getImageSubresource();
            (result.imageSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageOffset();
            (result.imageOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageExtent();
            (result.imageExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyMemoryToImageIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyMemoryToImageIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageResolve::Builder& builder, VkImageResolve member){
        
    
[&](){
            auto temp=builder.initSrcSubresource(srcSubresource);
            return serialize_struct(temp, (member.srcSubresource));
            }();
[&](){
            auto temp=builder.initSrcOffset(srcOffset);
            return serialize_struct(temp, (member.srcOffset));
            }();
[&](){
            auto temp=builder.initDstSubresource(dstSubresource);
            return serialize_struct(temp, (member.dstSubresource));
            }();
[&](){
            auto temp=builder.initDstOffset(dstOffset);
            return serialize_struct(temp, (member.dstOffset));
            }();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
}

    VkImageResolve deserialize_struct(stream::VkImageResolve::Reader reader){
        auto result=VkImageResolve();
    
[&](){
            auto temp=reader.getSrcSubresource();
            (result.srcSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSrcOffset();
            (result.srcOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstSubresource();
            (result.dstSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstOffset();
            (result.dstOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageResolve member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageResolve member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkShaderModuleCreateInfo::Builder& builder, VkShaderModuleCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setCodeSize((member.codeSize));}();
[&](){
            if ((member.pCode)==NULL){
                builder.initPCode(0);
            return; }
        auto proto_arr=builder.initPCode(member.codeSize / 4);
        for(int AXpbriB=0; AXpbriB < member.codeSize / 4; AXpbriB++){
            [&](){return proto_arr.set(AXpbriB,((member.pCode)[AXpbriB]));}();
        }
        }();
}

    VkShaderModuleCreateInfo deserialize_struct(stream::VkShaderModuleCreateInfo::Reader reader){
        auto result=VkShaderModuleCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.codeSize)=reader.getCodeSize();}();
[&](){ uint32_t* temp_eBlvmlE[&](){
            if (!reader.getPCode().size()==0){
                (result.pCode)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.codeSize / 4*sizeof(uint32_t));
        auto proto_arr=reader.getPCode(result.codeSize / 4);
        for(int QIlxWNh=0; QIlxWNh < result.codeSize / 4; QIlxWNh++){
            [&](){((result.pCode)[QIlxWNh])=proto_arr[QIlxWNh];}();
        }
        }();(result.pCode)=temp_eBlvmlE;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkShaderModuleCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkShaderModuleCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetLayoutBinding::Builder& builder, VkDescriptorSetLayoutBinding member){
        
    
[&](){return builder.setBinding((member.binding));}();
[&](){[&](){[&](){return builder.setDescriptorType((member.descriptorType));}();}();}();
[&](){return builder.setDescriptorCount((member.descriptorCount));}();
[&](){[&](){[&](){return builder.setStageFlags((member.stageFlags));}();}();}();
[&](){
            if ((member.pImmutableSamplers)==NULL){
                builder.initPImmutableSamplers(0);
            return; }
        auto proto_arr=builder.initPImmutableSamplers(member.descriptorCount);
        for(int wKzMDsL=0; wKzMDsL < member.descriptorCount; wKzMDsL++){
            [&](){return proto_arr.set(wKzMDsL,serialize_handle((member.pImmutableSamplers)[wKzMDsL]));}();
        }
        }();
}

    VkDescriptorSetLayoutBinding deserialize_struct(stream::VkDescriptorSetLayoutBinding::Reader reader){
        auto result=VkDescriptorSetLayoutBinding();
    
[&](){(result.binding)=reader.getBinding();}();
[&](){[&](){[&](){(result.descriptorType)=reader.getDescriptorType();}();}();}();
[&](){(result.descriptorCount)=reader.getDescriptorCount();}();
[&](){[&](){[&](){(result.stageFlags)=reader.getStageFlags();}();}();}();
[&](){ VkSampler* temp_nQMkzBN[&](){
            if (!reader.getPImmutableSamplers().size()==0){
                (result.pImmutableSamplers)=NULL;
            return; }{native_concat()}=(VkSampler*)malloc(result.descriptorCount*sizeof(VkSampler));
        auto proto_arr=reader.getPImmutableSamplers(result.descriptorCount);
        for(int DwrtaGO=0; DwrtaGO < result.descriptorCount; DwrtaGO++){
            [&](){((result.pImmutableSamplers)[DwrtaGO])=deserialize_VkSampler(proto_arr[DwrtaGO]);}();
        }
        }();(result.pImmutableSamplers)=temp_nQMkzBN;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetLayoutBinding member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetLayoutBinding member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetLayoutCreateInfo::Builder& builder, VkDescriptorSetLayoutCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setBindingCount((member.bindingCount));}();
[&](){
            if ((member.pBindings)==NULL){
                builder.initPBindings(0);
            return; }
        auto proto_arr=builder.initPBindings(member.bindingCount);
        for(int sYqothM=0; sYqothM < member.bindingCount; sYqothM++){
            [&](){
            auto temp=proto_arr[sYqothM];
            return serialize_struct(temp, ((member.pBindings)[sYqothM]));
            }();
        }
        }();
}

    VkDescriptorSetLayoutCreateInfo deserialize_struct(stream::VkDescriptorSetLayoutCreateInfo::Reader reader){
        auto result=VkDescriptorSetLayoutCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.bindingCount)=reader.getBindingCount();}();
[&](){ VkDescriptorSetLayoutBinding* temp_MODlZmi[&](){
            if (!reader.getPBindings().size()==0){
                (result.pBindings)=NULL;
            return; }{native_concat()}=(VkDescriptorSetLayoutBinding*)malloc(result.bindingCount*sizeof(VkDescriptorSetLayoutBinding));
        auto proto_arr=reader.getPBindings(result.bindingCount);
        for(int KUIwNnx=0; KUIwNnx < result.bindingCount; KUIwNnx++){
            [&](){
            auto temp=proto_arr[KUIwNnx];
            ((result.pBindings)[KUIwNnx])=deserialize_struct(temp);
            }();
        }
        }();(result.pBindings)=temp_MODlZmi;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetLayoutCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetLayoutCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorPoolSize::Builder& builder, VkDescriptorPoolSize member){
        
    
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){return builder.setDescriptorCount((member.descriptorCount));}();
}

    VkDescriptorPoolSize deserialize_struct(stream::VkDescriptorPoolSize::Reader reader){
        auto result=VkDescriptorPoolSize();
    
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){(result.descriptorCount)=reader.getDescriptorCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorPoolSize member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorPoolSize member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorPoolCreateInfo::Builder& builder, VkDescriptorPoolCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setMaxSets((member.maxSets));}();
[&](){return builder.setPoolSizeCount((member.poolSizeCount));}();
[&](){
            if ((member.pPoolSizes)==NULL){
                builder.initPPoolSizes(0);
            return; }
        auto proto_arr=builder.initPPoolSizes(member.poolSizeCount);
        for(int cpawFXU=0; cpawFXU < member.poolSizeCount; cpawFXU++){
            [&](){
            auto temp=proto_arr[cpawFXU];
            return serialize_struct(temp, ((member.pPoolSizes)[cpawFXU]));
            }();
        }
        }();
}

    VkDescriptorPoolCreateInfo deserialize_struct(stream::VkDescriptorPoolCreateInfo::Reader reader){
        auto result=VkDescriptorPoolCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.maxSets)=reader.getMaxSets();}();
[&](){(result.poolSizeCount)=reader.getPoolSizeCount();}();
[&](){ VkDescriptorPoolSize* temp_CclESUy[&](){
            if (!reader.getPPoolSizes().size()==0){
                (result.pPoolSizes)=NULL;
            return; }{native_concat()}=(VkDescriptorPoolSize*)malloc(result.poolSizeCount*sizeof(VkDescriptorPoolSize));
        auto proto_arr=reader.getPPoolSizes(result.poolSizeCount);
        for(int IdhEcbd=0; IdhEcbd < result.poolSizeCount; IdhEcbd++){
            [&](){
            auto temp=proto_arr[IdhEcbd];
            ((result.pPoolSizes)[IdhEcbd])=deserialize_struct(temp);
            }();
        }
        }();(result.pPoolSizes)=temp_CclESUy;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorPoolCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorPoolCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetAllocateInfo::Builder& builder, VkDescriptorSetAllocateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDescriptorPool(serialize_handle(member.descriptorPool));}();
[&](){return builder.setDescriptorSetCount((member.descriptorSetCount));}();
[&](){
            if ((member.pSetLayouts)==NULL){
                builder.initPSetLayouts(0);
            return; }
        auto proto_arr=builder.initPSetLayouts(member.descriptorSetCount);
        for(int gfILRjy=0; gfILRjy < member.descriptorSetCount; gfILRjy++){
            [&](){return proto_arr.set(gfILRjy,serialize_handle((member.pSetLayouts)[gfILRjy]));}();
        }
        }();
}

    VkDescriptorSetAllocateInfo deserialize_struct(stream::VkDescriptorSetAllocateInfo::Reader reader){
        auto result=VkDescriptorSetAllocateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.descriptorPool)=deserialize_VkDescriptorPool(reader.getDescriptorPool());}();
[&](){(result.descriptorSetCount)=reader.getDescriptorSetCount();}();
[&](){ VkDescriptorSetLayout* temp_pqhsZKt[&](){
            if (!reader.getPSetLayouts().size()==0){
                (result.pSetLayouts)=NULL;
            return; }{native_concat()}=(VkDescriptorSetLayout*)malloc(result.descriptorSetCount*sizeof(VkDescriptorSetLayout));
        auto proto_arr=reader.getPSetLayouts(result.descriptorSetCount);
        for(int kjCEeqP=0; kjCEeqP < result.descriptorSetCount; kjCEeqP++){
            [&](){((result.pSetLayouts)[kjCEeqP])=deserialize_VkDescriptorSetLayout(proto_arr[kjCEeqP]);}();
        }
        }();(result.pSetLayouts)=temp_pqhsZKt;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetAllocateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetAllocateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSpecializationMapEntry::Builder& builder, VkSpecializationMapEntry member){
        
    
[&](){return builder.setConstantID((member.constantID));}();
[&](){return builder.setOffset((member.offset));}();
[&](){return builder.setSize((member.size));}();
}

    VkSpecializationMapEntry deserialize_struct(stream::VkSpecializationMapEntry::Reader reader){
        auto result=VkSpecializationMapEntry();
    
[&](){(result.constantID)=reader.getConstantID();}();
[&](){(result.offset)=reader.getOffset();}();
[&](){(result.size)=reader.getSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSpecializationMapEntry member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSpecializationMapEntry member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSpecializationInfo::Builder& builder, VkSpecializationInfo member){
        
    
[&](){return builder.setMapEntryCount((member.mapEntryCount));}();
[&](){
            if ((member.pMapEntries)==NULL){
                builder.initPMapEntries(0);
            return; }
        auto proto_arr=builder.initPMapEntries(member.mapEntryCount);
        for(int heBswyj=0; heBswyj < member.mapEntryCount; heBswyj++){
            [&](){
            auto temp=proto_arr[heBswyj];
            return serialize_struct(temp, ((member.pMapEntries)[heBswyj]));
            }();
        }
        }();
[&](){return builder.setDataSize((member.dataSize));}();
[&](){
            if ((member.pData)==NULL){
                builder.initPData(0);
            return; }[&](){
            if (((char*)(member.pData).pData)==NULL){
                builder.initPData(0);
            return; }
        auto proto_arr=builder.initPData(member.dataSize);
        for(int KUeyATI=0; KUeyATI < member.dataSize; KUeyATI++){
            [&](){return proto_arr.set(KUeyATI,(((char*)(member.pData).pData)[KUeyATI]));}();
        }
        }();}();
}

    VkSpecializationInfo deserialize_struct(stream::VkSpecializationInfo::Reader reader){
        auto result=VkSpecializationInfo();
    
[&](){(result.mapEntryCount)=reader.getMapEntryCount();}();
[&](){ VkSpecializationMapEntry* temp_LhdpHbT[&](){
            if (!reader.getPMapEntries().size()==0){
                (result.pMapEntries)=NULL;
            return; }{native_concat()}=(VkSpecializationMapEntry*)malloc(result.mapEntryCount*sizeof(VkSpecializationMapEntry));
        auto proto_arr=reader.getPMapEntries(result.mapEntryCount);
        for(int XLjYAsC=0; XLjYAsC < result.mapEntryCount; XLjYAsC++){
            [&](){
            auto temp=proto_arr[XLjYAsC];
            ((result.pMapEntries)[XLjYAsC])=deserialize_struct(temp);
            }();
        }
        }();(result.pMapEntries)=temp_LhdpHbT;}();
[&](){(result.dataSize)=reader.getDataSize();}();
[&](){ void* temp_RUIzmiy[&](){
            if (!reader.getPData().size()==0){
                (result.pData)=NULL;
            return; }char* temp_KoPqpjZ;[&](){
            if (!reader.getPData().size()==0){
                (temp_KoPqpjZ.pData)=NULL;
            return; }{native_concat()}=(char*)malloc(result.dataSize*sizeof(char));
        auto proto_arr=reader.getPData(result.dataSize);
        for(int OCmuZGI=0; OCmuZGI < result.dataSize; OCmuZGI++){
            [&](){((temp_KoPqpjZ.pData)[OCmuZGI])=proto_arr[OCmuZGI];}();
        }
        }();(result.pData)=temp_KoPqpjZ;}();(result.pData)=temp_RUIzmiy;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSpecializationInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSpecializationInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineShaderStageCreateInfo::Builder& builder, VkPipelineShaderStageCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setStage((member.stage));}();}();}();
[&](){return builder.setModule(serialize_handle(member.module));}();
[&](){
            if ((member.pName)==NULL){
                builder.initPName(0);
            return; }
        auto proto_arr=builder.initPName(strlen((member.pName))+1);
        for(int opTkazg=0; opTkazg < strlen((member.pName))+1; opTkazg++){
            [&](){return proto_arr.set(opTkazg,((member.pName)[opTkazg]));}();
        }
        }();
[&](){
            if ((member.pSpecializationInfo)==NULL){
                builder.initPSpecializationInfo(0);
            return; }
        auto proto_arr=builder.initPSpecializationInfo(1);
        for(int xbxpxgP=0; xbxpxgP < 1; xbxpxgP++){
            [&](){
            auto temp=proto_arr[xbxpxgP];
            return serialize_struct(temp, ((member.pSpecializationInfo)[xbxpxgP]));
            }();
        }
        }();
}

    VkPipelineShaderStageCreateInfo deserialize_struct(stream::VkPipelineShaderStageCreateInfo::Reader reader){
        auto result=VkPipelineShaderStageCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.stage)=reader.getStage();}();}();}();
[&](){(result.module)=deserialize_VkShaderModule(reader.getModule());}();
[&](){ char* temp_xDKNBiw[&](){
            if (!reader.getPName().size()==0){
                (result.pName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPName().size();*sizeof(char));
        auto proto_arr=reader.getPName(reader.getPName().size(););
        for(int zzMOHXu=0; zzMOHXu < reader.getPName().size();; zzMOHXu++){
            [&](){((result.pName)[zzMOHXu])=proto_arr[zzMOHXu];}();
        }
        }();(result.pName)=temp_xDKNBiw;}();
[&](){ VkSpecializationInfo* temp_mZLjDhf[&](){
            if (!reader.getPSpecializationInfo().size()==0){
                (result.pSpecializationInfo)=NULL;
            return; }{native_concat()}=(VkSpecializationInfo*)malloc(1*sizeof(VkSpecializationInfo));
        auto proto_arr=reader.getPSpecializationInfo(1);
        for(int ZWKvpYr=0; ZWKvpYr < 1; ZWKvpYr++){
            [&](){
            auto temp=proto_arr[ZWKvpYr];
            ((result.pSpecializationInfo)[ZWKvpYr])=deserialize_struct(temp);
            }();
        }
        }();(result.pSpecializationInfo)=temp_mZLjDhf;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineShaderStageCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineShaderStageCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkComputePipelineCreateInfo::Builder& builder, VkComputePipelineCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            auto temp=builder.initStage(stage);
            return serialize_struct(temp, (member.stage));
            }();
[&](){return builder.setLayout(serialize_handle(member.layout));}();
[&](){return builder.setBasePipelineHandle(serialize_handle(member.basePipelineHandle));}();
[&](){return builder.setBasePipelineIndex((member.basePipelineIndex));}();
}

    VkComputePipelineCreateInfo deserialize_struct(stream::VkComputePipelineCreateInfo::Reader reader){
        auto result=VkComputePipelineCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
            auto temp=reader.getStage();
            (result.stage)=deserialize_struct(temp);
            }();
[&](){(result.layout)=deserialize_VkPipelineLayout(reader.getLayout());}();
[&](){(result.basePipelineHandle)=deserialize_VkPipeline(reader.getBasePipelineHandle());}();
[&](){(result.basePipelineIndex)=reader.getBasePipelineIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkComputePipelineCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkComputePipelineCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkComputePipelineIndirectBufferInfoNV::Builder& builder, VkComputePipelineIndirectBufferInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){return builder.setPipelineDeviceAddressCaptureReplay((member.pipelineDeviceAddressCaptureReplay));}();}();
}

    VkComputePipelineIndirectBufferInfoNV deserialize_struct(stream::VkComputePipelineIndirectBufferInfoNV::Reader reader){
        auto result=VkComputePipelineIndirectBufferInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){(result.pipelineDeviceAddressCaptureReplay)=reader.getPipelineDeviceAddressCaptureReplay();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkComputePipelineIndirectBufferInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkComputePipelineIndirectBufferInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCreateFlags2CreateInfoKHR::Builder& builder, VkPipelineCreateFlags2CreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkPipelineCreateFlags2CreateInfoKHR deserialize_struct(stream::VkPipelineCreateFlags2CreateInfoKHR::Reader reader){
        auto result=VkPipelineCreateFlags2CreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCreateFlags2CreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCreateFlags2CreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVertexInputBindingDescription::Builder& builder, VkVertexInputBindingDescription member){
        
    
[&](){return builder.setBinding((member.binding));}();
[&](){return builder.setStride((member.stride));}();
[&](){[&](){[&](){return builder.setInputRate((member.inputRate));}();}();}();
}

    VkVertexInputBindingDescription deserialize_struct(stream::VkVertexInputBindingDescription::Reader reader){
        auto result=VkVertexInputBindingDescription();
    
[&](){(result.binding)=reader.getBinding();}();
[&](){(result.stride)=reader.getStride();}();
[&](){[&](){[&](){(result.inputRate)=reader.getInputRate();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVertexInputBindingDescription member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVertexInputBindingDescription member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVertexInputAttributeDescription::Builder& builder, VkVertexInputAttributeDescription member){
        
    
[&](){return builder.setLocation((member.location));}();
[&](){return builder.setBinding((member.binding));}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){return builder.setOffset((member.offset));}();
}

    VkVertexInputAttributeDescription deserialize_struct(stream::VkVertexInputAttributeDescription::Reader reader){
        auto result=VkVertexInputAttributeDescription();
    
[&](){(result.location)=reader.getLocation();}();
[&](){(result.binding)=reader.getBinding();}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){(result.offset)=reader.getOffset();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVertexInputAttributeDescription member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVertexInputAttributeDescription member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineVertexInputStateCreateInfo::Builder& builder, VkPipelineVertexInputStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setVertexBindingDescriptionCount((member.vertexBindingDescriptionCount));}();
[&](){
            if ((member.pVertexBindingDescriptions)==NULL){
                builder.initPVertexBindingDescriptions(0);
            return; }
        auto proto_arr=builder.initPVertexBindingDescriptions(member.vertexBindingDescriptionCount);
        for(int UYAeNka=0; UYAeNka < member.vertexBindingDescriptionCount; UYAeNka++){
            [&](){
            auto temp=proto_arr[UYAeNka];
            return serialize_struct(temp, ((member.pVertexBindingDescriptions)[UYAeNka]));
            }();
        }
        }();
[&](){return builder.setVertexAttributeDescriptionCount((member.vertexAttributeDescriptionCount));}();
[&](){
            if ((member.pVertexAttributeDescriptions)==NULL){
                builder.initPVertexAttributeDescriptions(0);
            return; }
        auto proto_arr=builder.initPVertexAttributeDescriptions(member.vertexAttributeDescriptionCount);
        for(int RsYbObC=0; RsYbObC < member.vertexAttributeDescriptionCount; RsYbObC++){
            [&](){
            auto temp=proto_arr[RsYbObC];
            return serialize_struct(temp, ((member.pVertexAttributeDescriptions)[RsYbObC]));
            }();
        }
        }();
}

    VkPipelineVertexInputStateCreateInfo deserialize_struct(stream::VkPipelineVertexInputStateCreateInfo::Reader reader){
        auto result=VkPipelineVertexInputStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.vertexBindingDescriptionCount)=reader.getVertexBindingDescriptionCount();}();
[&](){ VkVertexInputBindingDescription* temp_tIwgstl[&](){
            if (!reader.getPVertexBindingDescriptions().size()==0){
                (result.pVertexBindingDescriptions)=NULL;
            return; }{native_concat()}=(VkVertexInputBindingDescription*)malloc(result.vertexBindingDescriptionCount*sizeof(VkVertexInputBindingDescription));
        auto proto_arr=reader.getPVertexBindingDescriptions(result.vertexBindingDescriptionCount);
        for(int OSCEDEw=0; OSCEDEw < result.vertexBindingDescriptionCount; OSCEDEw++){
            [&](){
            auto temp=proto_arr[OSCEDEw];
            ((result.pVertexBindingDescriptions)[OSCEDEw])=deserialize_struct(temp);
            }();
        }
        }();(result.pVertexBindingDescriptions)=temp_tIwgstl;}();
[&](){(result.vertexAttributeDescriptionCount)=reader.getVertexAttributeDescriptionCount();}();
[&](){ VkVertexInputAttributeDescription* temp_TUrVxbd[&](){
            if (!reader.getPVertexAttributeDescriptions().size()==0){
                (result.pVertexAttributeDescriptions)=NULL;
            return; }{native_concat()}=(VkVertexInputAttributeDescription*)malloc(result.vertexAttributeDescriptionCount*sizeof(VkVertexInputAttributeDescription));
        auto proto_arr=reader.getPVertexAttributeDescriptions(result.vertexAttributeDescriptionCount);
        for(int CvxmTtW=0; CvxmTtW < result.vertexAttributeDescriptionCount; CvxmTtW++){
            [&](){
            auto temp=proto_arr[CvxmTtW];
            ((result.pVertexAttributeDescriptions)[CvxmTtW])=deserialize_struct(temp);
            }();
        }
        }();(result.pVertexAttributeDescriptions)=temp_TUrVxbd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineVertexInputStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineVertexInputStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineInputAssemblyStateCreateInfo::Builder& builder, VkPipelineInputAssemblyStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setTopology((member.topology));}();}();}();
[&](){[&](){return builder.setPrimitiveRestartEnable((member.primitiveRestartEnable));}();}();
}

    VkPipelineInputAssemblyStateCreateInfo deserialize_struct(stream::VkPipelineInputAssemblyStateCreateInfo::Reader reader){
        auto result=VkPipelineInputAssemblyStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.topology)=reader.getTopology();}();}();}();
[&](){[&](){(result.primitiveRestartEnable)=reader.getPrimitiveRestartEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineInputAssemblyStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineInputAssemblyStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineTessellationStateCreateInfo::Builder& builder, VkPipelineTessellationStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setPatchControlPoints((member.patchControlPoints));}();
}

    VkPipelineTessellationStateCreateInfo deserialize_struct(stream::VkPipelineTessellationStateCreateInfo::Reader reader){
        auto result=VkPipelineTessellationStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.patchControlPoints)=reader.getPatchControlPoints();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineTessellationStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineTessellationStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineViewportStateCreateInfo::Builder& builder, VkPipelineViewportStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setViewportCount((member.viewportCount));}();
[&](){
            if ((member.pViewports)==NULL){
                builder.initPViewports(0);
            return; }
        auto proto_arr=builder.initPViewports(member.viewportCount);
        for(int nudoDfU=0; nudoDfU < member.viewportCount; nudoDfU++){
            [&](){
            auto temp=proto_arr[nudoDfU];
            return serialize_struct(temp, ((member.pViewports)[nudoDfU]));
            }();
        }
        }();
[&](){return builder.setScissorCount((member.scissorCount));}();
[&](){
            if ((member.pScissors)==NULL){
                builder.initPScissors(0);
            return; }
        auto proto_arr=builder.initPScissors(member.scissorCount);
        for(int fZdpvXx=0; fZdpvXx < member.scissorCount; fZdpvXx++){
            [&](){
            auto temp=proto_arr[fZdpvXx];
            return serialize_struct(temp, ((member.pScissors)[fZdpvXx]));
            }();
        }
        }();
}

    VkPipelineViewportStateCreateInfo deserialize_struct(stream::VkPipelineViewportStateCreateInfo::Reader reader){
        auto result=VkPipelineViewportStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.viewportCount)=reader.getViewportCount();}();
[&](){ VkViewport* temp_krEdrLQ[&](){
            if (!reader.getPViewports().size()==0){
                (result.pViewports)=NULL;
            return; }{native_concat()}=(VkViewport*)malloc(result.viewportCount*sizeof(VkViewport));
        auto proto_arr=reader.getPViewports(result.viewportCount);
        for(int joicTxZ=0; joicTxZ < result.viewportCount; joicTxZ++){
            [&](){
            auto temp=proto_arr[joicTxZ];
            ((result.pViewports)[joicTxZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pViewports)=temp_krEdrLQ;}();
[&](){(result.scissorCount)=reader.getScissorCount();}();
[&](){ VkRect2D* temp_luRjaix[&](){
            if (!reader.getPScissors().size()==0){
                (result.pScissors)=NULL;
            return; }{native_concat()}=(VkRect2D*)malloc(result.scissorCount*sizeof(VkRect2D));
        auto proto_arr=reader.getPScissors(result.scissorCount);
        for(int jztdrHP=0; jztdrHP < result.scissorCount; jztdrHP++){
            [&](){
            auto temp=proto_arr[jztdrHP];
            ((result.pScissors)[jztdrHP])=deserialize_struct(temp);
            }();
        }
        }();(result.pScissors)=temp_luRjaix;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineViewportStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineViewportStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRasterizationStateCreateInfo::Builder& builder, VkPipelineRasterizationStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setDepthClampEnable((member.depthClampEnable));}();}();
[&](){[&](){return builder.setRasterizerDiscardEnable((member.rasterizerDiscardEnable));}();}();
[&](){[&](){[&](){return builder.setPolygonMode((member.polygonMode));}();}();}();
[&](){[&](){[&](){return builder.setCullMode((member.cullMode));}();}();}();
[&](){[&](){[&](){return builder.setFrontFace((member.frontFace));}();}();}();
[&](){[&](){return builder.setDepthBiasEnable((member.depthBiasEnable));}();}();
[&](){return builder.setDepthBiasConstantFactor((member.depthBiasConstantFactor));}();
[&](){return builder.setDepthBiasClamp((member.depthBiasClamp));}();
[&](){return builder.setDepthBiasSlopeFactor((member.depthBiasSlopeFactor));}();
[&](){return builder.setLineWidth((member.lineWidth));}();
}

    VkPipelineRasterizationStateCreateInfo deserialize_struct(stream::VkPipelineRasterizationStateCreateInfo::Reader reader){
        auto result=VkPipelineRasterizationStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.depthClampEnable)=reader.getDepthClampEnable();}();}();
[&](){[&](){(result.rasterizerDiscardEnable)=reader.getRasterizerDiscardEnable();}();}();
[&](){[&](){[&](){(result.polygonMode)=reader.getPolygonMode();}();}();}();
[&](){[&](){[&](){(result.cullMode)=reader.getCullMode();}();}();}();
[&](){[&](){[&](){(result.frontFace)=reader.getFrontFace();}();}();}();
[&](){[&](){(result.depthBiasEnable)=reader.getDepthBiasEnable();}();}();
[&](){(result.depthBiasConstantFactor)=reader.getDepthBiasConstantFactor();}();
[&](){(result.depthBiasClamp)=reader.getDepthBiasClamp();}();
[&](){(result.depthBiasSlopeFactor)=reader.getDepthBiasSlopeFactor();}();
[&](){(result.lineWidth)=reader.getLineWidth();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRasterizationStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRasterizationStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineMultisampleStateCreateInfo::Builder& builder, VkPipelineMultisampleStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setRasterizationSamples((member.rasterizationSamples));}();}();}();
[&](){[&](){return builder.setSampleShadingEnable((member.sampleShadingEnable));}();}();
[&](){return builder.setMinSampleShading((member.minSampleShading));}();
[&](){
            if ((member.pSampleMask)==NULL){
                builder.initPSampleMask(0);
            return; }
        auto proto_arr=builder.initPSampleMask((member.rasterizationSamples + 31) / 32);
        for(int KkmOuEW=0; KkmOuEW < (member.rasterizationSamples + 31) / 32; KkmOuEW++){
            [&](){[&](){return proto_arr.set(KkmOuEW,((member.pSampleMask)[KkmOuEW]));}();}();
        }
        }();
[&](){[&](){return builder.setAlphaToCoverageEnable((member.alphaToCoverageEnable));}();}();
[&](){[&](){return builder.setAlphaToOneEnable((member.alphaToOneEnable));}();}();
}

    VkPipelineMultisampleStateCreateInfo deserialize_struct(stream::VkPipelineMultisampleStateCreateInfo::Reader reader){
        auto result=VkPipelineMultisampleStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.rasterizationSamples)=reader.getRasterizationSamples();}();}();}();
[&](){[&](){(result.sampleShadingEnable)=reader.getSampleShadingEnable();}();}();
[&](){(result.minSampleShading)=reader.getMinSampleShading();}();
[&](){ VkSampleMask* temp_iFbtOnI[&](){
            if (!reader.getPSampleMask().size()==0){
                (result.pSampleMask)=NULL;
            return; }{native_concat()}=(VkSampleMask*)malloc((result.rasterizationSamples + 31) / 32*sizeof(VkSampleMask));
        auto proto_arr=reader.getPSampleMask((result.rasterizationSamples + 31) / 32);
        for(int DkRZSWg=0; DkRZSWg < (result.rasterizationSamples + 31) / 32; DkRZSWg++){
            [&](){[&](){((result.pSampleMask)[DkRZSWg])=proto_arr[DkRZSWg];}();}();
        }
        }();(result.pSampleMask)=temp_iFbtOnI;}();
[&](){[&](){(result.alphaToCoverageEnable)=reader.getAlphaToCoverageEnable();}();}();
[&](){[&](){(result.alphaToOneEnable)=reader.getAlphaToOneEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineMultisampleStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineMultisampleStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineColorBlendAttachmentState::Builder& builder, VkPipelineColorBlendAttachmentState member){
        
    
[&](){[&](){return builder.setBlendEnable((member.blendEnable));}();}();
[&](){[&](){[&](){return builder.setSrcColorBlendFactor((member.srcColorBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setDstColorBlendFactor((member.dstColorBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setColorBlendOp((member.colorBlendOp));}();}();}();
[&](){[&](){[&](){return builder.setSrcAlphaBlendFactor((member.srcAlphaBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setDstAlphaBlendFactor((member.dstAlphaBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setAlphaBlendOp((member.alphaBlendOp));}();}();}();
[&](){[&](){[&](){return builder.setColorWriteMask((member.colorWriteMask));}();}();}();
}

    VkPipelineColorBlendAttachmentState deserialize_struct(stream::VkPipelineColorBlendAttachmentState::Reader reader){
        auto result=VkPipelineColorBlendAttachmentState();
    
[&](){[&](){(result.blendEnable)=reader.getBlendEnable();}();}();
[&](){[&](){[&](){(result.srcColorBlendFactor)=reader.getSrcColorBlendFactor();}();}();}();
[&](){[&](){[&](){(result.dstColorBlendFactor)=reader.getDstColorBlendFactor();}();}();}();
[&](){[&](){[&](){(result.colorBlendOp)=reader.getColorBlendOp();}();}();}();
[&](){[&](){[&](){(result.srcAlphaBlendFactor)=reader.getSrcAlphaBlendFactor();}();}();}();
[&](){[&](){[&](){(result.dstAlphaBlendFactor)=reader.getDstAlphaBlendFactor();}();}();}();
[&](){[&](){[&](){(result.alphaBlendOp)=reader.getAlphaBlendOp();}();}();}();
[&](){[&](){[&](){(result.colorWriteMask)=reader.getColorWriteMask();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineColorBlendAttachmentState member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineColorBlendAttachmentState member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineColorBlendStateCreateInfo::Builder& builder, VkPipelineColorBlendStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setLogicOpEnable((member.logicOpEnable));}();}();
[&](){[&](){[&](){return builder.setLogicOp((member.logicOp));}();}();}();
[&](){return builder.setAttachmentCount((member.attachmentCount));}();
[&](){
            if ((member.pAttachments)==NULL){
                builder.initPAttachments(0);
            return; }
        auto proto_arr=builder.initPAttachments(member.attachmentCount);
        for(int UeoCLDk=0; UeoCLDk < member.attachmentCount; UeoCLDk++){
            [&](){
            auto temp=proto_arr[UeoCLDk];
            return serialize_struct(temp, ((member.pAttachments)[UeoCLDk]));
            }();
        }
        }();
[&](){
        auto proto_arr=builder.initBlendConstants(4);
        for(int hihyfbp=0; hihyfbp < 4; hihyfbp++){
            [&](){return proto_arr.set(hihyfbp,((member.blendConstants)[hihyfbp]));}();
        }
        }();
}

    VkPipelineColorBlendStateCreateInfo deserialize_struct(stream::VkPipelineColorBlendStateCreateInfo::Reader reader){
        auto result=VkPipelineColorBlendStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.logicOpEnable)=reader.getLogicOpEnable();}();}();
[&](){[&](){[&](){(result.logicOp)=reader.getLogicOp();}();}();}();
[&](){(result.attachmentCount)=reader.getAttachmentCount();}();
[&](){ VkPipelineColorBlendAttachmentState* temp_bpKOhtp[&](){
            if (!reader.getPAttachments().size()==0){
                (result.pAttachments)=NULL;
            return; }{native_concat()}=(VkPipelineColorBlendAttachmentState*)malloc(result.attachmentCount*sizeof(VkPipelineColorBlendAttachmentState));
        auto proto_arr=reader.getPAttachments(result.attachmentCount);
        for(int ncYTsSD=0; ncYTsSD < result.attachmentCount; ncYTsSD++){
            [&](){
            auto temp=proto_arr[ncYTsSD];
            ((result.pAttachments)[ncYTsSD])=deserialize_struct(temp);
            }();
        }
        }();(result.pAttachments)=temp_bpKOhtp;}();
[&](){
        auto proto_arr=reader.getBlendConstants(4);
        for(int hihyfbp=0; hihyfbp < 4; hihyfbp++){
            [&](){((result.blendConstants)[hihyfbp])=proto_arr[hihyfbp];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineColorBlendStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineColorBlendStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineDynamicStateCreateInfo::Builder& builder, VkPipelineDynamicStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setDynamicStateCount((member.dynamicStateCount));}();
[&](){
            if ((member.pDynamicStates)==NULL){
                builder.initPDynamicStates(0);
            return; }
        auto proto_arr=builder.initPDynamicStates(member.dynamicStateCount);
        for(int aeBshMh=0; aeBshMh < member.dynamicStateCount; aeBshMh++){
            [&](){[&](){[&](){return proto_arr.set(aeBshMh,((member.pDynamicStates)[aeBshMh]));}();}();}();
        }
        }();
}

    VkPipelineDynamicStateCreateInfo deserialize_struct(stream::VkPipelineDynamicStateCreateInfo::Reader reader){
        auto result=VkPipelineDynamicStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.dynamicStateCount)=reader.getDynamicStateCount();}();
[&](){ VkDynamicState* temp_WyEatFJ[&](){
            if (!reader.getPDynamicStates().size()==0){
                (result.pDynamicStates)=NULL;
            return; }{native_concat()}=(VkDynamicState*)malloc(result.dynamicStateCount*sizeof(VkDynamicState));
        auto proto_arr=reader.getPDynamicStates(result.dynamicStateCount);
        for(int gZGZxPA=0; gZGZxPA < result.dynamicStateCount; gZGZxPA++){
            [&](){[&](){[&](){((result.pDynamicStates)[gZGZxPA])=proto_arr[gZGZxPA];}();}();}();
        }
        }();(result.pDynamicStates)=temp_WyEatFJ;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineDynamicStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineDynamicStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkStencilOpState::Builder& builder, VkStencilOpState member){
        
    
[&](){[&](){[&](){return builder.setFailOp((member.failOp));}();}();}();
[&](){[&](){[&](){return builder.setPassOp((member.passOp));}();}();}();
[&](){[&](){[&](){return builder.setDepthFailOp((member.depthFailOp));}();}();}();
[&](){[&](){[&](){return builder.setCompareOp((member.compareOp));}();}();}();
[&](){return builder.setCompareMask((member.compareMask));}();
[&](){return builder.setWriteMask((member.writeMask));}();
[&](){return builder.setReference((member.reference));}();
}

    VkStencilOpState deserialize_struct(stream::VkStencilOpState::Reader reader){
        auto result=VkStencilOpState();
    
[&](){[&](){[&](){(result.failOp)=reader.getFailOp();}();}();}();
[&](){[&](){[&](){(result.passOp)=reader.getPassOp();}();}();}();
[&](){[&](){[&](){(result.depthFailOp)=reader.getDepthFailOp();}();}();}();
[&](){[&](){[&](){(result.compareOp)=reader.getCompareOp();}();}();}();
[&](){(result.compareMask)=reader.getCompareMask();}();
[&](){(result.writeMask)=reader.getWriteMask();}();
[&](){(result.reference)=reader.getReference();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkStencilOpState member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkStencilOpState member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineDepthStencilStateCreateInfo::Builder& builder, VkPipelineDepthStencilStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setDepthTestEnable((member.depthTestEnable));}();}();
[&](){[&](){return builder.setDepthWriteEnable((member.depthWriteEnable));}();}();
[&](){[&](){[&](){return builder.setDepthCompareOp((member.depthCompareOp));}();}();}();
[&](){[&](){return builder.setDepthBoundsTestEnable((member.depthBoundsTestEnable));}();}();
[&](){[&](){return builder.setStencilTestEnable((member.stencilTestEnable));}();}();
[&](){
            auto temp=builder.initFront(front);
            return serialize_struct(temp, (member.front));
            }();
[&](){
            auto temp=builder.initBack(back);
            return serialize_struct(temp, (member.back));
            }();
[&](){return builder.setMinDepthBounds((member.minDepthBounds));}();
[&](){return builder.setMaxDepthBounds((member.maxDepthBounds));}();
}

    VkPipelineDepthStencilStateCreateInfo deserialize_struct(stream::VkPipelineDepthStencilStateCreateInfo::Reader reader){
        auto result=VkPipelineDepthStencilStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.depthTestEnable)=reader.getDepthTestEnable();}();}();
[&](){[&](){(result.depthWriteEnable)=reader.getDepthWriteEnable();}();}();
[&](){[&](){[&](){(result.depthCompareOp)=reader.getDepthCompareOp();}();}();}();
[&](){[&](){(result.depthBoundsTestEnable)=reader.getDepthBoundsTestEnable();}();}();
[&](){[&](){(result.stencilTestEnable)=reader.getStencilTestEnable();}();}();
[&](){
            auto temp=reader.getFront();
            (result.front)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getBack();
            (result.back)=deserialize_struct(temp);
            }();
[&](){(result.minDepthBounds)=reader.getMinDepthBounds();}();
[&](){(result.maxDepthBounds)=reader.getMaxDepthBounds();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineDepthStencilStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineDepthStencilStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGraphicsPipelineCreateInfo::Builder& builder, VkGraphicsPipelineCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setStageCount((member.stageCount));}();
[&](){
            if ((member.pStages)==NULL){
                builder.initPStages(0);
            return; }
        auto proto_arr=builder.initPStages(member.stageCount);
        for(int jHuRulk=0; jHuRulk < member.stageCount; jHuRulk++){
            [&](){
            auto temp=proto_arr[jHuRulk];
            return serialize_struct(temp, ((member.pStages)[jHuRulk]));
            }();
        }
        }();
[&](){
            if ((member.pVertexInputState)==NULL){
                builder.initPVertexInputState(0);
            return; }
        auto proto_arr=builder.initPVertexInputState(1);
        for(int wkXjKqh=0; wkXjKqh < 1; wkXjKqh++){
            [&](){
            auto temp=proto_arr[wkXjKqh];
            return serialize_struct(temp, ((member.pVertexInputState)[wkXjKqh]));
            }();
        }
        }();
[&](){
            if ((member.pInputAssemblyState)==NULL){
                builder.initPInputAssemblyState(0);
            return; }
        auto proto_arr=builder.initPInputAssemblyState(1);
        for(int eNpRXIQ=0; eNpRXIQ < 1; eNpRXIQ++){
            [&](){
            auto temp=proto_arr[eNpRXIQ];
            return serialize_struct(temp, ((member.pInputAssemblyState)[eNpRXIQ]));
            }();
        }
        }();
[&](){
            if ((member.pTessellationState)==NULL){
                builder.initPTessellationState(0);
            return; }
        auto proto_arr=builder.initPTessellationState(1);
        for(int rSxHnEH=0; rSxHnEH < 1; rSxHnEH++){
            [&](){
            auto temp=proto_arr[rSxHnEH];
            return serialize_struct(temp, ((member.pTessellationState)[rSxHnEH]));
            }();
        }
        }();
[&](){
            if ((member.pViewportState)==NULL){
                builder.initPViewportState(0);
            return; }
        auto proto_arr=builder.initPViewportState(1);
        for(int HszcYXw=0; HszcYXw < 1; HszcYXw++){
            [&](){
            auto temp=proto_arr[HszcYXw];
            return serialize_struct(temp, ((member.pViewportState)[HszcYXw]));
            }();
        }
        }();
[&](){
            if ((member.pRasterizationState)==NULL){
                builder.initPRasterizationState(0);
            return; }
        auto proto_arr=builder.initPRasterizationState(1);
        for(int YHpJqRW=0; YHpJqRW < 1; YHpJqRW++){
            [&](){
            auto temp=proto_arr[YHpJqRW];
            return serialize_struct(temp, ((member.pRasterizationState)[YHpJqRW]));
            }();
        }
        }();
[&](){
            if ((member.pMultisampleState)==NULL){
                builder.initPMultisampleState(0);
            return; }
        auto proto_arr=builder.initPMultisampleState(1);
        for(int itMmQwR=0; itMmQwR < 1; itMmQwR++){
            [&](){
            auto temp=proto_arr[itMmQwR];
            return serialize_struct(temp, ((member.pMultisampleState)[itMmQwR]));
            }();
        }
        }();
[&](){
            if ((member.pDepthStencilState)==NULL){
                builder.initPDepthStencilState(0);
            return; }
        auto proto_arr=builder.initPDepthStencilState(1);
        for(int dZXqjNN=0; dZXqjNN < 1; dZXqjNN++){
            [&](){
            auto temp=proto_arr[dZXqjNN];
            return serialize_struct(temp, ((member.pDepthStencilState)[dZXqjNN]));
            }();
        }
        }();
[&](){
            if ((member.pColorBlendState)==NULL){
                builder.initPColorBlendState(0);
            return; }
        auto proto_arr=builder.initPColorBlendState(1);
        for(int PZsHAXm=0; PZsHAXm < 1; PZsHAXm++){
            [&](){
            auto temp=proto_arr[PZsHAXm];
            return serialize_struct(temp, ((member.pColorBlendState)[PZsHAXm]));
            }();
        }
        }();
[&](){
            if ((member.pDynamicState)==NULL){
                builder.initPDynamicState(0);
            return; }
        auto proto_arr=builder.initPDynamicState(1);
        for(int UhXMcnS=0; UhXMcnS < 1; UhXMcnS++){
            [&](){
            auto temp=proto_arr[UhXMcnS];
            return serialize_struct(temp, ((member.pDynamicState)[UhXMcnS]));
            }();
        }
        }();
[&](){return builder.setLayout(serialize_handle(member.layout));}();
[&](){return builder.setRenderPass(serialize_handle(member.renderPass));}();
[&](){return builder.setSubpass((member.subpass));}();
[&](){return builder.setBasePipelineHandle(serialize_handle(member.basePipelineHandle));}();
[&](){return builder.setBasePipelineIndex((member.basePipelineIndex));}();
}

    VkGraphicsPipelineCreateInfo deserialize_struct(stream::VkGraphicsPipelineCreateInfo::Reader reader){
        auto result=VkGraphicsPipelineCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.stageCount)=reader.getStageCount();}();
[&](){ VkPipelineShaderStageCreateInfo* temp_FsQxpon[&](){
            if (!reader.getPStages().size()==0){
                (result.pStages)=NULL;
            return; }{native_concat()}=(VkPipelineShaderStageCreateInfo*)malloc(result.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto proto_arr=reader.getPStages(result.stageCount);
        for(int XttzcgZ=0; XttzcgZ < result.stageCount; XttzcgZ++){
            [&](){
            auto temp=proto_arr[XttzcgZ];
            ((result.pStages)[XttzcgZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pStages)=temp_FsQxpon;}();
[&](){ VkPipelineVertexInputStateCreateInfo* temp_GRDNOgA[&](){
            if (!reader.getPVertexInputState().size()==0){
                (result.pVertexInputState)=NULL;
            return; }{native_concat()}=(VkPipelineVertexInputStateCreateInfo*)malloc(1*sizeof(VkPipelineVertexInputStateCreateInfo));
        auto proto_arr=reader.getPVertexInputState(1);
        for(int RFpaRUE=0; RFpaRUE < 1; RFpaRUE++){
            [&](){
            auto temp=proto_arr[RFpaRUE];
            ((result.pVertexInputState)[RFpaRUE])=deserialize_struct(temp);
            }();
        }
        }();(result.pVertexInputState)=temp_GRDNOgA;}();
[&](){ VkPipelineInputAssemblyStateCreateInfo* temp_oaVANCx[&](){
            if (!reader.getPInputAssemblyState().size()==0){
                (result.pInputAssemblyState)=NULL;
            return; }{native_concat()}=(VkPipelineInputAssemblyStateCreateInfo*)malloc(1*sizeof(VkPipelineInputAssemblyStateCreateInfo));
        auto proto_arr=reader.getPInputAssemblyState(1);
        for(int LCsVUxO=0; LCsVUxO < 1; LCsVUxO++){
            [&](){
            auto temp=proto_arr[LCsVUxO];
            ((result.pInputAssemblyState)[LCsVUxO])=deserialize_struct(temp);
            }();
        }
        }();(result.pInputAssemblyState)=temp_oaVANCx;}();
[&](){ VkPipelineTessellationStateCreateInfo* temp_LTmoKJi[&](){
            if (!reader.getPTessellationState().size()==0){
                (result.pTessellationState)=NULL;
            return; }{native_concat()}=(VkPipelineTessellationStateCreateInfo*)malloc(1*sizeof(VkPipelineTessellationStateCreateInfo));
        auto proto_arr=reader.getPTessellationState(1);
        for(int QktcRuM=0; QktcRuM < 1; QktcRuM++){
            [&](){
            auto temp=proto_arr[QktcRuM];
            ((result.pTessellationState)[QktcRuM])=deserialize_struct(temp);
            }();
        }
        }();(result.pTessellationState)=temp_LTmoKJi;}();
[&](){ VkPipelineViewportStateCreateInfo* temp_utrxeew[&](){
            if (!reader.getPViewportState().size()==0){
                (result.pViewportState)=NULL;
            return; }{native_concat()}=(VkPipelineViewportStateCreateInfo*)malloc(1*sizeof(VkPipelineViewportStateCreateInfo));
        auto proto_arr=reader.getPViewportState(1);
        for(int BstHynL=0; BstHynL < 1; BstHynL++){
            [&](){
            auto temp=proto_arr[BstHynL];
            ((result.pViewportState)[BstHynL])=deserialize_struct(temp);
            }();
        }
        }();(result.pViewportState)=temp_utrxeew;}();
[&](){ VkPipelineRasterizationStateCreateInfo* temp_UeVfMZa[&](){
            if (!reader.getPRasterizationState().size()==0){
                (result.pRasterizationState)=NULL;
            return; }{native_concat()}=(VkPipelineRasterizationStateCreateInfo*)malloc(1*sizeof(VkPipelineRasterizationStateCreateInfo));
        auto proto_arr=reader.getPRasterizationState(1);
        for(int UrKpYID=0; UrKpYID < 1; UrKpYID++){
            [&](){
            auto temp=proto_arr[UrKpYID];
            ((result.pRasterizationState)[UrKpYID])=deserialize_struct(temp);
            }();
        }
        }();(result.pRasterizationState)=temp_UeVfMZa;}();
[&](){ VkPipelineMultisampleStateCreateInfo* temp_pwIOJfB[&](){
            if (!reader.getPMultisampleState().size()==0){
                (result.pMultisampleState)=NULL;
            return; }{native_concat()}=(VkPipelineMultisampleStateCreateInfo*)malloc(1*sizeof(VkPipelineMultisampleStateCreateInfo));
        auto proto_arr=reader.getPMultisampleState(1);
        for(int mkZpyGN=0; mkZpyGN < 1; mkZpyGN++){
            [&](){
            auto temp=proto_arr[mkZpyGN];
            ((result.pMultisampleState)[mkZpyGN])=deserialize_struct(temp);
            }();
        }
        }();(result.pMultisampleState)=temp_pwIOJfB;}();
[&](){ VkPipelineDepthStencilStateCreateInfo* temp_SgjgObT[&](){
            if (!reader.getPDepthStencilState().size()==0){
                (result.pDepthStencilState)=NULL;
            return; }{native_concat()}=(VkPipelineDepthStencilStateCreateInfo*)malloc(1*sizeof(VkPipelineDepthStencilStateCreateInfo));
        auto proto_arr=reader.getPDepthStencilState(1);
        for(int fcBDTZt=0; fcBDTZt < 1; fcBDTZt++){
            [&](){
            auto temp=proto_arr[fcBDTZt];
            ((result.pDepthStencilState)[fcBDTZt])=deserialize_struct(temp);
            }();
        }
        }();(result.pDepthStencilState)=temp_SgjgObT;}();
[&](){ VkPipelineColorBlendStateCreateInfo* temp_dPxXxzH[&](){
            if (!reader.getPColorBlendState().size()==0){
                (result.pColorBlendState)=NULL;
            return; }{native_concat()}=(VkPipelineColorBlendStateCreateInfo*)malloc(1*sizeof(VkPipelineColorBlendStateCreateInfo));
        auto proto_arr=reader.getPColorBlendState(1);
        for(int imvOMcm=0; imvOMcm < 1; imvOMcm++){
            [&](){
            auto temp=proto_arr[imvOMcm];
            ((result.pColorBlendState)[imvOMcm])=deserialize_struct(temp);
            }();
        }
        }();(result.pColorBlendState)=temp_dPxXxzH;}();
[&](){ VkPipelineDynamicStateCreateInfo* temp_aXXcKaH[&](){
            if (!reader.getPDynamicState().size()==0){
                (result.pDynamicState)=NULL;
            return; }{native_concat()}=(VkPipelineDynamicStateCreateInfo*)malloc(1*sizeof(VkPipelineDynamicStateCreateInfo));
        auto proto_arr=reader.getPDynamicState(1);
        for(int tTovUVg=0; tTovUVg < 1; tTovUVg++){
            [&](){
            auto temp=proto_arr[tTovUVg];
            ((result.pDynamicState)[tTovUVg])=deserialize_struct(temp);
            }();
        }
        }();(result.pDynamicState)=temp_aXXcKaH;}();
[&](){(result.layout)=deserialize_VkPipelineLayout(reader.getLayout());}();
[&](){(result.renderPass)=deserialize_VkRenderPass(reader.getRenderPass());}();
[&](){(result.subpass)=reader.getSubpass();}();
[&](){(result.basePipelineHandle)=deserialize_VkPipeline(reader.getBasePipelineHandle());}();
[&](){(result.basePipelineIndex)=reader.getBasePipelineIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGraphicsPipelineCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGraphicsPipelineCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCacheCreateInfo::Builder& builder, VkPipelineCacheCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setInitialDataSize((member.initialDataSize));}();
[&](){
            if ((member.pInitialData)==NULL){
                builder.initPInitialData(0);
            return; }[&](){
            if (((char*)(member.pInitialData).pInitialData)==NULL){
                builder.initPInitialData(0);
            return; }
        auto proto_arr=builder.initPInitialData(member.initialDataSize);
        for(int VgUKinx=0; VgUKinx < member.initialDataSize; VgUKinx++){
            [&](){return proto_arr.set(VgUKinx,(((char*)(member.pInitialData).pInitialData)[VgUKinx]));}();
        }
        }();}();
}

    VkPipelineCacheCreateInfo deserialize_struct(stream::VkPipelineCacheCreateInfo::Reader reader){
        auto result=VkPipelineCacheCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.initialDataSize)=reader.getInitialDataSize();}();
[&](){ void* temp_hSGagCA[&](){
            if (!reader.getPInitialData().size()==0){
                (result.pInitialData)=NULL;
            return; }char* temp_MNyHoci;[&](){
            if (!reader.getPInitialData().size()==0){
                (temp_MNyHoci.pInitialData)=NULL;
            return; }{native_concat()}=(char*)malloc(result.initialDataSize*sizeof(char));
        auto proto_arr=reader.getPInitialData(result.initialDataSize);
        for(int FUremIn=0; FUremIn < result.initialDataSize; FUremIn++){
            [&](){((temp_MNyHoci.pInitialData)[FUremIn])=proto_arr[FUremIn];}();
        }
        }();(result.pInitialData)=temp_MNyHoci;}();(result.pInitialData)=temp_hSGagCA;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCacheCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCacheCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCacheHeaderVersionOne::Builder& builder, VkPipelineCacheHeaderVersionOne member){
        
    
[&](){return builder.setHeaderSize((member.headerSize));}();
[&](){[&](){[&](){return builder.setHeaderVersion((member.headerVersion));}();}();}();
[&](){return builder.setVendorID((member.vendorID));}();
[&](){return builder.setDeviceID((member.deviceID));}();
[&](){
        auto proto_arr=builder.initPipelineCacheUUID(VK_UUID_SIZE);
        for(int pKnzMjr=0; pKnzMjr < VK_UUID_SIZE; pKnzMjr++){
            [&](){return proto_arr.set(pKnzMjr,((member.pipelineCacheUUID)[pKnzMjr]));}();
        }
        }();
}

    VkPipelineCacheHeaderVersionOne deserialize_struct(stream::VkPipelineCacheHeaderVersionOne::Reader reader){
        auto result=VkPipelineCacheHeaderVersionOne();
    
[&](){(result.headerSize)=reader.getHeaderSize();}();
[&](){[&](){[&](){(result.headerVersion)=reader.getHeaderVersion();}();}();}();
[&](){(result.vendorID)=reader.getVendorID();}();
[&](){(result.deviceID)=reader.getDeviceID();}();
[&](){
        auto proto_arr=reader.getPipelineCacheUUID(VK_UUID_SIZE);
        for(int pKnzMjr=0; pKnzMjr < VK_UUID_SIZE; pKnzMjr++){
            [&](){((result.pipelineCacheUUID)[pKnzMjr])=proto_arr[pKnzMjr];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCacheHeaderVersionOne member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCacheHeaderVersionOne member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPushConstantRange::Builder& builder, VkPushConstantRange member){
        
    
[&](){[&](){[&](){return builder.setStageFlags((member.stageFlags));}();}();}();
[&](){return builder.setOffset((member.offset));}();
[&](){return builder.setSize((member.size));}();
}

    VkPushConstantRange deserialize_struct(stream::VkPushConstantRange::Reader reader){
        auto result=VkPushConstantRange();
    
[&](){[&](){[&](){(result.stageFlags)=reader.getStageFlags();}();}();}();
[&](){(result.offset)=reader.getOffset();}();
[&](){(result.size)=reader.getSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPushConstantRange member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPushConstantRange member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineLayoutCreateInfo::Builder& builder, VkPipelineLayoutCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setSetLayoutCount((member.setLayoutCount));}();
[&](){
            if ((member.pSetLayouts)==NULL){
                builder.initPSetLayouts(0);
            return; }
        auto proto_arr=builder.initPSetLayouts(member.setLayoutCount);
        for(int gfILRjy=0; gfILRjy < member.setLayoutCount; gfILRjy++){
            [&](){return proto_arr.set(gfILRjy,serialize_handle((member.pSetLayouts)[gfILRjy]));}();
        }
        }();
[&](){return builder.setPushConstantRangeCount((member.pushConstantRangeCount));}();
[&](){
            if ((member.pPushConstantRanges)==NULL){
                builder.initPPushConstantRanges(0);
            return; }
        auto proto_arr=builder.initPPushConstantRanges(member.pushConstantRangeCount);
        for(int fStWwBo=0; fStWwBo < member.pushConstantRangeCount; fStWwBo++){
            [&](){
            auto temp=proto_arr[fStWwBo];
            return serialize_struct(temp, ((member.pPushConstantRanges)[fStWwBo]));
            }();
        }
        }();
}

    VkPipelineLayoutCreateInfo deserialize_struct(stream::VkPipelineLayoutCreateInfo::Reader reader){
        auto result=VkPipelineLayoutCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.setLayoutCount)=reader.getSetLayoutCount();}();
[&](){ VkDescriptorSetLayout* temp_BHNAemT[&](){
            if (!reader.getPSetLayouts().size()==0){
                (result.pSetLayouts)=NULL;
            return; }{native_concat()}=(VkDescriptorSetLayout*)malloc(result.setLayoutCount*sizeof(VkDescriptorSetLayout));
        auto proto_arr=reader.getPSetLayouts(result.setLayoutCount);
        for(int kjCEeqP=0; kjCEeqP < result.setLayoutCount; kjCEeqP++){
            [&](){((result.pSetLayouts)[kjCEeqP])=deserialize_VkDescriptorSetLayout(proto_arr[kjCEeqP]);}();
        }
        }();(result.pSetLayouts)=temp_BHNAemT;}();
[&](){(result.pushConstantRangeCount)=reader.getPushConstantRangeCount();}();
[&](){ VkPushConstantRange* temp_HDcMeFk[&](){
            if (!reader.getPPushConstantRanges().size()==0){
                (result.pPushConstantRanges)=NULL;
            return; }{native_concat()}=(VkPushConstantRange*)malloc(result.pushConstantRangeCount*sizeof(VkPushConstantRange));
        auto proto_arr=reader.getPPushConstantRanges(result.pushConstantRangeCount);
        for(int xSoqBwb=0; xSoqBwb < result.pushConstantRangeCount; xSoqBwb++){
            [&](){
            auto temp=proto_arr[xSoqBwb];
            ((result.pPushConstantRanges)[xSoqBwb])=deserialize_struct(temp);
            }();
        }
        }();(result.pPushConstantRanges)=temp_HDcMeFk;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineLayoutCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineLayoutCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerCreateInfo::Builder& builder, VkSamplerCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setMagFilter((member.magFilter));}();}();}();
[&](){[&](){[&](){return builder.setMinFilter((member.minFilter));}();}();}();
[&](){[&](){[&](){return builder.setMipmapMode((member.mipmapMode));}();}();}();
[&](){[&](){[&](){return builder.setAddressModeU((member.addressModeU));}();}();}();
[&](){[&](){[&](){return builder.setAddressModeV((member.addressModeV));}();}();}();
[&](){[&](){[&](){return builder.setAddressModeW((member.addressModeW));}();}();}();
[&](){return builder.setMipLodBias((member.mipLodBias));}();
[&](){[&](){return builder.setAnisotropyEnable((member.anisotropyEnable));}();}();
[&](){return builder.setMaxAnisotropy((member.maxAnisotropy));}();
[&](){[&](){return builder.setCompareEnable((member.compareEnable));}();}();
[&](){[&](){[&](){return builder.setCompareOp((member.compareOp));}();}();}();
[&](){return builder.setMinLod((member.minLod));}();
[&](){return builder.setMaxLod((member.maxLod));}();
[&](){[&](){[&](){return builder.setBorderColor((member.borderColor));}();}();}();
[&](){[&](){return builder.setUnnormalizedCoordinates((member.unnormalizedCoordinates));}();}();
}

    VkSamplerCreateInfo deserialize_struct(stream::VkSamplerCreateInfo::Reader reader){
        auto result=VkSamplerCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.magFilter)=reader.getMagFilter();}();}();}();
[&](){[&](){[&](){(result.minFilter)=reader.getMinFilter();}();}();}();
[&](){[&](){[&](){(result.mipmapMode)=reader.getMipmapMode();}();}();}();
[&](){[&](){[&](){(result.addressModeU)=reader.getAddressModeU();}();}();}();
[&](){[&](){[&](){(result.addressModeV)=reader.getAddressModeV();}();}();}();
[&](){[&](){[&](){(result.addressModeW)=reader.getAddressModeW();}();}();}();
[&](){(result.mipLodBias)=reader.getMipLodBias();}();
[&](){[&](){(result.anisotropyEnable)=reader.getAnisotropyEnable();}();}();
[&](){(result.maxAnisotropy)=reader.getMaxAnisotropy();}();
[&](){[&](){(result.compareEnable)=reader.getCompareEnable();}();}();
[&](){[&](){[&](){(result.compareOp)=reader.getCompareOp();}();}();}();
[&](){(result.minLod)=reader.getMinLod();}();
[&](){(result.maxLod)=reader.getMaxLod();}();
[&](){[&](){[&](){(result.borderColor)=reader.getBorderColor();}();}();}();
[&](){[&](){(result.unnormalizedCoordinates)=reader.getUnnormalizedCoordinates();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandPoolCreateInfo::Builder& builder, VkCommandPoolCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setQueueFamilyIndex((member.queueFamilyIndex));}();
}

    VkCommandPoolCreateInfo deserialize_struct(stream::VkCommandPoolCreateInfo::Reader reader){
        auto result=VkCommandPoolCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.queueFamilyIndex)=reader.getQueueFamilyIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandPoolCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandPoolCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferAllocateInfo::Builder& builder, VkCommandBufferAllocateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setCommandPool(serialize_handle(member.commandPool));}();
[&](){[&](){[&](){return builder.setLevel((member.level));}();}();}();
[&](){return builder.setCommandBufferCount((member.commandBufferCount));}();
}

    VkCommandBufferAllocateInfo deserialize_struct(stream::VkCommandBufferAllocateInfo::Reader reader){
        auto result=VkCommandBufferAllocateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.commandPool)=deserialize_VkCommandPool(reader.getCommandPool());}();
[&](){[&](){[&](){(result.level)=reader.getLevel();}();}();}();
[&](){(result.commandBufferCount)=reader.getCommandBufferCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferAllocateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferAllocateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferInheritanceInfo::Builder& builder, VkCommandBufferInheritanceInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setRenderPass(serialize_handle(member.renderPass));}();
[&](){return builder.setSubpass((member.subpass));}();
[&](){return builder.setFramebuffer(serialize_handle(member.framebuffer));}();
[&](){[&](){return builder.setOcclusionQueryEnable((member.occlusionQueryEnable));}();}();
[&](){[&](){[&](){return builder.setQueryFlags((member.queryFlags));}();}();}();
[&](){[&](){[&](){return builder.setPipelineStatistics((member.pipelineStatistics));}();}();}();
}

    VkCommandBufferInheritanceInfo deserialize_struct(stream::VkCommandBufferInheritanceInfo::Reader reader){
        auto result=VkCommandBufferInheritanceInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.renderPass)=deserialize_VkRenderPass(reader.getRenderPass());}();
[&](){(result.subpass)=reader.getSubpass();}();
[&](){(result.framebuffer)=deserialize_VkFramebuffer(reader.getFramebuffer());}();
[&](){[&](){(result.occlusionQueryEnable)=reader.getOcclusionQueryEnable();}();}();
[&](){[&](){[&](){(result.queryFlags)=reader.getQueryFlags();}();}();}();
[&](){[&](){[&](){(result.pipelineStatistics)=reader.getPipelineStatistics();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferInheritanceInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferInheritanceInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferBeginInfo::Builder& builder, VkCommandBufferBeginInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            if ((member.pInheritanceInfo)==NULL){
                builder.initPInheritanceInfo(0);
            return; }
        auto proto_arr=builder.initPInheritanceInfo(1);
        for(int nFDfwwm=0; nFDfwwm < 1; nFDfwwm++){
            [&](){
            auto temp=proto_arr[nFDfwwm];
            return serialize_struct(temp, ((member.pInheritanceInfo)[nFDfwwm]));
            }();
        }
        }();
}

    VkCommandBufferBeginInfo deserialize_struct(stream::VkCommandBufferBeginInfo::Reader reader){
        auto result=VkCommandBufferBeginInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){ VkCommandBufferInheritanceInfo* temp_RaTTAdf[&](){
            if (!reader.getPInheritanceInfo().size()==0){
                (result.pInheritanceInfo)=NULL;
            return; }{native_concat()}=(VkCommandBufferInheritanceInfo*)malloc(1*sizeof(VkCommandBufferInheritanceInfo));
        auto proto_arr=reader.getPInheritanceInfo(1);
        for(int bbedYXd=0; bbedYXd < 1; bbedYXd++){
            [&](){
            auto temp=proto_arr[bbedYXd];
            ((result.pInheritanceInfo)[bbedYXd])=deserialize_struct(temp);
            }();
        }
        }();(result.pInheritanceInfo)=temp_RaTTAdf;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferBeginInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferBeginInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassBeginInfo::Builder& builder, VkRenderPassBeginInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setRenderPass(serialize_handle(member.renderPass));}();
[&](){return builder.setFramebuffer(serialize_handle(member.framebuffer));}();
[&](){
            auto temp=builder.initRenderArea(renderArea);
            return serialize_struct(temp, (member.renderArea));
            }();
[&](){return builder.setClearValueCount((member.clearValueCount));}();
[&](){
            if ((member.pClearValues)==NULL){
                builder.initPClearValues(0);
            return; }
        auto proto_arr=builder.initPClearValues(member.clearValueCount);
        for(int qjoeTNt=0; qjoeTNt < member.clearValueCount; qjoeTNt++){
            [&](){
            auto temp=proto_arr[qjoeTNt];
            return serialize_struct(temp, ((member.pClearValues)[qjoeTNt]));
            }();
        }
        }();
}

    VkRenderPassBeginInfo deserialize_struct(stream::VkRenderPassBeginInfo::Reader reader){
        auto result=VkRenderPassBeginInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.renderPass)=deserialize_VkRenderPass(reader.getRenderPass());}();
[&](){(result.framebuffer)=deserialize_VkFramebuffer(reader.getFramebuffer());}();
[&](){
            auto temp=reader.getRenderArea();
            (result.renderArea)=deserialize_struct(temp);
            }();
[&](){(result.clearValueCount)=reader.getClearValueCount();}();
[&](){ VkClearValue* temp_pmVQpow[&](){
            if (!reader.getPClearValues().size()==0){
                (result.pClearValues)=NULL;
            return; }{native_concat()}=(VkClearValue*)malloc(result.clearValueCount*sizeof(VkClearValue));
        auto proto_arr=reader.getPClearValues(result.clearValueCount);
        for(int rHsxouv=0; rHsxouv < result.clearValueCount; rHsxouv++){
            [&](){
            auto temp=proto_arr[rHsxouv];
            ((result.pClearValues)[rHsxouv])=deserialize_struct(temp);
            }();
        }
        }();(result.pClearValues)=temp_pmVQpow;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassBeginInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassBeginInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkClearColorValue::Builder& builder, VkClearColorValue member){
        
    
[&](){
        auto proto_arr=builder.initFloat32(4);
        for(int kwfNrBt=0; kwfNrBt < 4; kwfNrBt++){
            [&](){return proto_arr.set(kwfNrBt,((member.float32)[kwfNrBt]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initInt32(4);
        for(int JWnmMeC=0; JWnmMeC < 4; JWnmMeC++){
            [&](){return proto_arr.set(JWnmMeC,((member.int32)[JWnmMeC]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initUint32(4);
        for(int vckpinK=0; vckpinK < 4; vckpinK++){
            [&](){return proto_arr.set(vckpinK,((member.uint32)[vckpinK]));}();
        }
        }();
}

    VkClearColorValue deserialize_struct(stream::VkClearColorValue::Reader reader){
        auto result=VkClearColorValue();
    
[&](){
        auto proto_arr=reader.getFloat32(4);
        for(int kwfNrBt=0; kwfNrBt < 4; kwfNrBt++){
            [&](){((result.float32)[kwfNrBt])=proto_arr[kwfNrBt];}();
        }
        }();
[&](){
        auto proto_arr=reader.getInt32(4);
        for(int JWnmMeC=0; JWnmMeC < 4; JWnmMeC++){
            [&](){((result.int32)[JWnmMeC])=proto_arr[JWnmMeC];}();
        }
        }();
[&](){
        auto proto_arr=reader.getUint32(4);
        for(int vckpinK=0; vckpinK < 4; vckpinK++){
            [&](){((result.uint32)[vckpinK])=proto_arr[vckpinK];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkClearColorValue member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkClearColorValue member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkClearDepthStencilValue::Builder& builder, VkClearDepthStencilValue member){
        
    
[&](){return builder.setDepth((member.depth));}();
[&](){return builder.setStencil((member.stencil));}();
}

    VkClearDepthStencilValue deserialize_struct(stream::VkClearDepthStencilValue::Reader reader){
        auto result=VkClearDepthStencilValue();
    
[&](){(result.depth)=reader.getDepth();}();
[&](){(result.stencil)=reader.getStencil();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkClearDepthStencilValue member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkClearDepthStencilValue member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkClearValue::Builder& builder, VkClearValue member){
        
    
[&](){
            auto temp=builder.initColor(color);
            return serialize_struct(temp, (member.color));
            }();
[&](){
            auto temp=builder.initDepthStencil(depthStencil);
            return serialize_struct(temp, (member.depthStencil));
            }();
}

    VkClearValue deserialize_struct(stream::VkClearValue::Reader reader){
        auto result=VkClearValue();
    
[&](){
            auto temp=reader.getColor();
            (result.color)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDepthStencil();
            (result.depthStencil)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkClearValue member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkClearValue member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkClearAttachment::Builder& builder, VkClearAttachment member){
        
    
[&](){[&](){[&](){return builder.setAspectMask((member.aspectMask));}();}();}();
[&](){return builder.setColorAttachment((member.colorAttachment));}();
[&](){
            auto temp=builder.initClearValue(clearValue);
            return serialize_struct(temp, (member.clearValue));
            }();
}

    VkClearAttachment deserialize_struct(stream::VkClearAttachment::Reader reader){
        auto result=VkClearAttachment();
    
[&](){[&](){[&](){(result.aspectMask)=reader.getAspectMask();}();}();}();
[&](){(result.colorAttachment)=reader.getColorAttachment();}();
[&](){
            auto temp=reader.getClearValue();
            (result.clearValue)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkClearAttachment member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkClearAttachment member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentDescription::Builder& builder, VkAttachmentDescription member){
        
    
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){[&](){[&](){return builder.setSamples((member.samples));}();}();}();
[&](){[&](){[&](){return builder.setLoadOp((member.loadOp));}();}();}();
[&](){[&](){[&](){return builder.setStoreOp((member.storeOp));}();}();}();
[&](){[&](){[&](){return builder.setStencilLoadOp((member.stencilLoadOp));}();}();}();
[&](){[&](){[&](){return builder.setStencilStoreOp((member.stencilStoreOp));}();}();}();
[&](){[&](){[&](){return builder.setInitialLayout((member.initialLayout));}();}();}();
[&](){[&](){[&](){return builder.setFinalLayout((member.finalLayout));}();}();}();
}

    VkAttachmentDescription deserialize_struct(stream::VkAttachmentDescription::Reader reader){
        auto result=VkAttachmentDescription();
    
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){[&](){[&](){(result.samples)=reader.getSamples();}();}();}();
[&](){[&](){[&](){(result.loadOp)=reader.getLoadOp();}();}();}();
[&](){[&](){[&](){(result.storeOp)=reader.getStoreOp();}();}();}();
[&](){[&](){[&](){(result.stencilLoadOp)=reader.getStencilLoadOp();}();}();}();
[&](){[&](){[&](){(result.stencilStoreOp)=reader.getStencilStoreOp();}();}();}();
[&](){[&](){[&](){(result.initialLayout)=reader.getInitialLayout();}();}();}();
[&](){[&](){[&](){(result.finalLayout)=reader.getFinalLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentDescription member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentDescription member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentReference::Builder& builder, VkAttachmentReference member){
        
    
[&](){return builder.setAttachment((member.attachment));}();
[&](){[&](){[&](){return builder.setLayout((member.layout));}();}();}();
}

    VkAttachmentReference deserialize_struct(stream::VkAttachmentReference::Reader reader){
        auto result=VkAttachmentReference();
    
[&](){(result.attachment)=reader.getAttachment();}();
[&](){[&](){[&](){(result.layout)=reader.getLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentReference member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentReference member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassDescription::Builder& builder, VkSubpassDescription member){
        
    
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setPipelineBindPoint((member.pipelineBindPoint));}();}();}();
[&](){return builder.setInputAttachmentCount((member.inputAttachmentCount));}();
[&](){
            if ((member.pInputAttachments)==NULL){
                builder.initPInputAttachments(0);
            return; }
        auto proto_arr=builder.initPInputAttachments(member.inputAttachmentCount);
        for(int lYXnngK=0; lYXnngK < member.inputAttachmentCount; lYXnngK++){
            [&](){
            auto temp=proto_arr[lYXnngK];
            return serialize_struct(temp, ((member.pInputAttachments)[lYXnngK]));
            }();
        }
        }();
[&](){return builder.setColorAttachmentCount((member.colorAttachmentCount));}();
[&](){
            if ((member.pColorAttachments)==NULL){
                builder.initPColorAttachments(0);
            return; }
        auto proto_arr=builder.initPColorAttachments(member.colorAttachmentCount);
        for(int oXMIDJx=0; oXMIDJx < member.colorAttachmentCount; oXMIDJx++){
            [&](){
            auto temp=proto_arr[oXMIDJx];
            return serialize_struct(temp, ((member.pColorAttachments)[oXMIDJx]));
            }();
        }
        }();
[&](){
            if ((member.pResolveAttachments)==NULL){
                builder.initPResolveAttachments(0);
            return; }
        auto proto_arr=builder.initPResolveAttachments(member.colorAttachmentCount);
        for(int KAJKvdn=0; KAJKvdn < member.colorAttachmentCount; KAJKvdn++){
            [&](){
            auto temp=proto_arr[KAJKvdn];
            return serialize_struct(temp, ((member.pResolveAttachments)[KAJKvdn]));
            }();
        }
        }();
[&](){
            if ((member.pDepthStencilAttachment)==NULL){
                builder.initPDepthStencilAttachment(0);
            return; }
        auto proto_arr=builder.initPDepthStencilAttachment(1);
        for(int FMSqhkQ=0; FMSqhkQ < 1; FMSqhkQ++){
            [&](){
            auto temp=proto_arr[FMSqhkQ];
            return serialize_struct(temp, ((member.pDepthStencilAttachment)[FMSqhkQ]));
            }();
        }
        }();
[&](){return builder.setPreserveAttachmentCount((member.preserveAttachmentCount));}();
[&](){
            if ((member.pPreserveAttachments)==NULL){
                builder.initPPreserveAttachments(0);
            return; }
        auto proto_arr=builder.initPPreserveAttachments(member.preserveAttachmentCount);
        for(int OunTLoO=0; OunTLoO < member.preserveAttachmentCount; OunTLoO++){
            [&](){return proto_arr.set(OunTLoO,((member.pPreserveAttachments)[OunTLoO]));}();
        }
        }();
}

    VkSubpassDescription deserialize_struct(stream::VkSubpassDescription::Reader reader){
        auto result=VkSubpassDescription();
    
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.pipelineBindPoint)=reader.getPipelineBindPoint();}();}();}();
[&](){(result.inputAttachmentCount)=reader.getInputAttachmentCount();}();
[&](){ VkAttachmentReference* temp_dLMhQtL[&](){
            if (!reader.getPInputAttachments().size()==0){
                (result.pInputAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentReference*)malloc(result.inputAttachmentCount*sizeof(VkAttachmentReference));
        auto proto_arr=reader.getPInputAttachments(result.inputAttachmentCount);
        for(int NTiwIDl=0; NTiwIDl < result.inputAttachmentCount; NTiwIDl++){
            [&](){
            auto temp=proto_arr[NTiwIDl];
            ((result.pInputAttachments)[NTiwIDl])=deserialize_struct(temp);
            }();
        }
        }();(result.pInputAttachments)=temp_dLMhQtL;}();
[&](){(result.colorAttachmentCount)=reader.getColorAttachmentCount();}();
[&](){ VkAttachmentReference* temp_FKySUeI[&](){
            if (!reader.getPColorAttachments().size()==0){
                (result.pColorAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentReference*)malloc(result.colorAttachmentCount*sizeof(VkAttachmentReference));
        auto proto_arr=reader.getPColorAttachments(result.colorAttachmentCount);
        for(int PRkPOeb=0; PRkPOeb < result.colorAttachmentCount; PRkPOeb++){
            [&](){
            auto temp=proto_arr[PRkPOeb];
            ((result.pColorAttachments)[PRkPOeb])=deserialize_struct(temp);
            }();
        }
        }();(result.pColorAttachments)=temp_FKySUeI;}();
[&](){ VkAttachmentReference* temp_JvthOEG[&](){
            if (!reader.getPResolveAttachments().size()==0){
                (result.pResolveAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentReference*)malloc(result.colorAttachmentCount*sizeof(VkAttachmentReference));
        auto proto_arr=reader.getPResolveAttachments(result.colorAttachmentCount);
        for(int OMbGyuZ=0; OMbGyuZ < result.colorAttachmentCount; OMbGyuZ++){
            [&](){
            auto temp=proto_arr[OMbGyuZ];
            ((result.pResolveAttachments)[OMbGyuZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pResolveAttachments)=temp_JvthOEG;}();
[&](){ VkAttachmentReference* temp_qvfNzlt[&](){
            if (!reader.getPDepthStencilAttachment().size()==0){
                (result.pDepthStencilAttachment)=NULL;
            return; }{native_concat()}=(VkAttachmentReference*)malloc(1*sizeof(VkAttachmentReference));
        auto proto_arr=reader.getPDepthStencilAttachment(1);
        for(int WEtsSUr=0; WEtsSUr < 1; WEtsSUr++){
            [&](){
            auto temp=proto_arr[WEtsSUr];
            ((result.pDepthStencilAttachment)[WEtsSUr])=deserialize_struct(temp);
            }();
        }
        }();(result.pDepthStencilAttachment)=temp_qvfNzlt;}();
[&](){(result.preserveAttachmentCount)=reader.getPreserveAttachmentCount();}();
[&](){ uint32_t* temp_OBPkkNN[&](){
            if (!reader.getPPreserveAttachments().size()==0){
                (result.pPreserveAttachments)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.preserveAttachmentCount*sizeof(uint32_t));
        auto proto_arr=reader.getPPreserveAttachments(result.preserveAttachmentCount);
        for(int Ucaahng=0; Ucaahng < result.preserveAttachmentCount; Ucaahng++){
            [&](){((result.pPreserveAttachments)[Ucaahng])=proto_arr[Ucaahng];}();
        }
        }();(result.pPreserveAttachments)=temp_OBPkkNN;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassDescription member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassDescription member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassDependency::Builder& builder, VkSubpassDependency member){
        
    
[&](){return builder.setSrcSubpass((member.srcSubpass));}();
[&](){return builder.setDstSubpass((member.dstSubpass));}();
[&](){[&](){[&](){return builder.setSrcStageMask((member.srcStageMask));}();}();}();
[&](){[&](){[&](){return builder.setDstStageMask((member.dstStageMask));}();}();}();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDependencyFlags((member.dependencyFlags));}();}();}();
}

    VkSubpassDependency deserialize_struct(stream::VkSubpassDependency::Reader reader){
        auto result=VkSubpassDependency();
    
[&](){(result.srcSubpass)=reader.getSrcSubpass();}();
[&](){(result.dstSubpass)=reader.getDstSubpass();}();
[&](){[&](){[&](){(result.srcStageMask)=reader.getSrcStageMask();}();}();}();
[&](){[&](){[&](){(result.dstStageMask)=reader.getDstStageMask();}();}();}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
[&](){[&](){[&](){(result.dependencyFlags)=reader.getDependencyFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassDependency member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassDependency member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassCreateInfo::Builder& builder, VkRenderPassCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setAttachmentCount((member.attachmentCount));}();
[&](){
            if ((member.pAttachments)==NULL){
                builder.initPAttachments(0);
            return; }
        auto proto_arr=builder.initPAttachments(member.attachmentCount);
        for(int rqvexer=0; rqvexer < member.attachmentCount; rqvexer++){
            [&](){
            auto temp=proto_arr[rqvexer];
            return serialize_struct(temp, ((member.pAttachments)[rqvexer]));
            }();
        }
        }();
[&](){return builder.setSubpassCount((member.subpassCount));}();
[&](){
            if ((member.pSubpasses)==NULL){
                builder.initPSubpasses(0);
            return; }
        auto proto_arr=builder.initPSubpasses(member.subpassCount);
        for(int lBvQvxn=0; lBvQvxn < member.subpassCount; lBvQvxn++){
            [&](){
            auto temp=proto_arr[lBvQvxn];
            return serialize_struct(temp, ((member.pSubpasses)[lBvQvxn]));
            }();
        }
        }();
[&](){return builder.setDependencyCount((member.dependencyCount));}();
[&](){
            if ((member.pDependencies)==NULL){
                builder.initPDependencies(0);
            return; }
        auto proto_arr=builder.initPDependencies(member.dependencyCount);
        for(int HytQjIJ=0; HytQjIJ < member.dependencyCount; HytQjIJ++){
            [&](){
            auto temp=proto_arr[HytQjIJ];
            return serialize_struct(temp, ((member.pDependencies)[HytQjIJ]));
            }();
        }
        }();
}

    VkRenderPassCreateInfo deserialize_struct(stream::VkRenderPassCreateInfo::Reader reader){
        auto result=VkRenderPassCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.attachmentCount)=reader.getAttachmentCount();}();
[&](){ VkAttachmentDescription* temp_gYBfaDU[&](){
            if (!reader.getPAttachments().size()==0){
                (result.pAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentDescription*)malloc(result.attachmentCount*sizeof(VkAttachmentDescription));
        auto proto_arr=reader.getPAttachments(result.attachmentCount);
        for(int LpvwhqR=0; LpvwhqR < result.attachmentCount; LpvwhqR++){
            [&](){
            auto temp=proto_arr[LpvwhqR];
            ((result.pAttachments)[LpvwhqR])=deserialize_struct(temp);
            }();
        }
        }();(result.pAttachments)=temp_gYBfaDU;}();
[&](){(result.subpassCount)=reader.getSubpassCount();}();
[&](){ VkSubpassDescription* temp_OdWUxSz[&](){
            if (!reader.getPSubpasses().size()==0){
                (result.pSubpasses)=NULL;
            return; }{native_concat()}=(VkSubpassDescription*)malloc(result.subpassCount*sizeof(VkSubpassDescription));
        auto proto_arr=reader.getPSubpasses(result.subpassCount);
        for(int QKYCKrd=0; QKYCKrd < result.subpassCount; QKYCKrd++){
            [&](){
            auto temp=proto_arr[QKYCKrd];
            ((result.pSubpasses)[QKYCKrd])=deserialize_struct(temp);
            }();
        }
        }();(result.pSubpasses)=temp_OdWUxSz;}();
[&](){(result.dependencyCount)=reader.getDependencyCount();}();
[&](){ VkSubpassDependency* temp_hXRdLOq[&](){
            if (!reader.getPDependencies().size()==0){
                (result.pDependencies)=NULL;
            return; }{native_concat()}=(VkSubpassDependency*)malloc(result.dependencyCount*sizeof(VkSubpassDependency));
        auto proto_arr=reader.getPDependencies(result.dependencyCount);
        for(int ABYVeAV=0; ABYVeAV < result.dependencyCount; ABYVeAV++){
            [&](){
            auto temp=proto_arr[ABYVeAV];
            ((result.pDependencies)[ABYVeAV])=deserialize_struct(temp);
            }();
        }
        }();(result.pDependencies)=temp_hXRdLOq;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkEventCreateInfo::Builder& builder, VkEventCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkEventCreateInfo deserialize_struct(stream::VkEventCreateInfo::Reader reader){
        auto result=VkEventCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkEventCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkEventCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFenceCreateInfo::Builder& builder, VkFenceCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkFenceCreateInfo deserialize_struct(stream::VkFenceCreateInfo::Reader reader){
        auto result=VkFenceCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFenceCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFenceCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFeatures::Builder& builder, VkPhysicalDeviceFeatures member){
        
    
[&](){[&](){return builder.setRobustBufferAccess((member.robustBufferAccess));}();}();
[&](){[&](){return builder.setFullDrawIndexUint32((member.fullDrawIndexUint32));}();}();
[&](){[&](){return builder.setImageCubeArray((member.imageCubeArray));}();}();
[&](){[&](){return builder.setIndependentBlend((member.independentBlend));}();}();
[&](){[&](){return builder.setGeometryShader((member.geometryShader));}();}();
[&](){[&](){return builder.setTessellationShader((member.tessellationShader));}();}();
[&](){[&](){return builder.setSampleRateShading((member.sampleRateShading));}();}();
[&](){[&](){return builder.setDualSrcBlend((member.dualSrcBlend));}();}();
[&](){[&](){return builder.setLogicOp((member.logicOp));}();}();
[&](){[&](){return builder.setMultiDrawIndirect((member.multiDrawIndirect));}();}();
[&](){[&](){return builder.setDrawIndirectFirstInstance((member.drawIndirectFirstInstance));}();}();
[&](){[&](){return builder.setDepthClamp((member.depthClamp));}();}();
[&](){[&](){return builder.setDepthBiasClamp((member.depthBiasClamp));}();}();
[&](){[&](){return builder.setFillModeNonSolid((member.fillModeNonSolid));}();}();
[&](){[&](){return builder.setDepthBounds((member.depthBounds));}();}();
[&](){[&](){return builder.setWideLines((member.wideLines));}();}();
[&](){[&](){return builder.setLargePoints((member.largePoints));}();}();
[&](){[&](){return builder.setAlphaToOne((member.alphaToOne));}();}();
[&](){[&](){return builder.setMultiViewport((member.multiViewport));}();}();
[&](){[&](){return builder.setSamplerAnisotropy((member.samplerAnisotropy));}();}();
[&](){[&](){return builder.setTextureCompressionETC2((member.textureCompressionETC2));}();}();
[&](){[&](){return builder.setTextureCompressionASTCLDR((member.textureCompressionASTC_LDR));}();}();
[&](){[&](){return builder.setTextureCompressionBC((member.textureCompressionBC));}();}();
[&](){[&](){return builder.setOcclusionQueryPrecise((member.occlusionQueryPrecise));}();}();
[&](){[&](){return builder.setPipelineStatisticsQuery((member.pipelineStatisticsQuery));}();}();
[&](){[&](){return builder.setVertexPipelineStoresAndAtomics((member.vertexPipelineStoresAndAtomics));}();}();
[&](){[&](){return builder.setFragmentStoresAndAtomics((member.fragmentStoresAndAtomics));}();}();
[&](){[&](){return builder.setShaderTessellationAndGeometryPointSize((member.shaderTessellationAndGeometryPointSize));}();}();
[&](){[&](){return builder.setShaderImageGatherExtended((member.shaderImageGatherExtended));}();}();
[&](){[&](){return builder.setShaderStorageImageExtendedFormats((member.shaderStorageImageExtendedFormats));}();}();
[&](){[&](){return builder.setShaderStorageImageMultisample((member.shaderStorageImageMultisample));}();}();
[&](){[&](){return builder.setShaderStorageImageReadWithoutFormat((member.shaderStorageImageReadWithoutFormat));}();}();
[&](){[&](){return builder.setShaderStorageImageWriteWithoutFormat((member.shaderStorageImageWriteWithoutFormat));}();}();
[&](){[&](){return builder.setShaderUniformBufferArrayDynamicIndexing((member.shaderUniformBufferArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderSampledImageArrayDynamicIndexing((member.shaderSampledImageArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderStorageBufferArrayDynamicIndexing((member.shaderStorageBufferArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderStorageImageArrayDynamicIndexing((member.shaderStorageImageArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderClipDistance((member.shaderClipDistance));}();}();
[&](){[&](){return builder.setShaderCullDistance((member.shaderCullDistance));}();}();
[&](){[&](){return builder.setShaderFloat64((member.shaderFloat64));}();}();
[&](){[&](){return builder.setShaderInt64((member.shaderInt64));}();}();
[&](){[&](){return builder.setShaderInt16((member.shaderInt16));}();}();
[&](){[&](){return builder.setShaderResourceResidency((member.shaderResourceResidency));}();}();
[&](){[&](){return builder.setShaderResourceMinLod((member.shaderResourceMinLod));}();}();
[&](){[&](){return builder.setSparseBinding((member.sparseBinding));}();}();
[&](){[&](){return builder.setSparseResidencyBuffer((member.sparseResidencyBuffer));}();}();
[&](){[&](){return builder.setSparseResidencyImage2D((member.sparseResidencyImage2D));}();}();
[&](){[&](){return builder.setSparseResidencyImage3D((member.sparseResidencyImage3D));}();}();
[&](){[&](){return builder.setSparseResidency2Samples((member.sparseResidency2Samples));}();}();
[&](){[&](){return builder.setSparseResidency4Samples((member.sparseResidency4Samples));}();}();
[&](){[&](){return builder.setSparseResidency8Samples((member.sparseResidency8Samples));}();}();
[&](){[&](){return builder.setSparseResidency16Samples((member.sparseResidency16Samples));}();}();
[&](){[&](){return builder.setSparseResidencyAliased((member.sparseResidencyAliased));}();}();
[&](){[&](){return builder.setVariableMultisampleRate((member.variableMultisampleRate));}();}();
[&](){[&](){return builder.setInheritedQueries((member.inheritedQueries));}();}();
}

    VkPhysicalDeviceFeatures deserialize_struct(stream::VkPhysicalDeviceFeatures::Reader reader){
        auto result=VkPhysicalDeviceFeatures();
    
[&](){[&](){(result.robustBufferAccess)=reader.getRobustBufferAccess();}();}();
[&](){[&](){(result.fullDrawIndexUint32)=reader.getFullDrawIndexUint32();}();}();
[&](){[&](){(result.imageCubeArray)=reader.getImageCubeArray();}();}();
[&](){[&](){(result.independentBlend)=reader.getIndependentBlend();}();}();
[&](){[&](){(result.geometryShader)=reader.getGeometryShader();}();}();
[&](){[&](){(result.tessellationShader)=reader.getTessellationShader();}();}();
[&](){[&](){(result.sampleRateShading)=reader.getSampleRateShading();}();}();
[&](){[&](){(result.dualSrcBlend)=reader.getDualSrcBlend();}();}();
[&](){[&](){(result.logicOp)=reader.getLogicOp();}();}();
[&](){[&](){(result.multiDrawIndirect)=reader.getMultiDrawIndirect();}();}();
[&](){[&](){(result.drawIndirectFirstInstance)=reader.getDrawIndirectFirstInstance();}();}();
[&](){[&](){(result.depthClamp)=reader.getDepthClamp();}();}();
[&](){[&](){(result.depthBiasClamp)=reader.getDepthBiasClamp();}();}();
[&](){[&](){(result.fillModeNonSolid)=reader.getFillModeNonSolid();}();}();
[&](){[&](){(result.depthBounds)=reader.getDepthBounds();}();}();
[&](){[&](){(result.wideLines)=reader.getWideLines();}();}();
[&](){[&](){(result.largePoints)=reader.getLargePoints();}();}();
[&](){[&](){(result.alphaToOne)=reader.getAlphaToOne();}();}();
[&](){[&](){(result.multiViewport)=reader.getMultiViewport();}();}();
[&](){[&](){(result.samplerAnisotropy)=reader.getSamplerAnisotropy();}();}();
[&](){[&](){(result.textureCompressionETC2)=reader.getTextureCompressionETC2();}();}();
[&](){[&](){(result.textureCompressionASTC_LDR)=reader.getTextureCompressionASTCLDR();}();}();
[&](){[&](){(result.textureCompressionBC)=reader.getTextureCompressionBC();}();}();
[&](){[&](){(result.occlusionQueryPrecise)=reader.getOcclusionQueryPrecise();}();}();
[&](){[&](){(result.pipelineStatisticsQuery)=reader.getPipelineStatisticsQuery();}();}();
[&](){[&](){(result.vertexPipelineStoresAndAtomics)=reader.getVertexPipelineStoresAndAtomics();}();}();
[&](){[&](){(result.fragmentStoresAndAtomics)=reader.getFragmentStoresAndAtomics();}();}();
[&](){[&](){(result.shaderTessellationAndGeometryPointSize)=reader.getShaderTessellationAndGeometryPointSize();}();}();
[&](){[&](){(result.shaderImageGatherExtended)=reader.getShaderImageGatherExtended();}();}();
[&](){[&](){(result.shaderStorageImageExtendedFormats)=reader.getShaderStorageImageExtendedFormats();}();}();
[&](){[&](){(result.shaderStorageImageMultisample)=reader.getShaderStorageImageMultisample();}();}();
[&](){[&](){(result.shaderStorageImageReadWithoutFormat)=reader.getShaderStorageImageReadWithoutFormat();}();}();
[&](){[&](){(result.shaderStorageImageWriteWithoutFormat)=reader.getShaderStorageImageWriteWithoutFormat();}();}();
[&](){[&](){(result.shaderUniformBufferArrayDynamicIndexing)=reader.getShaderUniformBufferArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderSampledImageArrayDynamicIndexing)=reader.getShaderSampledImageArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderStorageBufferArrayDynamicIndexing)=reader.getShaderStorageBufferArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderStorageImageArrayDynamicIndexing)=reader.getShaderStorageImageArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderClipDistance)=reader.getShaderClipDistance();}();}();
[&](){[&](){(result.shaderCullDistance)=reader.getShaderCullDistance();}();}();
[&](){[&](){(result.shaderFloat64)=reader.getShaderFloat64();}();}();
[&](){[&](){(result.shaderInt64)=reader.getShaderInt64();}();}();
[&](){[&](){(result.shaderInt16)=reader.getShaderInt16();}();}();
[&](){[&](){(result.shaderResourceResidency)=reader.getShaderResourceResidency();}();}();
[&](){[&](){(result.shaderResourceMinLod)=reader.getShaderResourceMinLod();}();}();
[&](){[&](){(result.sparseBinding)=reader.getSparseBinding();}();}();
[&](){[&](){(result.sparseResidencyBuffer)=reader.getSparseResidencyBuffer();}();}();
[&](){[&](){(result.sparseResidencyImage2D)=reader.getSparseResidencyImage2D();}();}();
[&](){[&](){(result.sparseResidencyImage3D)=reader.getSparseResidencyImage3D();}();}();
[&](){[&](){(result.sparseResidency2Samples)=reader.getSparseResidency2Samples();}();}();
[&](){[&](){(result.sparseResidency4Samples)=reader.getSparseResidency4Samples();}();}();
[&](){[&](){(result.sparseResidency8Samples)=reader.getSparseResidency8Samples();}();}();
[&](){[&](){(result.sparseResidency16Samples)=reader.getSparseResidency16Samples();}();}();
[&](){[&](){(result.sparseResidencyAliased)=reader.getSparseResidencyAliased();}();}();
[&](){[&](){(result.variableMultisampleRate)=reader.getVariableMultisampleRate();}();}();
[&](){[&](){(result.inheritedQueries)=reader.getInheritedQueries();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSparseProperties::Builder& builder, VkPhysicalDeviceSparseProperties member){
        
    
[&](){[&](){return builder.setResidencyStandard2DBlockShape((member.residencyStandard2DBlockShape));}();}();
[&](){[&](){return builder.setResidencyStandard2DMultisampleBlockShape((member.residencyStandard2DMultisampleBlockShape));}();}();
[&](){[&](){return builder.setResidencyStandard3DBlockShape((member.residencyStandard3DBlockShape));}();}();
[&](){[&](){return builder.setResidencyAlignedMipSize((member.residencyAlignedMipSize));}();}();
[&](){[&](){return builder.setResidencyNonResidentStrict((member.residencyNonResidentStrict));}();}();
}

    VkPhysicalDeviceSparseProperties deserialize_struct(stream::VkPhysicalDeviceSparseProperties::Reader reader){
        auto result=VkPhysicalDeviceSparseProperties();
    
[&](){[&](){(result.residencyStandard2DBlockShape)=reader.getResidencyStandard2DBlockShape();}();}();
[&](){[&](){(result.residencyStandard2DMultisampleBlockShape)=reader.getResidencyStandard2DMultisampleBlockShape();}();}();
[&](){[&](){(result.residencyStandard3DBlockShape)=reader.getResidencyStandard3DBlockShape();}();}();
[&](){[&](){(result.residencyAlignedMipSize)=reader.getResidencyAlignedMipSize();}();}();
[&](){[&](){(result.residencyNonResidentStrict)=reader.getResidencyNonResidentStrict();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSparseProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSparseProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceLimits::Builder& builder, VkPhysicalDeviceLimits member){
        
    
[&](){return builder.setMaxImageDimension1D((member.maxImageDimension1D));}();
[&](){return builder.setMaxImageDimension2D((member.maxImageDimension2D));}();
[&](){return builder.setMaxImageDimension3D((member.maxImageDimension3D));}();
[&](){return builder.setMaxImageDimensionCube((member.maxImageDimensionCube));}();
[&](){return builder.setMaxImageArrayLayers((member.maxImageArrayLayers));}();
[&](){return builder.setMaxTexelBufferElements((member.maxTexelBufferElements));}();
[&](){return builder.setMaxUniformBufferRange((member.maxUniformBufferRange));}();
[&](){return builder.setMaxStorageBufferRange((member.maxStorageBufferRange));}();
[&](){return builder.setMaxPushConstantsSize((member.maxPushConstantsSize));}();
[&](){return builder.setMaxMemoryAllocationCount((member.maxMemoryAllocationCount));}();
[&](){return builder.setMaxSamplerAllocationCount((member.maxSamplerAllocationCount));}();
[&](){[&](){return builder.setBufferImageGranularity((member.bufferImageGranularity));}();}();
[&](){[&](){return builder.setSparseAddressSpaceSize((member.sparseAddressSpaceSize));}();}();
[&](){return builder.setMaxBoundDescriptorSets((member.maxBoundDescriptorSets));}();
[&](){return builder.setMaxPerStageDescriptorSamplers((member.maxPerStageDescriptorSamplers));}();
[&](){return builder.setMaxPerStageDescriptorUniformBuffers((member.maxPerStageDescriptorUniformBuffers));}();
[&](){return builder.setMaxPerStageDescriptorStorageBuffers((member.maxPerStageDescriptorStorageBuffers));}();
[&](){return builder.setMaxPerStageDescriptorSampledImages((member.maxPerStageDescriptorSampledImages));}();
[&](){return builder.setMaxPerStageDescriptorStorageImages((member.maxPerStageDescriptorStorageImages));}();
[&](){return builder.setMaxPerStageDescriptorInputAttachments((member.maxPerStageDescriptorInputAttachments));}();
[&](){return builder.setMaxPerStageResources((member.maxPerStageResources));}();
[&](){return builder.setMaxDescriptorSetSamplers((member.maxDescriptorSetSamplers));}();
[&](){return builder.setMaxDescriptorSetUniformBuffers((member.maxDescriptorSetUniformBuffers));}();
[&](){return builder.setMaxDescriptorSetUniformBuffersDynamic((member.maxDescriptorSetUniformBuffersDynamic));}();
[&](){return builder.setMaxDescriptorSetStorageBuffers((member.maxDescriptorSetStorageBuffers));}();
[&](){return builder.setMaxDescriptorSetStorageBuffersDynamic((member.maxDescriptorSetStorageBuffersDynamic));}();
[&](){return builder.setMaxDescriptorSetSampledImages((member.maxDescriptorSetSampledImages));}();
[&](){return builder.setMaxDescriptorSetStorageImages((member.maxDescriptorSetStorageImages));}();
[&](){return builder.setMaxDescriptorSetInputAttachments((member.maxDescriptorSetInputAttachments));}();
[&](){return builder.setMaxVertexInputAttributes((member.maxVertexInputAttributes));}();
[&](){return builder.setMaxVertexInputBindings((member.maxVertexInputBindings));}();
[&](){return builder.setMaxVertexInputAttributeOffset((member.maxVertexInputAttributeOffset));}();
[&](){return builder.setMaxVertexInputBindingStride((member.maxVertexInputBindingStride));}();
[&](){return builder.setMaxVertexOutputComponents((member.maxVertexOutputComponents));}();
[&](){return builder.setMaxTessellationGenerationLevel((member.maxTessellationGenerationLevel));}();
[&](){return builder.setMaxTessellationPatchSize((member.maxTessellationPatchSize));}();
[&](){return builder.setMaxTessellationControlPerVertexInputComponents((member.maxTessellationControlPerVertexInputComponents));}();
[&](){return builder.setMaxTessellationControlPerVertexOutputComponents((member.maxTessellationControlPerVertexOutputComponents));}();
[&](){return builder.setMaxTessellationControlPerPatchOutputComponents((member.maxTessellationControlPerPatchOutputComponents));}();
[&](){return builder.setMaxTessellationControlTotalOutputComponents((member.maxTessellationControlTotalOutputComponents));}();
[&](){return builder.setMaxTessellationEvaluationInputComponents((member.maxTessellationEvaluationInputComponents));}();
[&](){return builder.setMaxTessellationEvaluationOutputComponents((member.maxTessellationEvaluationOutputComponents));}();
[&](){return builder.setMaxGeometryShaderInvocations((member.maxGeometryShaderInvocations));}();
[&](){return builder.setMaxGeometryInputComponents((member.maxGeometryInputComponents));}();
[&](){return builder.setMaxGeometryOutputComponents((member.maxGeometryOutputComponents));}();
[&](){return builder.setMaxGeometryOutputVertices((member.maxGeometryOutputVertices));}();
[&](){return builder.setMaxGeometryTotalOutputComponents((member.maxGeometryTotalOutputComponents));}();
[&](){return builder.setMaxFragmentInputComponents((member.maxFragmentInputComponents));}();
[&](){return builder.setMaxFragmentOutputAttachments((member.maxFragmentOutputAttachments));}();
[&](){return builder.setMaxFragmentDualSrcAttachments((member.maxFragmentDualSrcAttachments));}();
[&](){return builder.setMaxFragmentCombinedOutputResources((member.maxFragmentCombinedOutputResources));}();
[&](){return builder.setMaxComputeSharedMemorySize((member.maxComputeSharedMemorySize));}();
[&](){
        auto proto_arr=builder.initMaxComputeWorkGroupCount(3);
        for(int lIQmbhl=0; lIQmbhl < 3; lIQmbhl++){
            [&](){return proto_arr.set(lIQmbhl,((member.maxComputeWorkGroupCount)[lIQmbhl]));}();
        }
        }();
[&](){return builder.setMaxComputeWorkGroupInvocations((member.maxComputeWorkGroupInvocations));}();
[&](){
        auto proto_arr=builder.initMaxComputeWorkGroupSize(3);
        for(int ZsqtqEL=0; ZsqtqEL < 3; ZsqtqEL++){
            [&](){return proto_arr.set(ZsqtqEL,((member.maxComputeWorkGroupSize)[ZsqtqEL]));}();
        }
        }();
[&](){return builder.setSubPixelPrecisionBits((member.subPixelPrecisionBits));}();
[&](){return builder.setSubTexelPrecisionBits((member.subTexelPrecisionBits));}();
[&](){return builder.setMipmapPrecisionBits((member.mipmapPrecisionBits));}();
[&](){return builder.setMaxDrawIndexedIndexValue((member.maxDrawIndexedIndexValue));}();
[&](){return builder.setMaxDrawIndirectCount((member.maxDrawIndirectCount));}();
[&](){return builder.setMaxSamplerLodBias((member.maxSamplerLodBias));}();
[&](){return builder.setMaxSamplerAnisotropy((member.maxSamplerAnisotropy));}();
[&](){return builder.setMaxViewports((member.maxViewports));}();
[&](){
        auto proto_arr=builder.initMaxViewportDimensions(2);
        for(int FiWiYWY=0; FiWiYWY < 2; FiWiYWY++){
            [&](){return proto_arr.set(FiWiYWY,((member.maxViewportDimensions)[FiWiYWY]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initViewportBoundsRange(2);
        for(int HOnCwLW=0; HOnCwLW < 2; HOnCwLW++){
            [&](){return proto_arr.set(HOnCwLW,((member.viewportBoundsRange)[HOnCwLW]));}();
        }
        }();
[&](){return builder.setViewportSubPixelBits((member.viewportSubPixelBits));}();
[&](){return builder.setMinMemoryMapAlignment((member.minMemoryMapAlignment));}();
[&](){[&](){return builder.setMinTexelBufferOffsetAlignment((member.minTexelBufferOffsetAlignment));}();}();
[&](){[&](){return builder.setMinUniformBufferOffsetAlignment((member.minUniformBufferOffsetAlignment));}();}();
[&](){[&](){return builder.setMinStorageBufferOffsetAlignment((member.minStorageBufferOffsetAlignment));}();}();
[&](){return builder.setMinTexelOffset((member.minTexelOffset));}();
[&](){return builder.setMaxTexelOffset((member.maxTexelOffset));}();
[&](){return builder.setMinTexelGatherOffset((member.minTexelGatherOffset));}();
[&](){return builder.setMaxTexelGatherOffset((member.maxTexelGatherOffset));}();
[&](){return builder.setMinInterpolationOffset((member.minInterpolationOffset));}();
[&](){return builder.setMaxInterpolationOffset((member.maxInterpolationOffset));}();
[&](){return builder.setSubPixelInterpolationOffsetBits((member.subPixelInterpolationOffsetBits));}();
[&](){return builder.setMaxFramebufferWidth((member.maxFramebufferWidth));}();
[&](){return builder.setMaxFramebufferHeight((member.maxFramebufferHeight));}();
[&](){return builder.setMaxFramebufferLayers((member.maxFramebufferLayers));}();
[&](){[&](){[&](){return builder.setFramebufferColorSampleCounts((member.framebufferColorSampleCounts));}();}();}();
[&](){[&](){[&](){return builder.setFramebufferDepthSampleCounts((member.framebufferDepthSampleCounts));}();}();}();
[&](){[&](){[&](){return builder.setFramebufferStencilSampleCounts((member.framebufferStencilSampleCounts));}();}();}();
[&](){[&](){[&](){return builder.setFramebufferNoAttachmentsSampleCounts((member.framebufferNoAttachmentsSampleCounts));}();}();}();
[&](){return builder.setMaxColorAttachments((member.maxColorAttachments));}();
[&](){[&](){[&](){return builder.setSampledImageColorSampleCounts((member.sampledImageColorSampleCounts));}();}();}();
[&](){[&](){[&](){return builder.setSampledImageIntegerSampleCounts((member.sampledImageIntegerSampleCounts));}();}();}();
[&](){[&](){[&](){return builder.setSampledImageDepthSampleCounts((member.sampledImageDepthSampleCounts));}();}();}();
[&](){[&](){[&](){return builder.setSampledImageStencilSampleCounts((member.sampledImageStencilSampleCounts));}();}();}();
[&](){[&](){[&](){return builder.setStorageImageSampleCounts((member.storageImageSampleCounts));}();}();}();
[&](){return builder.setMaxSampleMaskWords((member.maxSampleMaskWords));}();
[&](){[&](){return builder.setTimestampComputeAndGraphics((member.timestampComputeAndGraphics));}();}();
[&](){return builder.setTimestampPeriod((member.timestampPeriod));}();
[&](){return builder.setMaxClipDistances((member.maxClipDistances));}();
[&](){return builder.setMaxCullDistances((member.maxCullDistances));}();
[&](){return builder.setMaxCombinedClipAndCullDistances((member.maxCombinedClipAndCullDistances));}();
[&](){return builder.setDiscreteQueuePriorities((member.discreteQueuePriorities));}();
[&](){
        auto proto_arr=builder.initPointSizeRange(2);
        for(int wFGzZLQ=0; wFGzZLQ < 2; wFGzZLQ++){
            [&](){return proto_arr.set(wFGzZLQ,((member.pointSizeRange)[wFGzZLQ]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initLineWidthRange(2);
        for(int mGntZIh=0; mGntZIh < 2; mGntZIh++){
            [&](){return proto_arr.set(mGntZIh,((member.lineWidthRange)[mGntZIh]));}();
        }
        }();
[&](){return builder.setPointSizeGranularity((member.pointSizeGranularity));}();
[&](){return builder.setLineWidthGranularity((member.lineWidthGranularity));}();
[&](){[&](){return builder.setStrictLines((member.strictLines));}();}();
[&](){[&](){return builder.setStandardSampleLocations((member.standardSampleLocations));}();}();
[&](){[&](){return builder.setOptimalBufferCopyOffsetAlignment((member.optimalBufferCopyOffsetAlignment));}();}();
[&](){[&](){return builder.setOptimalBufferCopyRowPitchAlignment((member.optimalBufferCopyRowPitchAlignment));}();}();
[&](){[&](){return builder.setNonCoherentAtomSize((member.nonCoherentAtomSize));}();}();
}

    VkPhysicalDeviceLimits deserialize_struct(stream::VkPhysicalDeviceLimits::Reader reader){
        auto result=VkPhysicalDeviceLimits();
    
[&](){(result.maxImageDimension1D)=reader.getMaxImageDimension1D();}();
[&](){(result.maxImageDimension2D)=reader.getMaxImageDimension2D();}();
[&](){(result.maxImageDimension3D)=reader.getMaxImageDimension3D();}();
[&](){(result.maxImageDimensionCube)=reader.getMaxImageDimensionCube();}();
[&](){(result.maxImageArrayLayers)=reader.getMaxImageArrayLayers();}();
[&](){(result.maxTexelBufferElements)=reader.getMaxTexelBufferElements();}();
[&](){(result.maxUniformBufferRange)=reader.getMaxUniformBufferRange();}();
[&](){(result.maxStorageBufferRange)=reader.getMaxStorageBufferRange();}();
[&](){(result.maxPushConstantsSize)=reader.getMaxPushConstantsSize();}();
[&](){(result.maxMemoryAllocationCount)=reader.getMaxMemoryAllocationCount();}();
[&](){(result.maxSamplerAllocationCount)=reader.getMaxSamplerAllocationCount();}();
[&](){[&](){(result.bufferImageGranularity)=reader.getBufferImageGranularity();}();}();
[&](){[&](){(result.sparseAddressSpaceSize)=reader.getSparseAddressSpaceSize();}();}();
[&](){(result.maxBoundDescriptorSets)=reader.getMaxBoundDescriptorSets();}();
[&](){(result.maxPerStageDescriptorSamplers)=reader.getMaxPerStageDescriptorSamplers();}();
[&](){(result.maxPerStageDescriptorUniformBuffers)=reader.getMaxPerStageDescriptorUniformBuffers();}();
[&](){(result.maxPerStageDescriptorStorageBuffers)=reader.getMaxPerStageDescriptorStorageBuffers();}();
[&](){(result.maxPerStageDescriptorSampledImages)=reader.getMaxPerStageDescriptorSampledImages();}();
[&](){(result.maxPerStageDescriptorStorageImages)=reader.getMaxPerStageDescriptorStorageImages();}();
[&](){(result.maxPerStageDescriptorInputAttachments)=reader.getMaxPerStageDescriptorInputAttachments();}();
[&](){(result.maxPerStageResources)=reader.getMaxPerStageResources();}();
[&](){(result.maxDescriptorSetSamplers)=reader.getMaxDescriptorSetSamplers();}();
[&](){(result.maxDescriptorSetUniformBuffers)=reader.getMaxDescriptorSetUniformBuffers();}();
[&](){(result.maxDescriptorSetUniformBuffersDynamic)=reader.getMaxDescriptorSetUniformBuffersDynamic();}();
[&](){(result.maxDescriptorSetStorageBuffers)=reader.getMaxDescriptorSetStorageBuffers();}();
[&](){(result.maxDescriptorSetStorageBuffersDynamic)=reader.getMaxDescriptorSetStorageBuffersDynamic();}();
[&](){(result.maxDescriptorSetSampledImages)=reader.getMaxDescriptorSetSampledImages();}();
[&](){(result.maxDescriptorSetStorageImages)=reader.getMaxDescriptorSetStorageImages();}();
[&](){(result.maxDescriptorSetInputAttachments)=reader.getMaxDescriptorSetInputAttachments();}();
[&](){(result.maxVertexInputAttributes)=reader.getMaxVertexInputAttributes();}();
[&](){(result.maxVertexInputBindings)=reader.getMaxVertexInputBindings();}();
[&](){(result.maxVertexInputAttributeOffset)=reader.getMaxVertexInputAttributeOffset();}();
[&](){(result.maxVertexInputBindingStride)=reader.getMaxVertexInputBindingStride();}();
[&](){(result.maxVertexOutputComponents)=reader.getMaxVertexOutputComponents();}();
[&](){(result.maxTessellationGenerationLevel)=reader.getMaxTessellationGenerationLevel();}();
[&](){(result.maxTessellationPatchSize)=reader.getMaxTessellationPatchSize();}();
[&](){(result.maxTessellationControlPerVertexInputComponents)=reader.getMaxTessellationControlPerVertexInputComponents();}();
[&](){(result.maxTessellationControlPerVertexOutputComponents)=reader.getMaxTessellationControlPerVertexOutputComponents();}();
[&](){(result.maxTessellationControlPerPatchOutputComponents)=reader.getMaxTessellationControlPerPatchOutputComponents();}();
[&](){(result.maxTessellationControlTotalOutputComponents)=reader.getMaxTessellationControlTotalOutputComponents();}();
[&](){(result.maxTessellationEvaluationInputComponents)=reader.getMaxTessellationEvaluationInputComponents();}();
[&](){(result.maxTessellationEvaluationOutputComponents)=reader.getMaxTessellationEvaluationOutputComponents();}();
[&](){(result.maxGeometryShaderInvocations)=reader.getMaxGeometryShaderInvocations();}();
[&](){(result.maxGeometryInputComponents)=reader.getMaxGeometryInputComponents();}();
[&](){(result.maxGeometryOutputComponents)=reader.getMaxGeometryOutputComponents();}();
[&](){(result.maxGeometryOutputVertices)=reader.getMaxGeometryOutputVertices();}();
[&](){(result.maxGeometryTotalOutputComponents)=reader.getMaxGeometryTotalOutputComponents();}();
[&](){(result.maxFragmentInputComponents)=reader.getMaxFragmentInputComponents();}();
[&](){(result.maxFragmentOutputAttachments)=reader.getMaxFragmentOutputAttachments();}();
[&](){(result.maxFragmentDualSrcAttachments)=reader.getMaxFragmentDualSrcAttachments();}();
[&](){(result.maxFragmentCombinedOutputResources)=reader.getMaxFragmentCombinedOutputResources();}();
[&](){(result.maxComputeSharedMemorySize)=reader.getMaxComputeSharedMemorySize();}();
[&](){
        auto proto_arr=reader.getMaxComputeWorkGroupCount(3);
        for(int lIQmbhl=0; lIQmbhl < 3; lIQmbhl++){
            [&](){((result.maxComputeWorkGroupCount)[lIQmbhl])=proto_arr[lIQmbhl];}();
        }
        }();
[&](){(result.maxComputeWorkGroupInvocations)=reader.getMaxComputeWorkGroupInvocations();}();
[&](){
        auto proto_arr=reader.getMaxComputeWorkGroupSize(3);
        for(int ZsqtqEL=0; ZsqtqEL < 3; ZsqtqEL++){
            [&](){((result.maxComputeWorkGroupSize)[ZsqtqEL])=proto_arr[ZsqtqEL];}();
        }
        }();
[&](){(result.subPixelPrecisionBits)=reader.getSubPixelPrecisionBits();}();
[&](){(result.subTexelPrecisionBits)=reader.getSubTexelPrecisionBits();}();
[&](){(result.mipmapPrecisionBits)=reader.getMipmapPrecisionBits();}();
[&](){(result.maxDrawIndexedIndexValue)=reader.getMaxDrawIndexedIndexValue();}();
[&](){(result.maxDrawIndirectCount)=reader.getMaxDrawIndirectCount();}();
[&](){(result.maxSamplerLodBias)=reader.getMaxSamplerLodBias();}();
[&](){(result.maxSamplerAnisotropy)=reader.getMaxSamplerAnisotropy();}();
[&](){(result.maxViewports)=reader.getMaxViewports();}();
[&](){
        auto proto_arr=reader.getMaxViewportDimensions(2);
        for(int FiWiYWY=0; FiWiYWY < 2; FiWiYWY++){
            [&](){((result.maxViewportDimensions)[FiWiYWY])=proto_arr[FiWiYWY];}();
        }
        }();
[&](){
        auto proto_arr=reader.getViewportBoundsRange(2);
        for(int HOnCwLW=0; HOnCwLW < 2; HOnCwLW++){
            [&](){((result.viewportBoundsRange)[HOnCwLW])=proto_arr[HOnCwLW];}();
        }
        }();
[&](){(result.viewportSubPixelBits)=reader.getViewportSubPixelBits();}();
[&](){(result.minMemoryMapAlignment)=reader.getMinMemoryMapAlignment();}();
[&](){[&](){(result.minTexelBufferOffsetAlignment)=reader.getMinTexelBufferOffsetAlignment();}();}();
[&](){[&](){(result.minUniformBufferOffsetAlignment)=reader.getMinUniformBufferOffsetAlignment();}();}();
[&](){[&](){(result.minStorageBufferOffsetAlignment)=reader.getMinStorageBufferOffsetAlignment();}();}();
[&](){(result.minTexelOffset)=reader.getMinTexelOffset();}();
[&](){(result.maxTexelOffset)=reader.getMaxTexelOffset();}();
[&](){(result.minTexelGatherOffset)=reader.getMinTexelGatherOffset();}();
[&](){(result.maxTexelGatherOffset)=reader.getMaxTexelGatherOffset();}();
[&](){(result.minInterpolationOffset)=reader.getMinInterpolationOffset();}();
[&](){(result.maxInterpolationOffset)=reader.getMaxInterpolationOffset();}();
[&](){(result.subPixelInterpolationOffsetBits)=reader.getSubPixelInterpolationOffsetBits();}();
[&](){(result.maxFramebufferWidth)=reader.getMaxFramebufferWidth();}();
[&](){(result.maxFramebufferHeight)=reader.getMaxFramebufferHeight();}();
[&](){(result.maxFramebufferLayers)=reader.getMaxFramebufferLayers();}();
[&](){[&](){[&](){(result.framebufferColorSampleCounts)=reader.getFramebufferColorSampleCounts();}();}();}();
[&](){[&](){[&](){(result.framebufferDepthSampleCounts)=reader.getFramebufferDepthSampleCounts();}();}();}();
[&](){[&](){[&](){(result.framebufferStencilSampleCounts)=reader.getFramebufferStencilSampleCounts();}();}();}();
[&](){[&](){[&](){(result.framebufferNoAttachmentsSampleCounts)=reader.getFramebufferNoAttachmentsSampleCounts();}();}();}();
[&](){(result.maxColorAttachments)=reader.getMaxColorAttachments();}();
[&](){[&](){[&](){(result.sampledImageColorSampleCounts)=reader.getSampledImageColorSampleCounts();}();}();}();
[&](){[&](){[&](){(result.sampledImageIntegerSampleCounts)=reader.getSampledImageIntegerSampleCounts();}();}();}();
[&](){[&](){[&](){(result.sampledImageDepthSampleCounts)=reader.getSampledImageDepthSampleCounts();}();}();}();
[&](){[&](){[&](){(result.sampledImageStencilSampleCounts)=reader.getSampledImageStencilSampleCounts();}();}();}();
[&](){[&](){[&](){(result.storageImageSampleCounts)=reader.getStorageImageSampleCounts();}();}();}();
[&](){(result.maxSampleMaskWords)=reader.getMaxSampleMaskWords();}();
[&](){[&](){(result.timestampComputeAndGraphics)=reader.getTimestampComputeAndGraphics();}();}();
[&](){(result.timestampPeriod)=reader.getTimestampPeriod();}();
[&](){(result.maxClipDistances)=reader.getMaxClipDistances();}();
[&](){(result.maxCullDistances)=reader.getMaxCullDistances();}();
[&](){(result.maxCombinedClipAndCullDistances)=reader.getMaxCombinedClipAndCullDistances();}();
[&](){(result.discreteQueuePriorities)=reader.getDiscreteQueuePriorities();}();
[&](){
        auto proto_arr=reader.getPointSizeRange(2);
        for(int wFGzZLQ=0; wFGzZLQ < 2; wFGzZLQ++){
            [&](){((result.pointSizeRange)[wFGzZLQ])=proto_arr[wFGzZLQ];}();
        }
        }();
[&](){
        auto proto_arr=reader.getLineWidthRange(2);
        for(int mGntZIh=0; mGntZIh < 2; mGntZIh++){
            [&](){((result.lineWidthRange)[mGntZIh])=proto_arr[mGntZIh];}();
        }
        }();
[&](){(result.pointSizeGranularity)=reader.getPointSizeGranularity();}();
[&](){(result.lineWidthGranularity)=reader.getLineWidthGranularity();}();
[&](){[&](){(result.strictLines)=reader.getStrictLines();}();}();
[&](){[&](){(result.standardSampleLocations)=reader.getStandardSampleLocations();}();}();
[&](){[&](){(result.optimalBufferCopyOffsetAlignment)=reader.getOptimalBufferCopyOffsetAlignment();}();}();
[&](){[&](){(result.optimalBufferCopyRowPitchAlignment)=reader.getOptimalBufferCopyRowPitchAlignment();}();}();
[&](){[&](){(result.nonCoherentAtomSize)=reader.getNonCoherentAtomSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceLimits member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceLimits member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSemaphoreCreateInfo::Builder& builder, VkSemaphoreCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkSemaphoreCreateInfo deserialize_struct(stream::VkSemaphoreCreateInfo::Reader reader){
        auto result=VkSemaphoreCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSemaphoreCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSemaphoreCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueryPoolCreateInfo::Builder& builder, VkQueryPoolCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setQueryType((member.queryType));}();}();}();
[&](){return builder.setQueryCount((member.queryCount));}();
[&](){[&](){[&](){return builder.setPipelineStatistics((member.pipelineStatistics));}();}();}();
}

    VkQueryPoolCreateInfo deserialize_struct(stream::VkQueryPoolCreateInfo::Reader reader){
        auto result=VkQueryPoolCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.queryType)=reader.getQueryType();}();}();}();
[&](){(result.queryCount)=reader.getQueryCount();}();
[&](){[&](){[&](){(result.pipelineStatistics)=reader.getPipelineStatistics();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueryPoolCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueryPoolCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFramebufferCreateInfo::Builder& builder, VkFramebufferCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setRenderPass(serialize_handle(member.renderPass));}();
[&](){return builder.setAttachmentCount((member.attachmentCount));}();
[&](){
            if ((member.pAttachments)==NULL){
                builder.initPAttachments(0);
            return; }
        auto proto_arr=builder.initPAttachments(member.attachmentCount);
        for(int vjwDzkt=0; vjwDzkt < member.attachmentCount; vjwDzkt++){
            [&](){return proto_arr.set(vjwDzkt,serialize_handle((member.pAttachments)[vjwDzkt]));}();
        }
        }();
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
[&](){return builder.setLayers((member.layers));}();
}

    VkFramebufferCreateInfo deserialize_struct(stream::VkFramebufferCreateInfo::Reader reader){
        auto result=VkFramebufferCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.renderPass)=deserialize_VkRenderPass(reader.getRenderPass());}();
[&](){(result.attachmentCount)=reader.getAttachmentCount();}();
[&](){ VkImageView* temp_engXCXd[&](){
            if (!reader.getPAttachments().size()==0){
                (result.pAttachments)=NULL;
            return; }{native_concat()}=(VkImageView*)malloc(result.attachmentCount*sizeof(VkImageView));
        auto proto_arr=reader.getPAttachments(result.attachmentCount);
        for(int qNVUjmy=0; qNVUjmy < result.attachmentCount; qNVUjmy++){
            [&](){((result.pAttachments)[qNVUjmy])=deserialize_VkImageView(proto_arr[qNVUjmy]);}();
        }
        }();(result.pAttachments)=temp_engXCXd;}();
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
[&](){(result.layers)=reader.getLayers();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFramebufferCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFramebufferCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrawIndirectCommand::Builder& builder, VkDrawIndirectCommand member){
        
    
[&](){return builder.setVertexCount((member.vertexCount));}();
[&](){return builder.setInstanceCount((member.instanceCount));}();
[&](){return builder.setFirstVertex((member.firstVertex));}();
[&](){return builder.setFirstInstance((member.firstInstance));}();
}

    VkDrawIndirectCommand deserialize_struct(stream::VkDrawIndirectCommand::Reader reader){
        auto result=VkDrawIndirectCommand();
    
[&](){(result.vertexCount)=reader.getVertexCount();}();
[&](){(result.instanceCount)=reader.getInstanceCount();}();
[&](){(result.firstVertex)=reader.getFirstVertex();}();
[&](){(result.firstInstance)=reader.getFirstInstance();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrawIndirectCommand member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrawIndirectCommand member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrawIndexedIndirectCommand::Builder& builder, VkDrawIndexedIndirectCommand member){
        
    
[&](){return builder.setIndexCount((member.indexCount));}();
[&](){return builder.setInstanceCount((member.instanceCount));}();
[&](){return builder.setFirstIndex((member.firstIndex));}();
[&](){return builder.setVertexOffset((member.vertexOffset));}();
[&](){return builder.setFirstInstance((member.firstInstance));}();
}

    VkDrawIndexedIndirectCommand deserialize_struct(stream::VkDrawIndexedIndirectCommand::Reader reader){
        auto result=VkDrawIndexedIndirectCommand();
    
[&](){(result.indexCount)=reader.getIndexCount();}();
[&](){(result.instanceCount)=reader.getInstanceCount();}();
[&](){(result.firstIndex)=reader.getFirstIndex();}();
[&](){(result.vertexOffset)=reader.getVertexOffset();}();
[&](){(result.firstInstance)=reader.getFirstInstance();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrawIndexedIndirectCommand member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrawIndexedIndirectCommand member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDispatchIndirectCommand::Builder& builder, VkDispatchIndirectCommand member){
        
    
[&](){return builder.setX((member.x));}();
[&](){return builder.setY((member.y));}();
[&](){return builder.setZ((member.z));}();
}

    VkDispatchIndirectCommand deserialize_struct(stream::VkDispatchIndirectCommand::Reader reader){
        auto result=VkDispatchIndirectCommand();
    
[&](){(result.x)=reader.getX();}();
[&](){(result.y)=reader.getY();}();
[&](){(result.z)=reader.getZ();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDispatchIndirectCommand member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDispatchIndirectCommand member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMultiDrawInfoEXT::Builder& builder, VkMultiDrawInfoEXT member){
        
    
[&](){return builder.setFirstVertex((member.firstVertex));}();
[&](){return builder.setVertexCount((member.vertexCount));}();
}

    VkMultiDrawInfoEXT deserialize_struct(stream::VkMultiDrawInfoEXT::Reader reader){
        auto result=VkMultiDrawInfoEXT();
    
[&](){(result.firstVertex)=reader.getFirstVertex();}();
[&](){(result.vertexCount)=reader.getVertexCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMultiDrawInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMultiDrawInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMultiDrawIndexedInfoEXT::Builder& builder, VkMultiDrawIndexedInfoEXT member){
        
    
[&](){return builder.setFirstIndex((member.firstIndex));}();
[&](){return builder.setIndexCount((member.indexCount));}();
[&](){return builder.setVertexOffset((member.vertexOffset));}();
}

    VkMultiDrawIndexedInfoEXT deserialize_struct(stream::VkMultiDrawIndexedInfoEXT::Reader reader){
        auto result=VkMultiDrawIndexedInfoEXT();
    
[&](){(result.firstIndex)=reader.getFirstIndex();}();
[&](){(result.indexCount)=reader.getIndexCount();}();
[&](){(result.vertexOffset)=reader.getVertexOffset();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMultiDrawIndexedInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMultiDrawIndexedInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubmitInfo::Builder& builder, VkSubmitInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setWaitSemaphoreCount((member.waitSemaphoreCount));}();
[&](){
            if ((member.pWaitSemaphores)==NULL){
                builder.initPWaitSemaphores(0);
            return; }
        auto proto_arr=builder.initPWaitSemaphores(member.waitSemaphoreCount);
        for(int UPuCjkG=0; UPuCjkG < member.waitSemaphoreCount; UPuCjkG++){
            [&](){return proto_arr.set(UPuCjkG,serialize_handle((member.pWaitSemaphores)[UPuCjkG]));}();
        }
        }();
[&](){
            if ((member.pWaitDstStageMask)==NULL){
                builder.initPWaitDstStageMask(0);
            return; }
        auto proto_arr=builder.initPWaitDstStageMask(member.waitSemaphoreCount);
        for(int OEMoieK=0; OEMoieK < member.waitSemaphoreCount; OEMoieK++){
            [&](){[&](){[&](){return proto_arr.set(OEMoieK,((member.pWaitDstStageMask)[OEMoieK]));}();}();}();
        }
        }();
[&](){return builder.setCommandBufferCount((member.commandBufferCount));}();
[&](){
            if ((member.pCommandBuffers)==NULL){
                builder.initPCommandBuffers(0);
            return; }
        auto proto_arr=builder.initPCommandBuffers(member.commandBufferCount);
        for(int VKjBFDE=0; VKjBFDE < member.commandBufferCount; VKjBFDE++){
            [&](){return proto_arr.set(VKjBFDE,serialize_handle((member.pCommandBuffers)[VKjBFDE]));}();
        }
        }();
[&](){return builder.setSignalSemaphoreCount((member.signalSemaphoreCount));}();
[&](){
            if ((member.pSignalSemaphores)==NULL){
                builder.initPSignalSemaphores(0);
            return; }
        auto proto_arr=builder.initPSignalSemaphores(member.signalSemaphoreCount);
        for(int NKFlfkK=0; NKFlfkK < member.signalSemaphoreCount; NKFlfkK++){
            [&](){return proto_arr.set(NKFlfkK,serialize_handle((member.pSignalSemaphores)[NKFlfkK]));}();
        }
        }();
}

    VkSubmitInfo deserialize_struct(stream::VkSubmitInfo::Reader reader){
        auto result=VkSubmitInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.waitSemaphoreCount)=reader.getWaitSemaphoreCount();}();
[&](){ VkSemaphore* temp_vxBhExF[&](){
            if (!reader.getPWaitSemaphores().size()==0){
                (result.pWaitSemaphores)=NULL;
            return; }{native_concat()}=(VkSemaphore*)malloc(result.waitSemaphoreCount*sizeof(VkSemaphore));
        auto proto_arr=reader.getPWaitSemaphores(result.waitSemaphoreCount);
        for(int eowObQx=0; eowObQx < result.waitSemaphoreCount; eowObQx++){
            [&](){((result.pWaitSemaphores)[eowObQx])=deserialize_VkSemaphore(proto_arr[eowObQx]);}();
        }
        }();(result.pWaitSemaphores)=temp_vxBhExF;}();
[&](){ VkPipelineStageFlags* temp_AHnwsmW[&](){
            if (!reader.getPWaitDstStageMask().size()==0){
                (result.pWaitDstStageMask)=NULL;
            return; }{native_concat()}=(VkPipelineStageFlags*)malloc(result.waitSemaphoreCount*sizeof(VkPipelineStageFlags));
        auto proto_arr=reader.getPWaitDstStageMask(result.waitSemaphoreCount);
        for(int mVEXVxn=0; mVEXVxn < result.waitSemaphoreCount; mVEXVxn++){
            [&](){[&](){[&](){((result.pWaitDstStageMask)[mVEXVxn])=proto_arr[mVEXVxn];}();}();}();
        }
        }();(result.pWaitDstStageMask)=temp_AHnwsmW;}();
[&](){(result.commandBufferCount)=reader.getCommandBufferCount();}();
[&](){ VkCommandBuffer* temp_mkqupUQ[&](){
            if (!reader.getPCommandBuffers().size()==0){
                (result.pCommandBuffers)=NULL;
            return; }{native_concat()}=(VkCommandBuffer*)malloc(result.commandBufferCount*sizeof(VkCommandBuffer));
        auto proto_arr=reader.getPCommandBuffers(result.commandBufferCount);
        for(int iNOFWDX=0; iNOFWDX < result.commandBufferCount; iNOFWDX++){
            [&](){((result.pCommandBuffers)[iNOFWDX])=deserialize_VkCommandBuffer(proto_arr[iNOFWDX]);}();
        }
        }();(result.pCommandBuffers)=temp_mkqupUQ;}();
[&](){(result.signalSemaphoreCount)=reader.getSignalSemaphoreCount();}();
[&](){ VkSemaphore* temp_rruuqWC[&](){
            if (!reader.getPSignalSemaphores().size()==0){
                (result.pSignalSemaphores)=NULL;
            return; }{native_concat()}=(VkSemaphore*)malloc(result.signalSemaphoreCount*sizeof(VkSemaphore));
        auto proto_arr=reader.getPSignalSemaphores(result.signalSemaphoreCount);
        for(int rsHNIbT=0; rsHNIbT < result.signalSemaphoreCount; rsHNIbT++){
            [&](){((result.pSignalSemaphores)[rsHNIbT])=deserialize_VkSemaphore(proto_arr[rsHNIbT]);}();
        }
        }();(result.pSignalSemaphores)=temp_rruuqWC;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubmitInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubmitInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPropertiesKHR::Builder& builder, VkDisplayPropertiesKHR member){
        
    
[&](){return builder.setDisplay(serialize_handle(member.display));}();
[&](){
            if ((member.displayName)==NULL){
                builder.initDisplayName(0);
            return; }
        auto proto_arr=builder.initDisplayName(strlen((member.displayName))+1);
        for(int lNoZZOd=0; lNoZZOd < strlen((member.displayName))+1; lNoZZOd++){
            [&](){return proto_arr.set(lNoZZOd,((member.displayName)[lNoZZOd]));}();
        }
        }();
[&](){
            auto temp=builder.initPhysicalDimensions(physicalDimensions);
            return serialize_struct(temp, (member.physicalDimensions));
            }();
[&](){
            auto temp=builder.initPhysicalResolution(physicalResolution);
            return serialize_struct(temp, (member.physicalResolution));
            }();
[&](){[&](){[&](){return builder.setSupportedTransforms((member.supportedTransforms));}();}();}();
[&](){[&](){return builder.setPlaneReorderPossible((member.planeReorderPossible));}();}();
[&](){[&](){return builder.setPersistentContent((member.persistentContent));}();}();
}

    VkDisplayPropertiesKHR deserialize_struct(stream::VkDisplayPropertiesKHR::Reader reader){
        auto result=VkDisplayPropertiesKHR();
    
[&](){(result.display)=deserialize_VkDisplayKHR(reader.getDisplay());}();
[&](){ char* temp_UKVMySz[&](){
            if (!reader.getDisplayName().size()==0){
                (result.displayName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getDisplayName().size();*sizeof(char));
        auto proto_arr=reader.getDisplayName(reader.getDisplayName().size(););
        for(int oCKUvgQ=0; oCKUvgQ < reader.getDisplayName().size();; oCKUvgQ++){
            [&](){((result.displayName)[oCKUvgQ])=proto_arr[oCKUvgQ];}();
        }
        }();(result.displayName)=temp_UKVMySz;}();
[&](){
            auto temp=reader.getPhysicalDimensions();
            (result.physicalDimensions)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getPhysicalResolution();
            (result.physicalResolution)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.supportedTransforms)=reader.getSupportedTransforms();}();}();}();
[&](){[&](){(result.planeReorderPossible)=reader.getPlaneReorderPossible();}();}();
[&](){[&](){(result.persistentContent)=reader.getPersistentContent();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPlanePropertiesKHR::Builder& builder, VkDisplayPlanePropertiesKHR member){
        
    
[&](){return builder.setCurrentDisplay(serialize_handle(member.currentDisplay));}();
[&](){return builder.setCurrentStackIndex((member.currentStackIndex));}();
}

    VkDisplayPlanePropertiesKHR deserialize_struct(stream::VkDisplayPlanePropertiesKHR::Reader reader){
        auto result=VkDisplayPlanePropertiesKHR();
    
[&](){(result.currentDisplay)=deserialize_VkDisplayKHR(reader.getCurrentDisplay());}();
[&](){(result.currentStackIndex)=reader.getCurrentStackIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPlanePropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPlanePropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayModeParametersKHR::Builder& builder, VkDisplayModeParametersKHR member){
        
    
[&](){
            auto temp=builder.initVisibleRegion(visibleRegion);
            return serialize_struct(temp, (member.visibleRegion));
            }();
[&](){return builder.setRefreshRate((member.refreshRate));}();
}

    VkDisplayModeParametersKHR deserialize_struct(stream::VkDisplayModeParametersKHR::Reader reader){
        auto result=VkDisplayModeParametersKHR();
    
[&](){
            auto temp=reader.getVisibleRegion();
            (result.visibleRegion)=deserialize_struct(temp);
            }();
[&](){(result.refreshRate)=reader.getRefreshRate();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayModeParametersKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayModeParametersKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayModePropertiesKHR::Builder& builder, VkDisplayModePropertiesKHR member){
        
    
[&](){return builder.setDisplayMode(serialize_handle(member.displayMode));}();
[&](){
            auto temp=builder.initParameters(parameters);
            return serialize_struct(temp, (member.parameters));
            }();
}

    VkDisplayModePropertiesKHR deserialize_struct(stream::VkDisplayModePropertiesKHR::Reader reader){
        auto result=VkDisplayModePropertiesKHR();
    
[&](){(result.displayMode)=deserialize_VkDisplayModeKHR(reader.getDisplayMode());}();
[&](){
            auto temp=reader.getParameters();
            (result.parameters)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayModePropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayModePropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayModeCreateInfoKHR::Builder& builder, VkDisplayModeCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            auto temp=builder.initParameters(parameters);
            return serialize_struct(temp, (member.parameters));
            }();
}

    VkDisplayModeCreateInfoKHR deserialize_struct(stream::VkDisplayModeCreateInfoKHR::Reader reader){
        auto result=VkDisplayModeCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
            auto temp=reader.getParameters();
            (result.parameters)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayModeCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayModeCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPlaneCapabilitiesKHR::Builder& builder, VkDisplayPlaneCapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSupportedAlpha((member.supportedAlpha));}();}();}();
[&](){
            auto temp=builder.initMinSrcPosition(minSrcPosition);
            return serialize_struct(temp, (member.minSrcPosition));
            }();
[&](){
            auto temp=builder.initMaxSrcPosition(maxSrcPosition);
            return serialize_struct(temp, (member.maxSrcPosition));
            }();
[&](){
            auto temp=builder.initMinSrcExtent(minSrcExtent);
            return serialize_struct(temp, (member.minSrcExtent));
            }();
[&](){
            auto temp=builder.initMaxSrcExtent(maxSrcExtent);
            return serialize_struct(temp, (member.maxSrcExtent));
            }();
[&](){
            auto temp=builder.initMinDstPosition(minDstPosition);
            return serialize_struct(temp, (member.minDstPosition));
            }();
[&](){
            auto temp=builder.initMaxDstPosition(maxDstPosition);
            return serialize_struct(temp, (member.maxDstPosition));
            }();
[&](){
            auto temp=builder.initMinDstExtent(minDstExtent);
            return serialize_struct(temp, (member.minDstExtent));
            }();
[&](){
            auto temp=builder.initMaxDstExtent(maxDstExtent);
            return serialize_struct(temp, (member.maxDstExtent));
            }();
}

    VkDisplayPlaneCapabilitiesKHR deserialize_struct(stream::VkDisplayPlaneCapabilitiesKHR::Reader reader){
        auto result=VkDisplayPlaneCapabilitiesKHR();
    
[&](){[&](){[&](){(result.supportedAlpha)=reader.getSupportedAlpha();}();}();}();
[&](){
            auto temp=reader.getMinSrcPosition();
            (result.minSrcPosition)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxSrcPosition();
            (result.maxSrcPosition)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinSrcExtent();
            (result.minSrcExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxSrcExtent();
            (result.maxSrcExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinDstPosition();
            (result.minDstPosition)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxDstPosition();
            (result.maxDstPosition)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinDstExtent();
            (result.minDstExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxDstExtent();
            (result.maxDstExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPlaneCapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPlaneCapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplaySurfaceCreateInfoKHR::Builder& builder, VkDisplaySurfaceCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setDisplayMode(serialize_handle(member.displayMode));}();
[&](){return builder.setPlaneIndex((member.planeIndex));}();
[&](){return builder.setPlaneStackIndex((member.planeStackIndex));}();
[&](){[&](){[&](){return builder.setTransform((member.transform));}();}();}();
[&](){return builder.setGlobalAlpha((member.globalAlpha));}();
[&](){[&](){[&](){return builder.setAlphaMode((member.alphaMode));}();}();}();
[&](){
            auto temp=builder.initImageExtent(imageExtent);
            return serialize_struct(temp, (member.imageExtent));
            }();
}

    VkDisplaySurfaceCreateInfoKHR deserialize_struct(stream::VkDisplaySurfaceCreateInfoKHR::Reader reader){
        auto result=VkDisplaySurfaceCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.displayMode)=deserialize_VkDisplayModeKHR(reader.getDisplayMode());}();
[&](){(result.planeIndex)=reader.getPlaneIndex();}();
[&](){(result.planeStackIndex)=reader.getPlaneStackIndex();}();
[&](){[&](){[&](){(result.transform)=reader.getTransform();}();}();}();
[&](){(result.globalAlpha)=reader.getGlobalAlpha();}();
[&](){[&](){[&](){(result.alphaMode)=reader.getAlphaMode();}();}();}();
[&](){
            auto temp=reader.getImageExtent();
            (result.imageExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplaySurfaceCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplaySurfaceCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPresentInfoKHR::Builder& builder, VkDisplayPresentInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSrcRect(srcRect);
            return serialize_struct(temp, (member.srcRect));
            }();
[&](){
            auto temp=builder.initDstRect(dstRect);
            return serialize_struct(temp, (member.dstRect));
            }();
[&](){[&](){return builder.setPersistent((member.persistent));}();}();
}

    VkDisplayPresentInfoKHR deserialize_struct(stream::VkDisplayPresentInfoKHR::Reader reader){
        auto result=VkDisplayPresentInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getSrcRect();
            (result.srcRect)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstRect();
            (result.dstRect)=deserialize_struct(temp);
            }();
[&](){[&](){(result.persistent)=reader.getPersistent();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPresentInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPresentInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfaceCapabilitiesKHR::Builder& builder, VkSurfaceCapabilitiesKHR member){
        
    
[&](){return builder.setMinImageCount((member.minImageCount));}();
[&](){return builder.setMaxImageCount((member.maxImageCount));}();
[&](){
            auto temp=builder.initCurrentExtent(currentExtent);
            return serialize_struct(temp, (member.currentExtent));
            }();
[&](){
            auto temp=builder.initMinImageExtent(minImageExtent);
            return serialize_struct(temp, (member.minImageExtent));
            }();
[&](){
            auto temp=builder.initMaxImageExtent(maxImageExtent);
            return serialize_struct(temp, (member.maxImageExtent));
            }();
[&](){return builder.setMaxImageArrayLayers((member.maxImageArrayLayers));}();
[&](){[&](){[&](){return builder.setSupportedTransforms((member.supportedTransforms));}();}();}();
[&](){[&](){[&](){return builder.setCurrentTransform((member.currentTransform));}();}();}();
[&](){[&](){[&](){return builder.setSupportedCompositeAlpha((member.supportedCompositeAlpha));}();}();}();
[&](){[&](){[&](){return builder.setSupportedUsageFlags((member.supportedUsageFlags));}();}();}();
}

    VkSurfaceCapabilitiesKHR deserialize_struct(stream::VkSurfaceCapabilitiesKHR::Reader reader){
        auto result=VkSurfaceCapabilitiesKHR();
    
[&](){(result.minImageCount)=reader.getMinImageCount();}();
[&](){(result.maxImageCount)=reader.getMaxImageCount();}();
[&](){
            auto temp=reader.getCurrentExtent();
            (result.currentExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinImageExtent();
            (result.minImageExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxImageExtent();
            (result.maxImageExtent)=deserialize_struct(temp);
            }();
[&](){(result.maxImageArrayLayers)=reader.getMaxImageArrayLayers();}();
[&](){[&](){[&](){(result.supportedTransforms)=reader.getSupportedTransforms();}();}();}();
[&](){[&](){[&](){(result.currentTransform)=reader.getCurrentTransform();}();}();}();
[&](){[&](){[&](){(result.supportedCompositeAlpha)=reader.getSupportedCompositeAlpha();}();}();}();
[&](){[&](){[&](){(result.supportedUsageFlags)=reader.getSupportedUsageFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfaceCapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfaceCapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkXlibSurfaceCreateInfoKHR::Builder& builder, VkXlibSurfaceCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            if ((member.dpy)==NULL){
                builder.initDpy(0);
            return; }builder.setDpy((uintptr_t)(member.dpy));}();
[&](){builder.setWindow((uintptr_t)(member.window));}();
}

    VkXlibSurfaceCreateInfoKHR deserialize_struct(stream::VkXlibSurfaceCreateInfoKHR::Reader reader){
        auto result=VkXlibSurfaceCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
            if (!reader.getDpy().size()==0){
                (result.dpy)=NULL;
            return; }(result.dpy)=(uintptr_t)reader.getDpy();}();
[&](){(result.window)=(uintptr_t)reader.getWindow();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkXlibSurfaceCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkXlibSurfaceCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkXcbSurfaceCreateInfoKHR::Builder& builder, VkXcbSurfaceCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            if ((member.connection)==NULL){
                builder.initConnection(0);
            return; }builder.setConnection((uintptr_t)(member.connection));}();
[&](){builder.setWindow((uintptr_t)(member.window));}();
}

    VkXcbSurfaceCreateInfoKHR deserialize_struct(stream::VkXcbSurfaceCreateInfoKHR::Reader reader){
        auto result=VkXcbSurfaceCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
            if (!reader.getConnection().size()==0){
                (result.connection)=NULL;
            return; }(result.connection)=(uintptr_t)reader.getConnection();}();
[&](){(result.window)=(uintptr_t)reader.getWindow();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkXcbSurfaceCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkXcbSurfaceCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfaceFormatKHR::Builder& builder, VkSurfaceFormatKHR member){
        
    
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){[&](){[&](){return builder.setColorSpace((member.colorSpace));}();}();}();
}

    VkSurfaceFormatKHR deserialize_struct(stream::VkSurfaceFormatKHR::Reader reader){
        auto result=VkSurfaceFormatKHR();
    
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){[&](){[&](){(result.colorSpace)=reader.getColorSpace();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfaceFormatKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfaceFormatKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainCreateInfoKHR::Builder& builder, VkSwapchainCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setSurface(serialize_handle(member.surface));}();
[&](){return builder.setMinImageCount((member.minImageCount));}();
[&](){[&](){[&](){return builder.setImageFormat((member.imageFormat));}();}();}();
[&](){[&](){[&](){return builder.setImageColorSpace((member.imageColorSpace));}();}();}();
[&](){
            auto temp=builder.initImageExtent(imageExtent);
            return serialize_struct(temp, (member.imageExtent));
            }();
[&](){return builder.setImageArrayLayers((member.imageArrayLayers));}();
[&](){[&](){[&](){return builder.setImageUsage((member.imageUsage));}();}();}();
[&](){[&](){[&](){return builder.setImageSharingMode((member.imageSharingMode));}();}();}();
[&](){return builder.setQueueFamilyIndexCount((member.queueFamilyIndexCount));}();
[&](){
            if ((member.pQueueFamilyIndices)==NULL){
                builder.initPQueueFamilyIndices(0);
            return; }
        auto proto_arr=builder.initPQueueFamilyIndices(member.queueFamilyIndexCount);
        for(int rqZQqua=0; rqZQqua < member.queueFamilyIndexCount; rqZQqua++){
            [&](){return proto_arr.set(rqZQqua,((member.pQueueFamilyIndices)[rqZQqua]));}();
        }
        }();
[&](){[&](){[&](){return builder.setPreTransform((member.preTransform));}();}();}();
[&](){[&](){[&](){return builder.setCompositeAlpha((member.compositeAlpha));}();}();}();
[&](){[&](){[&](){return builder.setPresentMode((member.presentMode));}();}();}();
[&](){[&](){return builder.setClipped((member.clipped));}();}();
[&](){return builder.setOldSwapchain(serialize_handle(member.oldSwapchain));}();
}

    VkSwapchainCreateInfoKHR deserialize_struct(stream::VkSwapchainCreateInfoKHR::Reader reader){
        auto result=VkSwapchainCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.surface)=deserialize_VkSurfaceKHR(reader.getSurface());}();
[&](){(result.minImageCount)=reader.getMinImageCount();}();
[&](){[&](){[&](){(result.imageFormat)=reader.getImageFormat();}();}();}();
[&](){[&](){[&](){(result.imageColorSpace)=reader.getImageColorSpace();}();}();}();
[&](){
            auto temp=reader.getImageExtent();
            (result.imageExtent)=deserialize_struct(temp);
            }();
[&](){(result.imageArrayLayers)=reader.getImageArrayLayers();}();
[&](){[&](){[&](){(result.imageUsage)=reader.getImageUsage();}();}();}();
[&](){[&](){[&](){(result.imageSharingMode)=reader.getImageSharingMode();}();}();}();
[&](){(result.queueFamilyIndexCount)=reader.getQueueFamilyIndexCount();}();
[&](){ uint32_t* temp_NzZliok[&](){
            if (!reader.getPQueueFamilyIndices().size()==0){
                (result.pQueueFamilyIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.queueFamilyIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPQueueFamilyIndices(result.queueFamilyIndexCount);
        for(int JEqKTnG=0; JEqKTnG < result.queueFamilyIndexCount; JEqKTnG++){
            [&](){((result.pQueueFamilyIndices)[JEqKTnG])=proto_arr[JEqKTnG];}();
        }
        }();(result.pQueueFamilyIndices)=temp_NzZliok;}();
[&](){[&](){[&](){(result.preTransform)=reader.getPreTransform();}();}();}();
[&](){[&](){[&](){(result.compositeAlpha)=reader.getCompositeAlpha();}();}();}();
[&](){[&](){[&](){(result.presentMode)=reader.getPresentMode();}();}();}();
[&](){[&](){(result.clipped)=reader.getClipped();}();}();
[&](){(result.oldSwapchain)=deserialize_VkSwapchainKHR(reader.getOldSwapchain());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPresentInfoKHR::Builder& builder, VkPresentInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setWaitSemaphoreCount((member.waitSemaphoreCount));}();
[&](){
            if ((member.pWaitSemaphores)==NULL){
                builder.initPWaitSemaphores(0);
            return; }
        auto proto_arr=builder.initPWaitSemaphores(member.waitSemaphoreCount);
        for(int UPuCjkG=0; UPuCjkG < member.waitSemaphoreCount; UPuCjkG++){
            [&](){return proto_arr.set(UPuCjkG,serialize_handle((member.pWaitSemaphores)[UPuCjkG]));}();
        }
        }();
[&](){return builder.setSwapchainCount((member.swapchainCount));}();
[&](){
            if ((member.pSwapchains)==NULL){
                builder.initPSwapchains(0);
            return; }
        auto proto_arr=builder.initPSwapchains(member.swapchainCount);
        for(int zFXKoee=0; zFXKoee < member.swapchainCount; zFXKoee++){
            [&](){return proto_arr.set(zFXKoee,serialize_handle((member.pSwapchains)[zFXKoee]));}();
        }
        }();
[&](){
            if ((member.pImageIndices)==NULL){
                builder.initPImageIndices(0);
            return; }
        auto proto_arr=builder.initPImageIndices(member.swapchainCount);
        for(int uFkTWYN=0; uFkTWYN < member.swapchainCount; uFkTWYN++){
            [&](){return proto_arr.set(uFkTWYN,((member.pImageIndices)[uFkTWYN]));}();
        }
        }();
[&](){
            if ((member.pResults)==NULL){
                builder.initPResults(0);
            return; }
        auto proto_arr=builder.initPResults(member.swapchainCount);
        for(int bYifpDK=0; bYifpDK < member.swapchainCount; bYifpDK++){
            [&](){[&](){[&](){return proto_arr.set(bYifpDK,((member.pResults)[bYifpDK]));}();}();}();
        }
        }();
}

    VkPresentInfoKHR deserialize_struct(stream::VkPresentInfoKHR::Reader reader){
        auto result=VkPresentInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.waitSemaphoreCount)=reader.getWaitSemaphoreCount();}();
[&](){ VkSemaphore* temp_vxBhExF[&](){
            if (!reader.getPWaitSemaphores().size()==0){
                (result.pWaitSemaphores)=NULL;
            return; }{native_concat()}=(VkSemaphore*)malloc(result.waitSemaphoreCount*sizeof(VkSemaphore));
        auto proto_arr=reader.getPWaitSemaphores(result.waitSemaphoreCount);
        for(int eowObQx=0; eowObQx < result.waitSemaphoreCount; eowObQx++){
            [&](){((result.pWaitSemaphores)[eowObQx])=deserialize_VkSemaphore(proto_arr[eowObQx]);}();
        }
        }();(result.pWaitSemaphores)=temp_vxBhExF;}();
[&](){(result.swapchainCount)=reader.getSwapchainCount();}();
[&](){ VkSwapchainKHR* temp_hEHQKBw[&](){
            if (!reader.getPSwapchains().size()==0){
                (result.pSwapchains)=NULL;
            return; }{native_concat()}=(VkSwapchainKHR*)malloc(result.swapchainCount*sizeof(VkSwapchainKHR));
        auto proto_arr=reader.getPSwapchains(result.swapchainCount);
        for(int KhSRwHa=0; KhSRwHa < result.swapchainCount; KhSRwHa++){
            [&](){((result.pSwapchains)[KhSRwHa])=deserialize_VkSwapchainKHR(proto_arr[KhSRwHa]);}();
        }
        }();(result.pSwapchains)=temp_hEHQKBw;}();
[&](){ uint32_t* temp_qoVkzeK[&](){
            if (!reader.getPImageIndices().size()==0){
                (result.pImageIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.swapchainCount*sizeof(uint32_t));
        auto proto_arr=reader.getPImageIndices(result.swapchainCount);
        for(int daliJoD=0; daliJoD < result.swapchainCount; daliJoD++){
            [&](){((result.pImageIndices)[daliJoD])=proto_arr[daliJoD];}();
        }
        }();(result.pImageIndices)=temp_qoVkzeK;}();
[&](){
            if (!reader.getPResults().size()==0){
                (result.pResults)=NULL;
            return; }{native_concat()}=(VkResult*)malloc(result.swapchainCount*sizeof(VkResult));
        auto proto_arr=reader.getPResults(result.swapchainCount);
        for(int bYifpDK=0; bYifpDK < result.swapchainCount; bYifpDK++){
            [&](){[&](){[&](){((result.pResults)[bYifpDK])=proto_arr[bYifpDK];}();}();}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPresentInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPresentInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugReportCallbackCreateInfoEXT::Builder& builder, VkDebugReportCallbackCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            auto temp=builder.initPfnCallback(pfnCallback);
            return serialize_funcpointer(temp, (member.pfnCallback));
            }();
[&](){
            auto temp=builder.initPUserData(pUserData);
            return serialize_struct(temp, (member.pUserData));
            }();
}

    VkDebugReportCallbackCreateInfoEXT deserialize_struct(stream::VkDebugReportCallbackCreateInfoEXT::Reader reader){
        auto result=VkDebugReportCallbackCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnCallback();
            (result.pfnCallback)=deserialize_funcpointer(temp);
            #endif
}();
[&](){
            auto temp=reader.getPUserData();
            (result.pUserData)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugReportCallbackCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
builder.setPFN_vkDebugReportCallbackEXT((uintptr_t)(member.pfnCallback));
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugReportCallbackCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();
result.pfnCallback=reader.getPFN_vkDebugReportCallbackEXT();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkValidationFlagsEXT::Builder& builder, VkValidationFlagsEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDisabledValidationCheckCount((member.disabledValidationCheckCount));}();
[&](){
            if ((member.pDisabledValidationChecks)==NULL){
                builder.initPDisabledValidationChecks(0);
            return; }
        auto proto_arr=builder.initPDisabledValidationChecks(member.disabledValidationCheckCount);
        for(int jaivMZO=0; jaivMZO < member.disabledValidationCheckCount; jaivMZO++){
            [&](){[&](){[&](){return proto_arr.set(jaivMZO,((member.pDisabledValidationChecks)[jaivMZO]));}();}();}();
        }
        }();
}

    VkValidationFlagsEXT deserialize_struct(stream::VkValidationFlagsEXT::Reader reader){
        auto result=VkValidationFlagsEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.disabledValidationCheckCount)=reader.getDisabledValidationCheckCount();}();
[&](){ VkValidationCheckEXT* temp_FfDDuBd[&](){
            if (!reader.getPDisabledValidationChecks().size()==0){
                (result.pDisabledValidationChecks)=NULL;
            return; }{native_concat()}=(VkValidationCheckEXT*)malloc(result.disabledValidationCheckCount*sizeof(VkValidationCheckEXT));
        auto proto_arr=reader.getPDisabledValidationChecks(result.disabledValidationCheckCount);
        for(int VTQHILD=0; VTQHILD < result.disabledValidationCheckCount; VTQHILD++){
            [&](){[&](){[&](){((result.pDisabledValidationChecks)[VTQHILD])=proto_arr[VTQHILD];}();}();}();
        }
        }();(result.pDisabledValidationChecks)=temp_FfDDuBd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkValidationFlagsEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkValidationFlagsEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkValidationFeaturesEXT::Builder& builder, VkValidationFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setEnabledValidationFeatureCount((member.enabledValidationFeatureCount));}();
[&](){
            if ((member.pEnabledValidationFeatures)==NULL){
                builder.initPEnabledValidationFeatures(0);
            return; }
        auto proto_arr=builder.initPEnabledValidationFeatures(member.enabledValidationFeatureCount);
        for(int ctgavwB=0; ctgavwB < member.enabledValidationFeatureCount; ctgavwB++){
            [&](){[&](){[&](){return proto_arr.set(ctgavwB,((member.pEnabledValidationFeatures)[ctgavwB]));}();}();}();
        }
        }();
[&](){return builder.setDisabledValidationFeatureCount((member.disabledValidationFeatureCount));}();
[&](){
            if ((member.pDisabledValidationFeatures)==NULL){
                builder.initPDisabledValidationFeatures(0);
            return; }
        auto proto_arr=builder.initPDisabledValidationFeatures(member.disabledValidationFeatureCount);
        for(int XEOKvrX=0; XEOKvrX < member.disabledValidationFeatureCount; XEOKvrX++){
            [&](){[&](){[&](){return proto_arr.set(XEOKvrX,((member.pDisabledValidationFeatures)[XEOKvrX]));}();}();}();
        }
        }();
}

    VkValidationFeaturesEXT deserialize_struct(stream::VkValidationFeaturesEXT::Reader reader){
        auto result=VkValidationFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.enabledValidationFeatureCount)=reader.getEnabledValidationFeatureCount();}();
[&](){ VkValidationFeatureEnableEXT* temp_OCkzFoO[&](){
            if (!reader.getPEnabledValidationFeatures().size()==0){
                (result.pEnabledValidationFeatures)=NULL;
            return; }{native_concat()}=(VkValidationFeatureEnableEXT*)malloc(result.enabledValidationFeatureCount*sizeof(VkValidationFeatureEnableEXT));
        auto proto_arr=reader.getPEnabledValidationFeatures(result.enabledValidationFeatureCount);
        for(int bCZcZYb=0; bCZcZYb < result.enabledValidationFeatureCount; bCZcZYb++){
            [&](){[&](){[&](){((result.pEnabledValidationFeatures)[bCZcZYb])=proto_arr[bCZcZYb];}();}();}();
        }
        }();(result.pEnabledValidationFeatures)=temp_OCkzFoO;}();
[&](){(result.disabledValidationFeatureCount)=reader.getDisabledValidationFeatureCount();}();
[&](){ VkValidationFeatureDisableEXT* temp_DUwYEtP[&](){
            if (!reader.getPDisabledValidationFeatures().size()==0){
                (result.pDisabledValidationFeatures)=NULL;
            return; }{native_concat()}=(VkValidationFeatureDisableEXT*)malloc(result.disabledValidationFeatureCount*sizeof(VkValidationFeatureDisableEXT));
        auto proto_arr=reader.getPDisabledValidationFeatures(result.disabledValidationFeatureCount);
        for(int wUHyvNv=0; wUHyvNv < result.disabledValidationFeatureCount; wUHyvNv++){
            [&](){[&](){[&](){((result.pDisabledValidationFeatures)[wUHyvNv])=proto_arr[wUHyvNv];}();}();}();
        }
        }();(result.pDisabledValidationFeatures)=temp_DUwYEtP;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkValidationFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkValidationFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRasterizationStateRasterizationOrderAMD::Builder& builder, VkPipelineRasterizationStateRasterizationOrderAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setRasterizationOrder((member.rasterizationOrder));}();}();}();
}

    VkPipelineRasterizationStateRasterizationOrderAMD deserialize_struct(stream::VkPipelineRasterizationStateRasterizationOrderAMD::Reader reader){
        auto result=VkPipelineRasterizationStateRasterizationOrderAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.rasterizationOrder)=reader.getRasterizationOrder();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRasterizationStateRasterizationOrderAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRasterizationStateRasterizationOrderAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugMarkerObjectNameInfoEXT::Builder& builder, VkDebugMarkerObjectNameInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setObjectType((member.objectType));}();}();}();
[&](){return builder.setObject((member.object));}();
[&](){
            if ((member.pObjectName)==NULL){
                builder.initPObjectName(0);
            return; }
        auto proto_arr=builder.initPObjectName(strlen((member.pObjectName))+1);
        for(int IrvYMgK=0; IrvYMgK < strlen((member.pObjectName))+1; IrvYMgK++){
            [&](){return proto_arr.set(IrvYMgK,((member.pObjectName)[IrvYMgK]));}();
        }
        }();
}

    VkDebugMarkerObjectNameInfoEXT deserialize_struct(stream::VkDebugMarkerObjectNameInfoEXT::Reader reader){
        auto result=VkDebugMarkerObjectNameInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.objectType)=reader.getObjectType();}();}();}();
[&](){(result.object)=reader.getObject();}();
[&](){ char* temp_AUIQNis[&](){
            if (!reader.getPObjectName().size()==0){
                (result.pObjectName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPObjectName().size();*sizeof(char));
        auto proto_arr=reader.getPObjectName(reader.getPObjectName().size(););
        for(int vNFhQsi=0; vNFhQsi < reader.getPObjectName().size();; vNFhQsi++){
            [&](){((result.pObjectName)[vNFhQsi])=proto_arr[vNFhQsi];}();
        }
        }();(result.pObjectName)=temp_AUIQNis;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugMarkerObjectNameInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugMarkerObjectNameInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugMarkerObjectTagInfoEXT::Builder& builder, VkDebugMarkerObjectTagInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setObjectType((member.objectType));}();}();}();
[&](){return builder.setObject((member.object));}();
[&](){return builder.setTagName((member.tagName));}();
[&](){return builder.setTagSize((member.tagSize));}();
[&](){
            if ((member.pTag)==NULL){
                builder.initPTag(0);
            return; }[&](){
            if (((char*)(member.pTag).pTag)==NULL){
                builder.initPTag(0);
            return; }
        auto proto_arr=builder.initPTag(member.tagSize);
        for(int RyqFIjd=0; RyqFIjd < member.tagSize; RyqFIjd++){
            [&](){return proto_arr.set(RyqFIjd,(((char*)(member.pTag).pTag)[RyqFIjd]));}();
        }
        }();}();
}

    VkDebugMarkerObjectTagInfoEXT deserialize_struct(stream::VkDebugMarkerObjectTagInfoEXT::Reader reader){
        auto result=VkDebugMarkerObjectTagInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.objectType)=reader.getObjectType();}();}();}();
[&](){(result.object)=reader.getObject();}();
[&](){(result.tagName)=reader.getTagName();}();
[&](){(result.tagSize)=reader.getTagSize();}();
[&](){ void* temp_hwJmLWe[&](){
            if (!reader.getPTag().size()==0){
                (result.pTag)=NULL;
            return; }char* temp_BYVrBDU;[&](){
            if (!reader.getPTag().size()==0){
                (temp_BYVrBDU.pTag)=NULL;
            return; }{native_concat()}=(char*)malloc(result.tagSize*sizeof(char));
        auto proto_arr=reader.getPTag(result.tagSize);
        for(int lxDYfsn=0; lxDYfsn < result.tagSize; lxDYfsn++){
            [&](){((temp_BYVrBDU.pTag)[lxDYfsn])=proto_arr[lxDYfsn];}();
        }
        }();(result.pTag)=temp_BYVrBDU;}();(result.pTag)=temp_hwJmLWe;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugMarkerObjectTagInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugMarkerObjectTagInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugMarkerMarkerInfoEXT::Builder& builder, VkDebugMarkerMarkerInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pMarkerName)==NULL){
                builder.initPMarkerName(0);
            return; }
        auto proto_arr=builder.initPMarkerName(strlen((member.pMarkerName))+1);
        for(int wSyyLJw=0; wSyyLJw < strlen((member.pMarkerName))+1; wSyyLJw++){
            [&](){return proto_arr.set(wSyyLJw,((member.pMarkerName)[wSyyLJw]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initColor(4);
        for(int oKnkjtQ=0; oKnkjtQ < 4; oKnkjtQ++){
            [&](){return proto_arr.set(oKnkjtQ,((member.color)[oKnkjtQ]));}();
        }
        }();
}

    VkDebugMarkerMarkerInfoEXT deserialize_struct(stream::VkDebugMarkerMarkerInfoEXT::Reader reader){
        auto result=VkDebugMarkerMarkerInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ char* temp_XJIlhPW[&](){
            if (!reader.getPMarkerName().size()==0){
                (result.pMarkerName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPMarkerName().size();*sizeof(char));
        auto proto_arr=reader.getPMarkerName(reader.getPMarkerName().size(););
        for(int GKICecd=0; GKICecd < reader.getPMarkerName().size();; GKICecd++){
            [&](){((result.pMarkerName)[GKICecd])=proto_arr[GKICecd];}();
        }
        }();(result.pMarkerName)=temp_XJIlhPW;}();
[&](){
        auto proto_arr=reader.getColor(4);
        for(int oKnkjtQ=0; oKnkjtQ < 4; oKnkjtQ++){
            [&](){((result.color)[oKnkjtQ])=proto_arr[oKnkjtQ];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugMarkerMarkerInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugMarkerMarkerInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDedicatedAllocationImageCreateInfoNV::Builder& builder, VkDedicatedAllocationImageCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDedicatedAllocation((member.dedicatedAllocation));}();}();
}

    VkDedicatedAllocationImageCreateInfoNV deserialize_struct(stream::VkDedicatedAllocationImageCreateInfoNV::Reader reader){
        auto result=VkDedicatedAllocationImageCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.dedicatedAllocation)=reader.getDedicatedAllocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDedicatedAllocationImageCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDedicatedAllocationImageCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDedicatedAllocationBufferCreateInfoNV::Builder& builder, VkDedicatedAllocationBufferCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDedicatedAllocation((member.dedicatedAllocation));}();}();
}

    VkDedicatedAllocationBufferCreateInfoNV deserialize_struct(stream::VkDedicatedAllocationBufferCreateInfoNV::Reader reader){
        auto result=VkDedicatedAllocationBufferCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.dedicatedAllocation)=reader.getDedicatedAllocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDedicatedAllocationBufferCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDedicatedAllocationBufferCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDedicatedAllocationMemoryAllocateInfoNV::Builder& builder, VkDedicatedAllocationMemoryAllocateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
}

    VkDedicatedAllocationMemoryAllocateInfoNV deserialize_struct(stream::VkDedicatedAllocationMemoryAllocateInfoNV::Reader reader){
        auto result=VkDedicatedAllocationMemoryAllocateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDedicatedAllocationMemoryAllocateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDedicatedAllocationMemoryAllocateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalImageFormatPropertiesNV::Builder& builder, VkExternalImageFormatPropertiesNV member){
        
    
[&](){
            auto temp=builder.initImageFormatProperties(imageFormatProperties);
            return serialize_struct(temp, (member.imageFormatProperties));
            }();
[&](){[&](){[&](){return builder.setExternalMemoryFeatures((member.externalMemoryFeatures));}();}();}();
[&](){[&](){[&](){return builder.setExportFromImportedHandleTypes((member.exportFromImportedHandleTypes));}();}();}();
[&](){[&](){[&](){return builder.setCompatibleHandleTypes((member.compatibleHandleTypes));}();}();}();
}

    VkExternalImageFormatPropertiesNV deserialize_struct(stream::VkExternalImageFormatPropertiesNV::Reader reader){
        auto result=VkExternalImageFormatPropertiesNV();
    
[&](){
            auto temp=reader.getImageFormatProperties();
            (result.imageFormatProperties)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.externalMemoryFeatures)=reader.getExternalMemoryFeatures();}();}();}();
[&](){[&](){[&](){(result.exportFromImportedHandleTypes)=reader.getExportFromImportedHandleTypes();}();}();}();
[&](){[&](){[&](){(result.compatibleHandleTypes)=reader.getCompatibleHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalImageFormatPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalImageFormatPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalMemoryImageCreateInfoNV::Builder& builder, VkExternalMemoryImageCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleTypes((member.handleTypes));}();}();}();
}

    VkExternalMemoryImageCreateInfoNV deserialize_struct(stream::VkExternalMemoryImageCreateInfoNV::Reader reader){
        auto result=VkExternalMemoryImageCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleTypes)=reader.getHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalMemoryImageCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalMemoryImageCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExportMemoryAllocateInfoNV::Builder& builder, VkExportMemoryAllocateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleTypes((member.handleTypes));}();}();}();
}

    VkExportMemoryAllocateInfoNV deserialize_struct(stream::VkExportMemoryAllocateInfoNV::Reader reader){
        auto result=VkExportMemoryAllocateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleTypes)=reader.getHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExportMemoryAllocateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExportMemoryAllocateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::Builder& builder, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceGeneratedCommands((member.deviceGeneratedCommands));}();}();
}

    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV deserialize_struct(stream::VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.deviceGeneratedCommands)=reader.getDeviceGeneratedCommands();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::Builder& builder, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceGeneratedCompute((member.deviceGeneratedCompute));}();}();
[&](){[&](){return builder.setDeviceGeneratedComputePipelines((member.deviceGeneratedComputePipelines));}();}();
[&](){[&](){return builder.setDeviceGeneratedComputeCaptureReplay((member.deviceGeneratedComputeCaptureReplay));}();}();
}

    VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV deserialize_struct(stream::VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.deviceGeneratedCompute)=reader.getDeviceGeneratedCompute();}();}();
[&](){[&](){(result.deviceGeneratedComputePipelines)=reader.getDeviceGeneratedComputePipelines();}();}();
[&](){[&](){(result.deviceGeneratedComputeCaptureReplay)=reader.getDeviceGeneratedComputeCaptureReplay();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDevicePrivateDataCreateInfo::Builder& builder, VkDevicePrivateDataCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPrivateDataSlotRequestCount((member.privateDataSlotRequestCount));}();
}

    VkDevicePrivateDataCreateInfo deserialize_struct(stream::VkDevicePrivateDataCreateInfo::Reader reader){
        auto result=VkDevicePrivateDataCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.privateDataSlotRequestCount)=reader.getPrivateDataSlotRequestCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDevicePrivateDataCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDevicePrivateDataCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPrivateDataSlotCreateInfo::Builder& builder, VkPrivateDataSlotCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkPrivateDataSlotCreateInfo deserialize_struct(stream::VkPrivateDataSlotCreateInfo::Reader reader){
        auto result=VkPrivateDataSlotCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPrivateDataSlotCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPrivateDataSlotCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePrivateDataFeatures::Builder& builder, VkPhysicalDevicePrivateDataFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPrivateData((member.privateData));}();}();
}

    VkPhysicalDevicePrivateDataFeatures deserialize_struct(stream::VkPhysicalDevicePrivateDataFeatures::Reader reader){
        auto result=VkPhysicalDevicePrivateDataFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.privateData)=reader.getPrivateData();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePrivateDataFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePrivateDataFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::Builder& builder, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxGraphicsShaderGroupCount((member.maxGraphicsShaderGroupCount));}();
[&](){return builder.setMaxIndirectSequenceCount((member.maxIndirectSequenceCount));}();
[&](){return builder.setMaxIndirectCommandsTokenCount((member.maxIndirectCommandsTokenCount));}();
[&](){return builder.setMaxIndirectCommandsStreamCount((member.maxIndirectCommandsStreamCount));}();
[&](){return builder.setMaxIndirectCommandsTokenOffset((member.maxIndirectCommandsTokenOffset));}();
[&](){return builder.setMaxIndirectCommandsStreamStride((member.maxIndirectCommandsStreamStride));}();
[&](){return builder.setMinSequencesCountBufferOffsetAlignment((member.minSequencesCountBufferOffsetAlignment));}();
[&](){return builder.setMinSequencesIndexBufferOffsetAlignment((member.minSequencesIndexBufferOffsetAlignment));}();
[&](){return builder.setMinIndirectCommandsBufferOffsetAlignment((member.minIndirectCommandsBufferOffsetAlignment));}();
}

    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV deserialize_struct(stream::VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxGraphicsShaderGroupCount)=reader.getMaxGraphicsShaderGroupCount();}();
[&](){(result.maxIndirectSequenceCount)=reader.getMaxIndirectSequenceCount();}();
[&](){(result.maxIndirectCommandsTokenCount)=reader.getMaxIndirectCommandsTokenCount();}();
[&](){(result.maxIndirectCommandsStreamCount)=reader.getMaxIndirectCommandsStreamCount();}();
[&](){(result.maxIndirectCommandsTokenOffset)=reader.getMaxIndirectCommandsTokenOffset();}();
[&](){(result.maxIndirectCommandsStreamStride)=reader.getMaxIndirectCommandsStreamStride();}();
[&](){(result.minSequencesCountBufferOffsetAlignment)=reader.getMinSequencesCountBufferOffsetAlignment();}();
[&](){(result.minSequencesIndexBufferOffsetAlignment)=reader.getMinSequencesIndexBufferOffsetAlignment();}();
[&](){(result.minIndirectCommandsBufferOffsetAlignment)=reader.getMinIndirectCommandsBufferOffsetAlignment();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultiDrawPropertiesEXT::Builder& builder, VkPhysicalDeviceMultiDrawPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxMultiDrawCount((member.maxMultiDrawCount));}();
}

    VkPhysicalDeviceMultiDrawPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceMultiDrawPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceMultiDrawPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxMultiDrawCount)=reader.getMaxMultiDrawCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultiDrawPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultiDrawPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGraphicsShaderGroupCreateInfoNV::Builder& builder, VkGraphicsShaderGroupCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setStageCount((member.stageCount));}();
[&](){
            if ((member.pStages)==NULL){
                builder.initPStages(0);
            return; }
        auto proto_arr=builder.initPStages(member.stageCount);
        for(int jHuRulk=0; jHuRulk < member.stageCount; jHuRulk++){
            [&](){
            auto temp=proto_arr[jHuRulk];
            return serialize_struct(temp, ((member.pStages)[jHuRulk]));
            }();
        }
        }();
[&](){
            if ((member.pVertexInputState)==NULL){
                builder.initPVertexInputState(0);
            return; }
        auto proto_arr=builder.initPVertexInputState(1);
        for(int wkXjKqh=0; wkXjKqh < 1; wkXjKqh++){
            [&](){
            auto temp=proto_arr[wkXjKqh];
            return serialize_struct(temp, ((member.pVertexInputState)[wkXjKqh]));
            }();
        }
        }();
[&](){
            if ((member.pTessellationState)==NULL){
                builder.initPTessellationState(0);
            return; }
        auto proto_arr=builder.initPTessellationState(1);
        for(int rSxHnEH=0; rSxHnEH < 1; rSxHnEH++){
            [&](){
            auto temp=proto_arr[rSxHnEH];
            return serialize_struct(temp, ((member.pTessellationState)[rSxHnEH]));
            }();
        }
        }();
}

    VkGraphicsShaderGroupCreateInfoNV deserialize_struct(stream::VkGraphicsShaderGroupCreateInfoNV::Reader reader){
        auto result=VkGraphicsShaderGroupCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.stageCount)=reader.getStageCount();}();
[&](){ VkPipelineShaderStageCreateInfo* temp_FsQxpon[&](){
            if (!reader.getPStages().size()==0){
                (result.pStages)=NULL;
            return; }{native_concat()}=(VkPipelineShaderStageCreateInfo*)malloc(result.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto proto_arr=reader.getPStages(result.stageCount);
        for(int XttzcgZ=0; XttzcgZ < result.stageCount; XttzcgZ++){
            [&](){
            auto temp=proto_arr[XttzcgZ];
            ((result.pStages)[XttzcgZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pStages)=temp_FsQxpon;}();
[&](){ VkPipelineVertexInputStateCreateInfo* temp_GRDNOgA[&](){
            if (!reader.getPVertexInputState().size()==0){
                (result.pVertexInputState)=NULL;
            return; }{native_concat()}=(VkPipelineVertexInputStateCreateInfo*)malloc(1*sizeof(VkPipelineVertexInputStateCreateInfo));
        auto proto_arr=reader.getPVertexInputState(1);
        for(int RFpaRUE=0; RFpaRUE < 1; RFpaRUE++){
            [&](){
            auto temp=proto_arr[RFpaRUE];
            ((result.pVertexInputState)[RFpaRUE])=deserialize_struct(temp);
            }();
        }
        }();(result.pVertexInputState)=temp_GRDNOgA;}();
[&](){ VkPipelineTessellationStateCreateInfo* temp_LTmoKJi[&](){
            if (!reader.getPTessellationState().size()==0){
                (result.pTessellationState)=NULL;
            return; }{native_concat()}=(VkPipelineTessellationStateCreateInfo*)malloc(1*sizeof(VkPipelineTessellationStateCreateInfo));
        auto proto_arr=reader.getPTessellationState(1);
        for(int QktcRuM=0; QktcRuM < 1; QktcRuM++){
            [&](){
            auto temp=proto_arr[QktcRuM];
            ((result.pTessellationState)[QktcRuM])=deserialize_struct(temp);
            }();
        }
        }();(result.pTessellationState)=temp_LTmoKJi;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGraphicsShaderGroupCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGraphicsShaderGroupCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGraphicsPipelineShaderGroupsCreateInfoNV::Builder& builder, VkGraphicsPipelineShaderGroupsCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setGroupCount((member.groupCount));}();
[&](){
            if ((member.pGroups)==NULL){
                builder.initPGroups(0);
            return; }
        auto proto_arr=builder.initPGroups(member.groupCount);
        for(int SHuCqju=0; SHuCqju < member.groupCount; SHuCqju++){
            [&](){
            auto temp=proto_arr[SHuCqju];
            return serialize_struct(temp, ((member.pGroups)[SHuCqju]));
            }();
        }
        }();
[&](){return builder.setPipelineCount((member.pipelineCount));}();
[&](){
            if ((member.pPipelines)==NULL){
                builder.initPPipelines(0);
            return; }
        auto proto_arr=builder.initPPipelines(member.pipelineCount);
        for(int lyGUQUU=0; lyGUQUU < member.pipelineCount; lyGUQUU++){
            [&](){return proto_arr.set(lyGUQUU,serialize_handle((member.pPipelines)[lyGUQUU]));}();
        }
        }();
}

    VkGraphicsPipelineShaderGroupsCreateInfoNV deserialize_struct(stream::VkGraphicsPipelineShaderGroupsCreateInfoNV::Reader reader){
        auto result=VkGraphicsPipelineShaderGroupsCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.groupCount)=reader.getGroupCount();}();
[&](){ VkGraphicsShaderGroupCreateInfoNV* temp_EyScfUH[&](){
            if (!reader.getPGroups().size()==0){
                (result.pGroups)=NULL;
            return; }{native_concat()}=(VkGraphicsShaderGroupCreateInfoNV*)malloc(result.groupCount*sizeof(VkGraphicsShaderGroupCreateInfoNV));
        auto proto_arr=reader.getPGroups(result.groupCount);
        for(int KggKLeT=0; KggKLeT < result.groupCount; KggKLeT++){
            [&](){
            auto temp=proto_arr[KggKLeT];
            ((result.pGroups)[KggKLeT])=deserialize_struct(temp);
            }();
        }
        }();(result.pGroups)=temp_EyScfUH;}();
[&](){(result.pipelineCount)=reader.getPipelineCount();}();
[&](){ VkPipeline* temp_tsZNydY[&](){
            if (!reader.getPPipelines().size()==0){
                (result.pPipelines)=NULL;
            return; }{native_concat()}=(VkPipeline*)malloc(result.pipelineCount*sizeof(VkPipeline));
        auto proto_arr=reader.getPPipelines(result.pipelineCount);
        for(int zikgMik=0; zikgMik < result.pipelineCount; zikgMik++){
            [&](){((result.pPipelines)[zikgMik])=deserialize_VkPipeline(proto_arr[zikgMik]);}();
        }
        }();(result.pPipelines)=temp_tsZNydY;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGraphicsPipelineShaderGroupsCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGraphicsPipelineShaderGroupsCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindShaderGroupIndirectCommandNV::Builder& builder, VkBindShaderGroupIndirectCommandNV member){
        
    
[&](){return builder.setGroupIndex((member.groupIndex));}();
}

    VkBindShaderGroupIndirectCommandNV deserialize_struct(stream::VkBindShaderGroupIndirectCommandNV::Reader reader){
        auto result=VkBindShaderGroupIndirectCommandNV();
    
[&](){(result.groupIndex)=reader.getGroupIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindShaderGroupIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindShaderGroupIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindIndexBufferIndirectCommandNV::Builder& builder, VkBindIndexBufferIndirectCommandNV member){
        
    
[&](){[&](){return builder.setBufferAddress((member.bufferAddress));}();}();
[&](){return builder.setSize((member.size));}();
[&](){[&](){[&](){return builder.setIndexType((member.indexType));}();}();}();
}

    VkBindIndexBufferIndirectCommandNV deserialize_struct(stream::VkBindIndexBufferIndirectCommandNV::Reader reader){
        auto result=VkBindIndexBufferIndirectCommandNV();
    
[&](){[&](){(result.bufferAddress)=reader.getBufferAddress();}();}();
[&](){(result.size)=reader.getSize();}();
[&](){[&](){[&](){(result.indexType)=reader.getIndexType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindIndexBufferIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindIndexBufferIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindVertexBufferIndirectCommandNV::Builder& builder, VkBindVertexBufferIndirectCommandNV member){
        
    
[&](){[&](){return builder.setBufferAddress((member.bufferAddress));}();}();
[&](){return builder.setSize((member.size));}();
[&](){return builder.setStride((member.stride));}();
}

    VkBindVertexBufferIndirectCommandNV deserialize_struct(stream::VkBindVertexBufferIndirectCommandNV::Reader reader){
        auto result=VkBindVertexBufferIndirectCommandNV();
    
[&](){[&](){(result.bufferAddress)=reader.getBufferAddress();}();}();
[&](){(result.size)=reader.getSize();}();
[&](){(result.stride)=reader.getStride();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindVertexBufferIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindVertexBufferIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSetStateFlagsIndirectCommandNV::Builder& builder, VkSetStateFlagsIndirectCommandNV member){
        
    
[&](){return builder.setData((member.data));}();
}

    VkSetStateFlagsIndirectCommandNV deserialize_struct(stream::VkSetStateFlagsIndirectCommandNV::Reader reader){
        auto result=VkSetStateFlagsIndirectCommandNV();
    
[&](){(result.data)=reader.getData();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSetStateFlagsIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSetStateFlagsIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkIndirectCommandsStreamNV::Builder& builder, VkIndirectCommandsStreamNV member){
        
    
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
}

    VkIndirectCommandsStreamNV deserialize_struct(stream::VkIndirectCommandsStreamNV::Reader reader){
        auto result=VkIndirectCommandsStreamNV();
    
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkIndirectCommandsStreamNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkIndirectCommandsStreamNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkIndirectCommandsLayoutTokenNV::Builder& builder, VkIndirectCommandsLayoutTokenNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setTokenType((member.tokenType));}();}();}();
[&](){return builder.setStream((member.stream));}();
[&](){return builder.setOffset((member.offset));}();
[&](){return builder.setVertexBindingUnit((member.vertexBindingUnit));}();
[&](){[&](){return builder.setVertexDynamicStride((member.vertexDynamicStride));}();}();
[&](){return builder.setPushconstantPipelineLayout(serialize_handle(member.pushconstantPipelineLayout));}();
[&](){[&](){[&](){return builder.setPushconstantShaderStageFlags((member.pushconstantShaderStageFlags));}();}();}();
[&](){return builder.setPushconstantOffset((member.pushconstantOffset));}();
[&](){return builder.setPushconstantSize((member.pushconstantSize));}();
[&](){[&](){[&](){return builder.setIndirectStateFlags((member.indirectStateFlags));}();}();}();
[&](){return builder.setIndexTypeCount((member.indexTypeCount));}();
[&](){
            if ((member.pIndexTypes)==NULL){
                builder.initPIndexTypes(0);
            return; }
        auto proto_arr=builder.initPIndexTypes(member.indexTypeCount);
        for(int MJIZeIG=0; MJIZeIG < member.indexTypeCount; MJIZeIG++){
            [&](){[&](){[&](){return proto_arr.set(MJIZeIG,((member.pIndexTypes)[MJIZeIG]));}();}();}();
        }
        }();
[&](){
            if ((member.pIndexTypeValues)==NULL){
                builder.initPIndexTypeValues(0);
            return; }
        auto proto_arr=builder.initPIndexTypeValues(member.indexTypeCount);
        for(int FhKsxka=0; FhKsxka < member.indexTypeCount; FhKsxka++){
            [&](){return proto_arr.set(FhKsxka,((member.pIndexTypeValues)[FhKsxka]));}();
        }
        }();
}

    VkIndirectCommandsLayoutTokenNV deserialize_struct(stream::VkIndirectCommandsLayoutTokenNV::Reader reader){
        auto result=VkIndirectCommandsLayoutTokenNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.tokenType)=reader.getTokenType();}();}();}();
[&](){(result.stream)=reader.getStream();}();
[&](){(result.offset)=reader.getOffset();}();
[&](){(result.vertexBindingUnit)=reader.getVertexBindingUnit();}();
[&](){[&](){(result.vertexDynamicStride)=reader.getVertexDynamicStride();}();}();
[&](){(result.pushconstantPipelineLayout)=deserialize_VkPipelineLayout(reader.getPushconstantPipelineLayout());}();
[&](){[&](){[&](){(result.pushconstantShaderStageFlags)=reader.getPushconstantShaderStageFlags();}();}();}();
[&](){(result.pushconstantOffset)=reader.getPushconstantOffset();}();
[&](){(result.pushconstantSize)=reader.getPushconstantSize();}();
[&](){[&](){[&](){(result.indirectStateFlags)=reader.getIndirectStateFlags();}();}();}();
[&](){(result.indexTypeCount)=reader.getIndexTypeCount();}();
[&](){ VkIndexType* temp_bqbRaET[&](){
            if (!reader.getPIndexTypes().size()==0){
                (result.pIndexTypes)=NULL;
            return; }{native_concat()}=(VkIndexType*)malloc(result.indexTypeCount*sizeof(VkIndexType));
        auto proto_arr=reader.getPIndexTypes(result.indexTypeCount);
        for(int FoZJVOk=0; FoZJVOk < result.indexTypeCount; FoZJVOk++){
            [&](){[&](){[&](){((result.pIndexTypes)[FoZJVOk])=proto_arr[FoZJVOk];}();}();}();
        }
        }();(result.pIndexTypes)=temp_bqbRaET;}();
[&](){ uint32_t* temp_QScLeat[&](){
            if (!reader.getPIndexTypeValues().size()==0){
                (result.pIndexTypeValues)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.indexTypeCount*sizeof(uint32_t));
        auto proto_arr=reader.getPIndexTypeValues(result.indexTypeCount);
        for(int kfKnjmM=0; kfKnjmM < result.indexTypeCount; kfKnjmM++){
            [&](){((result.pIndexTypeValues)[kfKnjmM])=proto_arr[kfKnjmM];}();
        }
        }();(result.pIndexTypeValues)=temp_QScLeat;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkIndirectCommandsLayoutTokenNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkIndirectCommandsLayoutTokenNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkIndirectCommandsLayoutCreateInfoNV::Builder& builder, VkIndirectCommandsLayoutCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setPipelineBindPoint((member.pipelineBindPoint));}();}();}();
[&](){return builder.setTokenCount((member.tokenCount));}();
[&](){
            if ((member.pTokens)==NULL){
                builder.initPTokens(0);
            return; }
        auto proto_arr=builder.initPTokens(member.tokenCount);
        for(int yPSEeiQ=0; yPSEeiQ < member.tokenCount; yPSEeiQ++){
            [&](){
            auto temp=proto_arr[yPSEeiQ];
            return serialize_struct(temp, ((member.pTokens)[yPSEeiQ]));
            }();
        }
        }();
[&](){return builder.setStreamCount((member.streamCount));}();
[&](){
            if ((member.pStreamStrides)==NULL){
                builder.initPStreamStrides(0);
            return; }
        auto proto_arr=builder.initPStreamStrides(member.streamCount);
        for(int MyKJLOU=0; MyKJLOU < member.streamCount; MyKJLOU++){
            [&](){return proto_arr.set(MyKJLOU,((member.pStreamStrides)[MyKJLOU]));}();
        }
        }();
}

    VkIndirectCommandsLayoutCreateInfoNV deserialize_struct(stream::VkIndirectCommandsLayoutCreateInfoNV::Reader reader){
        auto result=VkIndirectCommandsLayoutCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.pipelineBindPoint)=reader.getPipelineBindPoint();}();}();}();
[&](){(result.tokenCount)=reader.getTokenCount();}();
[&](){ VkIndirectCommandsLayoutTokenNV* temp_opjsDQE[&](){
            if (!reader.getPTokens().size()==0){
                (result.pTokens)=NULL;
            return; }{native_concat()}=(VkIndirectCommandsLayoutTokenNV*)malloc(result.tokenCount*sizeof(VkIndirectCommandsLayoutTokenNV));
        auto proto_arr=reader.getPTokens(result.tokenCount);
        for(int QziMwaF=0; QziMwaF < result.tokenCount; QziMwaF++){
            [&](){
            auto temp=proto_arr[QziMwaF];
            ((result.pTokens)[QziMwaF])=deserialize_struct(temp);
            }();
        }
        }();(result.pTokens)=temp_opjsDQE;}();
[&](){(result.streamCount)=reader.getStreamCount();}();
[&](){ uint32_t* temp_wbpzYbd[&](){
            if (!reader.getPStreamStrides().size()==0){
                (result.pStreamStrides)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.streamCount*sizeof(uint32_t));
        auto proto_arr=reader.getPStreamStrides(result.streamCount);
        for(int fUQEhtt=0; fUQEhtt < result.streamCount; fUQEhtt++){
            [&](){((result.pStreamStrides)[fUQEhtt])=proto_arr[fUQEhtt];}();
        }
        }();(result.pStreamStrides)=temp_wbpzYbd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkIndirectCommandsLayoutCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkIndirectCommandsLayoutCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGeneratedCommandsInfoNV::Builder& builder, VkGeneratedCommandsInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPipelineBindPoint((member.pipelineBindPoint));}();}();}();
[&](){return builder.setPipeline(serialize_handle(member.pipeline));}();
[&](){return builder.setIndirectCommandsLayout(serialize_handle(member.indirectCommandsLayout));}();
[&](){return builder.setStreamCount((member.streamCount));}();
[&](){
            if ((member.pStreams)==NULL){
                builder.initPStreams(0);
            return; }
        auto proto_arr=builder.initPStreams(member.streamCount);
        for(int TYeqEkQ=0; TYeqEkQ < member.streamCount; TYeqEkQ++){
            [&](){
            auto temp=proto_arr[TYeqEkQ];
            return serialize_struct(temp, ((member.pStreams)[TYeqEkQ]));
            }();
        }
        }();
[&](){return builder.setSequencesCount((member.sequencesCount));}();
[&](){return builder.setPreprocessBuffer(serialize_handle(member.preprocessBuffer));}();
[&](){[&](){return builder.setPreprocessOffset((member.preprocessOffset));}();}();
[&](){[&](){return builder.setPreprocessSize((member.preprocessSize));}();}();
[&](){return builder.setSequencesCountBuffer(serialize_handle(member.sequencesCountBuffer));}();
[&](){[&](){return builder.setSequencesCountOffset((member.sequencesCountOffset));}();}();
[&](){return builder.setSequencesIndexBuffer(serialize_handle(member.sequencesIndexBuffer));}();
[&](){[&](){return builder.setSequencesIndexOffset((member.sequencesIndexOffset));}();}();
}

    VkGeneratedCommandsInfoNV deserialize_struct(stream::VkGeneratedCommandsInfoNV::Reader reader){
        auto result=VkGeneratedCommandsInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.pipelineBindPoint)=reader.getPipelineBindPoint();}();}();}();
[&](){(result.pipeline)=deserialize_VkPipeline(reader.getPipeline());}();
[&](){(result.indirectCommandsLayout)=deserialize_VkIndirectCommandsLayoutNV(reader.getIndirectCommandsLayout());}();
[&](){(result.streamCount)=reader.getStreamCount();}();
[&](){ VkIndirectCommandsStreamNV* temp_uuukyeL[&](){
            if (!reader.getPStreams().size()==0){
                (result.pStreams)=NULL;
            return; }{native_concat()}=(VkIndirectCommandsStreamNV*)malloc(result.streamCount*sizeof(VkIndirectCommandsStreamNV));
        auto proto_arr=reader.getPStreams(result.streamCount);
        for(int rDgynwm=0; rDgynwm < result.streamCount; rDgynwm++){
            [&](){
            auto temp=proto_arr[rDgynwm];
            ((result.pStreams)[rDgynwm])=deserialize_struct(temp);
            }();
        }
        }();(result.pStreams)=temp_uuukyeL;}();
[&](){(result.sequencesCount)=reader.getSequencesCount();}();
[&](){(result.preprocessBuffer)=deserialize_VkBuffer(reader.getPreprocessBuffer());}();
[&](){[&](){(result.preprocessOffset)=reader.getPreprocessOffset();}();}();
[&](){[&](){(result.preprocessSize)=reader.getPreprocessSize();}();}();
[&](){(result.sequencesCountBuffer)=deserialize_VkBuffer(reader.getSequencesCountBuffer());}();
[&](){[&](){(result.sequencesCountOffset)=reader.getSequencesCountOffset();}();}();
[&](){(result.sequencesIndexBuffer)=deserialize_VkBuffer(reader.getSequencesIndexBuffer());}();
[&](){[&](){(result.sequencesIndexOffset)=reader.getSequencesIndexOffset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGeneratedCommandsInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGeneratedCommandsInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGeneratedCommandsMemoryRequirementsInfoNV::Builder& builder, VkGeneratedCommandsMemoryRequirementsInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPipelineBindPoint((member.pipelineBindPoint));}();}();}();
[&](){return builder.setPipeline(serialize_handle(member.pipeline));}();
[&](){return builder.setIndirectCommandsLayout(serialize_handle(member.indirectCommandsLayout));}();
[&](){return builder.setMaxSequencesCount((member.maxSequencesCount));}();
}

    VkGeneratedCommandsMemoryRequirementsInfoNV deserialize_struct(stream::VkGeneratedCommandsMemoryRequirementsInfoNV::Reader reader){
        auto result=VkGeneratedCommandsMemoryRequirementsInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.pipelineBindPoint)=reader.getPipelineBindPoint();}();}();}();
[&](){(result.pipeline)=deserialize_VkPipeline(reader.getPipeline());}();
[&](){(result.indirectCommandsLayout)=deserialize_VkIndirectCommandsLayoutNV(reader.getIndirectCommandsLayout());}();
[&](){(result.maxSequencesCount)=reader.getMaxSequencesCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGeneratedCommandsMemoryRequirementsInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGeneratedCommandsMemoryRequirementsInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineIndirectDeviceAddressInfoNV::Builder& builder, VkPipelineIndirectDeviceAddressInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPipelineBindPoint((member.pipelineBindPoint));}();}();}();
[&](){return builder.setPipeline(serialize_handle(member.pipeline));}();
}

    VkPipelineIndirectDeviceAddressInfoNV deserialize_struct(stream::VkPipelineIndirectDeviceAddressInfoNV::Reader reader){
        auto result=VkPipelineIndirectDeviceAddressInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.pipelineBindPoint)=reader.getPipelineBindPoint();}();}();}();
[&](){(result.pipeline)=deserialize_VkPipeline(reader.getPipeline());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineIndirectDeviceAddressInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineIndirectDeviceAddressInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindPipelineIndirectCommandNV::Builder& builder, VkBindPipelineIndirectCommandNV member){
        
    
[&](){[&](){return builder.setPipelineAddress((member.pipelineAddress));}();}();
}

    VkBindPipelineIndirectCommandNV deserialize_struct(stream::VkBindPipelineIndirectCommandNV::Reader reader){
        auto result=VkBindPipelineIndirectCommandNV();
    
[&](){[&](){(result.pipelineAddress)=reader.getPipelineAddress();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindPipelineIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindPipelineIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFeatures2::Builder& builder, VkPhysicalDeviceFeatures2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initFeatures(features);
            return serialize_struct(temp, (member.features));
            }();
}

    VkPhysicalDeviceFeatures2 deserialize_struct(stream::VkPhysicalDeviceFeatures2::Reader reader){
        auto result=VkPhysicalDeviceFeatures2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getFeatures();
            (result.features)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFeatures2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFeatures2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceProperties2::Builder& builder, VkPhysicalDeviceProperties2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initProperties(properties);
            return serialize_struct(temp, (member.properties));
            }();
}

    VkPhysicalDeviceProperties2 deserialize_struct(stream::VkPhysicalDeviceProperties2::Reader reader){
        auto result=VkPhysicalDeviceProperties2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getProperties();
            (result.properties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceProperties2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceProperties2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFormatProperties2::Builder& builder, VkFormatProperties2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initFormatProperties(formatProperties);
            return serialize_struct(temp, (member.formatProperties));
            }();
}

    VkFormatProperties2 deserialize_struct(stream::VkFormatProperties2::Reader reader){
        auto result=VkFormatProperties2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getFormatProperties();
            (result.formatProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFormatProperties2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFormatProperties2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageFormatProperties2::Builder& builder, VkImageFormatProperties2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initImageFormatProperties(imageFormatProperties);
            return serialize_struct(temp, (member.imageFormatProperties));
            }();
}

    VkImageFormatProperties2 deserialize_struct(stream::VkImageFormatProperties2::Reader reader){
        auto result=VkImageFormatProperties2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageFormatProperties();
            (result.imageFormatProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageFormatProperties2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageFormatProperties2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageFormatInfo2::Builder& builder, VkPhysicalDeviceImageFormatInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){[&](){return builder.setTiling((member.tiling));}();}();}();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkPhysicalDeviceImageFormatInfo2 deserialize_struct(stream::VkPhysicalDeviceImageFormatInfo2::Reader reader){
        auto result=VkPhysicalDeviceImageFormatInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){[&](){(result.tiling)=reader.getTiling();}();}();}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageFormatInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageFormatInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueueFamilyProperties2::Builder& builder, VkQueueFamilyProperties2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initQueueFamilyProperties(queueFamilyProperties);
            return serialize_struct(temp, (member.queueFamilyProperties));
            }();
}

    VkQueueFamilyProperties2 deserialize_struct(stream::VkQueueFamilyProperties2::Reader reader){
        auto result=VkQueueFamilyProperties2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getQueueFamilyProperties();
            (result.queueFamilyProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueueFamilyProperties2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueueFamilyProperties2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMemoryProperties2::Builder& builder, VkPhysicalDeviceMemoryProperties2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initMemoryProperties(memoryProperties);
            return serialize_struct(temp, (member.memoryProperties));
            }();
}

    VkPhysicalDeviceMemoryProperties2 deserialize_struct(stream::VkPhysicalDeviceMemoryProperties2::Reader reader){
        auto result=VkPhysicalDeviceMemoryProperties2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMemoryProperties();
            (result.memoryProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMemoryProperties2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMemoryProperties2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseImageFormatProperties2::Builder& builder, VkSparseImageFormatProperties2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initProperties(properties);
            return serialize_struct(temp, (member.properties));
            }();
}

    VkSparseImageFormatProperties2 deserialize_struct(stream::VkSparseImageFormatProperties2::Reader reader){
        auto result=VkSparseImageFormatProperties2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getProperties();
            (result.properties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseImageFormatProperties2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseImageFormatProperties2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSparseImageFormatInfo2::Builder& builder, VkPhysicalDeviceSparseImageFormatInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){[&](){return builder.setSamples((member.samples));}();}();}();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
[&](){[&](){[&](){return builder.setTiling((member.tiling));}();}();}();
}

    VkPhysicalDeviceSparseImageFormatInfo2 deserialize_struct(stream::VkPhysicalDeviceSparseImageFormatInfo2::Reader reader){
        auto result=VkPhysicalDeviceSparseImageFormatInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){[&](){(result.samples)=reader.getSamples();}();}();}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
[&](){[&](){[&](){(result.tiling)=reader.getTiling();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSparseImageFormatInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSparseImageFormatInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePushDescriptorPropertiesKHR::Builder& builder, VkPhysicalDevicePushDescriptorPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxPushDescriptors((member.maxPushDescriptors));}();
}

    VkPhysicalDevicePushDescriptorPropertiesKHR deserialize_struct(stream::VkPhysicalDevicePushDescriptorPropertiesKHR::Reader reader){
        auto result=VkPhysicalDevicePushDescriptorPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxPushDescriptors)=reader.getMaxPushDescriptors();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePushDescriptorPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePushDescriptorPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkConformanceVersion::Builder& builder, VkConformanceVersion member){
        
    
[&](){return builder.setMajor((member.major));}();
[&](){return builder.setMinor((member.minor));}();
[&](){return builder.setSubminor((member.subminor));}();
[&](){return builder.setPatch((member.patch));}();
}

    VkConformanceVersion deserialize_struct(stream::VkConformanceVersion::Reader reader){
        auto result=VkConformanceVersion();
    
[&](){(result.major)=reader.getMajor();}();
[&](){(result.minor)=reader.getMinor();}();
[&](){(result.subminor)=reader.getSubminor();}();
[&](){(result.patch)=reader.getPatch();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkConformanceVersion member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkConformanceVersion member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDriverProperties::Builder& builder, VkPhysicalDeviceDriverProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDriverID((member.driverID));}();}();}();
[&](){
        auto proto_arr=builder.initDriverName(VK_MAX_DRIVER_NAME_SIZE);
        for(int eglnjYG=0; eglnjYG < VK_MAX_DRIVER_NAME_SIZE; eglnjYG++){
            [&](){return proto_arr.set(eglnjYG,((member.driverName)[eglnjYG]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDriverInfo(VK_MAX_DRIVER_INFO_SIZE);
        for(int ygBYlpo=0; ygBYlpo < VK_MAX_DRIVER_INFO_SIZE; ygBYlpo++){
            [&](){return proto_arr.set(ygBYlpo,((member.driverInfo)[ygBYlpo]));}();
        }
        }();
[&](){
            auto temp=builder.initConformanceVersion(conformanceVersion);
            return serialize_struct(temp, (member.conformanceVersion));
            }();
}

    VkPhysicalDeviceDriverProperties deserialize_struct(stream::VkPhysicalDeviceDriverProperties::Reader reader){
        auto result=VkPhysicalDeviceDriverProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.driverID)=reader.getDriverID();}();}();}();
[&](){
        auto proto_arr=reader.getDriverName(VK_MAX_DRIVER_NAME_SIZE);
        for(int eglnjYG=0; eglnjYG < VK_MAX_DRIVER_NAME_SIZE; eglnjYG++){
            [&](){((result.driverName)[eglnjYG])=proto_arr[eglnjYG];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDriverInfo(VK_MAX_DRIVER_INFO_SIZE);
        for(int ygBYlpo=0; ygBYlpo < VK_MAX_DRIVER_INFO_SIZE; ygBYlpo++){
            [&](){((result.driverInfo)[ygBYlpo])=proto_arr[ygBYlpo];}();
        }
        }();
[&](){
            auto temp=reader.getConformanceVersion();
            (result.conformanceVersion)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDriverProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDriverProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPresentRegionsKHR::Builder& builder, VkPresentRegionsKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchainCount((member.swapchainCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.swapchainCount);
        for(int SKDbKhP=0; SKDbKhP < member.swapchainCount; SKDbKhP++){
            [&](){
            auto temp=proto_arr[SKDbKhP];
            return serialize_struct(temp, ((member.pRegions)[SKDbKhP]));
            }();
        }
        }();
}

    VkPresentRegionsKHR deserialize_struct(stream::VkPresentRegionsKHR::Reader reader){
        auto result=VkPresentRegionsKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchainCount)=reader.getSwapchainCount();}();
[&](){ VkPresentRegionKHR* temp_QpWCcdU[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkPresentRegionKHR*)malloc(result.swapchainCount*sizeof(VkPresentRegionKHR));
        auto proto_arr=reader.getPRegions(result.swapchainCount);
        for(int eyUXdIG=0; eyUXdIG < result.swapchainCount; eyUXdIG++){
            [&](){
            auto temp=proto_arr[eyUXdIG];
            ((result.pRegions)[eyUXdIG])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_QpWCcdU;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPresentRegionsKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPresentRegionsKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPresentRegionKHR::Builder& builder, VkPresentRegionKHR member){
        
    
[&](){return builder.setRectangleCount((member.rectangleCount));}();
[&](){
            if ((member.pRectangles)==NULL){
                builder.initPRectangles(0);
            return; }
        auto proto_arr=builder.initPRectangles(member.rectangleCount);
        for(int hAYHxnM=0; hAYHxnM < member.rectangleCount; hAYHxnM++){
            [&](){
            auto temp=proto_arr[hAYHxnM];
            return serialize_struct(temp, ((member.pRectangles)[hAYHxnM]));
            }();
        }
        }();
}

    VkPresentRegionKHR deserialize_struct(stream::VkPresentRegionKHR::Reader reader){
        auto result=VkPresentRegionKHR();
    
[&](){(result.rectangleCount)=reader.getRectangleCount();}();
[&](){ VkRectLayerKHR* temp_KMgHLYt[&](){
            if (!reader.getPRectangles().size()==0){
                (result.pRectangles)=NULL;
            return; }{native_concat()}=(VkRectLayerKHR*)malloc(result.rectangleCount*sizeof(VkRectLayerKHR));
        auto proto_arr=reader.getPRectangles(result.rectangleCount);
        for(int jYyfhtN=0; jYyfhtN < result.rectangleCount; jYyfhtN++){
            [&](){
            auto temp=proto_arr[jYyfhtN];
            ((result.pRectangles)[jYyfhtN])=deserialize_struct(temp);
            }();
        }
        }();(result.pRectangles)=temp_KMgHLYt;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPresentRegionKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPresentRegionKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRectLayerKHR::Builder& builder, VkRectLayerKHR member){
        
    
[&](){
            auto temp=builder.initOffset(offset);
            return serialize_struct(temp, (member.offset));
            }();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
[&](){return builder.setLayer((member.layer));}();
}

    VkRectLayerKHR deserialize_struct(stream::VkRectLayerKHR::Reader reader){
        auto result=VkRectLayerKHR();
    
[&](){
            auto temp=reader.getOffset();
            (result.offset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
[&](){(result.layer)=reader.getLayer();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRectLayerKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRectLayerKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVariablePointersFeatures::Builder& builder, VkPhysicalDeviceVariablePointersFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setVariablePointersStorageBuffer((member.variablePointersStorageBuffer));}();}();
[&](){[&](){return builder.setVariablePointers((member.variablePointers));}();}();
}

    VkPhysicalDeviceVariablePointersFeatures deserialize_struct(stream::VkPhysicalDeviceVariablePointersFeatures::Reader reader){
        auto result=VkPhysicalDeviceVariablePointersFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.variablePointersStorageBuffer)=reader.getVariablePointersStorageBuffer();}();}();
[&](){[&](){(result.variablePointers)=reader.getVariablePointers();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVariablePointersFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVariablePointersFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalMemoryProperties::Builder& builder, VkExternalMemoryProperties member){
        
    
[&](){[&](){[&](){return builder.setExternalMemoryFeatures((member.externalMemoryFeatures));}();}();}();
[&](){[&](){[&](){return builder.setExportFromImportedHandleTypes((member.exportFromImportedHandleTypes));}();}();}();
[&](){[&](){[&](){return builder.setCompatibleHandleTypes((member.compatibleHandleTypes));}();}();}();
}

    VkExternalMemoryProperties deserialize_struct(stream::VkExternalMemoryProperties::Reader reader){
        auto result=VkExternalMemoryProperties();
    
[&](){[&](){[&](){(result.externalMemoryFeatures)=reader.getExternalMemoryFeatures();}();}();}();
[&](){[&](){[&](){(result.exportFromImportedHandleTypes)=reader.getExportFromImportedHandleTypes();}();}();}();
[&](){[&](){[&](){(result.compatibleHandleTypes)=reader.getCompatibleHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalMemoryProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalMemoryProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExternalImageFormatInfo::Builder& builder, VkPhysicalDeviceExternalImageFormatInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkPhysicalDeviceExternalImageFormatInfo deserialize_struct(stream::VkPhysicalDeviceExternalImageFormatInfo::Reader reader){
        auto result=VkPhysicalDeviceExternalImageFormatInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExternalImageFormatInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExternalImageFormatInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalImageFormatProperties::Builder& builder, VkExternalImageFormatProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initExternalMemoryProperties(externalMemoryProperties);
            return serialize_struct(temp, (member.externalMemoryProperties));
            }();
}

    VkExternalImageFormatProperties deserialize_struct(stream::VkExternalImageFormatProperties::Reader reader){
        auto result=VkExternalImageFormatProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExternalMemoryProperties();
            (result.externalMemoryProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalImageFormatProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalImageFormatProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExternalBufferInfo::Builder& builder, VkPhysicalDeviceExternalBufferInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkPhysicalDeviceExternalBufferInfo deserialize_struct(stream::VkPhysicalDeviceExternalBufferInfo::Reader reader){
        auto result=VkPhysicalDeviceExternalBufferInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExternalBufferInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExternalBufferInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalBufferProperties::Builder& builder, VkExternalBufferProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initExternalMemoryProperties(externalMemoryProperties);
            return serialize_struct(temp, (member.externalMemoryProperties));
            }();
}

    VkExternalBufferProperties deserialize_struct(stream::VkExternalBufferProperties::Reader reader){
        auto result=VkExternalBufferProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExternalMemoryProperties();
            (result.externalMemoryProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalBufferProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalBufferProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceIDProperties::Builder& builder, VkPhysicalDeviceIDProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initDeviceUUID(VK_UUID_SIZE);
        for(int LghVtrk=0; LghVtrk < VK_UUID_SIZE; LghVtrk++){
            [&](){return proto_arr.set(LghVtrk,((member.deviceUUID)[LghVtrk]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDriverUUID(VK_UUID_SIZE);
        for(int WbhUlZS=0; WbhUlZS < VK_UUID_SIZE; WbhUlZS++){
            [&](){return proto_arr.set(WbhUlZS,((member.driverUUID)[WbhUlZS]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDeviceLUID(VK_LUID_SIZE);
        for(int kitdKfY=0; kitdKfY < VK_LUID_SIZE; kitdKfY++){
            [&](){return proto_arr.set(kitdKfY,((member.deviceLUID)[kitdKfY]));}();
        }
        }();
[&](){return builder.setDeviceNodeMask((member.deviceNodeMask));}();
[&](){[&](){return builder.setDeviceLUIDValid((member.deviceLUIDValid));}();}();
}

    VkPhysicalDeviceIDProperties deserialize_struct(stream::VkPhysicalDeviceIDProperties::Reader reader){
        auto result=VkPhysicalDeviceIDProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getDeviceUUID(VK_UUID_SIZE);
        for(int LghVtrk=0; LghVtrk < VK_UUID_SIZE; LghVtrk++){
            [&](){((result.deviceUUID)[LghVtrk])=proto_arr[LghVtrk];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDriverUUID(VK_UUID_SIZE);
        for(int WbhUlZS=0; WbhUlZS < VK_UUID_SIZE; WbhUlZS++){
            [&](){((result.driverUUID)[WbhUlZS])=proto_arr[WbhUlZS];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDeviceLUID(VK_LUID_SIZE);
        for(int kitdKfY=0; kitdKfY < VK_LUID_SIZE; kitdKfY++){
            [&](){((result.deviceLUID)[kitdKfY])=proto_arr[kitdKfY];}();
        }
        }();
[&](){(result.deviceNodeMask)=reader.getDeviceNodeMask();}();
[&](){[&](){(result.deviceLUIDValid)=reader.getDeviceLUIDValid();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceIDProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceIDProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalMemoryImageCreateInfo::Builder& builder, VkExternalMemoryImageCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleTypes((member.handleTypes));}();}();}();
}

    VkExternalMemoryImageCreateInfo deserialize_struct(stream::VkExternalMemoryImageCreateInfo::Reader reader){
        auto result=VkExternalMemoryImageCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleTypes)=reader.getHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalMemoryImageCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalMemoryImageCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalMemoryBufferCreateInfo::Builder& builder, VkExternalMemoryBufferCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleTypes((member.handleTypes));}();}();}();
}

    VkExternalMemoryBufferCreateInfo deserialize_struct(stream::VkExternalMemoryBufferCreateInfo::Reader reader){
        auto result=VkExternalMemoryBufferCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleTypes)=reader.getHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalMemoryBufferCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalMemoryBufferCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExportMemoryAllocateInfo::Builder& builder, VkExportMemoryAllocateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleTypes((member.handleTypes));}();}();}();
}

    VkExportMemoryAllocateInfo deserialize_struct(stream::VkExportMemoryAllocateInfo::Reader reader){
        auto result=VkExportMemoryAllocateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleTypes)=reader.getHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExportMemoryAllocateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExportMemoryAllocateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImportMemoryFdInfoKHR::Builder& builder, VkImportMemoryFdInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
[&](){return builder.setFd((member.fd));}();
}

    VkImportMemoryFdInfoKHR deserialize_struct(stream::VkImportMemoryFdInfoKHR::Reader reader){
        auto result=VkImportMemoryFdInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
[&](){(result.fd)=reader.getFd();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImportMemoryFdInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImportMemoryFdInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryFdPropertiesKHR::Builder& builder, VkMemoryFdPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemoryTypeBits((member.memoryTypeBits));}();
}

    VkMemoryFdPropertiesKHR deserialize_struct(stream::VkMemoryFdPropertiesKHR::Reader reader){
        auto result=VkMemoryFdPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.memoryTypeBits)=reader.getMemoryTypeBits();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryFdPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryFdPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryGetFdInfoKHR::Builder& builder, VkMemoryGetFdInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkMemoryGetFdInfoKHR deserialize_struct(stream::VkMemoryGetFdInfoKHR::Reader reader){
        auto result=VkMemoryGetFdInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryGetFdInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryGetFdInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExternalSemaphoreInfo::Builder& builder, VkPhysicalDeviceExternalSemaphoreInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkPhysicalDeviceExternalSemaphoreInfo deserialize_struct(stream::VkPhysicalDeviceExternalSemaphoreInfo::Reader reader){
        auto result=VkPhysicalDeviceExternalSemaphoreInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExternalSemaphoreInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExternalSemaphoreInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalSemaphoreProperties::Builder& builder, VkExternalSemaphoreProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setExportFromImportedHandleTypes((member.exportFromImportedHandleTypes));}();}();}();
[&](){[&](){[&](){return builder.setCompatibleHandleTypes((member.compatibleHandleTypes));}();}();}();
[&](){[&](){[&](){return builder.setExternalSemaphoreFeatures((member.externalSemaphoreFeatures));}();}();}();
}

    VkExternalSemaphoreProperties deserialize_struct(stream::VkExternalSemaphoreProperties::Reader reader){
        auto result=VkExternalSemaphoreProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.exportFromImportedHandleTypes)=reader.getExportFromImportedHandleTypes();}();}();}();
[&](){[&](){[&](){(result.compatibleHandleTypes)=reader.getCompatibleHandleTypes();}();}();}();
[&](){[&](){[&](){(result.externalSemaphoreFeatures)=reader.getExternalSemaphoreFeatures();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalSemaphoreProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalSemaphoreProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExportSemaphoreCreateInfo::Builder& builder, VkExportSemaphoreCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleTypes((member.handleTypes));}();}();}();
}

    VkExportSemaphoreCreateInfo deserialize_struct(stream::VkExportSemaphoreCreateInfo::Reader reader){
        auto result=VkExportSemaphoreCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleTypes)=reader.getHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExportSemaphoreCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExportSemaphoreCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImportSemaphoreFdInfoKHR::Builder& builder, VkImportSemaphoreFdInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSemaphore(serialize_handle(member.semaphore));}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
[&](){return builder.setFd((member.fd));}();
}

    VkImportSemaphoreFdInfoKHR deserialize_struct(stream::VkImportSemaphoreFdInfoKHR::Reader reader){
        auto result=VkImportSemaphoreFdInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.semaphore)=deserialize_VkSemaphore(reader.getSemaphore());}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
[&](){(result.fd)=reader.getFd();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImportSemaphoreFdInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImportSemaphoreFdInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSemaphoreGetFdInfoKHR::Builder& builder, VkSemaphoreGetFdInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSemaphore(serialize_handle(member.semaphore));}();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkSemaphoreGetFdInfoKHR deserialize_struct(stream::VkSemaphoreGetFdInfoKHR::Reader reader){
        auto result=VkSemaphoreGetFdInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.semaphore)=deserialize_VkSemaphore(reader.getSemaphore());}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSemaphoreGetFdInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSemaphoreGetFdInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExternalFenceInfo::Builder& builder, VkPhysicalDeviceExternalFenceInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkPhysicalDeviceExternalFenceInfo deserialize_struct(stream::VkPhysicalDeviceExternalFenceInfo::Reader reader){
        auto result=VkPhysicalDeviceExternalFenceInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExternalFenceInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExternalFenceInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalFenceProperties::Builder& builder, VkExternalFenceProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setExportFromImportedHandleTypes((member.exportFromImportedHandleTypes));}();}();}();
[&](){[&](){[&](){return builder.setCompatibleHandleTypes((member.compatibleHandleTypes));}();}();}();
[&](){[&](){[&](){return builder.setExternalFenceFeatures((member.externalFenceFeatures));}();}();}();
}

    VkExternalFenceProperties deserialize_struct(stream::VkExternalFenceProperties::Reader reader){
        auto result=VkExternalFenceProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.exportFromImportedHandleTypes)=reader.getExportFromImportedHandleTypes();}();}();}();
[&](){[&](){[&](){(result.compatibleHandleTypes)=reader.getCompatibleHandleTypes();}();}();}();
[&](){[&](){[&](){(result.externalFenceFeatures)=reader.getExternalFenceFeatures();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalFenceProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalFenceProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExportFenceCreateInfo::Builder& builder, VkExportFenceCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleTypes((member.handleTypes));}();}();}();
}

    VkExportFenceCreateInfo deserialize_struct(stream::VkExportFenceCreateInfo::Reader reader){
        auto result=VkExportFenceCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleTypes)=reader.getHandleTypes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExportFenceCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExportFenceCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImportFenceFdInfoKHR::Builder& builder, VkImportFenceFdInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setFence(serialize_handle(member.fence));}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
[&](){return builder.setFd((member.fd));}();
}

    VkImportFenceFdInfoKHR deserialize_struct(stream::VkImportFenceFdInfoKHR::Reader reader){
        auto result=VkImportFenceFdInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.fence)=deserialize_VkFence(reader.getFence());}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
[&](){(result.fd)=reader.getFd();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImportFenceFdInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImportFenceFdInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFenceGetFdInfoKHR::Builder& builder, VkFenceGetFdInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setFence(serialize_handle(member.fence));}();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkFenceGetFdInfoKHR deserialize_struct(stream::VkFenceGetFdInfoKHR::Reader reader){
        auto result=VkFenceGetFdInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.fence)=deserialize_VkFence(reader.getFence());}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFenceGetFdInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFenceGetFdInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultiviewFeatures::Builder& builder, VkPhysicalDeviceMultiviewFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMultiview((member.multiview));}();}();
[&](){[&](){return builder.setMultiviewGeometryShader((member.multiviewGeometryShader));}();}();
[&](){[&](){return builder.setMultiviewTessellationShader((member.multiviewTessellationShader));}();}();
}

    VkPhysicalDeviceMultiviewFeatures deserialize_struct(stream::VkPhysicalDeviceMultiviewFeatures::Reader reader){
        auto result=VkPhysicalDeviceMultiviewFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.multiview)=reader.getMultiview();}();}();
[&](){[&](){(result.multiviewGeometryShader)=reader.getMultiviewGeometryShader();}();}();
[&](){[&](){(result.multiviewTessellationShader)=reader.getMultiviewTessellationShader();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultiviewFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultiviewFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultiviewProperties::Builder& builder, VkPhysicalDeviceMultiviewProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxMultiviewViewCount((member.maxMultiviewViewCount));}();
[&](){return builder.setMaxMultiviewInstanceIndex((member.maxMultiviewInstanceIndex));}();
}

    VkPhysicalDeviceMultiviewProperties deserialize_struct(stream::VkPhysicalDeviceMultiviewProperties::Reader reader){
        auto result=VkPhysicalDeviceMultiviewProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxMultiviewViewCount)=reader.getMaxMultiviewViewCount();}();
[&](){(result.maxMultiviewInstanceIndex)=reader.getMaxMultiviewInstanceIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultiviewProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultiviewProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassMultiviewCreateInfo::Builder& builder, VkRenderPassMultiviewCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSubpassCount((member.subpassCount));}();
[&](){
            if ((member.pViewMasks)==NULL){
                builder.initPViewMasks(0);
            return; }
        auto proto_arr=builder.initPViewMasks(member.subpassCount);
        for(int CcPBXcz=0; CcPBXcz < member.subpassCount; CcPBXcz++){
            [&](){return proto_arr.set(CcPBXcz,((member.pViewMasks)[CcPBXcz]));}();
        }
        }();
[&](){return builder.setDependencyCount((member.dependencyCount));}();
[&](){
            if ((member.pViewOffsets)==NULL){
                builder.initPViewOffsets(0);
            return; }
        auto proto_arr=builder.initPViewOffsets(member.dependencyCount);
        for(int NmJKoPY=0; NmJKoPY < member.dependencyCount; NmJKoPY++){
            [&](){return proto_arr.set(NmJKoPY,((member.pViewOffsets)[NmJKoPY]));}();
        }
        }();
[&](){return builder.setCorrelationMaskCount((member.correlationMaskCount));}();
[&](){
            if ((member.pCorrelationMasks)==NULL){
                builder.initPCorrelationMasks(0);
            return; }
        auto proto_arr=builder.initPCorrelationMasks(member.correlationMaskCount);
        for(int uavhVgO=0; uavhVgO < member.correlationMaskCount; uavhVgO++){
            [&](){return proto_arr.set(uavhVgO,((member.pCorrelationMasks)[uavhVgO]));}();
        }
        }();
}

    VkRenderPassMultiviewCreateInfo deserialize_struct(stream::VkRenderPassMultiviewCreateInfo::Reader reader){
        auto result=VkRenderPassMultiviewCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.subpassCount)=reader.getSubpassCount();}();
[&](){ uint32_t* temp_MKXBWtz[&](){
            if (!reader.getPViewMasks().size()==0){
                (result.pViewMasks)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.subpassCount*sizeof(uint32_t));
        auto proto_arr=reader.getPViewMasks(result.subpassCount);
        for(int NeCZYBs=0; NeCZYBs < result.subpassCount; NeCZYBs++){
            [&](){((result.pViewMasks)[NeCZYBs])=proto_arr[NeCZYBs];}();
        }
        }();(result.pViewMasks)=temp_MKXBWtz;}();
[&](){(result.dependencyCount)=reader.getDependencyCount();}();
[&](){ int32_t* temp_WyifyVo[&](){
            if (!reader.getPViewOffsets().size()==0){
                (result.pViewOffsets)=NULL;
            return; }{native_concat()}=(int32_t*)malloc(result.dependencyCount*sizeof(int32_t));
        auto proto_arr=reader.getPViewOffsets(result.dependencyCount);
        for(int rcsDcPf=0; rcsDcPf < result.dependencyCount; rcsDcPf++){
            [&](){((result.pViewOffsets)[rcsDcPf])=proto_arr[rcsDcPf];}();
        }
        }();(result.pViewOffsets)=temp_WyifyVo;}();
[&](){(result.correlationMaskCount)=reader.getCorrelationMaskCount();}();
[&](){ uint32_t* temp_RaPnsig[&](){
            if (!reader.getPCorrelationMasks().size()==0){
                (result.pCorrelationMasks)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.correlationMaskCount*sizeof(uint32_t));
        auto proto_arr=reader.getPCorrelationMasks(result.correlationMaskCount);
        for(int ZTiZeBt=0; ZTiZeBt < result.correlationMaskCount; ZTiZeBt++){
            [&](){((result.pCorrelationMasks)[ZTiZeBt])=proto_arr[ZTiZeBt];}();
        }
        }();(result.pCorrelationMasks)=temp_RaPnsig;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassMultiviewCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassMultiviewCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfaceCapabilities2EXT::Builder& builder, VkSurfaceCapabilities2EXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMinImageCount((member.minImageCount));}();
[&](){return builder.setMaxImageCount((member.maxImageCount));}();
[&](){
            auto temp=builder.initCurrentExtent(currentExtent);
            return serialize_struct(temp, (member.currentExtent));
            }();
[&](){
            auto temp=builder.initMinImageExtent(minImageExtent);
            return serialize_struct(temp, (member.minImageExtent));
            }();
[&](){
            auto temp=builder.initMaxImageExtent(maxImageExtent);
            return serialize_struct(temp, (member.maxImageExtent));
            }();
[&](){return builder.setMaxImageArrayLayers((member.maxImageArrayLayers));}();
[&](){[&](){[&](){return builder.setSupportedTransforms((member.supportedTransforms));}();}();}();
[&](){[&](){[&](){return builder.setCurrentTransform((member.currentTransform));}();}();}();
[&](){[&](){[&](){return builder.setSupportedCompositeAlpha((member.supportedCompositeAlpha));}();}();}();
[&](){[&](){[&](){return builder.setSupportedUsageFlags((member.supportedUsageFlags));}();}();}();
[&](){[&](){[&](){return builder.setSupportedSurfaceCounters((member.supportedSurfaceCounters));}();}();}();
}

    VkSurfaceCapabilities2EXT deserialize_struct(stream::VkSurfaceCapabilities2EXT::Reader reader){
        auto result=VkSurfaceCapabilities2EXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.minImageCount)=reader.getMinImageCount();}();
[&](){(result.maxImageCount)=reader.getMaxImageCount();}();
[&](){
            auto temp=reader.getCurrentExtent();
            (result.currentExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinImageExtent();
            (result.minImageExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxImageExtent();
            (result.maxImageExtent)=deserialize_struct(temp);
            }();
[&](){(result.maxImageArrayLayers)=reader.getMaxImageArrayLayers();}();
[&](){[&](){[&](){(result.supportedTransforms)=reader.getSupportedTransforms();}();}();}();
[&](){[&](){[&](){(result.currentTransform)=reader.getCurrentTransform();}();}();}();
[&](){[&](){[&](){(result.supportedCompositeAlpha)=reader.getSupportedCompositeAlpha();}();}();}();
[&](){[&](){[&](){(result.supportedUsageFlags)=reader.getSupportedUsageFlags();}();}();}();
[&](){[&](){[&](){(result.supportedSurfaceCounters)=reader.getSupportedSurfaceCounters();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfaceCapabilities2EXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfaceCapabilities2EXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPowerInfoEXT::Builder& builder, VkDisplayPowerInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPowerState((member.powerState));}();}();}();
}

    VkDisplayPowerInfoEXT deserialize_struct(stream::VkDisplayPowerInfoEXT::Reader reader){
        auto result=VkDisplayPowerInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.powerState)=reader.getPowerState();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPowerInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPowerInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceEventInfoEXT::Builder& builder, VkDeviceEventInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDeviceEvent((member.deviceEvent));}();}();}();
}

    VkDeviceEventInfoEXT deserialize_struct(stream::VkDeviceEventInfoEXT::Reader reader){
        auto result=VkDeviceEventInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.deviceEvent)=reader.getDeviceEvent();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceEventInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceEventInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayEventInfoEXT::Builder& builder, VkDisplayEventInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDisplayEvent((member.displayEvent));}();}();}();
}

    VkDisplayEventInfoEXT deserialize_struct(stream::VkDisplayEventInfoEXT::Reader reader){
        auto result=VkDisplayEventInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.displayEvent)=reader.getDisplayEvent();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayEventInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayEventInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainCounterCreateInfoEXT::Builder& builder, VkSwapchainCounterCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSurfaceCounters((member.surfaceCounters));}();}();}();
}

    VkSwapchainCounterCreateInfoEXT deserialize_struct(stream::VkSwapchainCounterCreateInfoEXT::Reader reader){
        auto result=VkSwapchainCounterCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.surfaceCounters)=reader.getSurfaceCounters();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainCounterCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainCounterCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceGroupProperties::Builder& builder, VkPhysicalDeviceGroupProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPhysicalDeviceCount((member.physicalDeviceCount));}();
[&](){
        auto proto_arr=builder.initPhysicalDevices(VK_MAX_DEVICE_GROUP_SIZE);
        for(int SySGTYu=0; SySGTYu < VK_MAX_DEVICE_GROUP_SIZE; SySGTYu++){
            [&](){return proto_arr.set(SySGTYu,serialize_handle((member.physicalDevices)[SySGTYu]));}();
        }
        }();
[&](){[&](){return builder.setSubsetAllocation((member.subsetAllocation));}();}();
}

    VkPhysicalDeviceGroupProperties deserialize_struct(stream::VkPhysicalDeviceGroupProperties::Reader reader){
        auto result=VkPhysicalDeviceGroupProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.physicalDeviceCount)=reader.getPhysicalDeviceCount();}();
[&](){
        auto proto_arr=reader.getPhysicalDevices(VK_MAX_DEVICE_GROUP_SIZE);
        for(int SySGTYu=0; SySGTYu < VK_MAX_DEVICE_GROUP_SIZE; SySGTYu++){
            [&](){((result.physicalDevices)[SySGTYu])=deserialize_VkPhysicalDevice(proto_arr[SySGTYu]);}();
        }
        }();
[&](){[&](){(result.subsetAllocation)=reader.getSubsetAllocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceGroupProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceGroupProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryAllocateFlagsInfo::Builder& builder, VkMemoryAllocateFlagsInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setDeviceMask((member.deviceMask));}();
}

    VkMemoryAllocateFlagsInfo deserialize_struct(stream::VkMemoryAllocateFlagsInfo::Reader reader){
        auto result=VkMemoryAllocateFlagsInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.deviceMask)=reader.getDeviceMask();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryAllocateFlagsInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryAllocateFlagsInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindBufferMemoryInfo::Builder& builder, VkBindBufferMemoryInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setMemoryOffset((member.memoryOffset));}();}();
}

    VkBindBufferMemoryInfo deserialize_struct(stream::VkBindBufferMemoryInfo::Reader reader){
        auto result=VkBindBufferMemoryInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.memoryOffset)=reader.getMemoryOffset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindBufferMemoryInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindBufferMemoryInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindBufferMemoryDeviceGroupInfo::Builder& builder, VkBindBufferMemoryDeviceGroupInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDeviceIndexCount((member.deviceIndexCount));}();
[&](){
            if ((member.pDeviceIndices)==NULL){
                builder.initPDeviceIndices(0);
            return; }
        auto proto_arr=builder.initPDeviceIndices(member.deviceIndexCount);
        for(int lNKjpBY=0; lNKjpBY < member.deviceIndexCount; lNKjpBY++){
            [&](){return proto_arr.set(lNKjpBY,((member.pDeviceIndices)[lNKjpBY]));}();
        }
        }();
}

    VkBindBufferMemoryDeviceGroupInfo deserialize_struct(stream::VkBindBufferMemoryDeviceGroupInfo::Reader reader){
        auto result=VkBindBufferMemoryDeviceGroupInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.deviceIndexCount)=reader.getDeviceIndexCount();}();
[&](){ uint32_t* temp_chbZwCP[&](){
            if (!reader.getPDeviceIndices().size()==0){
                (result.pDeviceIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.deviceIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPDeviceIndices(result.deviceIndexCount);
        for(int CQTEfmn=0; CQTEfmn < result.deviceIndexCount; CQTEfmn++){
            [&](){((result.pDeviceIndices)[CQTEfmn])=proto_arr[CQTEfmn];}();
        }
        }();(result.pDeviceIndices)=temp_chbZwCP;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindBufferMemoryDeviceGroupInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindBufferMemoryDeviceGroupInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindImageMemoryInfo::Builder& builder, VkBindImageMemoryInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setMemoryOffset((member.memoryOffset));}();}();
}

    VkBindImageMemoryInfo deserialize_struct(stream::VkBindImageMemoryInfo::Reader reader){
        auto result=VkBindImageMemoryInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.memoryOffset)=reader.getMemoryOffset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindImageMemoryInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindImageMemoryInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindImageMemoryDeviceGroupInfo::Builder& builder, VkBindImageMemoryDeviceGroupInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDeviceIndexCount((member.deviceIndexCount));}();
[&](){
            if ((member.pDeviceIndices)==NULL){
                builder.initPDeviceIndices(0);
            return; }
        auto proto_arr=builder.initPDeviceIndices(member.deviceIndexCount);
        for(int lNKjpBY=0; lNKjpBY < member.deviceIndexCount; lNKjpBY++){
            [&](){return proto_arr.set(lNKjpBY,((member.pDeviceIndices)[lNKjpBY]));}();
        }
        }();
[&](){return builder.setSplitInstanceBindRegionCount((member.splitInstanceBindRegionCount));}();
[&](){
            if ((member.pSplitInstanceBindRegions)==NULL){
                builder.initPSplitInstanceBindRegions(0);
            return; }
        auto proto_arr=builder.initPSplitInstanceBindRegions(member.splitInstanceBindRegionCount);
        for(int jPXRrxI=0; jPXRrxI < member.splitInstanceBindRegionCount; jPXRrxI++){
            [&](){
            auto temp=proto_arr[jPXRrxI];
            return serialize_struct(temp, ((member.pSplitInstanceBindRegions)[jPXRrxI]));
            }();
        }
        }();
}

    VkBindImageMemoryDeviceGroupInfo deserialize_struct(stream::VkBindImageMemoryDeviceGroupInfo::Reader reader){
        auto result=VkBindImageMemoryDeviceGroupInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.deviceIndexCount)=reader.getDeviceIndexCount();}();
[&](){ uint32_t* temp_chbZwCP[&](){
            if (!reader.getPDeviceIndices().size()==0){
                (result.pDeviceIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.deviceIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPDeviceIndices(result.deviceIndexCount);
        for(int CQTEfmn=0; CQTEfmn < result.deviceIndexCount; CQTEfmn++){
            [&](){((result.pDeviceIndices)[CQTEfmn])=proto_arr[CQTEfmn];}();
        }
        }();(result.pDeviceIndices)=temp_chbZwCP;}();
[&](){(result.splitInstanceBindRegionCount)=reader.getSplitInstanceBindRegionCount();}();
[&](){ VkRect2D* temp_hQtrUyT[&](){
            if (!reader.getPSplitInstanceBindRegions().size()==0){
                (result.pSplitInstanceBindRegions)=NULL;
            return; }{native_concat()}=(VkRect2D*)malloc(result.splitInstanceBindRegionCount*sizeof(VkRect2D));
        auto proto_arr=reader.getPSplitInstanceBindRegions(result.splitInstanceBindRegionCount);
        for(int btPWlWs=0; btPWlWs < result.splitInstanceBindRegionCount; btPWlWs++){
            [&](){
            auto temp=proto_arr[btPWlWs];
            ((result.pSplitInstanceBindRegions)[btPWlWs])=deserialize_struct(temp);
            }();
        }
        }();(result.pSplitInstanceBindRegions)=temp_hQtrUyT;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindImageMemoryDeviceGroupInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindImageMemoryDeviceGroupInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupRenderPassBeginInfo::Builder& builder, VkDeviceGroupRenderPassBeginInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDeviceMask((member.deviceMask));}();
[&](){return builder.setDeviceRenderAreaCount((member.deviceRenderAreaCount));}();
[&](){
            if ((member.pDeviceRenderAreas)==NULL){
                builder.initPDeviceRenderAreas(0);
            return; }
        auto proto_arr=builder.initPDeviceRenderAreas(member.deviceRenderAreaCount);
        for(int mYcOwlX=0; mYcOwlX < member.deviceRenderAreaCount; mYcOwlX++){
            [&](){
            auto temp=proto_arr[mYcOwlX];
            return serialize_struct(temp, ((member.pDeviceRenderAreas)[mYcOwlX]));
            }();
        }
        }();
}

    VkDeviceGroupRenderPassBeginInfo deserialize_struct(stream::VkDeviceGroupRenderPassBeginInfo::Reader reader){
        auto result=VkDeviceGroupRenderPassBeginInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.deviceMask)=reader.getDeviceMask();}();
[&](){(result.deviceRenderAreaCount)=reader.getDeviceRenderAreaCount();}();
[&](){ VkRect2D* temp_mDeMhZj[&](){
            if (!reader.getPDeviceRenderAreas().size()==0){
                (result.pDeviceRenderAreas)=NULL;
            return; }{native_concat()}=(VkRect2D*)malloc(result.deviceRenderAreaCount*sizeof(VkRect2D));
        auto proto_arr=reader.getPDeviceRenderAreas(result.deviceRenderAreaCount);
        for(int jdrjfsb=0; jdrjfsb < result.deviceRenderAreaCount; jdrjfsb++){
            [&](){
            auto temp=proto_arr[jdrjfsb];
            ((result.pDeviceRenderAreas)[jdrjfsb])=deserialize_struct(temp);
            }();
        }
        }();(result.pDeviceRenderAreas)=temp_mDeMhZj;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupRenderPassBeginInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupRenderPassBeginInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupCommandBufferBeginInfo::Builder& builder, VkDeviceGroupCommandBufferBeginInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDeviceMask((member.deviceMask));}();
}

    VkDeviceGroupCommandBufferBeginInfo deserialize_struct(stream::VkDeviceGroupCommandBufferBeginInfo::Reader reader){
        auto result=VkDeviceGroupCommandBufferBeginInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.deviceMask)=reader.getDeviceMask();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupCommandBufferBeginInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupCommandBufferBeginInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupSubmitInfo::Builder& builder, VkDeviceGroupSubmitInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setWaitSemaphoreCount((member.waitSemaphoreCount));}();
[&](){
            if ((member.pWaitSemaphoreDeviceIndices)==NULL){
                builder.initPWaitSemaphoreDeviceIndices(0);
            return; }
        auto proto_arr=builder.initPWaitSemaphoreDeviceIndices(member.waitSemaphoreCount);
        for(int UfAbcmF=0; UfAbcmF < member.waitSemaphoreCount; UfAbcmF++){
            [&](){return proto_arr.set(UfAbcmF,((member.pWaitSemaphoreDeviceIndices)[UfAbcmF]));}();
        }
        }();
[&](){return builder.setCommandBufferCount((member.commandBufferCount));}();
[&](){
            if ((member.pCommandBufferDeviceMasks)==NULL){
                builder.initPCommandBufferDeviceMasks(0);
            return; }
        auto proto_arr=builder.initPCommandBufferDeviceMasks(member.commandBufferCount);
        for(int XIzJtyo=0; XIzJtyo < member.commandBufferCount; XIzJtyo++){
            [&](){return proto_arr.set(XIzJtyo,((member.pCommandBufferDeviceMasks)[XIzJtyo]));}();
        }
        }();
[&](){return builder.setSignalSemaphoreCount((member.signalSemaphoreCount));}();
[&](){
            if ((member.pSignalSemaphoreDeviceIndices)==NULL){
                builder.initPSignalSemaphoreDeviceIndices(0);
            return; }
        auto proto_arr=builder.initPSignalSemaphoreDeviceIndices(member.signalSemaphoreCount);
        for(int npBGdHi=0; npBGdHi < member.signalSemaphoreCount; npBGdHi++){
            [&](){return proto_arr.set(npBGdHi,((member.pSignalSemaphoreDeviceIndices)[npBGdHi]));}();
        }
        }();
}

    VkDeviceGroupSubmitInfo deserialize_struct(stream::VkDeviceGroupSubmitInfo::Reader reader){
        auto result=VkDeviceGroupSubmitInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.waitSemaphoreCount)=reader.getWaitSemaphoreCount();}();
[&](){ uint32_t* temp_IirIDXb[&](){
            if (!reader.getPWaitSemaphoreDeviceIndices().size()==0){
                (result.pWaitSemaphoreDeviceIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.waitSemaphoreCount*sizeof(uint32_t));
        auto proto_arr=reader.getPWaitSemaphoreDeviceIndices(result.waitSemaphoreCount);
        for(int BuBXuVG=0; BuBXuVG < result.waitSemaphoreCount; BuBXuVG++){
            [&](){((result.pWaitSemaphoreDeviceIndices)[BuBXuVG])=proto_arr[BuBXuVG];}();
        }
        }();(result.pWaitSemaphoreDeviceIndices)=temp_IirIDXb;}();
[&](){(result.commandBufferCount)=reader.getCommandBufferCount();}();
[&](){ uint32_t* temp_BwZKjQz[&](){
            if (!reader.getPCommandBufferDeviceMasks().size()==0){
                (result.pCommandBufferDeviceMasks)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.commandBufferCount*sizeof(uint32_t));
        auto proto_arr=reader.getPCommandBufferDeviceMasks(result.commandBufferCount);
        for(int lYHqVuX=0; lYHqVuX < result.commandBufferCount; lYHqVuX++){
            [&](){((result.pCommandBufferDeviceMasks)[lYHqVuX])=proto_arr[lYHqVuX];}();
        }
        }();(result.pCommandBufferDeviceMasks)=temp_BwZKjQz;}();
[&](){(result.signalSemaphoreCount)=reader.getSignalSemaphoreCount();}();
[&](){ uint32_t* temp_TPxcfCM[&](){
            if (!reader.getPSignalSemaphoreDeviceIndices().size()==0){
                (result.pSignalSemaphoreDeviceIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.signalSemaphoreCount*sizeof(uint32_t));
        auto proto_arr=reader.getPSignalSemaphoreDeviceIndices(result.signalSemaphoreCount);
        for(int YFAlfKs=0; YFAlfKs < result.signalSemaphoreCount; YFAlfKs++){
            [&](){((result.pSignalSemaphoreDeviceIndices)[YFAlfKs])=proto_arr[YFAlfKs];}();
        }
        }();(result.pSignalSemaphoreDeviceIndices)=temp_TPxcfCM;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupSubmitInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupSubmitInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupBindSparseInfo::Builder& builder, VkDeviceGroupBindSparseInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setResourceDeviceIndex((member.resourceDeviceIndex));}();
[&](){return builder.setMemoryDeviceIndex((member.memoryDeviceIndex));}();
}

    VkDeviceGroupBindSparseInfo deserialize_struct(stream::VkDeviceGroupBindSparseInfo::Reader reader){
        auto result=VkDeviceGroupBindSparseInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.resourceDeviceIndex)=reader.getResourceDeviceIndex();}();
[&](){(result.memoryDeviceIndex)=reader.getMemoryDeviceIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupBindSparseInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupBindSparseInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupPresentCapabilitiesKHR::Builder& builder, VkDeviceGroupPresentCapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initPresentMask(VK_MAX_DEVICE_GROUP_SIZE);
        for(int mvXAdTF=0; mvXAdTF < VK_MAX_DEVICE_GROUP_SIZE; mvXAdTF++){
            [&](){return proto_arr.set(mvXAdTF,((member.presentMask)[mvXAdTF]));}();
        }
        }();
[&](){[&](){[&](){return builder.setModes((member.modes));}();}();}();
}

    VkDeviceGroupPresentCapabilitiesKHR deserialize_struct(stream::VkDeviceGroupPresentCapabilitiesKHR::Reader reader){
        auto result=VkDeviceGroupPresentCapabilitiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getPresentMask(VK_MAX_DEVICE_GROUP_SIZE);
        for(int mvXAdTF=0; mvXAdTF < VK_MAX_DEVICE_GROUP_SIZE; mvXAdTF++){
            [&](){((result.presentMask)[mvXAdTF])=proto_arr[mvXAdTF];}();
        }
        }();
[&](){[&](){[&](){(result.modes)=reader.getModes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupPresentCapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupPresentCapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageSwapchainCreateInfoKHR::Builder& builder, VkImageSwapchainCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchain(serialize_handle(member.swapchain));}();
}

    VkImageSwapchainCreateInfoKHR deserialize_struct(stream::VkImageSwapchainCreateInfoKHR::Reader reader){
        auto result=VkImageSwapchainCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchain)=deserialize_VkSwapchainKHR(reader.getSwapchain());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageSwapchainCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageSwapchainCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindImageMemorySwapchainInfoKHR::Builder& builder, VkBindImageMemorySwapchainInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchain(serialize_handle(member.swapchain));}();
[&](){return builder.setImageIndex((member.imageIndex));}();
}

    VkBindImageMemorySwapchainInfoKHR deserialize_struct(stream::VkBindImageMemorySwapchainInfoKHR::Reader reader){
        auto result=VkBindImageMemorySwapchainInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchain)=deserialize_VkSwapchainKHR(reader.getSwapchain());}();
[&](){(result.imageIndex)=reader.getImageIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindImageMemorySwapchainInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindImageMemorySwapchainInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAcquireNextImageInfoKHR::Builder& builder, VkAcquireNextImageInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchain(serialize_handle(member.swapchain));}();
[&](){return builder.setTimeout((member.timeout));}();
[&](){return builder.setSemaphore(serialize_handle(member.semaphore));}();
[&](){return builder.setFence(serialize_handle(member.fence));}();
[&](){return builder.setDeviceMask((member.deviceMask));}();
}

    VkAcquireNextImageInfoKHR deserialize_struct(stream::VkAcquireNextImageInfoKHR::Reader reader){
        auto result=VkAcquireNextImageInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchain)=deserialize_VkSwapchainKHR(reader.getSwapchain());}();
[&](){(result.timeout)=reader.getTimeout();}();
[&](){(result.semaphore)=deserialize_VkSemaphore(reader.getSemaphore());}();
[&](){(result.fence)=deserialize_VkFence(reader.getFence());}();
[&](){(result.deviceMask)=reader.getDeviceMask();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAcquireNextImageInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAcquireNextImageInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupPresentInfoKHR::Builder& builder, VkDeviceGroupPresentInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchainCount((member.swapchainCount));}();
[&](){
            if ((member.pDeviceMasks)==NULL){
                builder.initPDeviceMasks(0);
            return; }
        auto proto_arr=builder.initPDeviceMasks(member.swapchainCount);
        for(int xoZBOZT=0; xoZBOZT < member.swapchainCount; xoZBOZT++){
            [&](){return proto_arr.set(xoZBOZT,((member.pDeviceMasks)[xoZBOZT]));}();
        }
        }();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
}

    VkDeviceGroupPresentInfoKHR deserialize_struct(stream::VkDeviceGroupPresentInfoKHR::Reader reader){
        auto result=VkDeviceGroupPresentInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchainCount)=reader.getSwapchainCount();}();
[&](){ uint32_t* temp_KxCPmLC[&](){
            if (!reader.getPDeviceMasks().size()==0){
                (result.pDeviceMasks)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.swapchainCount*sizeof(uint32_t));
        auto proto_arr=reader.getPDeviceMasks(result.swapchainCount);
        for(int rRsChIX=0; rRsChIX < result.swapchainCount; rRsChIX++){
            [&](){((result.pDeviceMasks)[rRsChIX])=proto_arr[rRsChIX];}();
        }
        }();(result.pDeviceMasks)=temp_KxCPmLC;}();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupPresentInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupPresentInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupDeviceCreateInfo::Builder& builder, VkDeviceGroupDeviceCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPhysicalDeviceCount((member.physicalDeviceCount));}();
[&](){
            if ((member.pPhysicalDevices)==NULL){
                builder.initPPhysicalDevices(0);
            return; }
        auto proto_arr=builder.initPPhysicalDevices(member.physicalDeviceCount);
        for(int GzWtyIK=0; GzWtyIK < member.physicalDeviceCount; GzWtyIK++){
            [&](){return proto_arr.set(GzWtyIK,serialize_handle((member.pPhysicalDevices)[GzWtyIK]));}();
        }
        }();
}

    VkDeviceGroupDeviceCreateInfo deserialize_struct(stream::VkDeviceGroupDeviceCreateInfo::Reader reader){
        auto result=VkDeviceGroupDeviceCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.physicalDeviceCount)=reader.getPhysicalDeviceCount();}();
[&](){ VkPhysicalDevice* temp_HiuUJud[&](){
            if (!reader.getPPhysicalDevices().size()==0){
                (result.pPhysicalDevices)=NULL;
            return; }{native_concat()}=(VkPhysicalDevice*)malloc(result.physicalDeviceCount*sizeof(VkPhysicalDevice));
        auto proto_arr=reader.getPPhysicalDevices(result.physicalDeviceCount);
        for(int YyctNwz=0; YyctNwz < result.physicalDeviceCount; YyctNwz++){
            [&](){((result.pPhysicalDevices)[YyctNwz])=deserialize_VkPhysicalDevice(proto_arr[YyctNwz]);}();
        }
        }();(result.pPhysicalDevices)=temp_HiuUJud;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupDeviceCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupDeviceCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceGroupSwapchainCreateInfoKHR::Builder& builder, VkDeviceGroupSwapchainCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setModes((member.modes));}();}();}();
}

    VkDeviceGroupSwapchainCreateInfoKHR deserialize_struct(stream::VkDeviceGroupSwapchainCreateInfoKHR::Reader reader){
        auto result=VkDeviceGroupSwapchainCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.modes)=reader.getModes();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceGroupSwapchainCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceGroupSwapchainCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorUpdateTemplateEntry::Builder& builder, VkDescriptorUpdateTemplateEntry member){
        
    
[&](){return builder.setDstBinding((member.dstBinding));}();
[&](){return builder.setDstArrayElement((member.dstArrayElement));}();
[&](){return builder.setDescriptorCount((member.descriptorCount));}();
[&](){[&](){[&](){return builder.setDescriptorType((member.descriptorType));}();}();}();
[&](){return builder.setOffset((member.offset));}();
[&](){return builder.setStride((member.stride));}();
}

    VkDescriptorUpdateTemplateEntry deserialize_struct(stream::VkDescriptorUpdateTemplateEntry::Reader reader){
        auto result=VkDescriptorUpdateTemplateEntry();
    
[&](){(result.dstBinding)=reader.getDstBinding();}();
[&](){(result.dstArrayElement)=reader.getDstArrayElement();}();
[&](){(result.descriptorCount)=reader.getDescriptorCount();}();
[&](){[&](){[&](){(result.descriptorType)=reader.getDescriptorType();}();}();}();
[&](){(result.offset)=reader.getOffset();}();
[&](){(result.stride)=reader.getStride();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorUpdateTemplateEntry member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorUpdateTemplateEntry member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorUpdateTemplateCreateInfo::Builder& builder, VkDescriptorUpdateTemplateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setDescriptorUpdateEntryCount((member.descriptorUpdateEntryCount));}();
[&](){
            if ((member.pDescriptorUpdateEntries)==NULL){
                builder.initPDescriptorUpdateEntries(0);
            return; }
        auto proto_arr=builder.initPDescriptorUpdateEntries(member.descriptorUpdateEntryCount);
        for(int ueVWUaH=0; ueVWUaH < member.descriptorUpdateEntryCount; ueVWUaH++){
            [&](){
            auto temp=proto_arr[ueVWUaH];
            return serialize_struct(temp, ((member.pDescriptorUpdateEntries)[ueVWUaH]));
            }();
        }
        }();
[&](){[&](){[&](){return builder.setTemplateType((member.templateType));}();}();}();
[&](){return builder.setDescriptorSetLayout(serialize_handle(member.descriptorSetLayout));}();
[&](){[&](){[&](){return builder.setPipelineBindPoint((member.pipelineBindPoint));}();}();}();
[&](){return builder.setPipelineLayout(serialize_handle(member.pipelineLayout));}();
[&](){return builder.setSet((member.set));}();
}

    VkDescriptorUpdateTemplateCreateInfo deserialize_struct(stream::VkDescriptorUpdateTemplateCreateInfo::Reader reader){
        auto result=VkDescriptorUpdateTemplateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.descriptorUpdateEntryCount)=reader.getDescriptorUpdateEntryCount();}();
[&](){ VkDescriptorUpdateTemplateEntry* temp_DgvFOQy[&](){
            if (!reader.getPDescriptorUpdateEntries().size()==0){
                (result.pDescriptorUpdateEntries)=NULL;
            return; }{native_concat()}=(VkDescriptorUpdateTemplateEntry*)malloc(result.descriptorUpdateEntryCount*sizeof(VkDescriptorUpdateTemplateEntry));
        auto proto_arr=reader.getPDescriptorUpdateEntries(result.descriptorUpdateEntryCount);
        for(int HbRTThr=0; HbRTThr < result.descriptorUpdateEntryCount; HbRTThr++){
            [&](){
            auto temp=proto_arr[HbRTThr];
            ((result.pDescriptorUpdateEntries)[HbRTThr])=deserialize_struct(temp);
            }();
        }
        }();(result.pDescriptorUpdateEntries)=temp_DgvFOQy;}();
[&](){[&](){[&](){(result.templateType)=reader.getTemplateType();}();}();}();
[&](){(result.descriptorSetLayout)=deserialize_VkDescriptorSetLayout(reader.getDescriptorSetLayout());}();
[&](){[&](){[&](){(result.pipelineBindPoint)=reader.getPipelineBindPoint();}();}();}();
[&](){(result.pipelineLayout)=deserialize_VkPipelineLayout(reader.getPipelineLayout());}();
[&](){(result.set)=reader.getSet();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorUpdateTemplateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorUpdateTemplateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkXYColorEXT::Builder& builder, VkXYColorEXT member){
        
    
[&](){return builder.setX((member.x));}();
[&](){return builder.setY((member.y));}();
}

    VkXYColorEXT deserialize_struct(stream::VkXYColorEXT::Reader reader){
        auto result=VkXYColorEXT();
    
[&](){(result.x)=reader.getX();}();
[&](){(result.y)=reader.getY();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkXYColorEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkXYColorEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePresentIdFeaturesKHR::Builder& builder, VkPhysicalDevicePresentIdFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPresentId((member.presentId));}();}();
}

    VkPhysicalDevicePresentIdFeaturesKHR deserialize_struct(stream::VkPhysicalDevicePresentIdFeaturesKHR::Reader reader){
        auto result=VkPhysicalDevicePresentIdFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.presentId)=reader.getPresentId();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePresentIdFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePresentIdFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPresentIdKHR::Builder& builder, VkPresentIdKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchainCount((member.swapchainCount));}();
[&](){
            if ((member.pPresentIds)==NULL){
                builder.initPPresentIds(0);
            return; }
        auto proto_arr=builder.initPPresentIds(member.swapchainCount);
        for(int BdqaAIv=0; BdqaAIv < member.swapchainCount; BdqaAIv++){
            [&](){return proto_arr.set(BdqaAIv,((member.pPresentIds)[BdqaAIv]));}();
        }
        }();
}

    VkPresentIdKHR deserialize_struct(stream::VkPresentIdKHR::Reader reader){
        auto result=VkPresentIdKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchainCount)=reader.getSwapchainCount();}();
[&](){ uint64_t* temp_sxJhiST[&](){
            if (!reader.getPPresentIds().size()==0){
                (result.pPresentIds)=NULL;
            return; }{native_concat()}=(uint64_t*)malloc(result.swapchainCount*sizeof(uint64_t));
        auto proto_arr=reader.getPPresentIds(result.swapchainCount);
        for(int gRltcKr=0; gRltcKr < result.swapchainCount; gRltcKr++){
            [&](){((result.pPresentIds)[gRltcKr])=proto_arr[gRltcKr];}();
        }
        }();(result.pPresentIds)=temp_sxJhiST;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPresentIdKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPresentIdKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePresentWaitFeaturesKHR::Builder& builder, VkPhysicalDevicePresentWaitFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPresentWait((member.presentWait));}();}();
}

    VkPhysicalDevicePresentWaitFeaturesKHR deserialize_struct(stream::VkPhysicalDevicePresentWaitFeaturesKHR::Reader reader){
        auto result=VkPhysicalDevicePresentWaitFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.presentWait)=reader.getPresentWait();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePresentWaitFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePresentWaitFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkHdrMetadataEXT::Builder& builder, VkHdrMetadataEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initDisplayPrimaryRed(displayPrimaryRed);
            return serialize_struct(temp, (member.displayPrimaryRed));
            }();
[&](){
            auto temp=builder.initDisplayPrimaryGreen(displayPrimaryGreen);
            return serialize_struct(temp, (member.displayPrimaryGreen));
            }();
[&](){
            auto temp=builder.initDisplayPrimaryBlue(displayPrimaryBlue);
            return serialize_struct(temp, (member.displayPrimaryBlue));
            }();
[&](){
            auto temp=builder.initWhitePoint(whitePoint);
            return serialize_struct(temp, (member.whitePoint));
            }();
[&](){return builder.setMaxLuminance((member.maxLuminance));}();
[&](){return builder.setMinLuminance((member.minLuminance));}();
[&](){return builder.setMaxContentLightLevel((member.maxContentLightLevel));}();
[&](){return builder.setMaxFrameAverageLightLevel((member.maxFrameAverageLightLevel));}();
}

    VkHdrMetadataEXT deserialize_struct(stream::VkHdrMetadataEXT::Reader reader){
        auto result=VkHdrMetadataEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getDisplayPrimaryRed();
            (result.displayPrimaryRed)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDisplayPrimaryGreen();
            (result.displayPrimaryGreen)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDisplayPrimaryBlue();
            (result.displayPrimaryBlue)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getWhitePoint();
            (result.whitePoint)=deserialize_struct(temp);
            }();
[&](){(result.maxLuminance)=reader.getMaxLuminance();}();
[&](){(result.minLuminance)=reader.getMinLuminance();}();
[&](){(result.maxContentLightLevel)=reader.getMaxContentLightLevel();}();
[&](){(result.maxFrameAverageLightLevel)=reader.getMaxFrameAverageLightLevel();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkHdrMetadataEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkHdrMetadataEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayNativeHdrSurfaceCapabilitiesAMD::Builder& builder, VkDisplayNativeHdrSurfaceCapabilitiesAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setLocalDimmingSupport((member.localDimmingSupport));}();}();
}

    VkDisplayNativeHdrSurfaceCapabilitiesAMD deserialize_struct(stream::VkDisplayNativeHdrSurfaceCapabilitiesAMD::Reader reader){
        auto result=VkDisplayNativeHdrSurfaceCapabilitiesAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.localDimmingSupport)=reader.getLocalDimmingSupport();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayNativeHdrSurfaceCapabilitiesAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayNativeHdrSurfaceCapabilitiesAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainDisplayNativeHdrCreateInfoAMD::Builder& builder, VkSwapchainDisplayNativeHdrCreateInfoAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setLocalDimmingEnable((member.localDimmingEnable));}();}();
}

    VkSwapchainDisplayNativeHdrCreateInfoAMD deserialize_struct(stream::VkSwapchainDisplayNativeHdrCreateInfoAMD::Reader reader){
        auto result=VkSwapchainDisplayNativeHdrCreateInfoAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.localDimmingEnable)=reader.getLocalDimmingEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainDisplayNativeHdrCreateInfoAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainDisplayNativeHdrCreateInfoAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRefreshCycleDurationGOOGLE::Builder& builder, VkRefreshCycleDurationGOOGLE member){
        
    
[&](){return builder.setRefreshDuration((member.refreshDuration));}();
}

    VkRefreshCycleDurationGOOGLE deserialize_struct(stream::VkRefreshCycleDurationGOOGLE::Reader reader){
        auto result=VkRefreshCycleDurationGOOGLE();
    
[&](){(result.refreshDuration)=reader.getRefreshDuration();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRefreshCycleDurationGOOGLE member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRefreshCycleDurationGOOGLE member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPastPresentationTimingGOOGLE::Builder& builder, VkPastPresentationTimingGOOGLE member){
        
    
[&](){return builder.setPresentID((member.presentID));}();
[&](){return builder.setDesiredPresentTime((member.desiredPresentTime));}();
[&](){return builder.setActualPresentTime((member.actualPresentTime));}();
[&](){return builder.setEarliestPresentTime((member.earliestPresentTime));}();
[&](){return builder.setPresentMargin((member.presentMargin));}();
}

    VkPastPresentationTimingGOOGLE deserialize_struct(stream::VkPastPresentationTimingGOOGLE::Reader reader){
        auto result=VkPastPresentationTimingGOOGLE();
    
[&](){(result.presentID)=reader.getPresentID();}();
[&](){(result.desiredPresentTime)=reader.getDesiredPresentTime();}();
[&](){(result.actualPresentTime)=reader.getActualPresentTime();}();
[&](){(result.earliestPresentTime)=reader.getEarliestPresentTime();}();
[&](){(result.presentMargin)=reader.getPresentMargin();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPastPresentationTimingGOOGLE member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPastPresentationTimingGOOGLE member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPresentTimesInfoGOOGLE::Builder& builder, VkPresentTimesInfoGOOGLE member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchainCount((member.swapchainCount));}();
[&](){
            if ((member.pTimes)==NULL){
                builder.initPTimes(0);
            return; }
        auto proto_arr=builder.initPTimes(member.swapchainCount);
        for(int cvRjTcE=0; cvRjTcE < member.swapchainCount; cvRjTcE++){
            [&](){
            auto temp=proto_arr[cvRjTcE];
            return serialize_struct(temp, ((member.pTimes)[cvRjTcE]));
            }();
        }
        }();
}

    VkPresentTimesInfoGOOGLE deserialize_struct(stream::VkPresentTimesInfoGOOGLE::Reader reader){
        auto result=VkPresentTimesInfoGOOGLE();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchainCount)=reader.getSwapchainCount();}();
[&](){ VkPresentTimeGOOGLE* temp_IJhMpVo[&](){
            if (!reader.getPTimes().size()==0){
                (result.pTimes)=NULL;
            return; }{native_concat()}=(VkPresentTimeGOOGLE*)malloc(result.swapchainCount*sizeof(VkPresentTimeGOOGLE));
        auto proto_arr=reader.getPTimes(result.swapchainCount);
        for(int TsPUkSX=0; TsPUkSX < result.swapchainCount; TsPUkSX++){
            [&](){
            auto temp=proto_arr[TsPUkSX];
            ((result.pTimes)[TsPUkSX])=deserialize_struct(temp);
            }();
        }
        }();(result.pTimes)=temp_IJhMpVo;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPresentTimesInfoGOOGLE member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPresentTimesInfoGOOGLE member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPresentTimeGOOGLE::Builder& builder, VkPresentTimeGOOGLE member){
        
    
[&](){return builder.setPresentID((member.presentID));}();
[&](){return builder.setDesiredPresentTime((member.desiredPresentTime));}();
}

    VkPresentTimeGOOGLE deserialize_struct(stream::VkPresentTimeGOOGLE::Reader reader){
        auto result=VkPresentTimeGOOGLE();
    
[&](){(result.presentID)=reader.getPresentID();}();
[&](){(result.desiredPresentTime)=reader.getDesiredPresentTime();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPresentTimeGOOGLE member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPresentTimeGOOGLE member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkViewportWScalingNV::Builder& builder, VkViewportWScalingNV member){
        
    
[&](){return builder.setXcoeff((member.xcoeff));}();
[&](){return builder.setYcoeff((member.ycoeff));}();
}

    VkViewportWScalingNV deserialize_struct(stream::VkViewportWScalingNV::Reader reader){
        auto result=VkViewportWScalingNV();
    
[&](){(result.xcoeff)=reader.getXcoeff();}();
[&](){(result.ycoeff)=reader.getYcoeff();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkViewportWScalingNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkViewportWScalingNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineViewportWScalingStateCreateInfoNV::Builder& builder, VkPipelineViewportWScalingStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setViewportWScalingEnable((member.viewportWScalingEnable));}();}();
[&](){return builder.setViewportCount((member.viewportCount));}();
[&](){
            if ((member.pViewportWScalings)==NULL){
                builder.initPViewportWScalings(0);
            return; }
        auto proto_arr=builder.initPViewportWScalings(member.viewportCount);
        for(int EfZNYhr=0; EfZNYhr < member.viewportCount; EfZNYhr++){
            [&](){
            auto temp=proto_arr[EfZNYhr];
            return serialize_struct(temp, ((member.pViewportWScalings)[EfZNYhr]));
            }();
        }
        }();
}

    VkPipelineViewportWScalingStateCreateInfoNV deserialize_struct(stream::VkPipelineViewportWScalingStateCreateInfoNV::Reader reader){
        auto result=VkPipelineViewportWScalingStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.viewportWScalingEnable)=reader.getViewportWScalingEnable();}();}();
[&](){(result.viewportCount)=reader.getViewportCount();}();
[&](){ VkViewportWScalingNV* temp_wUhaSqC[&](){
            if (!reader.getPViewportWScalings().size()==0){
                (result.pViewportWScalings)=NULL;
            return; }{native_concat()}=(VkViewportWScalingNV*)malloc(result.viewportCount*sizeof(VkViewportWScalingNV));
        auto proto_arr=reader.getPViewportWScalings(result.viewportCount);
        for(int FpWmrJX=0; FpWmrJX < result.viewportCount; FpWmrJX++){
            [&](){
            auto temp=proto_arr[FpWmrJX];
            ((result.pViewportWScalings)[FpWmrJX])=deserialize_struct(temp);
            }();
        }
        }();(result.pViewportWScalings)=temp_wUhaSqC;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineViewportWScalingStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineViewportWScalingStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkViewportSwizzleNV::Builder& builder, VkViewportSwizzleNV member){
        
    
[&](){[&](){[&](){return builder.setX((member.x));}();}();}();
[&](){[&](){[&](){return builder.setY((member.y));}();}();}();
[&](){[&](){[&](){return builder.setZ((member.z));}();}();}();
[&](){[&](){[&](){return builder.setW((member.w));}();}();}();
}

    VkViewportSwizzleNV deserialize_struct(stream::VkViewportSwizzleNV::Reader reader){
        auto result=VkViewportSwizzleNV();
    
[&](){[&](){[&](){(result.x)=reader.getX();}();}();}();
[&](){[&](){[&](){(result.y)=reader.getY();}();}();}();
[&](){[&](){[&](){(result.z)=reader.getZ();}();}();}();
[&](){[&](){[&](){(result.w)=reader.getW();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkViewportSwizzleNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkViewportSwizzleNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineViewportSwizzleStateCreateInfoNV::Builder& builder, VkPipelineViewportSwizzleStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setViewportCount((member.viewportCount));}();
[&](){
            if ((member.pViewportSwizzles)==NULL){
                builder.initPViewportSwizzles(0);
            return; }
        auto proto_arr=builder.initPViewportSwizzles(member.viewportCount);
        for(int JmIiIjF=0; JmIiIjF < member.viewportCount; JmIiIjF++){
            [&](){
            auto temp=proto_arr[JmIiIjF];
            return serialize_struct(temp, ((member.pViewportSwizzles)[JmIiIjF]));
            }();
        }
        }();
}

    VkPipelineViewportSwizzleStateCreateInfoNV deserialize_struct(stream::VkPipelineViewportSwizzleStateCreateInfoNV::Reader reader){
        auto result=VkPipelineViewportSwizzleStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.viewportCount)=reader.getViewportCount();}();
[&](){ VkViewportSwizzleNV* temp_MGDyAkt[&](){
            if (!reader.getPViewportSwizzles().size()==0){
                (result.pViewportSwizzles)=NULL;
            return; }{native_concat()}=(VkViewportSwizzleNV*)malloc(result.viewportCount*sizeof(VkViewportSwizzleNV));
        auto proto_arr=reader.getPViewportSwizzles(result.viewportCount);
        for(int cnyoCkA=0; cnyoCkA < result.viewportCount; cnyoCkA++){
            [&](){
            auto temp=proto_arr[cnyoCkA];
            ((result.pViewportSwizzles)[cnyoCkA])=deserialize_struct(temp);
            }();
        }
        }();(result.pViewportSwizzles)=temp_MGDyAkt;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineViewportSwizzleStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineViewportSwizzleStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDiscardRectanglePropertiesEXT::Builder& builder, VkPhysicalDeviceDiscardRectanglePropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxDiscardRectangles((member.maxDiscardRectangles));}();
}

    VkPhysicalDeviceDiscardRectanglePropertiesEXT deserialize_struct(stream::VkPhysicalDeviceDiscardRectanglePropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceDiscardRectanglePropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxDiscardRectangles)=reader.getMaxDiscardRectangles();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDiscardRectanglePropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDiscardRectanglePropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineDiscardRectangleStateCreateInfoEXT::Builder& builder, VkPipelineDiscardRectangleStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setDiscardRectangleMode((member.discardRectangleMode));}();}();}();
[&](){return builder.setDiscardRectangleCount((member.discardRectangleCount));}();
[&](){
            if ((member.pDiscardRectangles)==NULL){
                builder.initPDiscardRectangles(0);
            return; }
        auto proto_arr=builder.initPDiscardRectangles(member.discardRectangleCount);
        for(int utzawpH=0; utzawpH < member.discardRectangleCount; utzawpH++){
            [&](){
            auto temp=proto_arr[utzawpH];
            return serialize_struct(temp, ((member.pDiscardRectangles)[utzawpH]));
            }();
        }
        }();
}

    VkPipelineDiscardRectangleStateCreateInfoEXT deserialize_struct(stream::VkPipelineDiscardRectangleStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineDiscardRectangleStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.discardRectangleMode)=reader.getDiscardRectangleMode();}();}();}();
[&](){(result.discardRectangleCount)=reader.getDiscardRectangleCount();}();
[&](){ VkRect2D* temp_qvjcnOw[&](){
            if (!reader.getPDiscardRectangles().size()==0){
                (result.pDiscardRectangles)=NULL;
            return; }{native_concat()}=(VkRect2D*)malloc(result.discardRectangleCount*sizeof(VkRect2D));
        auto proto_arr=reader.getPDiscardRectangles(result.discardRectangleCount);
        for(int xzQKeqP=0; xzQKeqP < result.discardRectangleCount; xzQKeqP++){
            [&](){
            auto temp=proto_arr[xzQKeqP];
            ((result.pDiscardRectangles)[xzQKeqP])=deserialize_struct(temp);
            }();
        }
        }();(result.pDiscardRectangles)=temp_qvjcnOw;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineDiscardRectangleStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineDiscardRectangleStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::Builder& builder, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPerViewPositionAllComponents((member.perViewPositionAllComponents));}();}();
}

    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX deserialize_struct(stream::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::Reader reader){
        auto result=VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.perViewPositionAllComponents)=reader.getPerViewPositionAllComponents();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkInputAttachmentAspectReference::Builder& builder, VkInputAttachmentAspectReference member){
        
    
[&](){return builder.setSubpass((member.subpass));}();
[&](){return builder.setInputAttachmentIndex((member.inputAttachmentIndex));}();
[&](){[&](){[&](){return builder.setAspectMask((member.aspectMask));}();}();}();
}

    VkInputAttachmentAspectReference deserialize_struct(stream::VkInputAttachmentAspectReference::Reader reader){
        auto result=VkInputAttachmentAspectReference();
    
[&](){(result.subpass)=reader.getSubpass();}();
[&](){(result.inputAttachmentIndex)=reader.getInputAttachmentIndex();}();
[&](){[&](){[&](){(result.aspectMask)=reader.getAspectMask();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkInputAttachmentAspectReference member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkInputAttachmentAspectReference member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassInputAttachmentAspectCreateInfo::Builder& builder, VkRenderPassInputAttachmentAspectCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAspectReferenceCount((member.aspectReferenceCount));}();
[&](){
            if ((member.pAspectReferences)==NULL){
                builder.initPAspectReferences(0);
            return; }
        auto proto_arr=builder.initPAspectReferences(member.aspectReferenceCount);
        for(int rIgAnwx=0; rIgAnwx < member.aspectReferenceCount; rIgAnwx++){
            [&](){
            auto temp=proto_arr[rIgAnwx];
            return serialize_struct(temp, ((member.pAspectReferences)[rIgAnwx]));
            }();
        }
        }();
}

    VkRenderPassInputAttachmentAspectCreateInfo deserialize_struct(stream::VkRenderPassInputAttachmentAspectCreateInfo::Reader reader){
        auto result=VkRenderPassInputAttachmentAspectCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.aspectReferenceCount)=reader.getAspectReferenceCount();}();
[&](){ VkInputAttachmentAspectReference* temp_QSYjiIr[&](){
            if (!reader.getPAspectReferences().size()==0){
                (result.pAspectReferences)=NULL;
            return; }{native_concat()}=(VkInputAttachmentAspectReference*)malloc(result.aspectReferenceCount*sizeof(VkInputAttachmentAspectReference));
        auto proto_arr=reader.getPAspectReferences(result.aspectReferenceCount);
        for(int FZlDMBF=0; FZlDMBF < result.aspectReferenceCount; FZlDMBF++){
            [&](){
            auto temp=proto_arr[FZlDMBF];
            ((result.pAspectReferences)[FZlDMBF])=deserialize_struct(temp);
            }();
        }
        }();(result.pAspectReferences)=temp_QSYjiIr;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassInputAttachmentAspectCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassInputAttachmentAspectCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSurfaceInfo2KHR::Builder& builder, VkPhysicalDeviceSurfaceInfo2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSurface(serialize_handle(member.surface));}();
}

    VkPhysicalDeviceSurfaceInfo2KHR deserialize_struct(stream::VkPhysicalDeviceSurfaceInfo2KHR::Reader reader){
        auto result=VkPhysicalDeviceSurfaceInfo2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.surface)=deserialize_VkSurfaceKHR(reader.getSurface());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSurfaceInfo2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSurfaceInfo2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfaceCapabilities2KHR::Builder& builder, VkSurfaceCapabilities2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSurfaceCapabilities(surfaceCapabilities);
            return serialize_struct(temp, (member.surfaceCapabilities));
            }();
}

    VkSurfaceCapabilities2KHR deserialize_struct(stream::VkSurfaceCapabilities2KHR::Reader reader){
        auto result=VkSurfaceCapabilities2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSurfaceCapabilities();
            (result.surfaceCapabilities)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfaceCapabilities2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfaceCapabilities2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfaceFormat2KHR::Builder& builder, VkSurfaceFormat2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSurfaceFormat(surfaceFormat);
            return serialize_struct(temp, (member.surfaceFormat));
            }();
}

    VkSurfaceFormat2KHR deserialize_struct(stream::VkSurfaceFormat2KHR::Reader reader){
        auto result=VkSurfaceFormat2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSurfaceFormat();
            (result.surfaceFormat)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfaceFormat2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfaceFormat2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayProperties2KHR::Builder& builder, VkDisplayProperties2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initDisplayProperties(displayProperties);
            return serialize_struct(temp, (member.displayProperties));
            }();
}

    VkDisplayProperties2KHR deserialize_struct(stream::VkDisplayProperties2KHR::Reader reader){
        auto result=VkDisplayProperties2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDisplayProperties();
            (result.displayProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayProperties2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayProperties2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPlaneProperties2KHR::Builder& builder, VkDisplayPlaneProperties2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initDisplayPlaneProperties(displayPlaneProperties);
            return serialize_struct(temp, (member.displayPlaneProperties));
            }();
}

    VkDisplayPlaneProperties2KHR deserialize_struct(stream::VkDisplayPlaneProperties2KHR::Reader reader){
        auto result=VkDisplayPlaneProperties2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDisplayPlaneProperties();
            (result.displayPlaneProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPlaneProperties2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPlaneProperties2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayModeProperties2KHR::Builder& builder, VkDisplayModeProperties2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initDisplayModeProperties(displayModeProperties);
            return serialize_struct(temp, (member.displayModeProperties));
            }();
}

    VkDisplayModeProperties2KHR deserialize_struct(stream::VkDisplayModeProperties2KHR::Reader reader){
        auto result=VkDisplayModeProperties2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDisplayModeProperties();
            (result.displayModeProperties)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayModeProperties2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayModeProperties2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPlaneInfo2KHR::Builder& builder, VkDisplayPlaneInfo2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMode(serialize_handle(member.mode));}();
[&](){return builder.setPlaneIndex((member.planeIndex));}();
}

    VkDisplayPlaneInfo2KHR deserialize_struct(stream::VkDisplayPlaneInfo2KHR::Reader reader){
        auto result=VkDisplayPlaneInfo2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.mode)=deserialize_VkDisplayModeKHR(reader.getMode());}();
[&](){(result.planeIndex)=reader.getPlaneIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPlaneInfo2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPlaneInfo2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDisplayPlaneCapabilities2KHR::Builder& builder, VkDisplayPlaneCapabilities2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initCapabilities(capabilities);
            return serialize_struct(temp, (member.capabilities));
            }();
}

    VkDisplayPlaneCapabilities2KHR deserialize_struct(stream::VkDisplayPlaneCapabilities2KHR::Reader reader){
        auto result=VkDisplayPlaneCapabilities2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getCapabilities();
            (result.capabilities)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDisplayPlaneCapabilities2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDisplayPlaneCapabilities2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSharedPresentSurfaceCapabilitiesKHR::Builder& builder, VkSharedPresentSurfaceCapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSharedPresentSupportedUsageFlags((member.sharedPresentSupportedUsageFlags));}();}();}();
}

    VkSharedPresentSurfaceCapabilitiesKHR deserialize_struct(stream::VkSharedPresentSurfaceCapabilitiesKHR::Reader reader){
        auto result=VkSharedPresentSurfaceCapabilitiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.sharedPresentSupportedUsageFlags)=reader.getSharedPresentSupportedUsageFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSharedPresentSurfaceCapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSharedPresentSurfaceCapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevice16BitStorageFeatures::Builder& builder, VkPhysicalDevice16BitStorageFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setStorageBuffer16BitAccess((member.storageBuffer16BitAccess));}();}();
[&](){[&](){return builder.setUniformAndStorageBuffer16BitAccess((member.uniformAndStorageBuffer16BitAccess));}();}();
[&](){[&](){return builder.setStoragePushConstant16((member.storagePushConstant16));}();}();
[&](){[&](){return builder.setStorageInputOutput16((member.storageInputOutput16));}();}();
}

    VkPhysicalDevice16BitStorageFeatures deserialize_struct(stream::VkPhysicalDevice16BitStorageFeatures::Reader reader){
        auto result=VkPhysicalDevice16BitStorageFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.storageBuffer16BitAccess)=reader.getStorageBuffer16BitAccess();}();}();
[&](){[&](){(result.uniformAndStorageBuffer16BitAccess)=reader.getUniformAndStorageBuffer16BitAccess();}();}();
[&](){[&](){(result.storagePushConstant16)=reader.getStoragePushConstant16();}();}();
[&](){[&](){(result.storageInputOutput16)=reader.getStorageInputOutput16();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevice16BitStorageFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevice16BitStorageFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSubgroupProperties::Builder& builder, VkPhysicalDeviceSubgroupProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSubgroupSize((member.subgroupSize));}();
[&](){[&](){[&](){return builder.setSupportedStages((member.supportedStages));}();}();}();
[&](){[&](){[&](){return builder.setSupportedOperations((member.supportedOperations));}();}();}();
[&](){[&](){return builder.setQuadOperationsInAllStages((member.quadOperationsInAllStages));}();}();
}

    VkPhysicalDeviceSubgroupProperties deserialize_struct(stream::VkPhysicalDeviceSubgroupProperties::Reader reader){
        auto result=VkPhysicalDeviceSubgroupProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.subgroupSize)=reader.getSubgroupSize();}();
[&](){[&](){[&](){(result.supportedStages)=reader.getSupportedStages();}();}();}();
[&](){[&](){[&](){(result.supportedOperations)=reader.getSupportedOperations();}();}();}();
[&](){[&](){(result.quadOperationsInAllStages)=reader.getQuadOperationsInAllStages();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSubgroupProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSubgroupProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::Builder& builder, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderSubgroupExtendedTypes((member.shaderSubgroupExtendedTypes));}();}();
}

    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures deserialize_struct(stream::VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures::Reader reader){
        auto result=VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderSubgroupExtendedTypes)=reader.getShaderSubgroupExtendedTypes();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferMemoryRequirementsInfo2::Builder& builder, VkBufferMemoryRequirementsInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
}

    VkBufferMemoryRequirementsInfo2 deserialize_struct(stream::VkBufferMemoryRequirementsInfo2::Reader reader){
        auto result=VkBufferMemoryRequirementsInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferMemoryRequirementsInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferMemoryRequirementsInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceBufferMemoryRequirements::Builder& builder, VkDeviceBufferMemoryRequirements member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pCreateInfo)==NULL){
                builder.initPCreateInfo(0);
            return; }
        auto proto_arr=builder.initPCreateInfo(1);
        for(int xlJNDRB=0; xlJNDRB < 1; xlJNDRB++){
            [&](){
            auto temp=proto_arr[xlJNDRB];
            return serialize_struct(temp, ((member.pCreateInfo)[xlJNDRB]));
            }();
        }
        }();
}

    VkDeviceBufferMemoryRequirements deserialize_struct(stream::VkDeviceBufferMemoryRequirements::Reader reader){
        auto result=VkDeviceBufferMemoryRequirements();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ VkBufferCreateInfo* temp_jZUqWFE[&](){
            if (!reader.getPCreateInfo().size()==0){
                (result.pCreateInfo)=NULL;
            return; }{native_concat()}=(VkBufferCreateInfo*)malloc(1*sizeof(VkBufferCreateInfo));
        auto proto_arr=reader.getPCreateInfo(1);
        for(int uLhNaqZ=0; uLhNaqZ < 1; uLhNaqZ++){
            [&](){
            auto temp=proto_arr[uLhNaqZ];
            ((result.pCreateInfo)[uLhNaqZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pCreateInfo)=temp_jZUqWFE;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceBufferMemoryRequirements member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceBufferMemoryRequirements member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageMemoryRequirementsInfo2::Builder& builder, VkImageMemoryRequirementsInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImage(serialize_handle(member.image));}();
}

    VkImageMemoryRequirementsInfo2 deserialize_struct(stream::VkImageMemoryRequirementsInfo2::Reader reader){
        auto result=VkImageMemoryRequirementsInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageMemoryRequirementsInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageMemoryRequirementsInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageSparseMemoryRequirementsInfo2::Builder& builder, VkImageSparseMemoryRequirementsInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImage(serialize_handle(member.image));}();
}

    VkImageSparseMemoryRequirementsInfo2 deserialize_struct(stream::VkImageSparseMemoryRequirementsInfo2::Reader reader){
        auto result=VkImageSparseMemoryRequirementsInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageSparseMemoryRequirementsInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageSparseMemoryRequirementsInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceImageMemoryRequirements::Builder& builder, VkDeviceImageMemoryRequirements member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pCreateInfo)==NULL){
                builder.initPCreateInfo(0);
            return; }
        auto proto_arr=builder.initPCreateInfo(1);
        for(int pUPULkH=0; pUPULkH < 1; pUPULkH++){
            [&](){
            auto temp=proto_arr[pUPULkH];
            return serialize_struct(temp, ((member.pCreateInfo)[pUPULkH]));
            }();
        }
        }();
[&](){[&](){[&](){return builder.setPlaneAspect((member.planeAspect));}();}();}();
}

    VkDeviceImageMemoryRequirements deserialize_struct(stream::VkDeviceImageMemoryRequirements::Reader reader){
        auto result=VkDeviceImageMemoryRequirements();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ VkImageCreateInfo* temp_GaGgIvU[&](){
            if (!reader.getPCreateInfo().size()==0){
                (result.pCreateInfo)=NULL;
            return; }{native_concat()}=(VkImageCreateInfo*)malloc(1*sizeof(VkImageCreateInfo));
        auto proto_arr=reader.getPCreateInfo(1);
        for(int OCzXYbh=0; OCzXYbh < 1; OCzXYbh++){
            [&](){
            auto temp=proto_arr[OCzXYbh];
            ((result.pCreateInfo)[OCzXYbh])=deserialize_struct(temp);
            }();
        }
        }();(result.pCreateInfo)=temp_GaGgIvU;}();
[&](){[&](){[&](){(result.planeAspect)=reader.getPlaneAspect();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceImageMemoryRequirements member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceImageMemoryRequirements member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryRequirements2::Builder& builder, VkMemoryRequirements2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initMemoryRequirements(memoryRequirements);
            return serialize_struct(temp, (member.memoryRequirements));
            }();
}

    VkMemoryRequirements2 deserialize_struct(stream::VkMemoryRequirements2::Reader reader){
        auto result=VkMemoryRequirements2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMemoryRequirements();
            (result.memoryRequirements)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryRequirements2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryRequirements2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSparseImageMemoryRequirements2::Builder& builder, VkSparseImageMemoryRequirements2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initMemoryRequirements(memoryRequirements);
            return serialize_struct(temp, (member.memoryRequirements));
            }();
}

    VkSparseImageMemoryRequirements2 deserialize_struct(stream::VkSparseImageMemoryRequirements2::Reader reader){
        auto result=VkSparseImageMemoryRequirements2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMemoryRequirements();
            (result.memoryRequirements)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSparseImageMemoryRequirements2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSparseImageMemoryRequirements2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePointClippingProperties::Builder& builder, VkPhysicalDevicePointClippingProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPointClippingBehavior((member.pointClippingBehavior));}();}();}();
}

    VkPhysicalDevicePointClippingProperties deserialize_struct(stream::VkPhysicalDevicePointClippingProperties::Reader reader){
        auto result=VkPhysicalDevicePointClippingProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.pointClippingBehavior)=reader.getPointClippingBehavior();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePointClippingProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePointClippingProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryDedicatedRequirements::Builder& builder, VkMemoryDedicatedRequirements member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPrefersDedicatedAllocation((member.prefersDedicatedAllocation));}();}();
[&](){[&](){return builder.setRequiresDedicatedAllocation((member.requiresDedicatedAllocation));}();}();
}

    VkMemoryDedicatedRequirements deserialize_struct(stream::VkMemoryDedicatedRequirements::Reader reader){
        auto result=VkMemoryDedicatedRequirements();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.prefersDedicatedAllocation)=reader.getPrefersDedicatedAllocation();}();}();
[&](){[&](){(result.requiresDedicatedAllocation)=reader.getRequiresDedicatedAllocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryDedicatedRequirements member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryDedicatedRequirements member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryDedicatedAllocateInfo::Builder& builder, VkMemoryDedicatedAllocateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
}

    VkMemoryDedicatedAllocateInfo deserialize_struct(stream::VkMemoryDedicatedAllocateInfo::Reader reader){
        auto result=VkMemoryDedicatedAllocateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryDedicatedAllocateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryDedicatedAllocateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewUsageCreateInfo::Builder& builder, VkImageViewUsageCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
}

    VkImageViewUsageCreateInfo deserialize_struct(stream::VkImageViewUsageCreateInfo::Reader reader){
        auto result=VkImageViewUsageCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewUsageCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewUsageCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewSlicedCreateInfoEXT::Builder& builder, VkImageViewSlicedCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSliceOffset((member.sliceOffset));}();
[&](){return builder.setSliceCount((member.sliceCount));}();
}

    VkImageViewSlicedCreateInfoEXT deserialize_struct(stream::VkImageViewSlicedCreateInfoEXT::Reader reader){
        auto result=VkImageViewSlicedCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.sliceOffset)=reader.getSliceOffset();}();
[&](){(result.sliceCount)=reader.getSliceCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewSlicedCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewSlicedCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineTessellationDomainOriginStateCreateInfo::Builder& builder, VkPipelineTessellationDomainOriginStateCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDomainOrigin((member.domainOrigin));}();}();}();
}

    VkPipelineTessellationDomainOriginStateCreateInfo deserialize_struct(stream::VkPipelineTessellationDomainOriginStateCreateInfo::Reader reader){
        auto result=VkPipelineTessellationDomainOriginStateCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.domainOrigin)=reader.getDomainOrigin();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineTessellationDomainOriginStateCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineTessellationDomainOriginStateCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerYcbcrConversionInfo::Builder& builder, VkSamplerYcbcrConversionInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setConversion(serialize_handle(member.conversion));}();
}

    VkSamplerYcbcrConversionInfo deserialize_struct(stream::VkSamplerYcbcrConversionInfo::Reader reader){
        auto result=VkSamplerYcbcrConversionInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.conversion)=deserialize_VkSamplerYcbcrConversion(reader.getConversion());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerYcbcrConversionInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerYcbcrConversionInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerYcbcrConversionCreateInfo::Builder& builder, VkSamplerYcbcrConversionCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){[&](){[&](){return builder.setYcbcrModel((member.ycbcrModel));}();}();}();
[&](){[&](){[&](){return builder.setYcbcrRange((member.ycbcrRange));}();}();}();
[&](){
            auto temp=builder.initComponents(components);
            return serialize_struct(temp, (member.components));
            }();
[&](){[&](){[&](){return builder.setXChromaOffset((member.xChromaOffset));}();}();}();
[&](){[&](){[&](){return builder.setYChromaOffset((member.yChromaOffset));}();}();}();
[&](){[&](){[&](){return builder.setChromaFilter((member.chromaFilter));}();}();}();
[&](){[&](){return builder.setForceExplicitReconstruction((member.forceExplicitReconstruction));}();}();
}

    VkSamplerYcbcrConversionCreateInfo deserialize_struct(stream::VkSamplerYcbcrConversionCreateInfo::Reader reader){
        auto result=VkSamplerYcbcrConversionCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){[&](){[&](){(result.ycbcrModel)=reader.getYcbcrModel();}();}();}();
[&](){[&](){[&](){(result.ycbcrRange)=reader.getYcbcrRange();}();}();}();
[&](){
            auto temp=reader.getComponents();
            (result.components)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.xChromaOffset)=reader.getXChromaOffset();}();}();}();
[&](){[&](){[&](){(result.yChromaOffset)=reader.getYChromaOffset();}();}();}();
[&](){[&](){[&](){(result.chromaFilter)=reader.getChromaFilter();}();}();}();
[&](){[&](){(result.forceExplicitReconstruction)=reader.getForceExplicitReconstruction();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerYcbcrConversionCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerYcbcrConversionCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindImagePlaneMemoryInfo::Builder& builder, VkBindImagePlaneMemoryInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPlaneAspect((member.planeAspect));}();}();}();
}

    VkBindImagePlaneMemoryInfo deserialize_struct(stream::VkBindImagePlaneMemoryInfo::Reader reader){
        auto result=VkBindImagePlaneMemoryInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.planeAspect)=reader.getPlaneAspect();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindImagePlaneMemoryInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindImagePlaneMemoryInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImagePlaneMemoryRequirementsInfo::Builder& builder, VkImagePlaneMemoryRequirementsInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPlaneAspect((member.planeAspect));}();}();}();
}

    VkImagePlaneMemoryRequirementsInfo deserialize_struct(stream::VkImagePlaneMemoryRequirementsInfo::Reader reader){
        auto result=VkImagePlaneMemoryRequirementsInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.planeAspect)=reader.getPlaneAspect();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImagePlaneMemoryRequirementsInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImagePlaneMemoryRequirementsInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSamplerYcbcrConversionFeatures::Builder& builder, VkPhysicalDeviceSamplerYcbcrConversionFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSamplerYcbcrConversion((member.samplerYcbcrConversion));}();}();
}

    VkPhysicalDeviceSamplerYcbcrConversionFeatures deserialize_struct(stream::VkPhysicalDeviceSamplerYcbcrConversionFeatures::Reader reader){
        auto result=VkPhysicalDeviceSamplerYcbcrConversionFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.samplerYcbcrConversion)=reader.getSamplerYcbcrConversion();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSamplerYcbcrConversionFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSamplerYcbcrConversionFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerYcbcrConversionImageFormatProperties::Builder& builder, VkSamplerYcbcrConversionImageFormatProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setCombinedImageSamplerDescriptorCount((member.combinedImageSamplerDescriptorCount));}();
}

    VkSamplerYcbcrConversionImageFormatProperties deserialize_struct(stream::VkSamplerYcbcrConversionImageFormatProperties::Reader reader){
        auto result=VkSamplerYcbcrConversionImageFormatProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.combinedImageSamplerDescriptorCount)=reader.getCombinedImageSamplerDescriptorCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerYcbcrConversionImageFormatProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerYcbcrConversionImageFormatProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkTextureLODGatherFormatPropertiesAMD::Builder& builder, VkTextureLODGatherFormatPropertiesAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSupportsTextureGatherLODBiasAMD((member.supportsTextureGatherLODBiasAMD));}();}();
}

    VkTextureLODGatherFormatPropertiesAMD deserialize_struct(stream::VkTextureLODGatherFormatPropertiesAMD::Reader reader){
        auto result=VkTextureLODGatherFormatPropertiesAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.supportsTextureGatherLODBiasAMD)=reader.getSupportsTextureGatherLODBiasAMD();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkTextureLODGatherFormatPropertiesAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkTextureLODGatherFormatPropertiesAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkConditionalRenderingBeginInfoEXT::Builder& builder, VkConditionalRenderingBeginInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkConditionalRenderingBeginInfoEXT deserialize_struct(stream::VkConditionalRenderingBeginInfoEXT::Reader reader){
        auto result=VkConditionalRenderingBeginInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkConditionalRenderingBeginInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkConditionalRenderingBeginInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkProtectedSubmitInfo::Builder& builder, VkProtectedSubmitInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setProtectedSubmit((member.protectedSubmit));}();}();
}

    VkProtectedSubmitInfo deserialize_struct(stream::VkProtectedSubmitInfo::Reader reader){
        auto result=VkProtectedSubmitInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.protectedSubmit)=reader.getProtectedSubmit();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkProtectedSubmitInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkProtectedSubmitInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceProtectedMemoryFeatures::Builder& builder, VkPhysicalDeviceProtectedMemoryFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setProtectedMemory((member.protectedMemory));}();}();
}

    VkPhysicalDeviceProtectedMemoryFeatures deserialize_struct(stream::VkPhysicalDeviceProtectedMemoryFeatures::Reader reader){
        auto result=VkPhysicalDeviceProtectedMemoryFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.protectedMemory)=reader.getProtectedMemory();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceProtectedMemoryFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceProtectedMemoryFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceProtectedMemoryProperties::Builder& builder, VkPhysicalDeviceProtectedMemoryProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setProtectedNoFault((member.protectedNoFault));}();}();
}

    VkPhysicalDeviceProtectedMemoryProperties deserialize_struct(stream::VkPhysicalDeviceProtectedMemoryProperties::Reader reader){
        auto result=VkPhysicalDeviceProtectedMemoryProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.protectedNoFault)=reader.getProtectedNoFault();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceProtectedMemoryProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceProtectedMemoryProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceQueueInfo2::Builder& builder, VkDeviceQueueInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setQueueFamilyIndex((member.queueFamilyIndex));}();
[&](){return builder.setQueueIndex((member.queueIndex));}();
}

    VkDeviceQueueInfo2 deserialize_struct(stream::VkDeviceQueueInfo2::Reader reader){
        auto result=VkDeviceQueueInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.queueFamilyIndex)=reader.getQueueFamilyIndex();}();
[&](){(result.queueIndex)=reader.getQueueIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceQueueInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceQueueInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCoverageToColorStateCreateInfoNV::Builder& builder, VkPipelineCoverageToColorStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setCoverageToColorEnable((member.coverageToColorEnable));}();}();
[&](){return builder.setCoverageToColorLocation((member.coverageToColorLocation));}();
}

    VkPipelineCoverageToColorStateCreateInfoNV deserialize_struct(stream::VkPipelineCoverageToColorStateCreateInfoNV::Reader reader){
        auto result=VkPipelineCoverageToColorStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.coverageToColorEnable)=reader.getCoverageToColorEnable();}();}();
[&](){(result.coverageToColorLocation)=reader.getCoverageToColorLocation();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCoverageToColorStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCoverageToColorStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSamplerFilterMinmaxProperties::Builder& builder, VkPhysicalDeviceSamplerFilterMinmaxProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFilterMinmaxSingleComponentFormats((member.filterMinmaxSingleComponentFormats));}();}();
[&](){[&](){return builder.setFilterMinmaxImageComponentMapping((member.filterMinmaxImageComponentMapping));}();}();
}

    VkPhysicalDeviceSamplerFilterMinmaxProperties deserialize_struct(stream::VkPhysicalDeviceSamplerFilterMinmaxProperties::Reader reader){
        auto result=VkPhysicalDeviceSamplerFilterMinmaxProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.filterMinmaxSingleComponentFormats)=reader.getFilterMinmaxSingleComponentFormats();}();}();
[&](){[&](){(result.filterMinmaxImageComponentMapping)=reader.getFilterMinmaxImageComponentMapping();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSamplerFilterMinmaxProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSamplerFilterMinmaxProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSampleLocationEXT::Builder& builder, VkSampleLocationEXT member){
        
    
[&](){return builder.setX((member.x));}();
[&](){return builder.setY((member.y));}();
}

    VkSampleLocationEXT deserialize_struct(stream::VkSampleLocationEXT::Reader reader){
        auto result=VkSampleLocationEXT();
    
[&](){(result.x)=reader.getX();}();
[&](){(result.y)=reader.getY();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSampleLocationEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSampleLocationEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSampleLocationsInfoEXT::Builder& builder, VkSampleLocationsInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSampleLocationsPerPixel((member.sampleLocationsPerPixel));}();}();}();
[&](){
            auto temp=builder.initSampleLocationGridSize(sampleLocationGridSize);
            return serialize_struct(temp, (member.sampleLocationGridSize));
            }();
[&](){return builder.setSampleLocationsCount((member.sampleLocationsCount));}();
[&](){
            if ((member.pSampleLocations)==NULL){
                builder.initPSampleLocations(0);
            return; }
        auto proto_arr=builder.initPSampleLocations(member.sampleLocationsCount);
        for(int AEcYmme=0; AEcYmme < member.sampleLocationsCount; AEcYmme++){
            [&](){
            auto temp=proto_arr[AEcYmme];
            return serialize_struct(temp, ((member.pSampleLocations)[AEcYmme]));
            }();
        }
        }();
}

    VkSampleLocationsInfoEXT deserialize_struct(stream::VkSampleLocationsInfoEXT::Reader reader){
        auto result=VkSampleLocationsInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.sampleLocationsPerPixel)=reader.getSampleLocationsPerPixel();}();}();}();
[&](){
            auto temp=reader.getSampleLocationGridSize();
            (result.sampleLocationGridSize)=deserialize_struct(temp);
            }();
[&](){(result.sampleLocationsCount)=reader.getSampleLocationsCount();}();
[&](){ VkSampleLocationEXT* temp_VQWplTH[&](){
            if (!reader.getPSampleLocations().size()==0){
                (result.pSampleLocations)=NULL;
            return; }{native_concat()}=(VkSampleLocationEXT*)malloc(result.sampleLocationsCount*sizeof(VkSampleLocationEXT));
        auto proto_arr=reader.getPSampleLocations(result.sampleLocationsCount);
        for(int VuEajPo=0; VuEajPo < result.sampleLocationsCount; VuEajPo++){
            [&](){
            auto temp=proto_arr[VuEajPo];
            ((result.pSampleLocations)[VuEajPo])=deserialize_struct(temp);
            }();
        }
        }();(result.pSampleLocations)=temp_VQWplTH;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSampleLocationsInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSampleLocationsInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentSampleLocationsEXT::Builder& builder, VkAttachmentSampleLocationsEXT member){
        
    
[&](){return builder.setAttachmentIndex((member.attachmentIndex));}();
[&](){
            auto temp=builder.initSampleLocationsInfo(sampleLocationsInfo);
            return serialize_struct(temp, (member.sampleLocationsInfo));
            }();
}

    VkAttachmentSampleLocationsEXT deserialize_struct(stream::VkAttachmentSampleLocationsEXT::Reader reader){
        auto result=VkAttachmentSampleLocationsEXT();
    
[&](){(result.attachmentIndex)=reader.getAttachmentIndex();}();
[&](){
            auto temp=reader.getSampleLocationsInfo();
            (result.sampleLocationsInfo)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentSampleLocationsEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentSampleLocationsEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassSampleLocationsEXT::Builder& builder, VkSubpassSampleLocationsEXT member){
        
    
[&](){return builder.setSubpassIndex((member.subpassIndex));}();
[&](){
            auto temp=builder.initSampleLocationsInfo(sampleLocationsInfo);
            return serialize_struct(temp, (member.sampleLocationsInfo));
            }();
}

    VkSubpassSampleLocationsEXT deserialize_struct(stream::VkSubpassSampleLocationsEXT::Reader reader){
        auto result=VkSubpassSampleLocationsEXT();
    
[&](){(result.subpassIndex)=reader.getSubpassIndex();}();
[&](){
            auto temp=reader.getSampleLocationsInfo();
            (result.sampleLocationsInfo)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassSampleLocationsEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassSampleLocationsEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassSampleLocationsBeginInfoEXT::Builder& builder, VkRenderPassSampleLocationsBeginInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAttachmentInitialSampleLocationsCount((member.attachmentInitialSampleLocationsCount));}();
[&](){
            if ((member.pAttachmentInitialSampleLocations)==NULL){
                builder.initPAttachmentInitialSampleLocations(0);
            return; }
        auto proto_arr=builder.initPAttachmentInitialSampleLocations(member.attachmentInitialSampleLocationsCount);
        for(int VhCXYaI=0; VhCXYaI < member.attachmentInitialSampleLocationsCount; VhCXYaI++){
            [&](){
            auto temp=proto_arr[VhCXYaI];
            return serialize_struct(temp, ((member.pAttachmentInitialSampleLocations)[VhCXYaI]));
            }();
        }
        }();
[&](){return builder.setPostSubpassSampleLocationsCount((member.postSubpassSampleLocationsCount));}();
[&](){
            if ((member.pPostSubpassSampleLocations)==NULL){
                builder.initPPostSubpassSampleLocations(0);
            return; }
        auto proto_arr=builder.initPPostSubpassSampleLocations(member.postSubpassSampleLocationsCount);
        for(int KWZzgwg=0; KWZzgwg < member.postSubpassSampleLocationsCount; KWZzgwg++){
            [&](){
            auto temp=proto_arr[KWZzgwg];
            return serialize_struct(temp, ((member.pPostSubpassSampleLocations)[KWZzgwg]));
            }();
        }
        }();
}

    VkRenderPassSampleLocationsBeginInfoEXT deserialize_struct(stream::VkRenderPassSampleLocationsBeginInfoEXT::Reader reader){
        auto result=VkRenderPassSampleLocationsBeginInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.attachmentInitialSampleLocationsCount)=reader.getAttachmentInitialSampleLocationsCount();}();
[&](){ VkAttachmentSampleLocationsEXT* temp_fmtsDMG[&](){
            if (!reader.getPAttachmentInitialSampleLocations().size()==0){
                (result.pAttachmentInitialSampleLocations)=NULL;
            return; }{native_concat()}=(VkAttachmentSampleLocationsEXT*)malloc(result.attachmentInitialSampleLocationsCount*sizeof(VkAttachmentSampleLocationsEXT));
        auto proto_arr=reader.getPAttachmentInitialSampleLocations(result.attachmentInitialSampleLocationsCount);
        for(int KcToJrv=0; KcToJrv < result.attachmentInitialSampleLocationsCount; KcToJrv++){
            [&](){
            auto temp=proto_arr[KcToJrv];
            ((result.pAttachmentInitialSampleLocations)[KcToJrv])=deserialize_struct(temp);
            }();
        }
        }();(result.pAttachmentInitialSampleLocations)=temp_fmtsDMG;}();
[&](){(result.postSubpassSampleLocationsCount)=reader.getPostSubpassSampleLocationsCount();}();
[&](){ VkSubpassSampleLocationsEXT* temp_CPGKVcw[&](){
            if (!reader.getPPostSubpassSampleLocations().size()==0){
                (result.pPostSubpassSampleLocations)=NULL;
            return; }{native_concat()}=(VkSubpassSampleLocationsEXT*)malloc(result.postSubpassSampleLocationsCount*sizeof(VkSubpassSampleLocationsEXT));
        auto proto_arr=reader.getPPostSubpassSampleLocations(result.postSubpassSampleLocationsCount);
        for(int JwwfDjw=0; JwwfDjw < result.postSubpassSampleLocationsCount; JwwfDjw++){
            [&](){
            auto temp=proto_arr[JwwfDjw];
            ((result.pPostSubpassSampleLocations)[JwwfDjw])=deserialize_struct(temp);
            }();
        }
        }();(result.pPostSubpassSampleLocations)=temp_CPGKVcw;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassSampleLocationsBeginInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassSampleLocationsBeginInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineSampleLocationsStateCreateInfoEXT::Builder& builder, VkPipelineSampleLocationsStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSampleLocationsEnable((member.sampleLocationsEnable));}();}();
[&](){
            auto temp=builder.initSampleLocationsInfo(sampleLocationsInfo);
            return serialize_struct(temp, (member.sampleLocationsInfo));
            }();
}

    VkPipelineSampleLocationsStateCreateInfoEXT deserialize_struct(stream::VkPipelineSampleLocationsStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineSampleLocationsStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.sampleLocationsEnable)=reader.getSampleLocationsEnable();}();}();
[&](){
            auto temp=reader.getSampleLocationsInfo();
            (result.sampleLocationsInfo)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineSampleLocationsStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineSampleLocationsStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSampleLocationsPropertiesEXT::Builder& builder, VkPhysicalDeviceSampleLocationsPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSampleLocationSampleCounts((member.sampleLocationSampleCounts));}();}();}();
[&](){
            auto temp=builder.initMaxSampleLocationGridSize(maxSampleLocationGridSize);
            return serialize_struct(temp, (member.maxSampleLocationGridSize));
            }();
[&](){
        auto proto_arr=builder.initSampleLocationCoordinateRange(2);
        for(int PRguJoc=0; PRguJoc < 2; PRguJoc++){
            [&](){return proto_arr.set(PRguJoc,((member.sampleLocationCoordinateRange)[PRguJoc]));}();
        }
        }();
[&](){return builder.setSampleLocationSubPixelBits((member.sampleLocationSubPixelBits));}();
[&](){[&](){return builder.setVariableSampleLocations((member.variableSampleLocations));}();}();
}

    VkPhysicalDeviceSampleLocationsPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceSampleLocationsPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceSampleLocationsPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.sampleLocationSampleCounts)=reader.getSampleLocationSampleCounts();}();}();}();
[&](){
            auto temp=reader.getMaxSampleLocationGridSize();
            (result.maxSampleLocationGridSize)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getSampleLocationCoordinateRange(2);
        for(int PRguJoc=0; PRguJoc < 2; PRguJoc++){
            [&](){((result.sampleLocationCoordinateRange)[PRguJoc])=proto_arr[PRguJoc];}();
        }
        }();
[&](){(result.sampleLocationSubPixelBits)=reader.getSampleLocationSubPixelBits();}();
[&](){[&](){(result.variableSampleLocations)=reader.getVariableSampleLocations();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSampleLocationsPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSampleLocationsPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMultisamplePropertiesEXT::Builder& builder, VkMultisamplePropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initMaxSampleLocationGridSize(maxSampleLocationGridSize);
            return serialize_struct(temp, (member.maxSampleLocationGridSize));
            }();
}

    VkMultisamplePropertiesEXT deserialize_struct(stream::VkMultisamplePropertiesEXT::Reader reader){
        auto result=VkMultisamplePropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxSampleLocationGridSize();
            (result.maxSampleLocationGridSize)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMultisamplePropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMultisamplePropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerReductionModeCreateInfo::Builder& builder, VkSamplerReductionModeCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setReductionMode((member.reductionMode));}();}();}();
}

    VkSamplerReductionModeCreateInfo deserialize_struct(stream::VkSamplerReductionModeCreateInfo::Reader reader){
        auto result=VkSamplerReductionModeCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.reductionMode)=reader.getReductionMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerReductionModeCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerReductionModeCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::Builder& builder, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAdvancedBlendCoherentOperations((member.advancedBlendCoherentOperations));}();}();
}

    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.advancedBlendCoherentOperations)=reader.getAdvancedBlendCoherentOperations();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultiDrawFeaturesEXT::Builder& builder, VkPhysicalDeviceMultiDrawFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMultiDraw((member.multiDraw));}();}();
}

    VkPhysicalDeviceMultiDrawFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceMultiDrawFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceMultiDrawFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.multiDraw)=reader.getMultiDraw();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultiDrawFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultiDrawFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::Builder& builder, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAdvancedBlendMaxColorAttachments((member.advancedBlendMaxColorAttachments));}();
[&](){[&](){return builder.setAdvancedBlendIndependentBlend((member.advancedBlendIndependentBlend));}();}();
[&](){[&](){return builder.setAdvancedBlendNonPremultipliedSrcColor((member.advancedBlendNonPremultipliedSrcColor));}();}();
[&](){[&](){return builder.setAdvancedBlendNonPremultipliedDstColor((member.advancedBlendNonPremultipliedDstColor));}();}();
[&](){[&](){return builder.setAdvancedBlendCorrelatedOverlap((member.advancedBlendCorrelatedOverlap));}();}();
[&](){[&](){return builder.setAdvancedBlendAllOperations((member.advancedBlendAllOperations));}();}();
}

    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.advancedBlendMaxColorAttachments)=reader.getAdvancedBlendMaxColorAttachments();}();
[&](){[&](){(result.advancedBlendIndependentBlend)=reader.getAdvancedBlendIndependentBlend();}();}();
[&](){[&](){(result.advancedBlendNonPremultipliedSrcColor)=reader.getAdvancedBlendNonPremultipliedSrcColor();}();}();
[&](){[&](){(result.advancedBlendNonPremultipliedDstColor)=reader.getAdvancedBlendNonPremultipliedDstColor();}();}();
[&](){[&](){(result.advancedBlendCorrelatedOverlap)=reader.getAdvancedBlendCorrelatedOverlap();}();}();
[&](){[&](){(result.advancedBlendAllOperations)=reader.getAdvancedBlendAllOperations();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineColorBlendAdvancedStateCreateInfoEXT::Builder& builder, VkPipelineColorBlendAdvancedStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSrcPremultiplied((member.srcPremultiplied));}();}();
[&](){[&](){return builder.setDstPremultiplied((member.dstPremultiplied));}();}();
[&](){[&](){[&](){return builder.setBlendOverlap((member.blendOverlap));}();}();}();
}

    VkPipelineColorBlendAdvancedStateCreateInfoEXT deserialize_struct(stream::VkPipelineColorBlendAdvancedStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineColorBlendAdvancedStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.srcPremultiplied)=reader.getSrcPremultiplied();}();}();
[&](){[&](){(result.dstPremultiplied)=reader.getDstPremultiplied();}();}();
[&](){[&](){[&](){(result.blendOverlap)=reader.getBlendOverlap();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineColorBlendAdvancedStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineColorBlendAdvancedStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceInlineUniformBlockFeatures::Builder& builder, VkPhysicalDeviceInlineUniformBlockFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setInlineUniformBlock((member.inlineUniformBlock));}();}();
[&](){[&](){return builder.setDescriptorBindingInlineUniformBlockUpdateAfterBind((member.descriptorBindingInlineUniformBlockUpdateAfterBind));}();}();
}

    VkPhysicalDeviceInlineUniformBlockFeatures deserialize_struct(stream::VkPhysicalDeviceInlineUniformBlockFeatures::Reader reader){
        auto result=VkPhysicalDeviceInlineUniformBlockFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.inlineUniformBlock)=reader.getInlineUniformBlock();}();}();
[&](){[&](){(result.descriptorBindingInlineUniformBlockUpdateAfterBind)=reader.getDescriptorBindingInlineUniformBlockUpdateAfterBind();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceInlineUniformBlockFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceInlineUniformBlockFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceInlineUniformBlockProperties::Builder& builder, VkPhysicalDeviceInlineUniformBlockProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxInlineUniformBlockSize((member.maxInlineUniformBlockSize));}();
[&](){return builder.setMaxPerStageDescriptorInlineUniformBlocks((member.maxPerStageDescriptorInlineUniformBlocks));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks((member.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks));}();
[&](){return builder.setMaxDescriptorSetInlineUniformBlocks((member.maxDescriptorSetInlineUniformBlocks));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindInlineUniformBlocks((member.maxDescriptorSetUpdateAfterBindInlineUniformBlocks));}();
}

    VkPhysicalDeviceInlineUniformBlockProperties deserialize_struct(stream::VkPhysicalDeviceInlineUniformBlockProperties::Reader reader){
        auto result=VkPhysicalDeviceInlineUniformBlockProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxInlineUniformBlockSize)=reader.getMaxInlineUniformBlockSize();}();
[&](){(result.maxPerStageDescriptorInlineUniformBlocks)=reader.getMaxPerStageDescriptorInlineUniformBlocks();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)=reader.getMaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks();}();
[&](){(result.maxDescriptorSetInlineUniformBlocks)=reader.getMaxDescriptorSetInlineUniformBlocks();}();
[&](){(result.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)=reader.getMaxDescriptorSetUpdateAfterBindInlineUniformBlocks();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceInlineUniformBlockProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceInlineUniformBlockProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkWriteDescriptorSetInlineUniformBlock::Builder& builder, VkWriteDescriptorSetInlineUniformBlock member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDataSize((member.dataSize));}();
[&](){
            if ((member.pData)==NULL){
                builder.initPData(0);
            return; }[&](){
            if (((char*)(member.pData).pData)==NULL){
                builder.initPData(0);
            return; }
        auto proto_arr=builder.initPData(member.dataSize);
        for(int KUeyATI=0; KUeyATI < member.dataSize; KUeyATI++){
            [&](){return proto_arr.set(KUeyATI,(((char*)(member.pData).pData)[KUeyATI]));}();
        }
        }();}();
}

    VkWriteDescriptorSetInlineUniformBlock deserialize_struct(stream::VkWriteDescriptorSetInlineUniformBlock::Reader reader){
        auto result=VkWriteDescriptorSetInlineUniformBlock();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.dataSize)=reader.getDataSize();}();
[&](){ void* temp_RUIzmiy[&](){
            if (!reader.getPData().size()==0){
                (result.pData)=NULL;
            return; }char* temp_KoPqpjZ;[&](){
            if (!reader.getPData().size()==0){
                (temp_KoPqpjZ.pData)=NULL;
            return; }{native_concat()}=(char*)malloc(result.dataSize*sizeof(char));
        auto proto_arr=reader.getPData(result.dataSize);
        for(int OCmuZGI=0; OCmuZGI < result.dataSize; OCmuZGI++){
            [&](){((temp_KoPqpjZ.pData)[OCmuZGI])=proto_arr[OCmuZGI];}();
        }
        }();(result.pData)=temp_KoPqpjZ;}();(result.pData)=temp_RUIzmiy;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkWriteDescriptorSetInlineUniformBlock member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkWriteDescriptorSetInlineUniformBlock member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorPoolInlineUniformBlockCreateInfo::Builder& builder, VkDescriptorPoolInlineUniformBlockCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxInlineUniformBlockBindings((member.maxInlineUniformBlockBindings));}();
}

    VkDescriptorPoolInlineUniformBlockCreateInfo deserialize_struct(stream::VkDescriptorPoolInlineUniformBlockCreateInfo::Reader reader){
        auto result=VkDescriptorPoolInlineUniformBlockCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.maxInlineUniformBlockBindings)=reader.getMaxInlineUniformBlockBindings();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorPoolInlineUniformBlockCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorPoolInlineUniformBlockCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCoverageModulationStateCreateInfoNV::Builder& builder, VkPipelineCoverageModulationStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setCoverageModulationMode((member.coverageModulationMode));}();}();}();
[&](){[&](){return builder.setCoverageModulationTableEnable((member.coverageModulationTableEnable));}();}();
[&](){return builder.setCoverageModulationTableCount((member.coverageModulationTableCount));}();
[&](){
            if ((member.pCoverageModulationTable)==NULL){
                builder.initPCoverageModulationTable(0);
            return; }
        auto proto_arr=builder.initPCoverageModulationTable(member.coverageModulationTableCount);
        for(int PsVHolD=0; PsVHolD < member.coverageModulationTableCount; PsVHolD++){
            [&](){return proto_arr.set(PsVHolD,((member.pCoverageModulationTable)[PsVHolD]));}();
        }
        }();
}

    VkPipelineCoverageModulationStateCreateInfoNV deserialize_struct(stream::VkPipelineCoverageModulationStateCreateInfoNV::Reader reader){
        auto result=VkPipelineCoverageModulationStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.coverageModulationMode)=reader.getCoverageModulationMode();}();}();}();
[&](){[&](){(result.coverageModulationTableEnable)=reader.getCoverageModulationTableEnable();}();}();
[&](){(result.coverageModulationTableCount)=reader.getCoverageModulationTableCount();}();
[&](){ float* temp_mxuICcT[&](){
            if (!reader.getPCoverageModulationTable().size()==0){
                (result.pCoverageModulationTable)=NULL;
            return; }{native_concat()}=(float*)malloc(result.coverageModulationTableCount*sizeof(float));
        auto proto_arr=reader.getPCoverageModulationTable(result.coverageModulationTableCount);
        for(int hQRBHsT=0; hQRBHsT < result.coverageModulationTableCount; hQRBHsT++){
            [&](){((result.pCoverageModulationTable)[hQRBHsT])=proto_arr[hQRBHsT];}();
        }
        }();(result.pCoverageModulationTable)=temp_mxuICcT;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCoverageModulationStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCoverageModulationStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageFormatListCreateInfo::Builder& builder, VkImageFormatListCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setViewFormatCount((member.viewFormatCount));}();
[&](){
            if ((member.pViewFormats)==NULL){
                builder.initPViewFormats(0);
            return; }
        auto proto_arr=builder.initPViewFormats(member.viewFormatCount);
        for(int JvKPhOq=0; JvKPhOq < member.viewFormatCount; JvKPhOq++){
            [&](){[&](){[&](){return proto_arr.set(JvKPhOq,((member.pViewFormats)[JvKPhOq]));}();}();}();
        }
        }();
}

    VkImageFormatListCreateInfo deserialize_struct(stream::VkImageFormatListCreateInfo::Reader reader){
        auto result=VkImageFormatListCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.viewFormatCount)=reader.getViewFormatCount();}();
[&](){ VkFormat* temp_IZMfCii[&](){
            if (!reader.getPViewFormats().size()==0){
                (result.pViewFormats)=NULL;
            return; }{native_concat()}=(VkFormat*)malloc(result.viewFormatCount*sizeof(VkFormat));
        auto proto_arr=reader.getPViewFormats(result.viewFormatCount);
        for(int tWwlFTf=0; tWwlFTf < result.viewFormatCount; tWwlFTf++){
            [&](){[&](){[&](){((result.pViewFormats)[tWwlFTf])=proto_arr[tWwlFTf];}();}();}();
        }
        }();(result.pViewFormats)=temp_IZMfCii;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageFormatListCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageFormatListCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkValidationCacheCreateInfoEXT::Builder& builder, VkValidationCacheCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setInitialDataSize((member.initialDataSize));}();
[&](){
            if ((member.pInitialData)==NULL){
                builder.initPInitialData(0);
            return; }[&](){
            if (((char*)(member.pInitialData).pInitialData)==NULL){
                builder.initPInitialData(0);
            return; }
        auto proto_arr=builder.initPInitialData(member.initialDataSize);
        for(int VgUKinx=0; VgUKinx < member.initialDataSize; VgUKinx++){
            [&](){return proto_arr.set(VgUKinx,(((char*)(member.pInitialData).pInitialData)[VgUKinx]));}();
        }
        }();}();
}

    VkValidationCacheCreateInfoEXT deserialize_struct(stream::VkValidationCacheCreateInfoEXT::Reader reader){
        auto result=VkValidationCacheCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.initialDataSize)=reader.getInitialDataSize();}();
[&](){ void* temp_hSGagCA[&](){
            if (!reader.getPInitialData().size()==0){
                (result.pInitialData)=NULL;
            return; }char* temp_MNyHoci;[&](){
            if (!reader.getPInitialData().size()==0){
                (temp_MNyHoci.pInitialData)=NULL;
            return; }{native_concat()}=(char*)malloc(result.initialDataSize*sizeof(char));
        auto proto_arr=reader.getPInitialData(result.initialDataSize);
        for(int FUremIn=0; FUremIn < result.initialDataSize; FUremIn++){
            [&](){((temp_MNyHoci.pInitialData)[FUremIn])=proto_arr[FUremIn];}();
        }
        }();(result.pInitialData)=temp_MNyHoci;}();(result.pInitialData)=temp_hSGagCA;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkValidationCacheCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkValidationCacheCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkShaderModuleValidationCacheCreateInfoEXT::Builder& builder, VkShaderModuleValidationCacheCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setValidationCache(serialize_handle(member.validationCache));}();
}

    VkShaderModuleValidationCacheCreateInfoEXT deserialize_struct(stream::VkShaderModuleValidationCacheCreateInfoEXT::Reader reader){
        auto result=VkShaderModuleValidationCacheCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.validationCache)=deserialize_VkValidationCacheEXT(reader.getValidationCache());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkShaderModuleValidationCacheCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkShaderModuleValidationCacheCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMaintenance3Properties::Builder& builder, VkPhysicalDeviceMaintenance3Properties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxPerSetDescriptors((member.maxPerSetDescriptors));}();
[&](){[&](){return builder.setMaxMemoryAllocationSize((member.maxMemoryAllocationSize));}();}();
}

    VkPhysicalDeviceMaintenance3Properties deserialize_struct(stream::VkPhysicalDeviceMaintenance3Properties::Reader reader){
        auto result=VkPhysicalDeviceMaintenance3Properties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxPerSetDescriptors)=reader.getMaxPerSetDescriptors();}();
[&](){[&](){(result.maxMemoryAllocationSize)=reader.getMaxMemoryAllocationSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMaintenance3Properties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMaintenance3Properties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMaintenance4Features::Builder& builder, VkPhysicalDeviceMaintenance4Features member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMaintenance4((member.maintenance4));}();}();
}

    VkPhysicalDeviceMaintenance4Features deserialize_struct(stream::VkPhysicalDeviceMaintenance4Features::Reader reader){
        auto result=VkPhysicalDeviceMaintenance4Features();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.maintenance4)=reader.getMaintenance4();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMaintenance4Features member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMaintenance4Features member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMaintenance4Properties::Builder& builder, VkPhysicalDeviceMaintenance4Properties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMaxBufferSize((member.maxBufferSize));}();}();
}

    VkPhysicalDeviceMaintenance4Properties deserialize_struct(stream::VkPhysicalDeviceMaintenance4Properties::Reader reader){
        auto result=VkPhysicalDeviceMaintenance4Properties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.maxBufferSize)=reader.getMaxBufferSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMaintenance4Properties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMaintenance4Properties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMaintenance5FeaturesKHR::Builder& builder, VkPhysicalDeviceMaintenance5FeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMaintenance5((member.maintenance5));}();}();
}

    VkPhysicalDeviceMaintenance5FeaturesKHR deserialize_struct(stream::VkPhysicalDeviceMaintenance5FeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceMaintenance5FeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.maintenance5)=reader.getMaintenance5();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMaintenance5FeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMaintenance5FeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMaintenance5PropertiesKHR::Builder& builder, VkPhysicalDeviceMaintenance5PropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setEarlyFragmentMultisampleCoverageAfterSampleCounting((member.earlyFragmentMultisampleCoverageAfterSampleCounting));}();}();
[&](){[&](){return builder.setEarlyFragmentSampleMaskTestBeforeSampleCounting((member.earlyFragmentSampleMaskTestBeforeSampleCounting));}();}();
[&](){[&](){return builder.setDepthStencilSwizzleOneSupport((member.depthStencilSwizzleOneSupport));}();}();
[&](){[&](){return builder.setPolygonModePointSize((member.polygonModePointSize));}();}();
[&](){[&](){return builder.setNonStrictSinglePixelWideLinesUseParallelogram((member.nonStrictSinglePixelWideLinesUseParallelogram));}();}();
[&](){[&](){return builder.setNonStrictWideLinesUseParallelogram((member.nonStrictWideLinesUseParallelogram));}();}();
}

    VkPhysicalDeviceMaintenance5PropertiesKHR deserialize_struct(stream::VkPhysicalDeviceMaintenance5PropertiesKHR::Reader reader){
        auto result=VkPhysicalDeviceMaintenance5PropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.earlyFragmentMultisampleCoverageAfterSampleCounting)=reader.getEarlyFragmentMultisampleCoverageAfterSampleCounting();}();}();
[&](){[&](){(result.earlyFragmentSampleMaskTestBeforeSampleCounting)=reader.getEarlyFragmentSampleMaskTestBeforeSampleCounting();}();}();
[&](){[&](){(result.depthStencilSwizzleOneSupport)=reader.getDepthStencilSwizzleOneSupport();}();}();
[&](){[&](){(result.polygonModePointSize)=reader.getPolygonModePointSize();}();}();
[&](){[&](){(result.nonStrictSinglePixelWideLinesUseParallelogram)=reader.getNonStrictSinglePixelWideLinesUseParallelogram();}();}();
[&](){[&](){(result.nonStrictWideLinesUseParallelogram)=reader.getNonStrictWideLinesUseParallelogram();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMaintenance5PropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMaintenance5PropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderingAreaInfoKHR::Builder& builder, VkRenderingAreaInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setViewMask((member.viewMask));}();
[&](){return builder.setColorAttachmentCount((member.colorAttachmentCount));}();
[&](){
            if ((member.pColorAttachmentFormats)==NULL){
                builder.initPColorAttachmentFormats(0);
            return; }
        auto proto_arr=builder.initPColorAttachmentFormats(member.colorAttachmentCount);
        for(int wEZNsRI=0; wEZNsRI < member.colorAttachmentCount; wEZNsRI++){
            [&](){[&](){[&](){return proto_arr.set(wEZNsRI,((member.pColorAttachmentFormats)[wEZNsRI]));}();}();}();
        }
        }();
[&](){[&](){[&](){return builder.setDepthAttachmentFormat((member.depthAttachmentFormat));}();}();}();
[&](){[&](){[&](){return builder.setStencilAttachmentFormat((member.stencilAttachmentFormat));}();}();}();
}

    VkRenderingAreaInfoKHR deserialize_struct(stream::VkRenderingAreaInfoKHR::Reader reader){
        auto result=VkRenderingAreaInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.viewMask)=reader.getViewMask();}();
[&](){(result.colorAttachmentCount)=reader.getColorAttachmentCount();}();
[&](){ VkFormat* temp_PrgeUSF[&](){
            if (!reader.getPColorAttachmentFormats().size()==0){
                (result.pColorAttachmentFormats)=NULL;
            return; }{native_concat()}=(VkFormat*)malloc(result.colorAttachmentCount*sizeof(VkFormat));
        auto proto_arr=reader.getPColorAttachmentFormats(result.colorAttachmentCount);
        for(int XcfMUtc=0; XcfMUtc < result.colorAttachmentCount; XcfMUtc++){
            [&](){[&](){[&](){((result.pColorAttachmentFormats)[XcfMUtc])=proto_arr[XcfMUtc];}();}();}();
        }
        }();(result.pColorAttachmentFormats)=temp_PrgeUSF;}();
[&](){[&](){[&](){(result.depthAttachmentFormat)=reader.getDepthAttachmentFormat();}();}();}();
[&](){[&](){[&](){(result.stencilAttachmentFormat)=reader.getStencilAttachmentFormat();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderingAreaInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderingAreaInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetLayoutSupport::Builder& builder, VkDescriptorSetLayoutSupport member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSupported((member.supported));}();}();
}

    VkDescriptorSetLayoutSupport deserialize_struct(stream::VkDescriptorSetLayoutSupport::Reader reader){
        auto result=VkDescriptorSetLayoutSupport();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.supported)=reader.getSupported();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetLayoutSupport member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetLayoutSupport member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderDrawParametersFeatures::Builder& builder, VkPhysicalDeviceShaderDrawParametersFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderDrawParameters((member.shaderDrawParameters));}();}();
}

    VkPhysicalDeviceShaderDrawParametersFeatures deserialize_struct(stream::VkPhysicalDeviceShaderDrawParametersFeatures::Reader reader){
        auto result=VkPhysicalDeviceShaderDrawParametersFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderDrawParameters)=reader.getShaderDrawParameters();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderDrawParametersFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderDrawParametersFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderFloat16Int8Features::Builder& builder, VkPhysicalDeviceShaderFloat16Int8Features member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderFloat16((member.shaderFloat16));}();}();
[&](){[&](){return builder.setShaderInt8((member.shaderInt8));}();}();
}

    VkPhysicalDeviceShaderFloat16Int8Features deserialize_struct(stream::VkPhysicalDeviceShaderFloat16Int8Features::Reader reader){
        auto result=VkPhysicalDeviceShaderFloat16Int8Features();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderFloat16)=reader.getShaderFloat16();}();}();
[&](){[&](){(result.shaderInt8)=reader.getShaderInt8();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderFloat16Int8Features member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderFloat16Int8Features member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFloatControlsProperties::Builder& builder, VkPhysicalDeviceFloatControlsProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDenormBehaviorIndependence((member.denormBehaviorIndependence));}();}();}();
[&](){[&](){[&](){return builder.setRoundingModeIndependence((member.roundingModeIndependence));}();}();}();
[&](){[&](){return builder.setShaderSignedZeroInfNanPreserveFloat16((member.shaderSignedZeroInfNanPreserveFloat16));}();}();
[&](){[&](){return builder.setShaderSignedZeroInfNanPreserveFloat32((member.shaderSignedZeroInfNanPreserveFloat32));}();}();
[&](){[&](){return builder.setShaderSignedZeroInfNanPreserveFloat64((member.shaderSignedZeroInfNanPreserveFloat64));}();}();
[&](){[&](){return builder.setShaderDenormPreserveFloat16((member.shaderDenormPreserveFloat16));}();}();
[&](){[&](){return builder.setShaderDenormPreserveFloat32((member.shaderDenormPreserveFloat32));}();}();
[&](){[&](){return builder.setShaderDenormPreserveFloat64((member.shaderDenormPreserveFloat64));}();}();
[&](){[&](){return builder.setShaderDenormFlushToZeroFloat16((member.shaderDenormFlushToZeroFloat16));}();}();
[&](){[&](){return builder.setShaderDenormFlushToZeroFloat32((member.shaderDenormFlushToZeroFloat32));}();}();
[&](){[&](){return builder.setShaderDenormFlushToZeroFloat64((member.shaderDenormFlushToZeroFloat64));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTEFloat16((member.shaderRoundingModeRTEFloat16));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTEFloat32((member.shaderRoundingModeRTEFloat32));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTEFloat64((member.shaderRoundingModeRTEFloat64));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTZFloat16((member.shaderRoundingModeRTZFloat16));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTZFloat32((member.shaderRoundingModeRTZFloat32));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTZFloat64((member.shaderRoundingModeRTZFloat64));}();}();
}

    VkPhysicalDeviceFloatControlsProperties deserialize_struct(stream::VkPhysicalDeviceFloatControlsProperties::Reader reader){
        auto result=VkPhysicalDeviceFloatControlsProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.denormBehaviorIndependence)=reader.getDenormBehaviorIndependence();}();}();}();
[&](){[&](){[&](){(result.roundingModeIndependence)=reader.getRoundingModeIndependence();}();}();}();
[&](){[&](){(result.shaderSignedZeroInfNanPreserveFloat16)=reader.getShaderSignedZeroInfNanPreserveFloat16();}();}();
[&](){[&](){(result.shaderSignedZeroInfNanPreserveFloat32)=reader.getShaderSignedZeroInfNanPreserveFloat32();}();}();
[&](){[&](){(result.shaderSignedZeroInfNanPreserveFloat64)=reader.getShaderSignedZeroInfNanPreserveFloat64();}();}();
[&](){[&](){(result.shaderDenormPreserveFloat16)=reader.getShaderDenormPreserveFloat16();}();}();
[&](){[&](){(result.shaderDenormPreserveFloat32)=reader.getShaderDenormPreserveFloat32();}();}();
[&](){[&](){(result.shaderDenormPreserveFloat64)=reader.getShaderDenormPreserveFloat64();}();}();
[&](){[&](){(result.shaderDenormFlushToZeroFloat16)=reader.getShaderDenormFlushToZeroFloat16();}();}();
[&](){[&](){(result.shaderDenormFlushToZeroFloat32)=reader.getShaderDenormFlushToZeroFloat32();}();}();
[&](){[&](){(result.shaderDenormFlushToZeroFloat64)=reader.getShaderDenormFlushToZeroFloat64();}();}();
[&](){[&](){(result.shaderRoundingModeRTEFloat16)=reader.getShaderRoundingModeRTEFloat16();}();}();
[&](){[&](){(result.shaderRoundingModeRTEFloat32)=reader.getShaderRoundingModeRTEFloat32();}();}();
[&](){[&](){(result.shaderRoundingModeRTEFloat64)=reader.getShaderRoundingModeRTEFloat64();}();}();
[&](){[&](){(result.shaderRoundingModeRTZFloat16)=reader.getShaderRoundingModeRTZFloat16();}();}();
[&](){[&](){(result.shaderRoundingModeRTZFloat32)=reader.getShaderRoundingModeRTZFloat32();}();}();
[&](){[&](){(result.shaderRoundingModeRTZFloat64)=reader.getShaderRoundingModeRTZFloat64();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFloatControlsProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFloatControlsProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceHostQueryResetFeatures::Builder& builder, VkPhysicalDeviceHostQueryResetFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setHostQueryReset((member.hostQueryReset));}();}();
}

    VkPhysicalDeviceHostQueryResetFeatures deserialize_struct(stream::VkPhysicalDeviceHostQueryResetFeatures::Reader reader){
        auto result=VkPhysicalDeviceHostQueryResetFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.hostQueryReset)=reader.getHostQueryReset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceHostQueryResetFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceHostQueryResetFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkShaderResourceUsageAMD::Builder& builder, VkShaderResourceUsageAMD member){
        
    
[&](){return builder.setNumUsedVgprs((member.numUsedVgprs));}();
[&](){return builder.setNumUsedSgprs((member.numUsedSgprs));}();
[&](){return builder.setLdsSizePerLocalWorkGroup((member.ldsSizePerLocalWorkGroup));}();
[&](){return builder.setLdsUsageSizeInBytes((member.ldsUsageSizeInBytes));}();
[&](){return builder.setScratchMemUsageInBytes((member.scratchMemUsageInBytes));}();
}

    VkShaderResourceUsageAMD deserialize_struct(stream::VkShaderResourceUsageAMD::Reader reader){
        auto result=VkShaderResourceUsageAMD();
    
[&](){(result.numUsedVgprs)=reader.getNumUsedVgprs();}();
[&](){(result.numUsedSgprs)=reader.getNumUsedSgprs();}();
[&](){(result.ldsSizePerLocalWorkGroup)=reader.getLdsSizePerLocalWorkGroup();}();
[&](){(result.ldsUsageSizeInBytes)=reader.getLdsUsageSizeInBytes();}();
[&](){(result.scratchMemUsageInBytes)=reader.getScratchMemUsageInBytes();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkShaderResourceUsageAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkShaderResourceUsageAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkShaderStatisticsInfoAMD::Builder& builder, VkShaderStatisticsInfoAMD member){
        
    
[&](){[&](){[&](){return builder.setShaderStageMask((member.shaderStageMask));}();}();}();
[&](){
            auto temp=builder.initResourceUsage(resourceUsage);
            return serialize_struct(temp, (member.resourceUsage));
            }();
[&](){return builder.setNumPhysicalVgprs((member.numPhysicalVgprs));}();
[&](){return builder.setNumPhysicalSgprs((member.numPhysicalSgprs));}();
[&](){return builder.setNumAvailableVgprs((member.numAvailableVgprs));}();
[&](){return builder.setNumAvailableSgprs((member.numAvailableSgprs));}();
[&](){
        auto proto_arr=builder.initComputeWorkGroupSize(3);
        for(int gYtCXER=0; gYtCXER < 3; gYtCXER++){
            [&](){return proto_arr.set(gYtCXER,((member.computeWorkGroupSize)[gYtCXER]));}();
        }
        }();
}

    VkShaderStatisticsInfoAMD deserialize_struct(stream::VkShaderStatisticsInfoAMD::Reader reader){
        auto result=VkShaderStatisticsInfoAMD();
    
[&](){[&](){[&](){(result.shaderStageMask)=reader.getShaderStageMask();}();}();}();
[&](){
            auto temp=reader.getResourceUsage();
            (result.resourceUsage)=deserialize_struct(temp);
            }();
[&](){(result.numPhysicalVgprs)=reader.getNumPhysicalVgprs();}();
[&](){(result.numPhysicalSgprs)=reader.getNumPhysicalSgprs();}();
[&](){(result.numAvailableVgprs)=reader.getNumAvailableVgprs();}();
[&](){(result.numAvailableSgprs)=reader.getNumAvailableSgprs();}();
[&](){
        auto proto_arr=reader.getComputeWorkGroupSize(3);
        for(int gYtCXER=0; gYtCXER < 3; gYtCXER++){
            [&](){((result.computeWorkGroupSize)[gYtCXER])=proto_arr[gYtCXER];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkShaderStatisticsInfoAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkShaderStatisticsInfoAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceQueueGlobalPriorityCreateInfoKHR::Builder& builder, VkDeviceQueueGlobalPriorityCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setGlobalPriority((member.globalPriority));}();}();}();
}

    VkDeviceQueueGlobalPriorityCreateInfoKHR deserialize_struct(stream::VkDeviceQueueGlobalPriorityCreateInfoKHR::Reader reader){
        auto result=VkDeviceQueueGlobalPriorityCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.globalPriority)=reader.getGlobalPriority();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceQueueGlobalPriorityCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceQueueGlobalPriorityCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR::Builder& builder, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setGlobalPriorityQuery((member.globalPriorityQuery));}();}();
}

    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.globalPriorityQuery)=reader.getGlobalPriorityQuery();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueueFamilyGlobalPriorityPropertiesKHR::Builder& builder, VkQueueFamilyGlobalPriorityPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPriorityCount((member.priorityCount));}();
[&](){
        auto proto_arr=builder.initPriorities(VK_MAX_GLOBAL_PRIORITY_SIZE_KHR);
        for(int fMHmDjA=0; fMHmDjA < VK_MAX_GLOBAL_PRIORITY_SIZE_KHR; fMHmDjA++){
            [&](){[&](){[&](){return proto_arr.set(fMHmDjA,((member.priorities)[fMHmDjA]));}();}();}();
        }
        }();
}

    VkQueueFamilyGlobalPriorityPropertiesKHR deserialize_struct(stream::VkQueueFamilyGlobalPriorityPropertiesKHR::Reader reader){
        auto result=VkQueueFamilyGlobalPriorityPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.priorityCount)=reader.getPriorityCount();}();
[&](){
        auto proto_arr=reader.getPriorities(VK_MAX_GLOBAL_PRIORITY_SIZE_KHR);
        for(int fMHmDjA=0; fMHmDjA < VK_MAX_GLOBAL_PRIORITY_SIZE_KHR; fMHmDjA++){
            [&](){[&](){[&](){((result.priorities)[fMHmDjA])=proto_arr[fMHmDjA];}();}();}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueueFamilyGlobalPriorityPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueueFamilyGlobalPriorityPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugUtilsObjectNameInfoEXT::Builder& builder, VkDebugUtilsObjectNameInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setObjectType((member.objectType));}();}();}();
[&](){return builder.setObjectHandle((member.objectHandle));}();
[&](){
            if ((member.pObjectName)==NULL){
                builder.initPObjectName(0);
            return; }
        auto proto_arr=builder.initPObjectName(strlen((member.pObjectName))+1);
        for(int IrvYMgK=0; IrvYMgK < strlen((member.pObjectName))+1; IrvYMgK++){
            [&](){return proto_arr.set(IrvYMgK,((member.pObjectName)[IrvYMgK]));}();
        }
        }();
}

    VkDebugUtilsObjectNameInfoEXT deserialize_struct(stream::VkDebugUtilsObjectNameInfoEXT::Reader reader){
        auto result=VkDebugUtilsObjectNameInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.objectType)=reader.getObjectType();}();}();}();
[&](){(result.objectHandle)=reader.getObjectHandle();}();
[&](){ char* temp_AUIQNis[&](){
            if (!reader.getPObjectName().size()==0){
                (result.pObjectName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPObjectName().size();*sizeof(char));
        auto proto_arr=reader.getPObjectName(reader.getPObjectName().size(););
        for(int vNFhQsi=0; vNFhQsi < reader.getPObjectName().size();; vNFhQsi++){
            [&](){((result.pObjectName)[vNFhQsi])=proto_arr[vNFhQsi];}();
        }
        }();(result.pObjectName)=temp_AUIQNis;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugUtilsObjectNameInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugUtilsObjectNameInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugUtilsObjectTagInfoEXT::Builder& builder, VkDebugUtilsObjectTagInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setObjectType((member.objectType));}();}();}();
[&](){return builder.setObjectHandle((member.objectHandle));}();
[&](){return builder.setTagName((member.tagName));}();
[&](){return builder.setTagSize((member.tagSize));}();
[&](){
            if ((member.pTag)==NULL){
                builder.initPTag(0);
            return; }[&](){
            if (((char*)(member.pTag).pTag)==NULL){
                builder.initPTag(0);
            return; }
        auto proto_arr=builder.initPTag(member.tagSize);
        for(int RyqFIjd=0; RyqFIjd < member.tagSize; RyqFIjd++){
            [&](){return proto_arr.set(RyqFIjd,(((char*)(member.pTag).pTag)[RyqFIjd]));}();
        }
        }();}();
}

    VkDebugUtilsObjectTagInfoEXT deserialize_struct(stream::VkDebugUtilsObjectTagInfoEXT::Reader reader){
        auto result=VkDebugUtilsObjectTagInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.objectType)=reader.getObjectType();}();}();}();
[&](){(result.objectHandle)=reader.getObjectHandle();}();
[&](){(result.tagName)=reader.getTagName();}();
[&](){(result.tagSize)=reader.getTagSize();}();
[&](){ void* temp_hwJmLWe[&](){
            if (!reader.getPTag().size()==0){
                (result.pTag)=NULL;
            return; }char* temp_BYVrBDU;[&](){
            if (!reader.getPTag().size()==0){
                (temp_BYVrBDU.pTag)=NULL;
            return; }{native_concat()}=(char*)malloc(result.tagSize*sizeof(char));
        auto proto_arr=reader.getPTag(result.tagSize);
        for(int lxDYfsn=0; lxDYfsn < result.tagSize; lxDYfsn++){
            [&](){((temp_BYVrBDU.pTag)[lxDYfsn])=proto_arr[lxDYfsn];}();
        }
        }();(result.pTag)=temp_BYVrBDU;}();(result.pTag)=temp_hwJmLWe;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugUtilsObjectTagInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugUtilsObjectTagInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugUtilsLabelEXT::Builder& builder, VkDebugUtilsLabelEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pLabelName)==NULL){
                builder.initPLabelName(0);
            return; }
        auto proto_arr=builder.initPLabelName(strlen((member.pLabelName))+1);
        for(int MIohVNO=0; MIohVNO < strlen((member.pLabelName))+1; MIohVNO++){
            [&](){return proto_arr.set(MIohVNO,((member.pLabelName)[MIohVNO]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initColor(4);
        for(int oKnkjtQ=0; oKnkjtQ < 4; oKnkjtQ++){
            [&](){return proto_arr.set(oKnkjtQ,((member.color)[oKnkjtQ]));}();
        }
        }();
}

    VkDebugUtilsLabelEXT deserialize_struct(stream::VkDebugUtilsLabelEXT::Reader reader){
        auto result=VkDebugUtilsLabelEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ char* temp_rAzUFXL[&](){
            if (!reader.getPLabelName().size()==0){
                (result.pLabelName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPLabelName().size();*sizeof(char));
        auto proto_arr=reader.getPLabelName(reader.getPLabelName().size(););
        for(int HnGeXhl=0; HnGeXhl < reader.getPLabelName().size();; HnGeXhl++){
            [&](){((result.pLabelName)[HnGeXhl])=proto_arr[HnGeXhl];}();
        }
        }();(result.pLabelName)=temp_rAzUFXL;}();
[&](){
        auto proto_arr=reader.getColor(4);
        for(int oKnkjtQ=0; oKnkjtQ < 4; oKnkjtQ++){
            [&](){((result.color)[oKnkjtQ])=proto_arr[oKnkjtQ];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugUtilsLabelEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugUtilsLabelEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugUtilsMessengerCreateInfoEXT::Builder& builder, VkDebugUtilsMessengerCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setMessageSeverity((member.messageSeverity));}();}();}();
[&](){[&](){[&](){return builder.setMessageType((member.messageType));}();}();}();
[&](){
            auto temp=builder.initPfnUserCallback(pfnUserCallback);
            return serialize_funcpointer(temp, (member.pfnUserCallback));
            }();
[&](){
            auto temp=builder.initPUserData(pUserData);
            return serialize_struct(temp, (member.pUserData));
            }();
}

    VkDebugUtilsMessengerCreateInfoEXT deserialize_struct(stream::VkDebugUtilsMessengerCreateInfoEXT::Reader reader){
        auto result=VkDebugUtilsMessengerCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.messageSeverity)=reader.getMessageSeverity();}();}();}();
[&](){[&](){[&](){(result.messageType)=reader.getMessageType();}();}();}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnUserCallback();
            (result.pfnUserCallback)=deserialize_funcpointer(temp);
            #endif
}();
[&](){
            auto temp=reader.getPUserData();
            (result.pUserData)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugUtilsMessengerCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
builder.setPFN_vkDebugUtilsMessengerCallbackEXT((uintptr_t)(member.pfnUserCallback));
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugUtilsMessengerCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();
result.pfnUserCallback=reader.getPFN_vkDebugUtilsMessengerCallbackEXT();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDebugUtilsMessengerCallbackDataEXT::Builder& builder, VkDebugUtilsMessengerCallbackDataEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            if ((member.pMessageIdName)==NULL){
                builder.initPMessageIdName(0);
            return; }
        auto proto_arr=builder.initPMessageIdName(strlen((member.pMessageIdName))+1);
        for(int BmwQwRz=0; BmwQwRz < strlen((member.pMessageIdName))+1; BmwQwRz++){
            [&](){return proto_arr.set(BmwQwRz,((member.pMessageIdName)[BmwQwRz]));}();
        }
        }();
[&](){return builder.setMessageIdNumber((member.messageIdNumber));}();
[&](){
            if ((member.pMessage)==NULL){
                builder.initPMessage(0);
            return; }
        auto proto_arr=builder.initPMessage(strlen((member.pMessage))+1);
        for(int SjkcUWO=0; SjkcUWO < strlen((member.pMessage))+1; SjkcUWO++){
            [&](){return proto_arr.set(SjkcUWO,((member.pMessage)[SjkcUWO]));}();
        }
        }();
[&](){return builder.setQueueLabelCount((member.queueLabelCount));}();
[&](){
            if ((member.pQueueLabels)==NULL){
                builder.initPQueueLabels(0);
            return; }
        auto proto_arr=builder.initPQueueLabels(member.queueLabelCount);
        for(int Cickicm=0; Cickicm < member.queueLabelCount; Cickicm++){
            [&](){
            auto temp=proto_arr[Cickicm];
            return serialize_struct(temp, ((member.pQueueLabels)[Cickicm]));
            }();
        }
        }();
[&](){return builder.setCmdBufLabelCount((member.cmdBufLabelCount));}();
[&](){
            if ((member.pCmdBufLabels)==NULL){
                builder.initPCmdBufLabels(0);
            return; }
        auto proto_arr=builder.initPCmdBufLabels(member.cmdBufLabelCount);
        for(int oRsJZdR=0; oRsJZdR < member.cmdBufLabelCount; oRsJZdR++){
            [&](){
            auto temp=proto_arr[oRsJZdR];
            return serialize_struct(temp, ((member.pCmdBufLabels)[oRsJZdR]));
            }();
        }
        }();
[&](){return builder.setObjectCount((member.objectCount));}();
[&](){
            if ((member.pObjects)==NULL){
                builder.initPObjects(0);
            return; }
        auto proto_arr=builder.initPObjects(member.objectCount);
        for(int uqPjyhr=0; uqPjyhr < member.objectCount; uqPjyhr++){
            [&](){
            auto temp=proto_arr[uqPjyhr];
            return serialize_struct(temp, ((member.pObjects)[uqPjyhr]));
            }();
        }
        }();
}

    VkDebugUtilsMessengerCallbackDataEXT deserialize_struct(stream::VkDebugUtilsMessengerCallbackDataEXT::Reader reader){
        auto result=VkDebugUtilsMessengerCallbackDataEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){ char* temp_kwCXxpj[&](){
            if (!reader.getPMessageIdName().size()==0){
                (result.pMessageIdName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPMessageIdName().size();*sizeof(char));
        auto proto_arr=reader.getPMessageIdName(reader.getPMessageIdName().size(););
        for(int ModiWWF=0; ModiWWF < reader.getPMessageIdName().size();; ModiWWF++){
            [&](){((result.pMessageIdName)[ModiWWF])=proto_arr[ModiWWF];}();
        }
        }();(result.pMessageIdName)=temp_kwCXxpj;}();
[&](){(result.messageIdNumber)=reader.getMessageIdNumber();}();
[&](){ char* temp_vAWXWir[&](){
            if (!reader.getPMessage().size()==0){
                (result.pMessage)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPMessage().size();*sizeof(char));
        auto proto_arr=reader.getPMessage(reader.getPMessage().size(););
        for(int GRiWTDL=0; GRiWTDL < reader.getPMessage().size();; GRiWTDL++){
            [&](){((result.pMessage)[GRiWTDL])=proto_arr[GRiWTDL];}();
        }
        }();(result.pMessage)=temp_vAWXWir;}();
[&](){(result.queueLabelCount)=reader.getQueueLabelCount();}();
[&](){ VkDebugUtilsLabelEXT* temp_ULVZxDs[&](){
            if (!reader.getPQueueLabels().size()==0){
                (result.pQueueLabels)=NULL;
            return; }{native_concat()}=(VkDebugUtilsLabelEXT*)malloc(result.queueLabelCount*sizeof(VkDebugUtilsLabelEXT));
        auto proto_arr=reader.getPQueueLabels(result.queueLabelCount);
        for(int LkHCjKg=0; LkHCjKg < result.queueLabelCount; LkHCjKg++){
            [&](){
            auto temp=proto_arr[LkHCjKg];
            ((result.pQueueLabels)[LkHCjKg])=deserialize_struct(temp);
            }();
        }
        }();(result.pQueueLabels)=temp_ULVZxDs;}();
[&](){(result.cmdBufLabelCount)=reader.getCmdBufLabelCount();}();
[&](){ VkDebugUtilsLabelEXT* temp_oIvrzce[&](){
            if (!reader.getPCmdBufLabels().size()==0){
                (result.pCmdBufLabels)=NULL;
            return; }{native_concat()}=(VkDebugUtilsLabelEXT*)malloc(result.cmdBufLabelCount*sizeof(VkDebugUtilsLabelEXT));
        auto proto_arr=reader.getPCmdBufLabels(result.cmdBufLabelCount);
        for(int aRHhrDc=0; aRHhrDc < result.cmdBufLabelCount; aRHhrDc++){
            [&](){
            auto temp=proto_arr[aRHhrDc];
            ((result.pCmdBufLabels)[aRHhrDc])=deserialize_struct(temp);
            }();
        }
        }();(result.pCmdBufLabels)=temp_oIvrzce;}();
[&](){(result.objectCount)=reader.getObjectCount();}();
[&](){ VkDebugUtilsObjectNameInfoEXT* temp_TvcwRHi[&](){
            if (!reader.getPObjects().size()==0){
                (result.pObjects)=NULL;
            return; }{native_concat()}=(VkDebugUtilsObjectNameInfoEXT*)malloc(result.objectCount*sizeof(VkDebugUtilsObjectNameInfoEXT));
        auto proto_arr=reader.getPObjects(result.objectCount);
        for(int SOnpTum=0; SOnpTum < result.objectCount; SOnpTum++){
            [&](){
            auto temp=proto_arr[SOnpTum];
            ((result.pObjects)[SOnpTum])=deserialize_struct(temp);
            }();
        }
        }();(result.pObjects)=temp_TvcwRHi;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDebugUtilsMessengerCallbackDataEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDebugUtilsMessengerCallbackDataEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDeviceMemoryReportFeaturesEXT::Builder& builder, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceMemoryReport((member.deviceMemoryReport));}();}();
}

    VkPhysicalDeviceDeviceMemoryReportFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceDeviceMemoryReportFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceDeviceMemoryReportFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.deviceMemoryReport)=reader.getDeviceMemoryReport();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceDeviceMemoryReportCreateInfoEXT::Builder& builder, VkDeviceDeviceMemoryReportCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            auto temp=builder.initPfnUserCallback(pfnUserCallback);
            return serialize_funcpointer(temp, (member.pfnUserCallback));
            }();
[&](){
            auto temp=builder.initPUserData(pUserData);
            return serialize_struct(temp, (member.pUserData));
            }();
}

    VkDeviceDeviceMemoryReportCreateInfoEXT deserialize_struct(stream::VkDeviceDeviceMemoryReportCreateInfoEXT::Reader reader){
        auto result=VkDeviceDeviceMemoryReportCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnUserCallback();
            (result.pfnUserCallback)=deserialize_funcpointer(temp);
            #endif
}();
[&](){
            auto temp=reader.getPUserData();
            (result.pUserData)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceDeviceMemoryReportCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
builder.setPFN_vkDeviceMemoryReportCallbackEXT((uintptr_t)(member.pfnUserCallback));
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceDeviceMemoryReportCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();
result.pfnUserCallback=reader.getPFN_vkDeviceMemoryReportCallbackEXT();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceMemoryReportCallbackDataEXT::Builder& builder, VkDeviceMemoryReportCallbackDataEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){return builder.setMemoryObjectId((member.memoryObjectId));}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){[&](){return builder.setObjectType((member.objectType));}();}();}();
[&](){return builder.setObjectHandle((member.objectHandle));}();
[&](){return builder.setHeapIndex((member.heapIndex));}();
}

    VkDeviceMemoryReportCallbackDataEXT deserialize_struct(stream::VkDeviceMemoryReportCallbackDataEXT::Reader reader){
        auto result=VkDeviceMemoryReportCallbackDataEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){(result.memoryObjectId)=reader.getMemoryObjectId();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){[&](){(result.objectType)=reader.getObjectType();}();}();}();
[&](){(result.objectHandle)=reader.getObjectHandle();}();
[&](){(result.heapIndex)=reader.getHeapIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceMemoryReportCallbackDataEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceMemoryReportCallbackDataEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImportMemoryHostPointerInfoEXT::Builder& builder, VkImportMemoryHostPointerInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
[&](){
            if ((member.pHostPointer)==NULL){
                builder.initPHostPointer(0);
            return; }[&](){
            if (((char*)(member.pHostPointer).pHostPointer)==NULL){
                builder.initPHostPointer(0);
            return; }
        auto proto_arr=builder.initPHostPointer(strlen(((char*)(member.pHostPointer).pHostPointer))+1);
        for(int XfuwLTM=0; XfuwLTM < strlen(((char*)(member.pHostPointer).pHostPointer))+1; XfuwLTM++){
            [&](){return proto_arr.set(XfuwLTM,(((char*)(member.pHostPointer).pHostPointer)[XfuwLTM]));}();
        }
        }();}();
}

    VkImportMemoryHostPointerInfoEXT deserialize_struct(stream::VkImportMemoryHostPointerInfoEXT::Reader reader){
        auto result=VkImportMemoryHostPointerInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
[&](){
            if (!reader.getPHostPointer().size()==0){
                (result.pHostPointer)=NULL;
            return; }char* temp_sulXjuh;[&](){
            if (!reader.getPHostPointer().size()==0){
                (temp_sulXjuh.pHostPointer)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPHostPointer().size();*sizeof(char));
        auto proto_arr=reader.getPHostPointer(reader.getPHostPointer().size(););
        for(int XfuwLTM=0; XfuwLTM < reader.getPHostPointer().size();; XfuwLTM++){
            [&](){((temp_sulXjuh.pHostPointer)[XfuwLTM])=proto_arr[XfuwLTM];}();
        }
        }();(result.pHostPointer)=temp_sulXjuh;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImportMemoryHostPointerInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImportMemoryHostPointerInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryHostPointerPropertiesEXT::Builder& builder, VkMemoryHostPointerPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemoryTypeBits((member.memoryTypeBits));}();
}

    VkMemoryHostPointerPropertiesEXT deserialize_struct(stream::VkMemoryHostPointerPropertiesEXT::Reader reader){
        auto result=VkMemoryHostPointerPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.memoryTypeBits)=reader.getMemoryTypeBits();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryHostPointerPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryHostPointerPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExternalMemoryHostPropertiesEXT::Builder& builder, VkPhysicalDeviceExternalMemoryHostPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMinImportedHostPointerAlignment((member.minImportedHostPointerAlignment));}();}();
}

    VkPhysicalDeviceExternalMemoryHostPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceExternalMemoryHostPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceExternalMemoryHostPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.minImportedHostPointerAlignment)=reader.getMinImportedHostPointerAlignment();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExternalMemoryHostPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExternalMemoryHostPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceConservativeRasterizationPropertiesEXT::Builder& builder, VkPhysicalDeviceConservativeRasterizationPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPrimitiveOverestimationSize((member.primitiveOverestimationSize));}();
[&](){return builder.setMaxExtraPrimitiveOverestimationSize((member.maxExtraPrimitiveOverestimationSize));}();
[&](){return builder.setExtraPrimitiveOverestimationSizeGranularity((member.extraPrimitiveOverestimationSizeGranularity));}();
[&](){[&](){return builder.setPrimitiveUnderestimation((member.primitiveUnderestimation));}();}();
[&](){[&](){return builder.setConservativePointAndLineRasterization((member.conservativePointAndLineRasterization));}();}();
[&](){[&](){return builder.setDegenerateTrianglesRasterized((member.degenerateTrianglesRasterized));}();}();
[&](){[&](){return builder.setDegenerateLinesRasterized((member.degenerateLinesRasterized));}();}();
[&](){[&](){return builder.setFullyCoveredFragmentShaderInputVariable((member.fullyCoveredFragmentShaderInputVariable));}();}();
[&](){[&](){return builder.setConservativeRasterizationPostDepthCoverage((member.conservativeRasterizationPostDepthCoverage));}();}();
}

    VkPhysicalDeviceConservativeRasterizationPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceConservativeRasterizationPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceConservativeRasterizationPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.primitiveOverestimationSize)=reader.getPrimitiveOverestimationSize();}();
[&](){(result.maxExtraPrimitiveOverestimationSize)=reader.getMaxExtraPrimitiveOverestimationSize();}();
[&](){(result.extraPrimitiveOverestimationSizeGranularity)=reader.getExtraPrimitiveOverestimationSizeGranularity();}();
[&](){[&](){(result.primitiveUnderestimation)=reader.getPrimitiveUnderestimation();}();}();
[&](){[&](){(result.conservativePointAndLineRasterization)=reader.getConservativePointAndLineRasterization();}();}();
[&](){[&](){(result.degenerateTrianglesRasterized)=reader.getDegenerateTrianglesRasterized();}();}();
[&](){[&](){(result.degenerateLinesRasterized)=reader.getDegenerateLinesRasterized();}();}();
[&](){[&](){(result.fullyCoveredFragmentShaderInputVariable)=reader.getFullyCoveredFragmentShaderInputVariable();}();}();
[&](){[&](){(result.conservativeRasterizationPostDepthCoverage)=reader.getConservativeRasterizationPostDepthCoverage();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceConservativeRasterizationPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceConservativeRasterizationPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCalibratedTimestampInfoEXT::Builder& builder, VkCalibratedTimestampInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setTimeDomain((member.timeDomain));}();}();}();
}

    VkCalibratedTimestampInfoEXT deserialize_struct(stream::VkCalibratedTimestampInfoEXT::Reader reader){
        auto result=VkCalibratedTimestampInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.timeDomain)=reader.getTimeDomain();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCalibratedTimestampInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCalibratedTimestampInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderCorePropertiesAMD::Builder& builder, VkPhysicalDeviceShaderCorePropertiesAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setShaderEngineCount((member.shaderEngineCount));}();
[&](){return builder.setShaderArraysPerEngineCount((member.shaderArraysPerEngineCount));}();
[&](){return builder.setComputeUnitsPerShaderArray((member.computeUnitsPerShaderArray));}();
[&](){return builder.setSimdPerComputeUnit((member.simdPerComputeUnit));}();
[&](){return builder.setWavefrontsPerSimd((member.wavefrontsPerSimd));}();
[&](){return builder.setWavefrontSize((member.wavefrontSize));}();
[&](){return builder.setSgprsPerSimd((member.sgprsPerSimd));}();
[&](){return builder.setMinSgprAllocation((member.minSgprAllocation));}();
[&](){return builder.setMaxSgprAllocation((member.maxSgprAllocation));}();
[&](){return builder.setSgprAllocationGranularity((member.sgprAllocationGranularity));}();
[&](){return builder.setVgprsPerSimd((member.vgprsPerSimd));}();
[&](){return builder.setMinVgprAllocation((member.minVgprAllocation));}();
[&](){return builder.setMaxVgprAllocation((member.maxVgprAllocation));}();
[&](){return builder.setVgprAllocationGranularity((member.vgprAllocationGranularity));}();
}

    VkPhysicalDeviceShaderCorePropertiesAMD deserialize_struct(stream::VkPhysicalDeviceShaderCorePropertiesAMD::Reader reader){
        auto result=VkPhysicalDeviceShaderCorePropertiesAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.shaderEngineCount)=reader.getShaderEngineCount();}();
[&](){(result.shaderArraysPerEngineCount)=reader.getShaderArraysPerEngineCount();}();
[&](){(result.computeUnitsPerShaderArray)=reader.getComputeUnitsPerShaderArray();}();
[&](){(result.simdPerComputeUnit)=reader.getSimdPerComputeUnit();}();
[&](){(result.wavefrontsPerSimd)=reader.getWavefrontsPerSimd();}();
[&](){(result.wavefrontSize)=reader.getWavefrontSize();}();
[&](){(result.sgprsPerSimd)=reader.getSgprsPerSimd();}();
[&](){(result.minSgprAllocation)=reader.getMinSgprAllocation();}();
[&](){(result.maxSgprAllocation)=reader.getMaxSgprAllocation();}();
[&](){(result.sgprAllocationGranularity)=reader.getSgprAllocationGranularity();}();
[&](){(result.vgprsPerSimd)=reader.getVgprsPerSimd();}();
[&](){(result.minVgprAllocation)=reader.getMinVgprAllocation();}();
[&](){(result.maxVgprAllocation)=reader.getMaxVgprAllocation();}();
[&](){(result.vgprAllocationGranularity)=reader.getVgprAllocationGranularity();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderCorePropertiesAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderCorePropertiesAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderCoreProperties2AMD::Builder& builder, VkPhysicalDeviceShaderCoreProperties2AMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setShaderCoreFeatures((member.shaderCoreFeatures));}();}();}();
[&](){return builder.setActiveComputeUnitCount((member.activeComputeUnitCount));}();
}

    VkPhysicalDeviceShaderCoreProperties2AMD deserialize_struct(stream::VkPhysicalDeviceShaderCoreProperties2AMD::Reader reader){
        auto result=VkPhysicalDeviceShaderCoreProperties2AMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.shaderCoreFeatures)=reader.getShaderCoreFeatures();}();}();}();
[&](){(result.activeComputeUnitCount)=reader.getActiveComputeUnitCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderCoreProperties2AMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderCoreProperties2AMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRasterizationConservativeStateCreateInfoEXT::Builder& builder, VkPipelineRasterizationConservativeStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setConservativeRasterizationMode((member.conservativeRasterizationMode));}();}();}();
[&](){return builder.setExtraPrimitiveOverestimationSize((member.extraPrimitiveOverestimationSize));}();
}

    VkPipelineRasterizationConservativeStateCreateInfoEXT deserialize_struct(stream::VkPipelineRasterizationConservativeStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineRasterizationConservativeStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.conservativeRasterizationMode)=reader.getConservativeRasterizationMode();}();}();}();
[&](){(result.extraPrimitiveOverestimationSize)=reader.getExtraPrimitiveOverestimationSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRasterizationConservativeStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRasterizationConservativeStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDescriptorIndexingFeatures::Builder& builder, VkPhysicalDeviceDescriptorIndexingFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderInputAttachmentArrayDynamicIndexing((member.shaderInputAttachmentArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderUniformTexelBufferArrayDynamicIndexing((member.shaderUniformTexelBufferArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderStorageTexelBufferArrayDynamicIndexing((member.shaderStorageTexelBufferArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderUniformBufferArrayNonUniformIndexing((member.shaderUniformBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderSampledImageArrayNonUniformIndexing((member.shaderSampledImageArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderStorageBufferArrayNonUniformIndexing((member.shaderStorageBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderStorageImageArrayNonUniformIndexing((member.shaderStorageImageArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderInputAttachmentArrayNonUniformIndexing((member.shaderInputAttachmentArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderUniformTexelBufferArrayNonUniformIndexing((member.shaderUniformTexelBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderStorageTexelBufferArrayNonUniformIndexing((member.shaderStorageTexelBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setDescriptorBindingUniformBufferUpdateAfterBind((member.descriptorBindingUniformBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingSampledImageUpdateAfterBind((member.descriptorBindingSampledImageUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingStorageImageUpdateAfterBind((member.descriptorBindingStorageImageUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingStorageBufferUpdateAfterBind((member.descriptorBindingStorageBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingUniformTexelBufferUpdateAfterBind((member.descriptorBindingUniformTexelBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingStorageTexelBufferUpdateAfterBind((member.descriptorBindingStorageTexelBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingUpdateUnusedWhilePending((member.descriptorBindingUpdateUnusedWhilePending));}();}();
[&](){[&](){return builder.setDescriptorBindingPartiallyBound((member.descriptorBindingPartiallyBound));}();}();
[&](){[&](){return builder.setDescriptorBindingVariableDescriptorCount((member.descriptorBindingVariableDescriptorCount));}();}();
[&](){[&](){return builder.setRuntimeDescriptorArray((member.runtimeDescriptorArray));}();}();
}

    VkPhysicalDeviceDescriptorIndexingFeatures deserialize_struct(stream::VkPhysicalDeviceDescriptorIndexingFeatures::Reader reader){
        auto result=VkPhysicalDeviceDescriptorIndexingFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderInputAttachmentArrayDynamicIndexing)=reader.getShaderInputAttachmentArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderUniformTexelBufferArrayDynamicIndexing)=reader.getShaderUniformTexelBufferArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderStorageTexelBufferArrayDynamicIndexing)=reader.getShaderStorageTexelBufferArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderUniformBufferArrayNonUniformIndexing)=reader.getShaderUniformBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderSampledImageArrayNonUniformIndexing)=reader.getShaderSampledImageArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderStorageBufferArrayNonUniformIndexing)=reader.getShaderStorageBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderStorageImageArrayNonUniformIndexing)=reader.getShaderStorageImageArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderInputAttachmentArrayNonUniformIndexing)=reader.getShaderInputAttachmentArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderUniformTexelBufferArrayNonUniformIndexing)=reader.getShaderUniformTexelBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderStorageTexelBufferArrayNonUniformIndexing)=reader.getShaderStorageTexelBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.descriptorBindingUniformBufferUpdateAfterBind)=reader.getDescriptorBindingUniformBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingSampledImageUpdateAfterBind)=reader.getDescriptorBindingSampledImageUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingStorageImageUpdateAfterBind)=reader.getDescriptorBindingStorageImageUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingStorageBufferUpdateAfterBind)=reader.getDescriptorBindingStorageBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingUniformTexelBufferUpdateAfterBind)=reader.getDescriptorBindingUniformTexelBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingStorageTexelBufferUpdateAfterBind)=reader.getDescriptorBindingStorageTexelBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingUpdateUnusedWhilePending)=reader.getDescriptorBindingUpdateUnusedWhilePending();}();}();
[&](){[&](){(result.descriptorBindingPartiallyBound)=reader.getDescriptorBindingPartiallyBound();}();}();
[&](){[&](){(result.descriptorBindingVariableDescriptorCount)=reader.getDescriptorBindingVariableDescriptorCount();}();}();
[&](){[&](){(result.runtimeDescriptorArray)=reader.getRuntimeDescriptorArray();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDescriptorIndexingFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDescriptorIndexingFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDescriptorIndexingProperties::Builder& builder, VkPhysicalDeviceDescriptorIndexingProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxUpdateAfterBindDescriptorsInAllPools((member.maxUpdateAfterBindDescriptorsInAllPools));}();
[&](){[&](){return builder.setShaderUniformBufferArrayNonUniformIndexingNative((member.shaderUniformBufferArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderSampledImageArrayNonUniformIndexingNative((member.shaderSampledImageArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderStorageBufferArrayNonUniformIndexingNative((member.shaderStorageBufferArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderStorageImageArrayNonUniformIndexingNative((member.shaderStorageImageArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderInputAttachmentArrayNonUniformIndexingNative((member.shaderInputAttachmentArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setRobustBufferAccessUpdateAfterBind((member.robustBufferAccessUpdateAfterBind));}();}();
[&](){[&](){return builder.setQuadDivergentImplicitLod((member.quadDivergentImplicitLod));}();}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindSamplers((member.maxPerStageDescriptorUpdateAfterBindSamplers));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindUniformBuffers((member.maxPerStageDescriptorUpdateAfterBindUniformBuffers));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindStorageBuffers((member.maxPerStageDescriptorUpdateAfterBindStorageBuffers));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindSampledImages((member.maxPerStageDescriptorUpdateAfterBindSampledImages));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindStorageImages((member.maxPerStageDescriptorUpdateAfterBindStorageImages));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindInputAttachments((member.maxPerStageDescriptorUpdateAfterBindInputAttachments));}();
[&](){return builder.setMaxPerStageUpdateAfterBindResources((member.maxPerStageUpdateAfterBindResources));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindSamplers((member.maxDescriptorSetUpdateAfterBindSamplers));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindUniformBuffers((member.maxDescriptorSetUpdateAfterBindUniformBuffers));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic((member.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindStorageBuffers((member.maxDescriptorSetUpdateAfterBindStorageBuffers));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic((member.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindSampledImages((member.maxDescriptorSetUpdateAfterBindSampledImages));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindStorageImages((member.maxDescriptorSetUpdateAfterBindStorageImages));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindInputAttachments((member.maxDescriptorSetUpdateAfterBindInputAttachments));}();
}

    VkPhysicalDeviceDescriptorIndexingProperties deserialize_struct(stream::VkPhysicalDeviceDescriptorIndexingProperties::Reader reader){
        auto result=VkPhysicalDeviceDescriptorIndexingProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxUpdateAfterBindDescriptorsInAllPools)=reader.getMaxUpdateAfterBindDescriptorsInAllPools();}();
[&](){[&](){(result.shaderUniformBufferArrayNonUniformIndexingNative)=reader.getShaderUniformBufferArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderSampledImageArrayNonUniformIndexingNative)=reader.getShaderSampledImageArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderStorageBufferArrayNonUniformIndexingNative)=reader.getShaderStorageBufferArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderStorageImageArrayNonUniformIndexingNative)=reader.getShaderStorageImageArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderInputAttachmentArrayNonUniformIndexingNative)=reader.getShaderInputAttachmentArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.robustBufferAccessUpdateAfterBind)=reader.getRobustBufferAccessUpdateAfterBind();}();}();
[&](){[&](){(result.quadDivergentImplicitLod)=reader.getQuadDivergentImplicitLod();}();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindSamplers)=reader.getMaxPerStageDescriptorUpdateAfterBindSamplers();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindUniformBuffers)=reader.getMaxPerStageDescriptorUpdateAfterBindUniformBuffers();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindStorageBuffers)=reader.getMaxPerStageDescriptorUpdateAfterBindStorageBuffers();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindSampledImages)=reader.getMaxPerStageDescriptorUpdateAfterBindSampledImages();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindStorageImages)=reader.getMaxPerStageDescriptorUpdateAfterBindStorageImages();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindInputAttachments)=reader.getMaxPerStageDescriptorUpdateAfterBindInputAttachments();}();
[&](){(result.maxPerStageUpdateAfterBindResources)=reader.getMaxPerStageUpdateAfterBindResources();}();
[&](){(result.maxDescriptorSetUpdateAfterBindSamplers)=reader.getMaxDescriptorSetUpdateAfterBindSamplers();}();
[&](){(result.maxDescriptorSetUpdateAfterBindUniformBuffers)=reader.getMaxDescriptorSetUpdateAfterBindUniformBuffers();}();
[&](){(result.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)=reader.getMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic();}();
[&](){(result.maxDescriptorSetUpdateAfterBindStorageBuffers)=reader.getMaxDescriptorSetUpdateAfterBindStorageBuffers();}();
[&](){(result.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)=reader.getMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic();}();
[&](){(result.maxDescriptorSetUpdateAfterBindSampledImages)=reader.getMaxDescriptorSetUpdateAfterBindSampledImages();}();
[&](){(result.maxDescriptorSetUpdateAfterBindStorageImages)=reader.getMaxDescriptorSetUpdateAfterBindStorageImages();}();
[&](){(result.maxDescriptorSetUpdateAfterBindInputAttachments)=reader.getMaxDescriptorSetUpdateAfterBindInputAttachments();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDescriptorIndexingProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDescriptorIndexingProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetLayoutBindingFlagsCreateInfo::Builder& builder, VkDescriptorSetLayoutBindingFlagsCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBindingCount((member.bindingCount));}();
[&](){
            if ((member.pBindingFlags)==NULL){
                builder.initPBindingFlags(0);
            return; }
        auto proto_arr=builder.initPBindingFlags(member.bindingCount);
        for(int vPSYsQW=0; vPSYsQW < member.bindingCount; vPSYsQW++){
            [&](){[&](){[&](){return proto_arr.set(vPSYsQW,((member.pBindingFlags)[vPSYsQW]));}();}();}();
        }
        }();
}

    VkDescriptorSetLayoutBindingFlagsCreateInfo deserialize_struct(stream::VkDescriptorSetLayoutBindingFlagsCreateInfo::Reader reader){
        auto result=VkDescriptorSetLayoutBindingFlagsCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.bindingCount)=reader.getBindingCount();}();
[&](){ VkDescriptorBindingFlags* temp_seCkFox[&](){
            if (!reader.getPBindingFlags().size()==0){
                (result.pBindingFlags)=NULL;
            return; }{native_concat()}=(VkDescriptorBindingFlags*)malloc(result.bindingCount*sizeof(VkDescriptorBindingFlags));
        auto proto_arr=reader.getPBindingFlags(result.bindingCount);
        for(int ROiQLcN=0; ROiQLcN < result.bindingCount; ROiQLcN++){
            [&](){[&](){[&](){((result.pBindingFlags)[ROiQLcN])=proto_arr[ROiQLcN];}();}();}();
        }
        }();(result.pBindingFlags)=temp_seCkFox;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetLayoutBindingFlagsCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetLayoutBindingFlagsCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetVariableDescriptorCountAllocateInfo::Builder& builder, VkDescriptorSetVariableDescriptorCountAllocateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDescriptorSetCount((member.descriptorSetCount));}();
[&](){
            if ((member.pDescriptorCounts)==NULL){
                builder.initPDescriptorCounts(0);
            return; }
        auto proto_arr=builder.initPDescriptorCounts(member.descriptorSetCount);
        for(int ryLDzzp=0; ryLDzzp < member.descriptorSetCount; ryLDzzp++){
            [&](){return proto_arr.set(ryLDzzp,((member.pDescriptorCounts)[ryLDzzp]));}();
        }
        }();
}

    VkDescriptorSetVariableDescriptorCountAllocateInfo deserialize_struct(stream::VkDescriptorSetVariableDescriptorCountAllocateInfo::Reader reader){
        auto result=VkDescriptorSetVariableDescriptorCountAllocateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.descriptorSetCount)=reader.getDescriptorSetCount();}();
[&](){ uint32_t* temp_nucnUaf[&](){
            if (!reader.getPDescriptorCounts().size()==0){
                (result.pDescriptorCounts)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.descriptorSetCount*sizeof(uint32_t));
        auto proto_arr=reader.getPDescriptorCounts(result.descriptorSetCount);
        for(int VbFXKxf=0; VbFXKxf < result.descriptorSetCount; VbFXKxf++){
            [&](){((result.pDescriptorCounts)[VbFXKxf])=proto_arr[VbFXKxf];}();
        }
        }();(result.pDescriptorCounts)=temp_nucnUaf;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetVariableDescriptorCountAllocateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetVariableDescriptorCountAllocateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetVariableDescriptorCountLayoutSupport::Builder& builder, VkDescriptorSetVariableDescriptorCountLayoutSupport member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxVariableDescriptorCount((member.maxVariableDescriptorCount));}();
}

    VkDescriptorSetVariableDescriptorCountLayoutSupport deserialize_struct(stream::VkDescriptorSetVariableDescriptorCountLayoutSupport::Reader reader){
        auto result=VkDescriptorSetVariableDescriptorCountLayoutSupport();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxVariableDescriptorCount)=reader.getMaxVariableDescriptorCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetVariableDescriptorCountLayoutSupport member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetVariableDescriptorCountLayoutSupport member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentDescription2::Builder& builder, VkAttachmentDescription2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){[&](){[&](){return builder.setSamples((member.samples));}();}();}();
[&](){[&](){[&](){return builder.setLoadOp((member.loadOp));}();}();}();
[&](){[&](){[&](){return builder.setStoreOp((member.storeOp));}();}();}();
[&](){[&](){[&](){return builder.setStencilLoadOp((member.stencilLoadOp));}();}();}();
[&](){[&](){[&](){return builder.setStencilStoreOp((member.stencilStoreOp));}();}();}();
[&](){[&](){[&](){return builder.setInitialLayout((member.initialLayout));}();}();}();
[&](){[&](){[&](){return builder.setFinalLayout((member.finalLayout));}();}();}();
}

    VkAttachmentDescription2 deserialize_struct(stream::VkAttachmentDescription2::Reader reader){
        auto result=VkAttachmentDescription2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){[&](){[&](){(result.samples)=reader.getSamples();}();}();}();
[&](){[&](){[&](){(result.loadOp)=reader.getLoadOp();}();}();}();
[&](){[&](){[&](){(result.storeOp)=reader.getStoreOp();}();}();}();
[&](){[&](){[&](){(result.stencilLoadOp)=reader.getStencilLoadOp();}();}();}();
[&](){[&](){[&](){(result.stencilStoreOp)=reader.getStencilStoreOp();}();}();}();
[&](){[&](){[&](){(result.initialLayout)=reader.getInitialLayout();}();}();}();
[&](){[&](){[&](){(result.finalLayout)=reader.getFinalLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentDescription2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentDescription2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentReference2::Builder& builder, VkAttachmentReference2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAttachment((member.attachment));}();
[&](){[&](){[&](){return builder.setLayout((member.layout));}();}();}();
[&](){[&](){[&](){return builder.setAspectMask((member.aspectMask));}();}();}();
}

    VkAttachmentReference2 deserialize_struct(stream::VkAttachmentReference2::Reader reader){
        auto result=VkAttachmentReference2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.attachment)=reader.getAttachment();}();
[&](){[&](){[&](){(result.layout)=reader.getLayout();}();}();}();
[&](){[&](){[&](){(result.aspectMask)=reader.getAspectMask();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentReference2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentReference2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassDescription2::Builder& builder, VkSubpassDescription2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setPipelineBindPoint((member.pipelineBindPoint));}();}();}();
[&](){return builder.setViewMask((member.viewMask));}();
[&](){return builder.setInputAttachmentCount((member.inputAttachmentCount));}();
[&](){
            if ((member.pInputAttachments)==NULL){
                builder.initPInputAttachments(0);
            return; }
        auto proto_arr=builder.initPInputAttachments(member.inputAttachmentCount);
        for(int NsTMCqB=0; NsTMCqB < member.inputAttachmentCount; NsTMCqB++){
            [&](){
            auto temp=proto_arr[NsTMCqB];
            return serialize_struct(temp, ((member.pInputAttachments)[NsTMCqB]));
            }();
        }
        }();
[&](){return builder.setColorAttachmentCount((member.colorAttachmentCount));}();
[&](){
            if ((member.pColorAttachments)==NULL){
                builder.initPColorAttachments(0);
            return; }
        auto proto_arr=builder.initPColorAttachments(member.colorAttachmentCount);
        for(int nAcellO=0; nAcellO < member.colorAttachmentCount; nAcellO++){
            [&](){
            auto temp=proto_arr[nAcellO];
            return serialize_struct(temp, ((member.pColorAttachments)[nAcellO]));
            }();
        }
        }();
[&](){
            if ((member.pResolveAttachments)==NULL){
                builder.initPResolveAttachments(0);
            return; }
        auto proto_arr=builder.initPResolveAttachments(member.colorAttachmentCount);
        for(int asCGjsj=0; asCGjsj < member.colorAttachmentCount; asCGjsj++){
            [&](){
            auto temp=proto_arr[asCGjsj];
            return serialize_struct(temp, ((member.pResolveAttachments)[asCGjsj]));
            }();
        }
        }();
[&](){
            if ((member.pDepthStencilAttachment)==NULL){
                builder.initPDepthStencilAttachment(0);
            return; }
        auto proto_arr=builder.initPDepthStencilAttachment(1);
        for(int KprxYqO=0; KprxYqO < 1; KprxYqO++){
            [&](){
            auto temp=proto_arr[KprxYqO];
            return serialize_struct(temp, ((member.pDepthStencilAttachment)[KprxYqO]));
            }();
        }
        }();
[&](){return builder.setPreserveAttachmentCount((member.preserveAttachmentCount));}();
[&](){
            if ((member.pPreserveAttachments)==NULL){
                builder.initPPreserveAttachments(0);
            return; }
        auto proto_arr=builder.initPPreserveAttachments(member.preserveAttachmentCount);
        for(int OunTLoO=0; OunTLoO < member.preserveAttachmentCount; OunTLoO++){
            [&](){return proto_arr.set(OunTLoO,((member.pPreserveAttachments)[OunTLoO]));}();
        }
        }();
}

    VkSubpassDescription2 deserialize_struct(stream::VkSubpassDescription2::Reader reader){
        auto result=VkSubpassDescription2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.pipelineBindPoint)=reader.getPipelineBindPoint();}();}();}();
[&](){(result.viewMask)=reader.getViewMask();}();
[&](){(result.inputAttachmentCount)=reader.getInputAttachmentCount();}();
[&](){ VkAttachmentReference2* temp_hfGqGNu[&](){
            if (!reader.getPInputAttachments().size()==0){
                (result.pInputAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentReference2*)malloc(result.inputAttachmentCount*sizeof(VkAttachmentReference2));
        auto proto_arr=reader.getPInputAttachments(result.inputAttachmentCount);
        for(int iiiKhHa=0; iiiKhHa < result.inputAttachmentCount; iiiKhHa++){
            [&](){
            auto temp=proto_arr[iiiKhHa];
            ((result.pInputAttachments)[iiiKhHa])=deserialize_struct(temp);
            }();
        }
        }();(result.pInputAttachments)=temp_hfGqGNu;}();
[&](){(result.colorAttachmentCount)=reader.getColorAttachmentCount();}();
[&](){ VkAttachmentReference2* temp_WIfdigD[&](){
            if (!reader.getPColorAttachments().size()==0){
                (result.pColorAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentReference2*)malloc(result.colorAttachmentCount*sizeof(VkAttachmentReference2));
        auto proto_arr=reader.getPColorAttachments(result.colorAttachmentCount);
        for(int loPpvff=0; loPpvff < result.colorAttachmentCount; loPpvff++){
            [&](){
            auto temp=proto_arr[loPpvff];
            ((result.pColorAttachments)[loPpvff])=deserialize_struct(temp);
            }();
        }
        }();(result.pColorAttachments)=temp_WIfdigD;}();
[&](){ VkAttachmentReference2* temp_glgncXQ[&](){
            if (!reader.getPResolveAttachments().size()==0){
                (result.pResolveAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentReference2*)malloc(result.colorAttachmentCount*sizeof(VkAttachmentReference2));
        auto proto_arr=reader.getPResolveAttachments(result.colorAttachmentCount);
        for(int Ydlzhcl=0; Ydlzhcl < result.colorAttachmentCount; Ydlzhcl++){
            [&](){
            auto temp=proto_arr[Ydlzhcl];
            ((result.pResolveAttachments)[Ydlzhcl])=deserialize_struct(temp);
            }();
        }
        }();(result.pResolveAttachments)=temp_glgncXQ;}();
[&](){ VkAttachmentReference2* temp_NFxxVEH[&](){
            if (!reader.getPDepthStencilAttachment().size()==0){
                (result.pDepthStencilAttachment)=NULL;
            return; }{native_concat()}=(VkAttachmentReference2*)malloc(1*sizeof(VkAttachmentReference2));
        auto proto_arr=reader.getPDepthStencilAttachment(1);
        for(int DhYpQMM=0; DhYpQMM < 1; DhYpQMM++){
            [&](){
            auto temp=proto_arr[DhYpQMM];
            ((result.pDepthStencilAttachment)[DhYpQMM])=deserialize_struct(temp);
            }();
        }
        }();(result.pDepthStencilAttachment)=temp_NFxxVEH;}();
[&](){(result.preserveAttachmentCount)=reader.getPreserveAttachmentCount();}();
[&](){ uint32_t* temp_OBPkkNN[&](){
            if (!reader.getPPreserveAttachments().size()==0){
                (result.pPreserveAttachments)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.preserveAttachmentCount*sizeof(uint32_t));
        auto proto_arr=reader.getPPreserveAttachments(result.preserveAttachmentCount);
        for(int Ucaahng=0; Ucaahng < result.preserveAttachmentCount; Ucaahng++){
            [&](){((result.pPreserveAttachments)[Ucaahng])=proto_arr[Ucaahng];}();
        }
        }();(result.pPreserveAttachments)=temp_OBPkkNN;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassDescription2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassDescription2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassDependency2::Builder& builder, VkSubpassDependency2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcSubpass((member.srcSubpass));}();
[&](){return builder.setDstSubpass((member.dstSubpass));}();
[&](){[&](){[&](){return builder.setSrcStageMask((member.srcStageMask));}();}();}();
[&](){[&](){[&](){return builder.setDstStageMask((member.dstStageMask));}();}();}();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDependencyFlags((member.dependencyFlags));}();}();}();
[&](){return builder.setViewOffset((member.viewOffset));}();
}

    VkSubpassDependency2 deserialize_struct(stream::VkSubpassDependency2::Reader reader){
        auto result=VkSubpassDependency2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcSubpass)=reader.getSrcSubpass();}();
[&](){(result.dstSubpass)=reader.getDstSubpass();}();
[&](){[&](){[&](){(result.srcStageMask)=reader.getSrcStageMask();}();}();}();
[&](){[&](){[&](){(result.dstStageMask)=reader.getDstStageMask();}();}();}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
[&](){[&](){[&](){(result.dependencyFlags)=reader.getDependencyFlags();}();}();}();
[&](){(result.viewOffset)=reader.getViewOffset();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassDependency2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassDependency2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassCreateInfo2::Builder& builder, VkRenderPassCreateInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setAttachmentCount((member.attachmentCount));}();
[&](){
            if ((member.pAttachments)==NULL){
                builder.initPAttachments(0);
            return; }
        auto proto_arr=builder.initPAttachments(member.attachmentCount);
        for(int ZWLUmNY=0; ZWLUmNY < member.attachmentCount; ZWLUmNY++){
            [&](){
            auto temp=proto_arr[ZWLUmNY];
            return serialize_struct(temp, ((member.pAttachments)[ZWLUmNY]));
            }();
        }
        }();
[&](){return builder.setSubpassCount((member.subpassCount));}();
[&](){
            if ((member.pSubpasses)==NULL){
                builder.initPSubpasses(0);
            return; }
        auto proto_arr=builder.initPSubpasses(member.subpassCount);
        for(int eUPzEKF=0; eUPzEKF < member.subpassCount; eUPzEKF++){
            [&](){
            auto temp=proto_arr[eUPzEKF];
            return serialize_struct(temp, ((member.pSubpasses)[eUPzEKF]));
            }();
        }
        }();
[&](){return builder.setDependencyCount((member.dependencyCount));}();
[&](){
            if ((member.pDependencies)==NULL){
                builder.initPDependencies(0);
            return; }
        auto proto_arr=builder.initPDependencies(member.dependencyCount);
        for(int NRheNuA=0; NRheNuA < member.dependencyCount; NRheNuA++){
            [&](){
            auto temp=proto_arr[NRheNuA];
            return serialize_struct(temp, ((member.pDependencies)[NRheNuA]));
            }();
        }
        }();
[&](){return builder.setCorrelatedViewMaskCount((member.correlatedViewMaskCount));}();
[&](){
            if ((member.pCorrelatedViewMasks)==NULL){
                builder.initPCorrelatedViewMasks(0);
            return; }
        auto proto_arr=builder.initPCorrelatedViewMasks(member.correlatedViewMaskCount);
        for(int yFHkrOi=0; yFHkrOi < member.correlatedViewMaskCount; yFHkrOi++){
            [&](){return proto_arr.set(yFHkrOi,((member.pCorrelatedViewMasks)[yFHkrOi]));}();
        }
        }();
}

    VkRenderPassCreateInfo2 deserialize_struct(stream::VkRenderPassCreateInfo2::Reader reader){
        auto result=VkRenderPassCreateInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.attachmentCount)=reader.getAttachmentCount();}();
[&](){ VkAttachmentDescription2* temp_XqgkFTU[&](){
            if (!reader.getPAttachments().size()==0){
                (result.pAttachments)=NULL;
            return; }{native_concat()}=(VkAttachmentDescription2*)malloc(result.attachmentCount*sizeof(VkAttachmentDescription2));
        auto proto_arr=reader.getPAttachments(result.attachmentCount);
        for(int aUCdCNG=0; aUCdCNG < result.attachmentCount; aUCdCNG++){
            [&](){
            auto temp=proto_arr[aUCdCNG];
            ((result.pAttachments)[aUCdCNG])=deserialize_struct(temp);
            }();
        }
        }();(result.pAttachments)=temp_XqgkFTU;}();
[&](){(result.subpassCount)=reader.getSubpassCount();}();
[&](){ VkSubpassDescription2* temp_XJwjEmi[&](){
            if (!reader.getPSubpasses().size()==0){
                (result.pSubpasses)=NULL;
            return; }{native_concat()}=(VkSubpassDescription2*)malloc(result.subpassCount*sizeof(VkSubpassDescription2));
        auto proto_arr=reader.getPSubpasses(result.subpassCount);
        for(int MGKKGXF=0; MGKKGXF < result.subpassCount; MGKKGXF++){
            [&](){
            auto temp=proto_arr[MGKKGXF];
            ((result.pSubpasses)[MGKKGXF])=deserialize_struct(temp);
            }();
        }
        }();(result.pSubpasses)=temp_XJwjEmi;}();
[&](){(result.dependencyCount)=reader.getDependencyCount();}();
[&](){ VkSubpassDependency2* temp_HqZlMVC[&](){
            if (!reader.getPDependencies().size()==0){
                (result.pDependencies)=NULL;
            return; }{native_concat()}=(VkSubpassDependency2*)malloc(result.dependencyCount*sizeof(VkSubpassDependency2));
        auto proto_arr=reader.getPDependencies(result.dependencyCount);
        for(int CPOdCsX=0; CPOdCsX < result.dependencyCount; CPOdCsX++){
            [&](){
            auto temp=proto_arr[CPOdCsX];
            ((result.pDependencies)[CPOdCsX])=deserialize_struct(temp);
            }();
        }
        }();(result.pDependencies)=temp_HqZlMVC;}();
[&](){(result.correlatedViewMaskCount)=reader.getCorrelatedViewMaskCount();}();
[&](){ uint32_t* temp_eZYsHuM[&](){
            if (!reader.getPCorrelatedViewMasks().size()==0){
                (result.pCorrelatedViewMasks)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.correlatedViewMaskCount*sizeof(uint32_t));
        auto proto_arr=reader.getPCorrelatedViewMasks(result.correlatedViewMaskCount);
        for(int RuvRSDs=0; RuvRSDs < result.correlatedViewMaskCount; RuvRSDs++){
            [&](){((result.pCorrelatedViewMasks)[RuvRSDs])=proto_arr[RuvRSDs];}();
        }
        }();(result.pCorrelatedViewMasks)=temp_eZYsHuM;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassCreateInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassCreateInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassBeginInfo::Builder& builder, VkSubpassBeginInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setContents((member.contents));}();}();}();
}

    VkSubpassBeginInfo deserialize_struct(stream::VkSubpassBeginInfo::Reader reader){
        auto result=VkSubpassBeginInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.contents)=reader.getContents();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassBeginInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassBeginInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassEndInfo::Builder& builder, VkSubpassEndInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
}

    VkSubpassEndInfo deserialize_struct(stream::VkSubpassEndInfo::Reader reader){
        auto result=VkSubpassEndInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassEndInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassEndInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTimelineSemaphoreFeatures::Builder& builder, VkPhysicalDeviceTimelineSemaphoreFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTimelineSemaphore((member.timelineSemaphore));}();}();
}

    VkPhysicalDeviceTimelineSemaphoreFeatures deserialize_struct(stream::VkPhysicalDeviceTimelineSemaphoreFeatures::Reader reader){
        auto result=VkPhysicalDeviceTimelineSemaphoreFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.timelineSemaphore)=reader.getTimelineSemaphore();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTimelineSemaphoreFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTimelineSemaphoreFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTimelineSemaphoreProperties::Builder& builder, VkPhysicalDeviceTimelineSemaphoreProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxTimelineSemaphoreValueDifference((member.maxTimelineSemaphoreValueDifference));}();
}

    VkPhysicalDeviceTimelineSemaphoreProperties deserialize_struct(stream::VkPhysicalDeviceTimelineSemaphoreProperties::Reader reader){
        auto result=VkPhysicalDeviceTimelineSemaphoreProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxTimelineSemaphoreValueDifference)=reader.getMaxTimelineSemaphoreValueDifference();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTimelineSemaphoreProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTimelineSemaphoreProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSemaphoreTypeCreateInfo::Builder& builder, VkSemaphoreTypeCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSemaphoreType((member.semaphoreType));}();}();}();
[&](){return builder.setInitialValue((member.initialValue));}();
}

    VkSemaphoreTypeCreateInfo deserialize_struct(stream::VkSemaphoreTypeCreateInfo::Reader reader){
        auto result=VkSemaphoreTypeCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.semaphoreType)=reader.getSemaphoreType();}();}();}();
[&](){(result.initialValue)=reader.getInitialValue();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSemaphoreTypeCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSemaphoreTypeCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkTimelineSemaphoreSubmitInfo::Builder& builder, VkTimelineSemaphoreSubmitInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setWaitSemaphoreValueCount((member.waitSemaphoreValueCount));}();
[&](){
            if ((member.pWaitSemaphoreValues)==NULL){
                builder.initPWaitSemaphoreValues(0);
            return; }
        auto proto_arr=builder.initPWaitSemaphoreValues(member.waitSemaphoreValueCount);
        for(int QJriFxq=0; QJriFxq < member.waitSemaphoreValueCount; QJriFxq++){
            [&](){return proto_arr.set(QJriFxq,((member.pWaitSemaphoreValues)[QJriFxq]));}();
        }
        }();
[&](){return builder.setSignalSemaphoreValueCount((member.signalSemaphoreValueCount));}();
[&](){
            if ((member.pSignalSemaphoreValues)==NULL){
                builder.initPSignalSemaphoreValues(0);
            return; }
        auto proto_arr=builder.initPSignalSemaphoreValues(member.signalSemaphoreValueCount);
        for(int Rnxwrqr=0; Rnxwrqr < member.signalSemaphoreValueCount; Rnxwrqr++){
            [&](){return proto_arr.set(Rnxwrqr,((member.pSignalSemaphoreValues)[Rnxwrqr]));}();
        }
        }();
}

    VkTimelineSemaphoreSubmitInfo deserialize_struct(stream::VkTimelineSemaphoreSubmitInfo::Reader reader){
        auto result=VkTimelineSemaphoreSubmitInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.waitSemaphoreValueCount)=reader.getWaitSemaphoreValueCount();}();
[&](){ uint64_t* temp_AAxtSvM[&](){
            if (!reader.getPWaitSemaphoreValues().size()==0){
                (result.pWaitSemaphoreValues)=NULL;
            return; }{native_concat()}=(uint64_t*)malloc(result.waitSemaphoreValueCount*sizeof(uint64_t));
        auto proto_arr=reader.getPWaitSemaphoreValues(result.waitSemaphoreValueCount);
        for(int gYZiaOt=0; gYZiaOt < result.waitSemaphoreValueCount; gYZiaOt++){
            [&](){((result.pWaitSemaphoreValues)[gYZiaOt])=proto_arr[gYZiaOt];}();
        }
        }();(result.pWaitSemaphoreValues)=temp_AAxtSvM;}();
[&](){(result.signalSemaphoreValueCount)=reader.getSignalSemaphoreValueCount();}();
[&](){ uint64_t* temp_uPzXKwE[&](){
            if (!reader.getPSignalSemaphoreValues().size()==0){
                (result.pSignalSemaphoreValues)=NULL;
            return; }{native_concat()}=(uint64_t*)malloc(result.signalSemaphoreValueCount*sizeof(uint64_t));
        auto proto_arr=reader.getPSignalSemaphoreValues(result.signalSemaphoreValueCount);
        for(int JRYJxZh=0; JRYJxZh < result.signalSemaphoreValueCount; JRYJxZh++){
            [&](){((result.pSignalSemaphoreValues)[JRYJxZh])=proto_arr[JRYJxZh];}();
        }
        }();(result.pSignalSemaphoreValues)=temp_uPzXKwE;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkTimelineSemaphoreSubmitInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkTimelineSemaphoreSubmitInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSemaphoreWaitInfo::Builder& builder, VkSemaphoreWaitInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setSemaphoreCount((member.semaphoreCount));}();
[&](){
            if ((member.pSemaphores)==NULL){
                builder.initPSemaphores(0);
            return; }
        auto proto_arr=builder.initPSemaphores(member.semaphoreCount);
        for(int ZaebsDj=0; ZaebsDj < member.semaphoreCount; ZaebsDj++){
            [&](){return proto_arr.set(ZaebsDj,serialize_handle((member.pSemaphores)[ZaebsDj]));}();
        }
        }();
[&](){
            if ((member.pValues)==NULL){
                builder.initPValues(0);
            return; }
        auto proto_arr=builder.initPValues(member.semaphoreCount);
        for(int ioKhjPI=0; ioKhjPI < member.semaphoreCount; ioKhjPI++){
            [&](){return proto_arr.set(ioKhjPI,((member.pValues)[ioKhjPI]));}();
        }
        }();
}

    VkSemaphoreWaitInfo deserialize_struct(stream::VkSemaphoreWaitInfo::Reader reader){
        auto result=VkSemaphoreWaitInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.semaphoreCount)=reader.getSemaphoreCount();}();
[&](){ VkSemaphore* temp_rygkoDc[&](){
            if (!reader.getPSemaphores().size()==0){
                (result.pSemaphores)=NULL;
            return; }{native_concat()}=(VkSemaphore*)malloc(result.semaphoreCount*sizeof(VkSemaphore));
        auto proto_arr=reader.getPSemaphores(result.semaphoreCount);
        for(int WAEDOAs=0; WAEDOAs < result.semaphoreCount; WAEDOAs++){
            [&](){((result.pSemaphores)[WAEDOAs])=deserialize_VkSemaphore(proto_arr[WAEDOAs]);}();
        }
        }();(result.pSemaphores)=temp_rygkoDc;}();
[&](){ uint64_t* temp_kSgMuTe[&](){
            if (!reader.getPValues().size()==0){
                (result.pValues)=NULL;
            return; }{native_concat()}=(uint64_t*)malloc(result.semaphoreCount*sizeof(uint64_t));
        auto proto_arr=reader.getPValues(result.semaphoreCount);
        for(int QDbgVwt=0; QDbgVwt < result.semaphoreCount; QDbgVwt++){
            [&](){((result.pValues)[QDbgVwt])=proto_arr[QDbgVwt];}();
        }
        }();(result.pValues)=temp_kSgMuTe;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSemaphoreWaitInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSemaphoreWaitInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSemaphoreSignalInfo::Builder& builder, VkSemaphoreSignalInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSemaphore(serialize_handle(member.semaphore));}();
[&](){return builder.setValue((member.value));}();
}

    VkSemaphoreSignalInfo deserialize_struct(stream::VkSemaphoreSignalInfo::Reader reader){
        auto result=VkSemaphoreSignalInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.semaphore)=deserialize_VkSemaphore(reader.getSemaphore());}();
[&](){(result.value)=reader.getValue();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSemaphoreSignalInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSemaphoreSignalInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVertexInputBindingDivisorDescriptionEXT::Builder& builder, VkVertexInputBindingDivisorDescriptionEXT member){
        
    
[&](){return builder.setBinding((member.binding));}();
[&](){return builder.setDivisor((member.divisor));}();
}

    VkVertexInputBindingDivisorDescriptionEXT deserialize_struct(stream::VkVertexInputBindingDivisorDescriptionEXT::Reader reader){
        auto result=VkVertexInputBindingDivisorDescriptionEXT();
    
[&](){(result.binding)=reader.getBinding();}();
[&](){(result.divisor)=reader.getDivisor();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVertexInputBindingDivisorDescriptionEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVertexInputBindingDivisorDescriptionEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineVertexInputDivisorStateCreateInfoEXT::Builder& builder, VkPipelineVertexInputDivisorStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setVertexBindingDivisorCount((member.vertexBindingDivisorCount));}();
[&](){
            if ((member.pVertexBindingDivisors)==NULL){
                builder.initPVertexBindingDivisors(0);
            return; }
        auto proto_arr=builder.initPVertexBindingDivisors(member.vertexBindingDivisorCount);
        for(int NyIqyrV=0; NyIqyrV < member.vertexBindingDivisorCount; NyIqyrV++){
            [&](){
            auto temp=proto_arr[NyIqyrV];
            return serialize_struct(temp, ((member.pVertexBindingDivisors)[NyIqyrV]));
            }();
        }
        }();
}

    VkPipelineVertexInputDivisorStateCreateInfoEXT deserialize_struct(stream::VkPipelineVertexInputDivisorStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineVertexInputDivisorStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.vertexBindingDivisorCount)=reader.getVertexBindingDivisorCount();}();
[&](){ VkVertexInputBindingDivisorDescriptionEXT* temp_ZOHcldD[&](){
            if (!reader.getPVertexBindingDivisors().size()==0){
                (result.pVertexBindingDivisors)=NULL;
            return; }{native_concat()}=(VkVertexInputBindingDivisorDescriptionEXT*)malloc(result.vertexBindingDivisorCount*sizeof(VkVertexInputBindingDivisorDescriptionEXT));
        auto proto_arr=reader.getPVertexBindingDivisors(result.vertexBindingDivisorCount);
        for(int WjkvGwK=0; WjkvGwK < result.vertexBindingDivisorCount; WjkvGwK++){
            [&](){
            auto temp=proto_arr[WjkvGwK];
            ((result.pVertexBindingDivisors)[WjkvGwK])=deserialize_struct(temp);
            }();
        }
        }();(result.pVertexBindingDivisors)=temp_ZOHcldD;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineVertexInputDivisorStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineVertexInputDivisorStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::Builder& builder, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxVertexAttribDivisor((member.maxVertexAttribDivisor));}();
}

    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxVertexAttribDivisor)=reader.getMaxVertexAttribDivisor();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePCIBusInfoPropertiesEXT::Builder& builder, VkPhysicalDevicePCIBusInfoPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPciDomain((member.pciDomain));}();
[&](){return builder.setPciBus((member.pciBus));}();
[&](){return builder.setPciDevice((member.pciDevice));}();
[&](){return builder.setPciFunction((member.pciFunction));}();
}

    VkPhysicalDevicePCIBusInfoPropertiesEXT deserialize_struct(stream::VkPhysicalDevicePCIBusInfoPropertiesEXT::Reader reader){
        auto result=VkPhysicalDevicePCIBusInfoPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.pciDomain)=reader.getPciDomain();}();
[&](){(result.pciBus)=reader.getPciBus();}();
[&](){(result.pciDevice)=reader.getPciDevice();}();
[&](){(result.pciFunction)=reader.getPciFunction();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePCIBusInfoPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePCIBusInfoPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferInheritanceConditionalRenderingInfoEXT::Builder& builder, VkCommandBufferInheritanceConditionalRenderingInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setConditionalRenderingEnable((member.conditionalRenderingEnable));}();}();
}

    VkCommandBufferInheritanceConditionalRenderingInfoEXT deserialize_struct(stream::VkCommandBufferInheritanceConditionalRenderingInfoEXT::Reader reader){
        auto result=VkCommandBufferInheritanceConditionalRenderingInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.conditionalRenderingEnable)=reader.getConditionalRenderingEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferInheritanceConditionalRenderingInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferInheritanceConditionalRenderingInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevice8BitStorageFeatures::Builder& builder, VkPhysicalDevice8BitStorageFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setStorageBuffer8BitAccess((member.storageBuffer8BitAccess));}();}();
[&](){[&](){return builder.setUniformAndStorageBuffer8BitAccess((member.uniformAndStorageBuffer8BitAccess));}();}();
[&](){[&](){return builder.setStoragePushConstant8((member.storagePushConstant8));}();}();
}

    VkPhysicalDevice8BitStorageFeatures deserialize_struct(stream::VkPhysicalDevice8BitStorageFeatures::Reader reader){
        auto result=VkPhysicalDevice8BitStorageFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.storageBuffer8BitAccess)=reader.getStorageBuffer8BitAccess();}();}();
[&](){[&](){(result.uniformAndStorageBuffer8BitAccess)=reader.getUniformAndStorageBuffer8BitAccess();}();}();
[&](){[&](){(result.storagePushConstant8)=reader.getStoragePushConstant8();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevice8BitStorageFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevice8BitStorageFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceConditionalRenderingFeaturesEXT::Builder& builder, VkPhysicalDeviceConditionalRenderingFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setConditionalRendering((member.conditionalRendering));}();}();
[&](){[&](){return builder.setInheritedConditionalRendering((member.inheritedConditionalRendering));}();}();
}

    VkPhysicalDeviceConditionalRenderingFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceConditionalRenderingFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceConditionalRenderingFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.conditionalRendering)=reader.getConditionalRendering();}();}();
[&](){[&](){(result.inheritedConditionalRendering)=reader.getInheritedConditionalRendering();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceConditionalRenderingFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceConditionalRenderingFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVulkanMemoryModelFeatures::Builder& builder, VkPhysicalDeviceVulkanMemoryModelFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setVulkanMemoryModel((member.vulkanMemoryModel));}();}();
[&](){[&](){return builder.setVulkanMemoryModelDeviceScope((member.vulkanMemoryModelDeviceScope));}();}();
[&](){[&](){return builder.setVulkanMemoryModelAvailabilityVisibilityChains((member.vulkanMemoryModelAvailabilityVisibilityChains));}();}();
}

    VkPhysicalDeviceVulkanMemoryModelFeatures deserialize_struct(stream::VkPhysicalDeviceVulkanMemoryModelFeatures::Reader reader){
        auto result=VkPhysicalDeviceVulkanMemoryModelFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.vulkanMemoryModel)=reader.getVulkanMemoryModel();}();}();
[&](){[&](){(result.vulkanMemoryModelDeviceScope)=reader.getVulkanMemoryModelDeviceScope();}();}();
[&](){[&](){(result.vulkanMemoryModelAvailabilityVisibilityChains)=reader.getVulkanMemoryModelAvailabilityVisibilityChains();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVulkanMemoryModelFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVulkanMemoryModelFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderAtomicInt64Features::Builder& builder, VkPhysicalDeviceShaderAtomicInt64Features member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderBufferInt64Atomics((member.shaderBufferInt64Atomics));}();}();
[&](){[&](){return builder.setShaderSharedInt64Atomics((member.shaderSharedInt64Atomics));}();}();
}

    VkPhysicalDeviceShaderAtomicInt64Features deserialize_struct(stream::VkPhysicalDeviceShaderAtomicInt64Features::Reader reader){
        auto result=VkPhysicalDeviceShaderAtomicInt64Features();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderBufferInt64Atomics)=reader.getShaderBufferInt64Atomics();}();}();
[&](){[&](){(result.shaderSharedInt64Atomics)=reader.getShaderSharedInt64Atomics();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderAtomicInt64Features member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderAtomicInt64Features member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::Builder& builder, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderBufferFloat32Atomics((member.shaderBufferFloat32Atomics));}();}();
[&](){[&](){return builder.setShaderBufferFloat32AtomicAdd((member.shaderBufferFloat32AtomicAdd));}();}();
[&](){[&](){return builder.setShaderBufferFloat64Atomics((member.shaderBufferFloat64Atomics));}();}();
[&](){[&](){return builder.setShaderBufferFloat64AtomicAdd((member.shaderBufferFloat64AtomicAdd));}();}();
[&](){[&](){return builder.setShaderSharedFloat32Atomics((member.shaderSharedFloat32Atomics));}();}();
[&](){[&](){return builder.setShaderSharedFloat32AtomicAdd((member.shaderSharedFloat32AtomicAdd));}();}();
[&](){[&](){return builder.setShaderSharedFloat64Atomics((member.shaderSharedFloat64Atomics));}();}();
[&](){[&](){return builder.setShaderSharedFloat64AtomicAdd((member.shaderSharedFloat64AtomicAdd));}();}();
[&](){[&](){return builder.setShaderImageFloat32Atomics((member.shaderImageFloat32Atomics));}();}();
[&](){[&](){return builder.setShaderImageFloat32AtomicAdd((member.shaderImageFloat32AtomicAdd));}();}();
[&](){[&](){return builder.setSparseImageFloat32Atomics((member.sparseImageFloat32Atomics));}();}();
[&](){[&](){return builder.setSparseImageFloat32AtomicAdd((member.sparseImageFloat32AtomicAdd));}();}();
}

    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderAtomicFloatFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderBufferFloat32Atomics)=reader.getShaderBufferFloat32Atomics();}();}();
[&](){[&](){(result.shaderBufferFloat32AtomicAdd)=reader.getShaderBufferFloat32AtomicAdd();}();}();
[&](){[&](){(result.shaderBufferFloat64Atomics)=reader.getShaderBufferFloat64Atomics();}();}();
[&](){[&](){(result.shaderBufferFloat64AtomicAdd)=reader.getShaderBufferFloat64AtomicAdd();}();}();
[&](){[&](){(result.shaderSharedFloat32Atomics)=reader.getShaderSharedFloat32Atomics();}();}();
[&](){[&](){(result.shaderSharedFloat32AtomicAdd)=reader.getShaderSharedFloat32AtomicAdd();}();}();
[&](){[&](){(result.shaderSharedFloat64Atomics)=reader.getShaderSharedFloat64Atomics();}();}();
[&](){[&](){(result.shaderSharedFloat64AtomicAdd)=reader.getShaderSharedFloat64AtomicAdd();}();}();
[&](){[&](){(result.shaderImageFloat32Atomics)=reader.getShaderImageFloat32Atomics();}();}();
[&](){[&](){(result.shaderImageFloat32AtomicAdd)=reader.getShaderImageFloat32AtomicAdd();}();}();
[&](){[&](){(result.sparseImageFloat32Atomics)=reader.getSparseImageFloat32Atomics();}();}();
[&](){[&](){(result.sparseImageFloat32AtomicAdd)=reader.getSparseImageFloat32AtomicAdd();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::Builder& builder, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderBufferFloat16Atomics((member.shaderBufferFloat16Atomics));}();}();
[&](){[&](){return builder.setShaderBufferFloat16AtomicAdd((member.shaderBufferFloat16AtomicAdd));}();}();
[&](){[&](){return builder.setShaderBufferFloat16AtomicMinMax((member.shaderBufferFloat16AtomicMinMax));}();}();
[&](){[&](){return builder.setShaderBufferFloat32AtomicMinMax((member.shaderBufferFloat32AtomicMinMax));}();}();
[&](){[&](){return builder.setShaderBufferFloat64AtomicMinMax((member.shaderBufferFloat64AtomicMinMax));}();}();
[&](){[&](){return builder.setShaderSharedFloat16Atomics((member.shaderSharedFloat16Atomics));}();}();
[&](){[&](){return builder.setShaderSharedFloat16AtomicAdd((member.shaderSharedFloat16AtomicAdd));}();}();
[&](){[&](){return builder.setShaderSharedFloat16AtomicMinMax((member.shaderSharedFloat16AtomicMinMax));}();}();
[&](){[&](){return builder.setShaderSharedFloat32AtomicMinMax((member.shaderSharedFloat32AtomicMinMax));}();}();
[&](){[&](){return builder.setShaderSharedFloat64AtomicMinMax((member.shaderSharedFloat64AtomicMinMax));}();}();
[&](){[&](){return builder.setShaderImageFloat32AtomicMinMax((member.shaderImageFloat32AtomicMinMax));}();}();
[&](){[&](){return builder.setSparseImageFloat32AtomicMinMax((member.sparseImageFloat32AtomicMinMax));}();}();
}

    VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderBufferFloat16Atomics)=reader.getShaderBufferFloat16Atomics();}();}();
[&](){[&](){(result.shaderBufferFloat16AtomicAdd)=reader.getShaderBufferFloat16AtomicAdd();}();}();
[&](){[&](){(result.shaderBufferFloat16AtomicMinMax)=reader.getShaderBufferFloat16AtomicMinMax();}();}();
[&](){[&](){(result.shaderBufferFloat32AtomicMinMax)=reader.getShaderBufferFloat32AtomicMinMax();}();}();
[&](){[&](){(result.shaderBufferFloat64AtomicMinMax)=reader.getShaderBufferFloat64AtomicMinMax();}();}();
[&](){[&](){(result.shaderSharedFloat16Atomics)=reader.getShaderSharedFloat16Atomics();}();}();
[&](){[&](){(result.shaderSharedFloat16AtomicAdd)=reader.getShaderSharedFloat16AtomicAdd();}();}();
[&](){[&](){(result.shaderSharedFloat16AtomicMinMax)=reader.getShaderSharedFloat16AtomicMinMax();}();}();
[&](){[&](){(result.shaderSharedFloat32AtomicMinMax)=reader.getShaderSharedFloat32AtomicMinMax();}();}();
[&](){[&](){(result.shaderSharedFloat64AtomicMinMax)=reader.getShaderSharedFloat64AtomicMinMax();}();}();
[&](){[&](){(result.shaderImageFloat32AtomicMinMax)=reader.getShaderImageFloat32AtomicMinMax();}();}();
[&](){[&](){(result.sparseImageFloat32AtomicMinMax)=reader.getSparseImageFloat32AtomicMinMax();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::Builder& builder, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setVertexAttributeInstanceRateDivisor((member.vertexAttributeInstanceRateDivisor));}();}();
[&](){[&](){return builder.setVertexAttributeInstanceRateZeroDivisor((member.vertexAttributeInstanceRateZeroDivisor));}();}();
}

    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.vertexAttributeInstanceRateDivisor)=reader.getVertexAttributeInstanceRateDivisor();}();}();
[&](){[&](){(result.vertexAttributeInstanceRateZeroDivisor)=reader.getVertexAttributeInstanceRateZeroDivisor();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueueFamilyCheckpointPropertiesNV::Builder& builder, VkQueueFamilyCheckpointPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCheckpointExecutionStageMask((member.checkpointExecutionStageMask));}();}();}();
}

    VkQueueFamilyCheckpointPropertiesNV deserialize_struct(stream::VkQueueFamilyCheckpointPropertiesNV::Reader reader){
        auto result=VkQueueFamilyCheckpointPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.checkpointExecutionStageMask)=reader.getCheckpointExecutionStageMask();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueueFamilyCheckpointPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueueFamilyCheckpointPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCheckpointDataNV::Builder& builder, VkCheckpointDataNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setStage((member.stage));}();}();}();
[&](){
            if ((member.pCheckpointMarker)==NULL){
                builder.initPCheckpointMarker(0);
            return; }[&](){
            if (((char*)(member.pCheckpointMarker).pCheckpointMarker)==NULL){
                builder.initPCheckpointMarker(0);
            return; }
        auto proto_arr=builder.initPCheckpointMarker(strlen(((char*)(member.pCheckpointMarker).pCheckpointMarker))+1);
        for(int ROoHiBu=0; ROoHiBu < strlen(((char*)(member.pCheckpointMarker).pCheckpointMarker))+1; ROoHiBu++){
            [&](){return proto_arr.set(ROoHiBu,(((char*)(member.pCheckpointMarker).pCheckpointMarker)[ROoHiBu]));}();
        }
        }();}();
}

    VkCheckpointDataNV deserialize_struct(stream::VkCheckpointDataNV::Reader reader){
        auto result=VkCheckpointDataNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.stage)=reader.getStage();}();}();}();
[&](){
            if (!reader.getPCheckpointMarker().size()==0){
                (result.pCheckpointMarker)=NULL;
            return; }char* temp_PEjVDYf;[&](){
            if (!reader.getPCheckpointMarker().size()==0){
                (temp_PEjVDYf.pCheckpointMarker)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPCheckpointMarker().size();*sizeof(char));
        auto proto_arr=reader.getPCheckpointMarker(reader.getPCheckpointMarker().size(););
        for(int ROoHiBu=0; ROoHiBu < reader.getPCheckpointMarker().size();; ROoHiBu++){
            [&](){((temp_PEjVDYf.pCheckpointMarker)[ROoHiBu])=proto_arr[ROoHiBu];}();
        }
        }();(result.pCheckpointMarker)=temp_PEjVDYf;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCheckpointDataNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCheckpointDataNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDepthStencilResolveProperties::Builder& builder, VkPhysicalDeviceDepthStencilResolveProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSupportedDepthResolveModes((member.supportedDepthResolveModes));}();}();}();
[&](){[&](){[&](){return builder.setSupportedStencilResolveModes((member.supportedStencilResolveModes));}();}();}();
[&](){[&](){return builder.setIndependentResolveNone((member.independentResolveNone));}();}();
[&](){[&](){return builder.setIndependentResolve((member.independentResolve));}();}();
}

    VkPhysicalDeviceDepthStencilResolveProperties deserialize_struct(stream::VkPhysicalDeviceDepthStencilResolveProperties::Reader reader){
        auto result=VkPhysicalDeviceDepthStencilResolveProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.supportedDepthResolveModes)=reader.getSupportedDepthResolveModes();}();}();}();
[&](){[&](){[&](){(result.supportedStencilResolveModes)=reader.getSupportedStencilResolveModes();}();}();}();
[&](){[&](){(result.independentResolveNone)=reader.getIndependentResolveNone();}();}();
[&](){[&](){(result.independentResolve)=reader.getIndependentResolve();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDepthStencilResolveProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDepthStencilResolveProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassDescriptionDepthStencilResolve::Builder& builder, VkSubpassDescriptionDepthStencilResolve member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDepthResolveMode((member.depthResolveMode));}();}();}();
[&](){[&](){[&](){return builder.setStencilResolveMode((member.stencilResolveMode));}();}();}();
[&](){
            if ((member.pDepthStencilResolveAttachment)==NULL){
                builder.initPDepthStencilResolveAttachment(0);
            return; }
        auto proto_arr=builder.initPDepthStencilResolveAttachment(1);
        for(int OUyBLoX=0; OUyBLoX < 1; OUyBLoX++){
            [&](){
            auto temp=proto_arr[OUyBLoX];
            return serialize_struct(temp, ((member.pDepthStencilResolveAttachment)[OUyBLoX]));
            }();
        }
        }();
}

    VkSubpassDescriptionDepthStencilResolve deserialize_struct(stream::VkSubpassDescriptionDepthStencilResolve::Reader reader){
        auto result=VkSubpassDescriptionDepthStencilResolve();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.depthResolveMode)=reader.getDepthResolveMode();}();}();}();
[&](){[&](){[&](){(result.stencilResolveMode)=reader.getStencilResolveMode();}();}();}();
[&](){ VkAttachmentReference2* temp_qZRzgVG[&](){
            if (!reader.getPDepthStencilResolveAttachment().size()==0){
                (result.pDepthStencilResolveAttachment)=NULL;
            return; }{native_concat()}=(VkAttachmentReference2*)malloc(1*sizeof(VkAttachmentReference2));
        auto proto_arr=reader.getPDepthStencilResolveAttachment(1);
        for(int mhYoNRQ=0; mhYoNRQ < 1; mhYoNRQ++){
            [&](){
            auto temp=proto_arr[mhYoNRQ];
            ((result.pDepthStencilResolveAttachment)[mhYoNRQ])=deserialize_struct(temp);
            }();
        }
        }();(result.pDepthStencilResolveAttachment)=temp_qZRzgVG;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassDescriptionDepthStencilResolve member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassDescriptionDepthStencilResolve member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewASTCDecodeModeEXT::Builder& builder, VkImageViewASTCDecodeModeEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDecodeMode((member.decodeMode));}();}();}();
}

    VkImageViewASTCDecodeModeEXT deserialize_struct(stream::VkImageViewASTCDecodeModeEXT::Reader reader){
        auto result=VkImageViewASTCDecodeModeEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.decodeMode)=reader.getDecodeMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewASTCDecodeModeEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewASTCDecodeModeEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceASTCDecodeFeaturesEXT::Builder& builder, VkPhysicalDeviceASTCDecodeFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDecodeModeSharedExponent((member.decodeModeSharedExponent));}();}();
}

    VkPhysicalDeviceASTCDecodeFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceASTCDecodeFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceASTCDecodeFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.decodeModeSharedExponent)=reader.getDecodeModeSharedExponent();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceASTCDecodeFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceASTCDecodeFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTransformFeedbackFeaturesEXT::Builder& builder, VkPhysicalDeviceTransformFeedbackFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTransformFeedback((member.transformFeedback));}();}();
[&](){[&](){return builder.setGeometryStreams((member.geometryStreams));}();}();
}

    VkPhysicalDeviceTransformFeedbackFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceTransformFeedbackFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceTransformFeedbackFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.transformFeedback)=reader.getTransformFeedback();}();}();
[&](){[&](){(result.geometryStreams)=reader.getGeometryStreams();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTransformFeedbackFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTransformFeedbackFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTransformFeedbackPropertiesEXT::Builder& builder, VkPhysicalDeviceTransformFeedbackPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxTransformFeedbackStreams((member.maxTransformFeedbackStreams));}();
[&](){return builder.setMaxTransformFeedbackBuffers((member.maxTransformFeedbackBuffers));}();
[&](){[&](){return builder.setMaxTransformFeedbackBufferSize((member.maxTransformFeedbackBufferSize));}();}();
[&](){return builder.setMaxTransformFeedbackStreamDataSize((member.maxTransformFeedbackStreamDataSize));}();
[&](){return builder.setMaxTransformFeedbackBufferDataSize((member.maxTransformFeedbackBufferDataSize));}();
[&](){return builder.setMaxTransformFeedbackBufferDataStride((member.maxTransformFeedbackBufferDataStride));}();
[&](){[&](){return builder.setTransformFeedbackQueries((member.transformFeedbackQueries));}();}();
[&](){[&](){return builder.setTransformFeedbackStreamsLinesTriangles((member.transformFeedbackStreamsLinesTriangles));}();}();
[&](){[&](){return builder.setTransformFeedbackRasterizationStreamSelect((member.transformFeedbackRasterizationStreamSelect));}();}();
[&](){[&](){return builder.setTransformFeedbackDraw((member.transformFeedbackDraw));}();}();
}

    VkPhysicalDeviceTransformFeedbackPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceTransformFeedbackPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceTransformFeedbackPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxTransformFeedbackStreams)=reader.getMaxTransformFeedbackStreams();}();
[&](){(result.maxTransformFeedbackBuffers)=reader.getMaxTransformFeedbackBuffers();}();
[&](){[&](){(result.maxTransformFeedbackBufferSize)=reader.getMaxTransformFeedbackBufferSize();}();}();
[&](){(result.maxTransformFeedbackStreamDataSize)=reader.getMaxTransformFeedbackStreamDataSize();}();
[&](){(result.maxTransformFeedbackBufferDataSize)=reader.getMaxTransformFeedbackBufferDataSize();}();
[&](){(result.maxTransformFeedbackBufferDataStride)=reader.getMaxTransformFeedbackBufferDataStride();}();
[&](){[&](){(result.transformFeedbackQueries)=reader.getTransformFeedbackQueries();}();}();
[&](){[&](){(result.transformFeedbackStreamsLinesTriangles)=reader.getTransformFeedbackStreamsLinesTriangles();}();}();
[&](){[&](){(result.transformFeedbackRasterizationStreamSelect)=reader.getTransformFeedbackRasterizationStreamSelect();}();}();
[&](){[&](){(result.transformFeedbackDraw)=reader.getTransformFeedbackDraw();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTransformFeedbackPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTransformFeedbackPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRasterizationStateStreamCreateInfoEXT::Builder& builder, VkPipelineRasterizationStateStreamCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setRasterizationStream((member.rasterizationStream));}();
}

    VkPipelineRasterizationStateStreamCreateInfoEXT deserialize_struct(stream::VkPipelineRasterizationStateStreamCreateInfoEXT::Reader reader){
        auto result=VkPipelineRasterizationStateStreamCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.rasterizationStream)=reader.getRasterizationStream();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRasterizationStateStreamCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRasterizationStateStreamCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::Builder& builder, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRepresentativeFragmentTest((member.representativeFragmentTest));}();}();
}

    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV deserialize_struct(stream::VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.representativeFragmentTest)=reader.getRepresentativeFragmentTest();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRepresentativeFragmentTestStateCreateInfoNV::Builder& builder, VkPipelineRepresentativeFragmentTestStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRepresentativeFragmentTestEnable((member.representativeFragmentTestEnable));}();}();
}

    VkPipelineRepresentativeFragmentTestStateCreateInfoNV deserialize_struct(stream::VkPipelineRepresentativeFragmentTestStateCreateInfoNV::Reader reader){
        auto result=VkPipelineRepresentativeFragmentTestStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.representativeFragmentTestEnable)=reader.getRepresentativeFragmentTestEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRepresentativeFragmentTestStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRepresentativeFragmentTestStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExclusiveScissorFeaturesNV::Builder& builder, VkPhysicalDeviceExclusiveScissorFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setExclusiveScissor((member.exclusiveScissor));}();}();
}

    VkPhysicalDeviceExclusiveScissorFeaturesNV deserialize_struct(stream::VkPhysicalDeviceExclusiveScissorFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceExclusiveScissorFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.exclusiveScissor)=reader.getExclusiveScissor();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExclusiveScissorFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExclusiveScissorFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineViewportExclusiveScissorStateCreateInfoNV::Builder& builder, VkPipelineViewportExclusiveScissorStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setExclusiveScissorCount((member.exclusiveScissorCount));}();
[&](){
            if ((member.pExclusiveScissors)==NULL){
                builder.initPExclusiveScissors(0);
            return; }
        auto proto_arr=builder.initPExclusiveScissors(member.exclusiveScissorCount);
        for(int hDCzNLp=0; hDCzNLp < member.exclusiveScissorCount; hDCzNLp++){
            [&](){
            auto temp=proto_arr[hDCzNLp];
            return serialize_struct(temp, ((member.pExclusiveScissors)[hDCzNLp]));
            }();
        }
        }();
}

    VkPipelineViewportExclusiveScissorStateCreateInfoNV deserialize_struct(stream::VkPipelineViewportExclusiveScissorStateCreateInfoNV::Reader reader){
        auto result=VkPipelineViewportExclusiveScissorStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.exclusiveScissorCount)=reader.getExclusiveScissorCount();}();
[&](){ VkRect2D* temp_HNTfgYD[&](){
            if (!reader.getPExclusiveScissors().size()==0){
                (result.pExclusiveScissors)=NULL;
            return; }{native_concat()}=(VkRect2D*)malloc(result.exclusiveScissorCount*sizeof(VkRect2D));
        auto proto_arr=reader.getPExclusiveScissors(result.exclusiveScissorCount);
        for(int gpvLKLX=0; gpvLKLX < result.exclusiveScissorCount; gpvLKLX++){
            [&](){
            auto temp=proto_arr[gpvLKLX];
            ((result.pExclusiveScissors)[gpvLKLX])=deserialize_struct(temp);
            }();
        }
        }();(result.pExclusiveScissors)=temp_HNTfgYD;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineViewportExclusiveScissorStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineViewportExclusiveScissorStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCornerSampledImageFeaturesNV::Builder& builder, VkPhysicalDeviceCornerSampledImageFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCornerSampledImage((member.cornerSampledImage));}();}();
}

    VkPhysicalDeviceCornerSampledImageFeaturesNV deserialize_struct(stream::VkPhysicalDeviceCornerSampledImageFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceCornerSampledImageFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.cornerSampledImage)=reader.getCornerSampledImage();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCornerSampledImageFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCornerSampledImageFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::Builder& builder, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setComputeDerivativeGroupQuads((member.computeDerivativeGroupQuads));}();}();
[&](){[&](){return builder.setComputeDerivativeGroupLinear((member.computeDerivativeGroupLinear));}();}();
}

    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV deserialize_struct(stream::VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.computeDerivativeGroupQuads)=reader.getComputeDerivativeGroupQuads();}();}();
[&](){[&](){(result.computeDerivativeGroupLinear)=reader.getComputeDerivativeGroupLinear();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceComputeShaderDerivativesFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderImageFootprintFeaturesNV::Builder& builder, VkPhysicalDeviceShaderImageFootprintFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setImageFootprint((member.imageFootprint));}();}();
}

    VkPhysicalDeviceShaderImageFootprintFeaturesNV deserialize_struct(stream::VkPhysicalDeviceShaderImageFootprintFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceShaderImageFootprintFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.imageFootprint)=reader.getImageFootprint();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderImageFootprintFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderImageFootprintFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::Builder& builder, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDedicatedAllocationImageAliasing((member.dedicatedAllocationImageAliasing));}();}();
}

    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV deserialize_struct(stream::VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.dedicatedAllocationImageAliasing)=reader.getDedicatedAllocationImageAliasing();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCopyMemoryIndirectFeaturesNV::Builder& builder, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setIndirectCopy((member.indirectCopy));}();}();
}

    VkPhysicalDeviceCopyMemoryIndirectFeaturesNV deserialize_struct(stream::VkPhysicalDeviceCopyMemoryIndirectFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceCopyMemoryIndirectFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.indirectCopy)=reader.getIndirectCopy();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCopyMemoryIndirectPropertiesNV::Builder& builder, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSupportedQueues((member.supportedQueues));}();}();}();
}

    VkPhysicalDeviceCopyMemoryIndirectPropertiesNV deserialize_struct(stream::VkPhysicalDeviceCopyMemoryIndirectPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceCopyMemoryIndirectPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.supportedQueues)=reader.getSupportedQueues();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMemoryDecompressionFeaturesNV::Builder& builder, VkPhysicalDeviceMemoryDecompressionFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMemoryDecompression((member.memoryDecompression));}();}();
}

    VkPhysicalDeviceMemoryDecompressionFeaturesNV deserialize_struct(stream::VkPhysicalDeviceMemoryDecompressionFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceMemoryDecompressionFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.memoryDecompression)=reader.getMemoryDecompression();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMemoryDecompressionFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMemoryDecompressionFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMemoryDecompressionPropertiesNV::Builder& builder, VkPhysicalDeviceMemoryDecompressionPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDecompressionMethods((member.decompressionMethods));}();}();}();
[&](){return builder.setMaxDecompressionIndirectCount((member.maxDecompressionIndirectCount));}();
}

    VkPhysicalDeviceMemoryDecompressionPropertiesNV deserialize_struct(stream::VkPhysicalDeviceMemoryDecompressionPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceMemoryDecompressionPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.decompressionMethods)=reader.getDecompressionMethods();}();}();}();
[&](){(result.maxDecompressionIndirectCount)=reader.getMaxDecompressionIndirectCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMemoryDecompressionPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMemoryDecompressionPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkShadingRatePaletteNV::Builder& builder, VkShadingRatePaletteNV member){
        
    
[&](){return builder.setShadingRatePaletteEntryCount((member.shadingRatePaletteEntryCount));}();
[&](){
            if ((member.pShadingRatePaletteEntries)==NULL){
                builder.initPShadingRatePaletteEntries(0);
            return; }
        auto proto_arr=builder.initPShadingRatePaletteEntries(member.shadingRatePaletteEntryCount);
        for(int yMnmzQx=0; yMnmzQx < member.shadingRatePaletteEntryCount; yMnmzQx++){
            [&](){[&](){[&](){return proto_arr.set(yMnmzQx,((member.pShadingRatePaletteEntries)[yMnmzQx]));}();}();}();
        }
        }();
}

    VkShadingRatePaletteNV deserialize_struct(stream::VkShadingRatePaletteNV::Reader reader){
        auto result=VkShadingRatePaletteNV();
    
[&](){(result.shadingRatePaletteEntryCount)=reader.getShadingRatePaletteEntryCount();}();
[&](){ VkShadingRatePaletteEntryNV* temp_jixKdSV[&](){
            if (!reader.getPShadingRatePaletteEntries().size()==0){
                (result.pShadingRatePaletteEntries)=NULL;
            return; }{native_concat()}=(VkShadingRatePaletteEntryNV*)malloc(result.shadingRatePaletteEntryCount*sizeof(VkShadingRatePaletteEntryNV));
        auto proto_arr=reader.getPShadingRatePaletteEntries(result.shadingRatePaletteEntryCount);
        for(int qHFlNbq=0; qHFlNbq < result.shadingRatePaletteEntryCount; qHFlNbq++){
            [&](){[&](){[&](){((result.pShadingRatePaletteEntries)[qHFlNbq])=proto_arr[qHFlNbq];}();}();}();
        }
        }();(result.pShadingRatePaletteEntries)=temp_jixKdSV;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkShadingRatePaletteNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkShadingRatePaletteNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineViewportShadingRateImageStateCreateInfoNV::Builder& builder, VkPipelineViewportShadingRateImageStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShadingRateImageEnable((member.shadingRateImageEnable));}();}();
[&](){return builder.setViewportCount((member.viewportCount));}();
[&](){
            if ((member.pShadingRatePalettes)==NULL){
                builder.initPShadingRatePalettes(0);
            return; }
        auto proto_arr=builder.initPShadingRatePalettes(member.viewportCount);
        for(int CEwDDNk=0; CEwDDNk < member.viewportCount; CEwDDNk++){
            [&](){
            auto temp=proto_arr[CEwDDNk];
            return serialize_struct(temp, ((member.pShadingRatePalettes)[CEwDDNk]));
            }();
        }
        }();
}

    VkPipelineViewportShadingRateImageStateCreateInfoNV deserialize_struct(stream::VkPipelineViewportShadingRateImageStateCreateInfoNV::Reader reader){
        auto result=VkPipelineViewportShadingRateImageStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.shadingRateImageEnable)=reader.getShadingRateImageEnable();}();}();
[&](){(result.viewportCount)=reader.getViewportCount();}();
[&](){ VkShadingRatePaletteNV* temp_NLCwpLF[&](){
            if (!reader.getPShadingRatePalettes().size()==0){
                (result.pShadingRatePalettes)=NULL;
            return; }{native_concat()}=(VkShadingRatePaletteNV*)malloc(result.viewportCount*sizeof(VkShadingRatePaletteNV));
        auto proto_arr=reader.getPShadingRatePalettes(result.viewportCount);
        for(int YEHriqV=0; YEHriqV < result.viewportCount; YEHriqV++){
            [&](){
            auto temp=proto_arr[YEHriqV];
            ((result.pShadingRatePalettes)[YEHriqV])=deserialize_struct(temp);
            }();
        }
        }();(result.pShadingRatePalettes)=temp_NLCwpLF;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineViewportShadingRateImageStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineViewportShadingRateImageStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShadingRateImageFeaturesNV::Builder& builder, VkPhysicalDeviceShadingRateImageFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShadingRateImage((member.shadingRateImage));}();}();
[&](){[&](){return builder.setShadingRateCoarseSampleOrder((member.shadingRateCoarseSampleOrder));}();}();
}

    VkPhysicalDeviceShadingRateImageFeaturesNV deserialize_struct(stream::VkPhysicalDeviceShadingRateImageFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceShadingRateImageFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shadingRateImage)=reader.getShadingRateImage();}();}();
[&](){[&](){(result.shadingRateCoarseSampleOrder)=reader.getShadingRateCoarseSampleOrder();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShadingRateImageFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShadingRateImageFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShadingRateImagePropertiesNV::Builder& builder, VkPhysicalDeviceShadingRateImagePropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initShadingRateTexelSize(shadingRateTexelSize);
            return serialize_struct(temp, (member.shadingRateTexelSize));
            }();
[&](){return builder.setShadingRatePaletteSize((member.shadingRatePaletteSize));}();
[&](){return builder.setShadingRateMaxCoarseSamples((member.shadingRateMaxCoarseSamples));}();
}

    VkPhysicalDeviceShadingRateImagePropertiesNV deserialize_struct(stream::VkPhysicalDeviceShadingRateImagePropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceShadingRateImagePropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getShadingRateTexelSize();
            (result.shadingRateTexelSize)=deserialize_struct(temp);
            }();
[&](){(result.shadingRatePaletteSize)=reader.getShadingRatePaletteSize();}();
[&](){(result.shadingRateMaxCoarseSamples)=reader.getShadingRateMaxCoarseSamples();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShadingRateImagePropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShadingRateImagePropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceInvocationMaskFeaturesHUAWEI::Builder& builder, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setInvocationMask((member.invocationMask));}();}();
}

    VkPhysicalDeviceInvocationMaskFeaturesHUAWEI deserialize_struct(stream::VkPhysicalDeviceInvocationMaskFeaturesHUAWEI::Reader reader){
        auto result=VkPhysicalDeviceInvocationMaskFeaturesHUAWEI();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.invocationMask)=reader.getInvocationMask();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCoarseSampleLocationNV::Builder& builder, VkCoarseSampleLocationNV member){
        
    
[&](){return builder.setPixelX((member.pixelX));}();
[&](){return builder.setPixelY((member.pixelY));}();
[&](){return builder.setSample((member.sample));}();
}

    VkCoarseSampleLocationNV deserialize_struct(stream::VkCoarseSampleLocationNV::Reader reader){
        auto result=VkCoarseSampleLocationNV();
    
[&](){(result.pixelX)=reader.getPixelX();}();
[&](){(result.pixelY)=reader.getPixelY();}();
[&](){(result.sample)=reader.getSample();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCoarseSampleLocationNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCoarseSampleLocationNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCoarseSampleOrderCustomNV::Builder& builder, VkCoarseSampleOrderCustomNV member){
        
    
[&](){[&](){[&](){return builder.setShadingRate((member.shadingRate));}();}();}();
[&](){return builder.setSampleCount((member.sampleCount));}();
[&](){return builder.setSampleLocationCount((member.sampleLocationCount));}();
[&](){
            if ((member.pSampleLocations)==NULL){
                builder.initPSampleLocations(0);
            return; }
        auto proto_arr=builder.initPSampleLocations(member.sampleLocationCount);
        for(int zloWrCx=0; zloWrCx < member.sampleLocationCount; zloWrCx++){
            [&](){
            auto temp=proto_arr[zloWrCx];
            return serialize_struct(temp, ((member.pSampleLocations)[zloWrCx]));
            }();
        }
        }();
}

    VkCoarseSampleOrderCustomNV deserialize_struct(stream::VkCoarseSampleOrderCustomNV::Reader reader){
        auto result=VkCoarseSampleOrderCustomNV();
    
[&](){[&](){[&](){(result.shadingRate)=reader.getShadingRate();}();}();}();
[&](){(result.sampleCount)=reader.getSampleCount();}();
[&](){(result.sampleLocationCount)=reader.getSampleLocationCount();}();
[&](){ VkCoarseSampleLocationNV* temp_GFCinfA[&](){
            if (!reader.getPSampleLocations().size()==0){
                (result.pSampleLocations)=NULL;
            return; }{native_concat()}=(VkCoarseSampleLocationNV*)malloc(result.sampleLocationCount*sizeof(VkCoarseSampleLocationNV));
        auto proto_arr=reader.getPSampleLocations(result.sampleLocationCount);
        for(int nGkqqOa=0; nGkqqOa < result.sampleLocationCount; nGkqqOa++){
            [&](){
            auto temp=proto_arr[nGkqqOa];
            ((result.pSampleLocations)[nGkqqOa])=deserialize_struct(temp);
            }();
        }
        }();(result.pSampleLocations)=temp_GFCinfA;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCoarseSampleOrderCustomNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCoarseSampleOrderCustomNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::Builder& builder, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSampleOrderType((member.sampleOrderType));}();}();}();
[&](){return builder.setCustomSampleOrderCount((member.customSampleOrderCount));}();
[&](){
            if ((member.pCustomSampleOrders)==NULL){
                builder.initPCustomSampleOrders(0);
            return; }
        auto proto_arr=builder.initPCustomSampleOrders(member.customSampleOrderCount);
        for(int rRLekif=0; rRLekif < member.customSampleOrderCount; rRLekif++){
            [&](){
            auto temp=proto_arr[rRLekif];
            return serialize_struct(temp, ((member.pCustomSampleOrders)[rRLekif]));
            }();
        }
        }();
}

    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV deserialize_struct(stream::VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::Reader reader){
        auto result=VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.sampleOrderType)=reader.getSampleOrderType();}();}();}();
[&](){(result.customSampleOrderCount)=reader.getCustomSampleOrderCount();}();
[&](){ VkCoarseSampleOrderCustomNV* temp_SaWbkHv[&](){
            if (!reader.getPCustomSampleOrders().size()==0){
                (result.pCustomSampleOrders)=NULL;
            return; }{native_concat()}=(VkCoarseSampleOrderCustomNV*)malloc(result.customSampleOrderCount*sizeof(VkCoarseSampleOrderCustomNV));
        auto proto_arr=reader.getPCustomSampleOrders(result.customSampleOrderCount);
        for(int LhLuItc=0; LhLuItc < result.customSampleOrderCount; LhLuItc++){
            [&](){
            auto temp=proto_arr[LhLuItc];
            ((result.pCustomSampleOrders)[LhLuItc])=deserialize_struct(temp);
            }();
        }
        }();(result.pCustomSampleOrders)=temp_SaWbkHv;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineViewportCoarseSampleOrderStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMeshShaderFeaturesNV::Builder& builder, VkPhysicalDeviceMeshShaderFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTaskShader((member.taskShader));}();}();
[&](){[&](){return builder.setMeshShader((member.meshShader));}();}();
}

    VkPhysicalDeviceMeshShaderFeaturesNV deserialize_struct(stream::VkPhysicalDeviceMeshShaderFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceMeshShaderFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.taskShader)=reader.getTaskShader();}();}();
[&](){[&](){(result.meshShader)=reader.getMeshShader();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMeshShaderFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMeshShaderFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMeshShaderPropertiesNV::Builder& builder, VkPhysicalDeviceMeshShaderPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxDrawMeshTasksCount((member.maxDrawMeshTasksCount));}();
[&](){return builder.setMaxTaskWorkGroupInvocations((member.maxTaskWorkGroupInvocations));}();
[&](){
        auto proto_arr=builder.initMaxTaskWorkGroupSize(3);
        for(int FICAZzf=0; FICAZzf < 3; FICAZzf++){
            [&](){return proto_arr.set(FICAZzf,((member.maxTaskWorkGroupSize)[FICAZzf]));}();
        }
        }();
[&](){return builder.setMaxTaskTotalMemorySize((member.maxTaskTotalMemorySize));}();
[&](){return builder.setMaxTaskOutputCount((member.maxTaskOutputCount));}();
[&](){return builder.setMaxMeshWorkGroupInvocations((member.maxMeshWorkGroupInvocations));}();
[&](){
        auto proto_arr=builder.initMaxMeshWorkGroupSize(3);
        for(int FHeKNFR=0; FHeKNFR < 3; FHeKNFR++){
            [&](){return proto_arr.set(FHeKNFR,((member.maxMeshWorkGroupSize)[FHeKNFR]));}();
        }
        }();
[&](){return builder.setMaxMeshTotalMemorySize((member.maxMeshTotalMemorySize));}();
[&](){return builder.setMaxMeshOutputVertices((member.maxMeshOutputVertices));}();
[&](){return builder.setMaxMeshOutputPrimitives((member.maxMeshOutputPrimitives));}();
[&](){return builder.setMaxMeshMultiviewViewCount((member.maxMeshMultiviewViewCount));}();
[&](){return builder.setMeshOutputPerVertexGranularity((member.meshOutputPerVertexGranularity));}();
[&](){return builder.setMeshOutputPerPrimitiveGranularity((member.meshOutputPerPrimitiveGranularity));}();
}

    VkPhysicalDeviceMeshShaderPropertiesNV deserialize_struct(stream::VkPhysicalDeviceMeshShaderPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceMeshShaderPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxDrawMeshTasksCount)=reader.getMaxDrawMeshTasksCount();}();
[&](){(result.maxTaskWorkGroupInvocations)=reader.getMaxTaskWorkGroupInvocations();}();
[&](){
        auto proto_arr=reader.getMaxTaskWorkGroupSize(3);
        for(int FICAZzf=0; FICAZzf < 3; FICAZzf++){
            [&](){((result.maxTaskWorkGroupSize)[FICAZzf])=proto_arr[FICAZzf];}();
        }
        }();
[&](){(result.maxTaskTotalMemorySize)=reader.getMaxTaskTotalMemorySize();}();
[&](){(result.maxTaskOutputCount)=reader.getMaxTaskOutputCount();}();
[&](){(result.maxMeshWorkGroupInvocations)=reader.getMaxMeshWorkGroupInvocations();}();
[&](){
        auto proto_arr=reader.getMaxMeshWorkGroupSize(3);
        for(int FHeKNFR=0; FHeKNFR < 3; FHeKNFR++){
            [&](){((result.maxMeshWorkGroupSize)[FHeKNFR])=proto_arr[FHeKNFR];}();
        }
        }();
[&](){(result.maxMeshTotalMemorySize)=reader.getMaxMeshTotalMemorySize();}();
[&](){(result.maxMeshOutputVertices)=reader.getMaxMeshOutputVertices();}();
[&](){(result.maxMeshOutputPrimitives)=reader.getMaxMeshOutputPrimitives();}();
[&](){(result.maxMeshMultiviewViewCount)=reader.getMaxMeshMultiviewViewCount();}();
[&](){(result.meshOutputPerVertexGranularity)=reader.getMeshOutputPerVertexGranularity();}();
[&](){(result.meshOutputPerPrimitiveGranularity)=reader.getMeshOutputPerPrimitiveGranularity();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMeshShaderPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMeshShaderPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrawMeshTasksIndirectCommandNV::Builder& builder, VkDrawMeshTasksIndirectCommandNV member){
        
    
[&](){return builder.setTaskCount((member.taskCount));}();
[&](){return builder.setFirstTask((member.firstTask));}();
}

    VkDrawMeshTasksIndirectCommandNV deserialize_struct(stream::VkDrawMeshTasksIndirectCommandNV::Reader reader){
        auto result=VkDrawMeshTasksIndirectCommandNV();
    
[&](){(result.taskCount)=reader.getTaskCount();}();
[&](){(result.firstTask)=reader.getFirstTask();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrawMeshTasksIndirectCommandNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrawMeshTasksIndirectCommandNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMeshShaderFeaturesEXT::Builder& builder, VkPhysicalDeviceMeshShaderFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTaskShader((member.taskShader));}();}();
[&](){[&](){return builder.setMeshShader((member.meshShader));}();}();
[&](){[&](){return builder.setMultiviewMeshShader((member.multiviewMeshShader));}();}();
[&](){[&](){return builder.setPrimitiveFragmentShadingRateMeshShader((member.primitiveFragmentShadingRateMeshShader));}();}();
[&](){[&](){return builder.setMeshShaderQueries((member.meshShaderQueries));}();}();
}

    VkPhysicalDeviceMeshShaderFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceMeshShaderFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceMeshShaderFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.taskShader)=reader.getTaskShader();}();}();
[&](){[&](){(result.meshShader)=reader.getMeshShader();}();}();
[&](){[&](){(result.multiviewMeshShader)=reader.getMultiviewMeshShader();}();}();
[&](){[&](){(result.primitiveFragmentShadingRateMeshShader)=reader.getPrimitiveFragmentShadingRateMeshShader();}();}();
[&](){[&](){(result.meshShaderQueries)=reader.getMeshShaderQueries();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMeshShaderFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMeshShaderFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMeshShaderPropertiesEXT::Builder& builder, VkPhysicalDeviceMeshShaderPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxTaskWorkGroupTotalCount((member.maxTaskWorkGroupTotalCount));}();
[&](){
        auto proto_arr=builder.initMaxTaskWorkGroupCount(3);
        for(int MDHjwFq=0; MDHjwFq < 3; MDHjwFq++){
            [&](){return proto_arr.set(MDHjwFq,((member.maxTaskWorkGroupCount)[MDHjwFq]));}();
        }
        }();
[&](){return builder.setMaxTaskWorkGroupInvocations((member.maxTaskWorkGroupInvocations));}();
[&](){
        auto proto_arr=builder.initMaxTaskWorkGroupSize(3);
        for(int FICAZzf=0; FICAZzf < 3; FICAZzf++){
            [&](){return proto_arr.set(FICAZzf,((member.maxTaskWorkGroupSize)[FICAZzf]));}();
        }
        }();
[&](){return builder.setMaxTaskPayloadSize((member.maxTaskPayloadSize));}();
[&](){return builder.setMaxTaskSharedMemorySize((member.maxTaskSharedMemorySize));}();
[&](){return builder.setMaxTaskPayloadAndSharedMemorySize((member.maxTaskPayloadAndSharedMemorySize));}();
[&](){return builder.setMaxMeshWorkGroupTotalCount((member.maxMeshWorkGroupTotalCount));}();
[&](){
        auto proto_arr=builder.initMaxMeshWorkGroupCount(3);
        for(int ZnMehla=0; ZnMehla < 3; ZnMehla++){
            [&](){return proto_arr.set(ZnMehla,((member.maxMeshWorkGroupCount)[ZnMehla]));}();
        }
        }();
[&](){return builder.setMaxMeshWorkGroupInvocations((member.maxMeshWorkGroupInvocations));}();
[&](){
        auto proto_arr=builder.initMaxMeshWorkGroupSize(3);
        for(int FHeKNFR=0; FHeKNFR < 3; FHeKNFR++){
            [&](){return proto_arr.set(FHeKNFR,((member.maxMeshWorkGroupSize)[FHeKNFR]));}();
        }
        }();
[&](){return builder.setMaxMeshSharedMemorySize((member.maxMeshSharedMemorySize));}();
[&](){return builder.setMaxMeshPayloadAndSharedMemorySize((member.maxMeshPayloadAndSharedMemorySize));}();
[&](){return builder.setMaxMeshOutputMemorySize((member.maxMeshOutputMemorySize));}();
[&](){return builder.setMaxMeshPayloadAndOutputMemorySize((member.maxMeshPayloadAndOutputMemorySize));}();
[&](){return builder.setMaxMeshOutputComponents((member.maxMeshOutputComponents));}();
[&](){return builder.setMaxMeshOutputVertices((member.maxMeshOutputVertices));}();
[&](){return builder.setMaxMeshOutputPrimitives((member.maxMeshOutputPrimitives));}();
[&](){return builder.setMaxMeshOutputLayers((member.maxMeshOutputLayers));}();
[&](){return builder.setMaxMeshMultiviewViewCount((member.maxMeshMultiviewViewCount));}();
[&](){return builder.setMeshOutputPerVertexGranularity((member.meshOutputPerVertexGranularity));}();
[&](){return builder.setMeshOutputPerPrimitiveGranularity((member.meshOutputPerPrimitiveGranularity));}();
[&](){return builder.setMaxPreferredTaskWorkGroupInvocations((member.maxPreferredTaskWorkGroupInvocations));}();
[&](){return builder.setMaxPreferredMeshWorkGroupInvocations((member.maxPreferredMeshWorkGroupInvocations));}();
[&](){[&](){return builder.setPrefersLocalInvocationVertexOutput((member.prefersLocalInvocationVertexOutput));}();}();
[&](){[&](){return builder.setPrefersLocalInvocationPrimitiveOutput((member.prefersLocalInvocationPrimitiveOutput));}();}();
[&](){[&](){return builder.setPrefersCompactVertexOutput((member.prefersCompactVertexOutput));}();}();
[&](){[&](){return builder.setPrefersCompactPrimitiveOutput((member.prefersCompactPrimitiveOutput));}();}();
}

    VkPhysicalDeviceMeshShaderPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceMeshShaderPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceMeshShaderPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxTaskWorkGroupTotalCount)=reader.getMaxTaskWorkGroupTotalCount();}();
[&](){
        auto proto_arr=reader.getMaxTaskWorkGroupCount(3);
        for(int MDHjwFq=0; MDHjwFq < 3; MDHjwFq++){
            [&](){((result.maxTaskWorkGroupCount)[MDHjwFq])=proto_arr[MDHjwFq];}();
        }
        }();
[&](){(result.maxTaskWorkGroupInvocations)=reader.getMaxTaskWorkGroupInvocations();}();
[&](){
        auto proto_arr=reader.getMaxTaskWorkGroupSize(3);
        for(int FICAZzf=0; FICAZzf < 3; FICAZzf++){
            [&](){((result.maxTaskWorkGroupSize)[FICAZzf])=proto_arr[FICAZzf];}();
        }
        }();
[&](){(result.maxTaskPayloadSize)=reader.getMaxTaskPayloadSize();}();
[&](){(result.maxTaskSharedMemorySize)=reader.getMaxTaskSharedMemorySize();}();
[&](){(result.maxTaskPayloadAndSharedMemorySize)=reader.getMaxTaskPayloadAndSharedMemorySize();}();
[&](){(result.maxMeshWorkGroupTotalCount)=reader.getMaxMeshWorkGroupTotalCount();}();
[&](){
        auto proto_arr=reader.getMaxMeshWorkGroupCount(3);
        for(int ZnMehla=0; ZnMehla < 3; ZnMehla++){
            [&](){((result.maxMeshWorkGroupCount)[ZnMehla])=proto_arr[ZnMehla];}();
        }
        }();
[&](){(result.maxMeshWorkGroupInvocations)=reader.getMaxMeshWorkGroupInvocations();}();
[&](){
        auto proto_arr=reader.getMaxMeshWorkGroupSize(3);
        for(int FHeKNFR=0; FHeKNFR < 3; FHeKNFR++){
            [&](){((result.maxMeshWorkGroupSize)[FHeKNFR])=proto_arr[FHeKNFR];}();
        }
        }();
[&](){(result.maxMeshSharedMemorySize)=reader.getMaxMeshSharedMemorySize();}();
[&](){(result.maxMeshPayloadAndSharedMemorySize)=reader.getMaxMeshPayloadAndSharedMemorySize();}();
[&](){(result.maxMeshOutputMemorySize)=reader.getMaxMeshOutputMemorySize();}();
[&](){(result.maxMeshPayloadAndOutputMemorySize)=reader.getMaxMeshPayloadAndOutputMemorySize();}();
[&](){(result.maxMeshOutputComponents)=reader.getMaxMeshOutputComponents();}();
[&](){(result.maxMeshOutputVertices)=reader.getMaxMeshOutputVertices();}();
[&](){(result.maxMeshOutputPrimitives)=reader.getMaxMeshOutputPrimitives();}();
[&](){(result.maxMeshOutputLayers)=reader.getMaxMeshOutputLayers();}();
[&](){(result.maxMeshMultiviewViewCount)=reader.getMaxMeshMultiviewViewCount();}();
[&](){(result.meshOutputPerVertexGranularity)=reader.getMeshOutputPerVertexGranularity();}();
[&](){(result.meshOutputPerPrimitiveGranularity)=reader.getMeshOutputPerPrimitiveGranularity();}();
[&](){(result.maxPreferredTaskWorkGroupInvocations)=reader.getMaxPreferredTaskWorkGroupInvocations();}();
[&](){(result.maxPreferredMeshWorkGroupInvocations)=reader.getMaxPreferredMeshWorkGroupInvocations();}();
[&](){[&](){(result.prefersLocalInvocationVertexOutput)=reader.getPrefersLocalInvocationVertexOutput();}();}();
[&](){[&](){(result.prefersLocalInvocationPrimitiveOutput)=reader.getPrefersLocalInvocationPrimitiveOutput();}();}();
[&](){[&](){(result.prefersCompactVertexOutput)=reader.getPrefersCompactVertexOutput();}();}();
[&](){[&](){(result.prefersCompactPrimitiveOutput)=reader.getPrefersCompactPrimitiveOutput();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMeshShaderPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMeshShaderPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrawMeshTasksIndirectCommandEXT::Builder& builder, VkDrawMeshTasksIndirectCommandEXT member){
        
    
[&](){return builder.setGroupCountX((member.groupCountX));}();
[&](){return builder.setGroupCountY((member.groupCountY));}();
[&](){return builder.setGroupCountZ((member.groupCountZ));}();
}

    VkDrawMeshTasksIndirectCommandEXT deserialize_struct(stream::VkDrawMeshTasksIndirectCommandEXT::Reader reader){
        auto result=VkDrawMeshTasksIndirectCommandEXT();
    
[&](){(result.groupCountX)=reader.getGroupCountX();}();
[&](){(result.groupCountY)=reader.getGroupCountY();}();
[&](){(result.groupCountZ)=reader.getGroupCountZ();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrawMeshTasksIndirectCommandEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrawMeshTasksIndirectCommandEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRayTracingShaderGroupCreateInfoNV::Builder& builder, VkRayTracingShaderGroupCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){return builder.setGeneralShader((member.generalShader));}();
[&](){return builder.setClosestHitShader((member.closestHitShader));}();
[&](){return builder.setAnyHitShader((member.anyHitShader));}();
[&](){return builder.setIntersectionShader((member.intersectionShader));}();
}

    VkRayTracingShaderGroupCreateInfoNV deserialize_struct(stream::VkRayTracingShaderGroupCreateInfoNV::Reader reader){
        auto result=VkRayTracingShaderGroupCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){(result.generalShader)=reader.getGeneralShader();}();
[&](){(result.closestHitShader)=reader.getClosestHitShader();}();
[&](){(result.anyHitShader)=reader.getAnyHitShader();}();
[&](){(result.intersectionShader)=reader.getIntersectionShader();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRayTracingShaderGroupCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRayTracingShaderGroupCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRayTracingShaderGroupCreateInfoKHR::Builder& builder, VkRayTracingShaderGroupCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){return builder.setGeneralShader((member.generalShader));}();
[&](){return builder.setClosestHitShader((member.closestHitShader));}();
[&](){return builder.setAnyHitShader((member.anyHitShader));}();
[&](){return builder.setIntersectionShader((member.intersectionShader));}();
[&](){
            if ((member.pShaderGroupCaptureReplayHandle)==NULL){
                builder.initPShaderGroupCaptureReplayHandle(0);
            return; }[&](){
            if (((char*)(member.pShaderGroupCaptureReplayHandle).pShaderGroupCaptureReplayHandle)==NULL){
                builder.initPShaderGroupCaptureReplayHandle(0);
            return; }
        auto proto_arr=builder.initPShaderGroupCaptureReplayHandle(strlen(((char*)(member.pShaderGroupCaptureReplayHandle).pShaderGroupCaptureReplayHandle))+1);
        for(int vaFpFFZ=0; vaFpFFZ < strlen(((char*)(member.pShaderGroupCaptureReplayHandle).pShaderGroupCaptureReplayHandle))+1; vaFpFFZ++){
            [&](){return proto_arr.set(vaFpFFZ,(((char*)(member.pShaderGroupCaptureReplayHandle).pShaderGroupCaptureReplayHandle)[vaFpFFZ]));}();
        }
        }();}();
}

    VkRayTracingShaderGroupCreateInfoKHR deserialize_struct(stream::VkRayTracingShaderGroupCreateInfoKHR::Reader reader){
        auto result=VkRayTracingShaderGroupCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){(result.generalShader)=reader.getGeneralShader();}();
[&](){(result.closestHitShader)=reader.getClosestHitShader();}();
[&](){(result.anyHitShader)=reader.getAnyHitShader();}();
[&](){(result.intersectionShader)=reader.getIntersectionShader();}();
[&](){ void* temp_lEgunrI[&](){
            if (!reader.getPShaderGroupCaptureReplayHandle().size()==0){
                (result.pShaderGroupCaptureReplayHandle)=NULL;
            return; }char* temp_qcvhJvn;[&](){
            if (!reader.getPShaderGroupCaptureReplayHandle().size()==0){
                (temp_qcvhJvn.pShaderGroupCaptureReplayHandle)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPShaderGroupCaptureReplayHandle().size();*sizeof(char));
        auto proto_arr=reader.getPShaderGroupCaptureReplayHandle(reader.getPShaderGroupCaptureReplayHandle().size(););
        for(int aGsUsXt=0; aGsUsXt < reader.getPShaderGroupCaptureReplayHandle().size();; aGsUsXt++){
            [&](){((temp_qcvhJvn.pShaderGroupCaptureReplayHandle)[aGsUsXt])=proto_arr[aGsUsXt];}();
        }
        }();(result.pShaderGroupCaptureReplayHandle)=temp_qcvhJvn;}();(result.pShaderGroupCaptureReplayHandle)=temp_lEgunrI;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRayTracingShaderGroupCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRayTracingShaderGroupCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRayTracingPipelineCreateInfoNV::Builder& builder, VkRayTracingPipelineCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setStageCount((member.stageCount));}();
[&](){
            if ((member.pStages)==NULL){
                builder.initPStages(0);
            return; }
        auto proto_arr=builder.initPStages(member.stageCount);
        for(int jHuRulk=0; jHuRulk < member.stageCount; jHuRulk++){
            [&](){
            auto temp=proto_arr[jHuRulk];
            return serialize_struct(temp, ((member.pStages)[jHuRulk]));
            }();
        }
        }();
[&](){return builder.setGroupCount((member.groupCount));}();
[&](){
            if ((member.pGroups)==NULL){
                builder.initPGroups(0);
            return; }
        auto proto_arr=builder.initPGroups(member.groupCount);
        for(int PfCnxjX=0; PfCnxjX < member.groupCount; PfCnxjX++){
            [&](){
            auto temp=proto_arr[PfCnxjX];
            return serialize_struct(temp, ((member.pGroups)[PfCnxjX]));
            }();
        }
        }();
[&](){return builder.setMaxRecursionDepth((member.maxRecursionDepth));}();
[&](){return builder.setLayout(serialize_handle(member.layout));}();
[&](){return builder.setBasePipelineHandle(serialize_handle(member.basePipelineHandle));}();
[&](){return builder.setBasePipelineIndex((member.basePipelineIndex));}();
}

    VkRayTracingPipelineCreateInfoNV deserialize_struct(stream::VkRayTracingPipelineCreateInfoNV::Reader reader){
        auto result=VkRayTracingPipelineCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.stageCount)=reader.getStageCount();}();
[&](){ VkPipelineShaderStageCreateInfo* temp_FsQxpon[&](){
            if (!reader.getPStages().size()==0){
                (result.pStages)=NULL;
            return; }{native_concat()}=(VkPipelineShaderStageCreateInfo*)malloc(result.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto proto_arr=reader.getPStages(result.stageCount);
        for(int XttzcgZ=0; XttzcgZ < result.stageCount; XttzcgZ++){
            [&](){
            auto temp=proto_arr[XttzcgZ];
            ((result.pStages)[XttzcgZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pStages)=temp_FsQxpon;}();
[&](){(result.groupCount)=reader.getGroupCount();}();
[&](){ VkRayTracingShaderGroupCreateInfoNV* temp_jFtlmol[&](){
            if (!reader.getPGroups().size()==0){
                (result.pGroups)=NULL;
            return; }{native_concat()}=(VkRayTracingShaderGroupCreateInfoNV*)malloc(result.groupCount*sizeof(VkRayTracingShaderGroupCreateInfoNV));
        auto proto_arr=reader.getPGroups(result.groupCount);
        for(int gtOdutD=0; gtOdutD < result.groupCount; gtOdutD++){
            [&](){
            auto temp=proto_arr[gtOdutD];
            ((result.pGroups)[gtOdutD])=deserialize_struct(temp);
            }();
        }
        }();(result.pGroups)=temp_jFtlmol;}();
[&](){(result.maxRecursionDepth)=reader.getMaxRecursionDepth();}();
[&](){(result.layout)=deserialize_VkPipelineLayout(reader.getLayout());}();
[&](){(result.basePipelineHandle)=deserialize_VkPipeline(reader.getBasePipelineHandle());}();
[&](){(result.basePipelineIndex)=reader.getBasePipelineIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRayTracingPipelineCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRayTracingPipelineCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRayTracingPipelineCreateInfoKHR::Builder& builder, VkRayTracingPipelineCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setStageCount((member.stageCount));}();
[&](){
            if ((member.pStages)==NULL){
                builder.initPStages(0);
            return; }
        auto proto_arr=builder.initPStages(member.stageCount);
        for(int jHuRulk=0; jHuRulk < member.stageCount; jHuRulk++){
            [&](){
            auto temp=proto_arr[jHuRulk];
            return serialize_struct(temp, ((member.pStages)[jHuRulk]));
            }();
        }
        }();
[&](){return builder.setGroupCount((member.groupCount));}();
[&](){
            if ((member.pGroups)==NULL){
                builder.initPGroups(0);
            return; }
        auto proto_arr=builder.initPGroups(member.groupCount);
        for(int zJRUzRJ=0; zJRUzRJ < member.groupCount; zJRUzRJ++){
            [&](){
            auto temp=proto_arr[zJRUzRJ];
            return serialize_struct(temp, ((member.pGroups)[zJRUzRJ]));
            }();
        }
        }();
[&](){return builder.setMaxPipelineRayRecursionDepth((member.maxPipelineRayRecursionDepth));}();
[&](){
            if ((member.pLibraryInfo)==NULL){
                builder.initPLibraryInfo(0);
            return; }
        auto proto_arr=builder.initPLibraryInfo(1);
        for(int DdrfJLf=0; DdrfJLf < 1; DdrfJLf++){
            [&](){
            auto temp=proto_arr[DdrfJLf];
            return serialize_struct(temp, ((member.pLibraryInfo)[DdrfJLf]));
            }();
        }
        }();
[&](){
            if ((member.pLibraryInterface)==NULL){
                builder.initPLibraryInterface(0);
            return; }
        auto proto_arr=builder.initPLibraryInterface(1);
        for(int mKbYlgK=0; mKbYlgK < 1; mKbYlgK++){
            [&](){
            auto temp=proto_arr[mKbYlgK];
            return serialize_struct(temp, ((member.pLibraryInterface)[mKbYlgK]));
            }();
        }
        }();
[&](){
            if ((member.pDynamicState)==NULL){
                builder.initPDynamicState(0);
            return; }
        auto proto_arr=builder.initPDynamicState(1);
        for(int UhXMcnS=0; UhXMcnS < 1; UhXMcnS++){
            [&](){
            auto temp=proto_arr[UhXMcnS];
            return serialize_struct(temp, ((member.pDynamicState)[UhXMcnS]));
            }();
        }
        }();
[&](){return builder.setLayout(serialize_handle(member.layout));}();
[&](){return builder.setBasePipelineHandle(serialize_handle(member.basePipelineHandle));}();
[&](){return builder.setBasePipelineIndex((member.basePipelineIndex));}();
}

    VkRayTracingPipelineCreateInfoKHR deserialize_struct(stream::VkRayTracingPipelineCreateInfoKHR::Reader reader){
        auto result=VkRayTracingPipelineCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.stageCount)=reader.getStageCount();}();
[&](){ VkPipelineShaderStageCreateInfo* temp_FsQxpon[&](){
            if (!reader.getPStages().size()==0){
                (result.pStages)=NULL;
            return; }{native_concat()}=(VkPipelineShaderStageCreateInfo*)malloc(result.stageCount*sizeof(VkPipelineShaderStageCreateInfo));
        auto proto_arr=reader.getPStages(result.stageCount);
        for(int XttzcgZ=0; XttzcgZ < result.stageCount; XttzcgZ++){
            [&](){
            auto temp=proto_arr[XttzcgZ];
            ((result.pStages)[XttzcgZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pStages)=temp_FsQxpon;}();
[&](){(result.groupCount)=reader.getGroupCount();}();
[&](){ VkRayTracingShaderGroupCreateInfoKHR* temp_SQVJuSU[&](){
            if (!reader.getPGroups().size()==0){
                (result.pGroups)=NULL;
            return; }{native_concat()}=(VkRayTracingShaderGroupCreateInfoKHR*)malloc(result.groupCount*sizeof(VkRayTracingShaderGroupCreateInfoKHR));
        auto proto_arr=reader.getPGroups(result.groupCount);
        for(int MsMuUIr=0; MsMuUIr < result.groupCount; MsMuUIr++){
            [&](){
            auto temp=proto_arr[MsMuUIr];
            ((result.pGroups)[MsMuUIr])=deserialize_struct(temp);
            }();
        }
        }();(result.pGroups)=temp_SQVJuSU;}();
[&](){(result.maxPipelineRayRecursionDepth)=reader.getMaxPipelineRayRecursionDepth();}();
[&](){ VkPipelineLibraryCreateInfoKHR* temp_eGVDWeB[&](){
            if (!reader.getPLibraryInfo().size()==0){
                (result.pLibraryInfo)=NULL;
            return; }{native_concat()}=(VkPipelineLibraryCreateInfoKHR*)malloc(1*sizeof(VkPipelineLibraryCreateInfoKHR));
        auto proto_arr=reader.getPLibraryInfo(1);
        for(int QEKAhqX=0; QEKAhqX < 1; QEKAhqX++){
            [&](){
            auto temp=proto_arr[QEKAhqX];
            ((result.pLibraryInfo)[QEKAhqX])=deserialize_struct(temp);
            }();
        }
        }();(result.pLibraryInfo)=temp_eGVDWeB;}();
[&](){ VkRayTracingPipelineInterfaceCreateInfoKHR* temp_PFNRuCj[&](){
            if (!reader.getPLibraryInterface().size()==0){
                (result.pLibraryInterface)=NULL;
            return; }{native_concat()}=(VkRayTracingPipelineInterfaceCreateInfoKHR*)malloc(1*sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR));
        auto proto_arr=reader.getPLibraryInterface(1);
        for(int NuMUcpj=0; NuMUcpj < 1; NuMUcpj++){
            [&](){
            auto temp=proto_arr[NuMUcpj];
            ((result.pLibraryInterface)[NuMUcpj])=deserialize_struct(temp);
            }();
        }
        }();(result.pLibraryInterface)=temp_PFNRuCj;}();
[&](){ VkPipelineDynamicStateCreateInfo* temp_aXXcKaH[&](){
            if (!reader.getPDynamicState().size()==0){
                (result.pDynamicState)=NULL;
            return; }{native_concat()}=(VkPipelineDynamicStateCreateInfo*)malloc(1*sizeof(VkPipelineDynamicStateCreateInfo));
        auto proto_arr=reader.getPDynamicState(1);
        for(int tTovUVg=0; tTovUVg < 1; tTovUVg++){
            [&](){
            auto temp=proto_arr[tTovUVg];
            ((result.pDynamicState)[tTovUVg])=deserialize_struct(temp);
            }();
        }
        }();(result.pDynamicState)=temp_aXXcKaH;}();
[&](){(result.layout)=deserialize_VkPipelineLayout(reader.getLayout());}();
[&](){(result.basePipelineHandle)=deserialize_VkPipeline(reader.getBasePipelineHandle());}();
[&](){(result.basePipelineIndex)=reader.getBasePipelineIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRayTracingPipelineCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRayTracingPipelineCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGeometryTrianglesNV::Builder& builder, VkGeometryTrianglesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setVertexData(serialize_handle(member.vertexData));}();
[&](){[&](){return builder.setVertexOffset((member.vertexOffset));}();}();
[&](){return builder.setVertexCount((member.vertexCount));}();
[&](){[&](){return builder.setVertexStride((member.vertexStride));}();}();
[&](){[&](){[&](){return builder.setVertexFormat((member.vertexFormat));}();}();}();
[&](){return builder.setIndexData(serialize_handle(member.indexData));}();
[&](){[&](){return builder.setIndexOffset((member.indexOffset));}();}();
[&](){return builder.setIndexCount((member.indexCount));}();
[&](){[&](){[&](){return builder.setIndexType((member.indexType));}();}();}();
[&](){return builder.setTransformData(serialize_handle(member.transformData));}();
[&](){[&](){return builder.setTransformOffset((member.transformOffset));}();}();
}

    VkGeometryTrianglesNV deserialize_struct(stream::VkGeometryTrianglesNV::Reader reader){
        auto result=VkGeometryTrianglesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.vertexData)=deserialize_VkBuffer(reader.getVertexData());}();
[&](){[&](){(result.vertexOffset)=reader.getVertexOffset();}();}();
[&](){(result.vertexCount)=reader.getVertexCount();}();
[&](){[&](){(result.vertexStride)=reader.getVertexStride();}();}();
[&](){[&](){[&](){(result.vertexFormat)=reader.getVertexFormat();}();}();}();
[&](){(result.indexData)=deserialize_VkBuffer(reader.getIndexData());}();
[&](){[&](){(result.indexOffset)=reader.getIndexOffset();}();}();
[&](){(result.indexCount)=reader.getIndexCount();}();
[&](){[&](){[&](){(result.indexType)=reader.getIndexType();}();}();}();
[&](){(result.transformData)=deserialize_VkBuffer(reader.getTransformData());}();
[&](){[&](){(result.transformOffset)=reader.getTransformOffset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGeometryTrianglesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGeometryTrianglesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGeometryAABBNV::Builder& builder, VkGeometryAABBNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAabbData(serialize_handle(member.aabbData));}();
[&](){return builder.setNumAABBs((member.numAABBs));}();
[&](){return builder.setStride((member.stride));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
}

    VkGeometryAABBNV deserialize_struct(stream::VkGeometryAABBNV::Reader reader){
        auto result=VkGeometryAABBNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.aabbData)=deserialize_VkBuffer(reader.getAabbData());}();
[&](){(result.numAABBs)=reader.getNumAABBs();}();
[&](){(result.stride)=reader.getStride();}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGeometryAABBNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGeometryAABBNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGeometryDataNV::Builder& builder, VkGeometryDataNV member){
        
    
[&](){
            auto temp=builder.initTriangles(triangles);
            return serialize_struct(temp, (member.triangles));
            }();
[&](){
            auto temp=builder.initAabbs(aabbs);
            return serialize_struct(temp, (member.aabbs));
            }();
}

    VkGeometryDataNV deserialize_struct(stream::VkGeometryDataNV::Reader reader){
        auto result=VkGeometryDataNV();
    
[&](){
            auto temp=reader.getTriangles();
            (result.triangles)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getAabbs();
            (result.aabbs)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGeometryDataNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGeometryDataNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGeometryNV::Builder& builder, VkGeometryNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setGeometryType((member.geometryType));}();}();}();
[&](){
            auto temp=builder.initGeometry(geometry);
            return serialize_struct(temp, (member.geometry));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkGeometryNV deserialize_struct(stream::VkGeometryNV::Reader reader){
        auto result=VkGeometryNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.geometryType)=reader.getGeometryType();}();}();}();
[&](){
            auto temp=reader.getGeometry();
            (result.geometry)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGeometryNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGeometryNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureInfoNV::Builder& builder, VkAccelerationStructureInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setInstanceCount((member.instanceCount));}();
[&](){return builder.setGeometryCount((member.geometryCount));}();
[&](){
            if ((member.pGeometries)==NULL){
                builder.initPGeometries(0);
            return; }
        auto proto_arr=builder.initPGeometries(member.geometryCount);
        for(int qVtknfQ=0; qVtknfQ < member.geometryCount; qVtknfQ++){
            [&](){
            auto temp=proto_arr[qVtknfQ];
            return serialize_struct(temp, ((member.pGeometries)[qVtknfQ]));
            }();
        }
        }();
}

    VkAccelerationStructureInfoNV deserialize_struct(stream::VkAccelerationStructureInfoNV::Reader reader){
        auto result=VkAccelerationStructureInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.instanceCount)=reader.getInstanceCount();}();
[&](){(result.geometryCount)=reader.getGeometryCount();}();
[&](){ VkGeometryNV* temp_MuazCQD[&](){
            if (!reader.getPGeometries().size()==0){
                (result.pGeometries)=NULL;
            return; }{native_concat()}=(VkGeometryNV*)malloc(result.geometryCount*sizeof(VkGeometryNV));
        auto proto_arr=reader.getPGeometries(result.geometryCount);
        for(int TTzXkkB=0; TTzXkkB < result.geometryCount; TTzXkkB++){
            [&](){
            auto temp=proto_arr[TTzXkkB];
            ((result.pGeometries)[TTzXkkB])=deserialize_struct(temp);
            }();
        }
        }();(result.pGeometries)=temp_MuazCQD;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureCreateInfoNV::Builder& builder, VkAccelerationStructureCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCompactedSize((member.compactedSize));}();}();
[&](){
            auto temp=builder.initInfo(info);
            return serialize_struct(temp, (member.info));
            }();
}

    VkAccelerationStructureCreateInfoNV deserialize_struct(stream::VkAccelerationStructureCreateInfoNV::Reader reader){
        auto result=VkAccelerationStructureCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.compactedSize)=reader.getCompactedSize();}();}();
[&](){
            auto temp=reader.getInfo();
            (result.info)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindAccelerationStructureMemoryInfoNV::Builder& builder, VkBindAccelerationStructureMemoryInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAccelerationStructure(serialize_handle(member.accelerationStructure));}();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setMemoryOffset((member.memoryOffset));}();}();
[&](){return builder.setDeviceIndexCount((member.deviceIndexCount));}();
[&](){
            if ((member.pDeviceIndices)==NULL){
                builder.initPDeviceIndices(0);
            return; }
        auto proto_arr=builder.initPDeviceIndices(member.deviceIndexCount);
        for(int lNKjpBY=0; lNKjpBY < member.deviceIndexCount; lNKjpBY++){
            [&](){return proto_arr.set(lNKjpBY,((member.pDeviceIndices)[lNKjpBY]));}();
        }
        }();
}

    VkBindAccelerationStructureMemoryInfoNV deserialize_struct(stream::VkBindAccelerationStructureMemoryInfoNV::Reader reader){
        auto result=VkBindAccelerationStructureMemoryInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.accelerationStructure)=deserialize_VkAccelerationStructureNV(reader.getAccelerationStructure());}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.memoryOffset)=reader.getMemoryOffset();}();}();
[&](){(result.deviceIndexCount)=reader.getDeviceIndexCount();}();
[&](){ uint32_t* temp_chbZwCP[&](){
            if (!reader.getPDeviceIndices().size()==0){
                (result.pDeviceIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.deviceIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPDeviceIndices(result.deviceIndexCount);
        for(int CQTEfmn=0; CQTEfmn < result.deviceIndexCount; CQTEfmn++){
            [&](){((result.pDeviceIndices)[CQTEfmn])=proto_arr[CQTEfmn];}();
        }
        }();(result.pDeviceIndices)=temp_chbZwCP;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindAccelerationStructureMemoryInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindAccelerationStructureMemoryInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkWriteDescriptorSetAccelerationStructureKHR::Builder& builder, VkWriteDescriptorSetAccelerationStructureKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAccelerationStructureCount((member.accelerationStructureCount));}();
[&](){
            if ((member.pAccelerationStructures)==NULL){
                builder.initPAccelerationStructures(0);
            return; }
        auto proto_arr=builder.initPAccelerationStructures(member.accelerationStructureCount);
        for(int lMRNMMP=0; lMRNMMP < member.accelerationStructureCount; lMRNMMP++){
            [&](){return proto_arr.set(lMRNMMP,serialize_handle((member.pAccelerationStructures)[lMRNMMP]));}();
        }
        }();
}

    VkWriteDescriptorSetAccelerationStructureKHR deserialize_struct(stream::VkWriteDescriptorSetAccelerationStructureKHR::Reader reader){
        auto result=VkWriteDescriptorSetAccelerationStructureKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.accelerationStructureCount)=reader.getAccelerationStructureCount();}();
[&](){ VkAccelerationStructureKHR* temp_BpvvoAe[&](){
            if (!reader.getPAccelerationStructures().size()==0){
                (result.pAccelerationStructures)=NULL;
            return; }{native_concat()}=(VkAccelerationStructureKHR*)malloc(result.accelerationStructureCount*sizeof(VkAccelerationStructureKHR));
        auto proto_arr=reader.getPAccelerationStructures(result.accelerationStructureCount);
        for(int YTGbDyo=0; YTGbDyo < result.accelerationStructureCount; YTGbDyo++){
            [&](){((result.pAccelerationStructures)[YTGbDyo])=deserialize_VkAccelerationStructureKHR(proto_arr[YTGbDyo]);}();
        }
        }();(result.pAccelerationStructures)=temp_BpvvoAe;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkWriteDescriptorSetAccelerationStructureKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkWriteDescriptorSetAccelerationStructureKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkWriteDescriptorSetAccelerationStructureNV::Builder& builder, VkWriteDescriptorSetAccelerationStructureNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAccelerationStructureCount((member.accelerationStructureCount));}();
[&](){
            if ((member.pAccelerationStructures)==NULL){
                builder.initPAccelerationStructures(0);
            return; }
        auto proto_arr=builder.initPAccelerationStructures(member.accelerationStructureCount);
        for(int BJXIzdF=0; BJXIzdF < member.accelerationStructureCount; BJXIzdF++){
            [&](){return proto_arr.set(BJXIzdF,serialize_handle((member.pAccelerationStructures)[BJXIzdF]));}();
        }
        }();
}

    VkWriteDescriptorSetAccelerationStructureNV deserialize_struct(stream::VkWriteDescriptorSetAccelerationStructureNV::Reader reader){
        auto result=VkWriteDescriptorSetAccelerationStructureNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.accelerationStructureCount)=reader.getAccelerationStructureCount();}();
[&](){ VkAccelerationStructureNV* temp_iPYWuqu[&](){
            if (!reader.getPAccelerationStructures().size()==0){
                (result.pAccelerationStructures)=NULL;
            return; }{native_concat()}=(VkAccelerationStructureNV*)malloc(result.accelerationStructureCount*sizeof(VkAccelerationStructureNV));
        auto proto_arr=reader.getPAccelerationStructures(result.accelerationStructureCount);
        for(int AvXgXgJ=0; AvXgXgJ < result.accelerationStructureCount; AvXgXgJ++){
            [&](){((result.pAccelerationStructures)[AvXgXgJ])=deserialize_VkAccelerationStructureNV(proto_arr[AvXgXgJ]);}();
        }
        }();(result.pAccelerationStructures)=temp_iPYWuqu;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkWriteDescriptorSetAccelerationStructureNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkWriteDescriptorSetAccelerationStructureNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureMemoryRequirementsInfoNV::Builder& builder, VkAccelerationStructureMemoryRequirementsInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){return builder.setAccelerationStructure(serialize_handle(member.accelerationStructure));}();
}

    VkAccelerationStructureMemoryRequirementsInfoNV deserialize_struct(stream::VkAccelerationStructureMemoryRequirementsInfoNV::Reader reader){
        auto result=VkAccelerationStructureMemoryRequirementsInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){(result.accelerationStructure)=deserialize_VkAccelerationStructureNV(reader.getAccelerationStructure());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureMemoryRequirementsInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureMemoryRequirementsInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceAccelerationStructureFeaturesKHR::Builder& builder, VkPhysicalDeviceAccelerationStructureFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAccelerationStructure((member.accelerationStructure));}();}();
[&](){[&](){return builder.setAccelerationStructureCaptureReplay((member.accelerationStructureCaptureReplay));}();}();
[&](){[&](){return builder.setAccelerationStructureIndirectBuild((member.accelerationStructureIndirectBuild));}();}();
[&](){[&](){return builder.setAccelerationStructureHostCommands((member.accelerationStructureHostCommands));}();}();
[&](){[&](){return builder.setDescriptorBindingAccelerationStructureUpdateAfterBind((member.descriptorBindingAccelerationStructureUpdateAfterBind));}();}();
}

    VkPhysicalDeviceAccelerationStructureFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceAccelerationStructureFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceAccelerationStructureFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.accelerationStructure)=reader.getAccelerationStructure();}();}();
[&](){[&](){(result.accelerationStructureCaptureReplay)=reader.getAccelerationStructureCaptureReplay();}();}();
[&](){[&](){(result.accelerationStructureIndirectBuild)=reader.getAccelerationStructureIndirectBuild();}();}();
[&](){[&](){(result.accelerationStructureHostCommands)=reader.getAccelerationStructureHostCommands();}();}();
[&](){[&](){(result.descriptorBindingAccelerationStructureUpdateAfterBind)=reader.getDescriptorBindingAccelerationStructureUpdateAfterBind();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceAccelerationStructureFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceAccelerationStructureFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingPipelineFeaturesKHR::Builder& builder, VkPhysicalDeviceRayTracingPipelineFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRayTracingPipeline((member.rayTracingPipeline));}();}();
[&](){[&](){return builder.setRayTracingPipelineShaderGroupHandleCaptureReplay((member.rayTracingPipelineShaderGroupHandleCaptureReplay));}();}();
[&](){[&](){return builder.setRayTracingPipelineShaderGroupHandleCaptureReplayMixed((member.rayTracingPipelineShaderGroupHandleCaptureReplayMixed));}();}();
[&](){[&](){return builder.setRayTracingPipelineTraceRaysIndirect((member.rayTracingPipelineTraceRaysIndirect));}();}();
[&](){[&](){return builder.setRayTraversalPrimitiveCulling((member.rayTraversalPrimitiveCulling));}();}();
}

    VkPhysicalDeviceRayTracingPipelineFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceRayTracingPipelineFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceRayTracingPipelineFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rayTracingPipeline)=reader.getRayTracingPipeline();}();}();
[&](){[&](){(result.rayTracingPipelineShaderGroupHandleCaptureReplay)=reader.getRayTracingPipelineShaderGroupHandleCaptureReplay();}();}();
[&](){[&](){(result.rayTracingPipelineShaderGroupHandleCaptureReplayMixed)=reader.getRayTracingPipelineShaderGroupHandleCaptureReplayMixed();}();}();
[&](){[&](){(result.rayTracingPipelineTraceRaysIndirect)=reader.getRayTracingPipelineTraceRaysIndirect();}();}();
[&](){[&](){(result.rayTraversalPrimitiveCulling)=reader.getRayTraversalPrimitiveCulling();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingPipelineFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingPipelineFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayQueryFeaturesKHR::Builder& builder, VkPhysicalDeviceRayQueryFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRayQuery((member.rayQuery));}();}();
}

    VkPhysicalDeviceRayQueryFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceRayQueryFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceRayQueryFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rayQuery)=reader.getRayQuery();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayQueryFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayQueryFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceAccelerationStructurePropertiesKHR::Builder& builder, VkPhysicalDeviceAccelerationStructurePropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxGeometryCount((member.maxGeometryCount));}();
[&](){return builder.setMaxInstanceCount((member.maxInstanceCount));}();
[&](){return builder.setMaxPrimitiveCount((member.maxPrimitiveCount));}();
[&](){return builder.setMaxPerStageDescriptorAccelerationStructures((member.maxPerStageDescriptorAccelerationStructures));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindAccelerationStructures((member.maxPerStageDescriptorUpdateAfterBindAccelerationStructures));}();
[&](){return builder.setMaxDescriptorSetAccelerationStructures((member.maxDescriptorSetAccelerationStructures));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindAccelerationStructures((member.maxDescriptorSetUpdateAfterBindAccelerationStructures));}();
[&](){return builder.setMinAccelerationStructureScratchOffsetAlignment((member.minAccelerationStructureScratchOffsetAlignment));}();
}

    VkPhysicalDeviceAccelerationStructurePropertiesKHR deserialize_struct(stream::VkPhysicalDeviceAccelerationStructurePropertiesKHR::Reader reader){
        auto result=VkPhysicalDeviceAccelerationStructurePropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxGeometryCount)=reader.getMaxGeometryCount();}();
[&](){(result.maxInstanceCount)=reader.getMaxInstanceCount();}();
[&](){(result.maxPrimitiveCount)=reader.getMaxPrimitiveCount();}();
[&](){(result.maxPerStageDescriptorAccelerationStructures)=reader.getMaxPerStageDescriptorAccelerationStructures();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindAccelerationStructures)=reader.getMaxPerStageDescriptorUpdateAfterBindAccelerationStructures();}();
[&](){(result.maxDescriptorSetAccelerationStructures)=reader.getMaxDescriptorSetAccelerationStructures();}();
[&](){(result.maxDescriptorSetUpdateAfterBindAccelerationStructures)=reader.getMaxDescriptorSetUpdateAfterBindAccelerationStructures();}();
[&](){(result.minAccelerationStructureScratchOffsetAlignment)=reader.getMinAccelerationStructureScratchOffsetAlignment();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceAccelerationStructurePropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceAccelerationStructurePropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingPipelinePropertiesKHR::Builder& builder, VkPhysicalDeviceRayTracingPipelinePropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setShaderGroupHandleSize((member.shaderGroupHandleSize));}();
[&](){return builder.setMaxRayRecursionDepth((member.maxRayRecursionDepth));}();
[&](){return builder.setMaxShaderGroupStride((member.maxShaderGroupStride));}();
[&](){return builder.setShaderGroupBaseAlignment((member.shaderGroupBaseAlignment));}();
[&](){return builder.setShaderGroupHandleCaptureReplaySize((member.shaderGroupHandleCaptureReplaySize));}();
[&](){return builder.setMaxRayDispatchInvocationCount((member.maxRayDispatchInvocationCount));}();
[&](){return builder.setShaderGroupHandleAlignment((member.shaderGroupHandleAlignment));}();
[&](){return builder.setMaxRayHitAttributeSize((member.maxRayHitAttributeSize));}();
}

    VkPhysicalDeviceRayTracingPipelinePropertiesKHR deserialize_struct(stream::VkPhysicalDeviceRayTracingPipelinePropertiesKHR::Reader reader){
        auto result=VkPhysicalDeviceRayTracingPipelinePropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.shaderGroupHandleSize)=reader.getShaderGroupHandleSize();}();
[&](){(result.maxRayRecursionDepth)=reader.getMaxRayRecursionDepth();}();
[&](){(result.maxShaderGroupStride)=reader.getMaxShaderGroupStride();}();
[&](){(result.shaderGroupBaseAlignment)=reader.getShaderGroupBaseAlignment();}();
[&](){(result.shaderGroupHandleCaptureReplaySize)=reader.getShaderGroupHandleCaptureReplaySize();}();
[&](){(result.maxRayDispatchInvocationCount)=reader.getMaxRayDispatchInvocationCount();}();
[&](){(result.shaderGroupHandleAlignment)=reader.getShaderGroupHandleAlignment();}();
[&](){(result.maxRayHitAttributeSize)=reader.getMaxRayHitAttributeSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingPipelinePropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingPipelinePropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingPropertiesNV::Builder& builder, VkPhysicalDeviceRayTracingPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setShaderGroupHandleSize((member.shaderGroupHandleSize));}();
[&](){return builder.setMaxRecursionDepth((member.maxRecursionDepth));}();
[&](){return builder.setMaxShaderGroupStride((member.maxShaderGroupStride));}();
[&](){return builder.setShaderGroupBaseAlignment((member.shaderGroupBaseAlignment));}();
[&](){return builder.setMaxGeometryCount((member.maxGeometryCount));}();
[&](){return builder.setMaxInstanceCount((member.maxInstanceCount));}();
[&](){return builder.setMaxTriangleCount((member.maxTriangleCount));}();
[&](){return builder.setMaxDescriptorSetAccelerationStructures((member.maxDescriptorSetAccelerationStructures));}();
}

    VkPhysicalDeviceRayTracingPropertiesNV deserialize_struct(stream::VkPhysicalDeviceRayTracingPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceRayTracingPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.shaderGroupHandleSize)=reader.getShaderGroupHandleSize();}();
[&](){(result.maxRecursionDepth)=reader.getMaxRecursionDepth();}();
[&](){(result.maxShaderGroupStride)=reader.getMaxShaderGroupStride();}();
[&](){(result.shaderGroupBaseAlignment)=reader.getShaderGroupBaseAlignment();}();
[&](){(result.maxGeometryCount)=reader.getMaxGeometryCount();}();
[&](){(result.maxInstanceCount)=reader.getMaxInstanceCount();}();
[&](){(result.maxTriangleCount)=reader.getMaxTriangleCount();}();
[&](){(result.maxDescriptorSetAccelerationStructures)=reader.getMaxDescriptorSetAccelerationStructures();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkStridedDeviceAddressRegionKHR::Builder& builder, VkStridedDeviceAddressRegionKHR member){
        
    
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
[&](){[&](){return builder.setStride((member.stride));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkStridedDeviceAddressRegionKHR deserialize_struct(stream::VkStridedDeviceAddressRegionKHR::Reader reader){
        auto result=VkStridedDeviceAddressRegionKHR();
    
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
[&](){[&](){(result.stride)=reader.getStride();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkStridedDeviceAddressRegionKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkStridedDeviceAddressRegionKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkTraceRaysIndirectCommandKHR::Builder& builder, VkTraceRaysIndirectCommandKHR member){
        
    
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
[&](){return builder.setDepth((member.depth));}();
}

    VkTraceRaysIndirectCommandKHR deserialize_struct(stream::VkTraceRaysIndirectCommandKHR::Reader reader){
        auto result=VkTraceRaysIndirectCommandKHR();
    
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
[&](){(result.depth)=reader.getDepth();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkTraceRaysIndirectCommandKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkTraceRaysIndirectCommandKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkTraceRaysIndirectCommand2KHR::Builder& builder, VkTraceRaysIndirectCommand2KHR member){
        
    
[&](){[&](){return builder.setRaygenShaderRecordAddress((member.raygenShaderRecordAddress));}();}();
[&](){[&](){return builder.setRaygenShaderRecordSize((member.raygenShaderRecordSize));}();}();
[&](){[&](){return builder.setMissShaderBindingTableAddress((member.missShaderBindingTableAddress));}();}();
[&](){[&](){return builder.setMissShaderBindingTableSize((member.missShaderBindingTableSize));}();}();
[&](){[&](){return builder.setMissShaderBindingTableStride((member.missShaderBindingTableStride));}();}();
[&](){[&](){return builder.setHitShaderBindingTableAddress((member.hitShaderBindingTableAddress));}();}();
[&](){[&](){return builder.setHitShaderBindingTableSize((member.hitShaderBindingTableSize));}();}();
[&](){[&](){return builder.setHitShaderBindingTableStride((member.hitShaderBindingTableStride));}();}();
[&](){[&](){return builder.setCallableShaderBindingTableAddress((member.callableShaderBindingTableAddress));}();}();
[&](){[&](){return builder.setCallableShaderBindingTableSize((member.callableShaderBindingTableSize));}();}();
[&](){[&](){return builder.setCallableShaderBindingTableStride((member.callableShaderBindingTableStride));}();}();
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
[&](){return builder.setDepth((member.depth));}();
}

    VkTraceRaysIndirectCommand2KHR deserialize_struct(stream::VkTraceRaysIndirectCommand2KHR::Reader reader){
        auto result=VkTraceRaysIndirectCommand2KHR();
    
[&](){[&](){(result.raygenShaderRecordAddress)=reader.getRaygenShaderRecordAddress();}();}();
[&](){[&](){(result.raygenShaderRecordSize)=reader.getRaygenShaderRecordSize();}();}();
[&](){[&](){(result.missShaderBindingTableAddress)=reader.getMissShaderBindingTableAddress();}();}();
[&](){[&](){(result.missShaderBindingTableSize)=reader.getMissShaderBindingTableSize();}();}();
[&](){[&](){(result.missShaderBindingTableStride)=reader.getMissShaderBindingTableStride();}();}();
[&](){[&](){(result.hitShaderBindingTableAddress)=reader.getHitShaderBindingTableAddress();}();}();
[&](){[&](){(result.hitShaderBindingTableSize)=reader.getHitShaderBindingTableSize();}();}();
[&](){[&](){(result.hitShaderBindingTableStride)=reader.getHitShaderBindingTableStride();}();}();
[&](){[&](){(result.callableShaderBindingTableAddress)=reader.getCallableShaderBindingTableAddress();}();}();
[&](){[&](){(result.callableShaderBindingTableSize)=reader.getCallableShaderBindingTableSize();}();}();
[&](){[&](){(result.callableShaderBindingTableStride)=reader.getCallableShaderBindingTableStride();}();}();
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
[&](){(result.depth)=reader.getDepth();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkTraceRaysIndirectCommand2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkTraceRaysIndirectCommand2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR::Builder& builder, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRayTracingMaintenance1((member.rayTracingMaintenance1));}();}();
[&](){[&](){return builder.setRayTracingPipelineTraceRaysIndirect2((member.rayTracingPipelineTraceRaysIndirect2));}();}();
}

    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR deserialize_struct(stream::VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rayTracingMaintenance1)=reader.getRayTracingMaintenance1();}();}();
[&](){[&](){(result.rayTracingPipelineTraceRaysIndirect2)=reader.getRayTracingPipelineTraceRaysIndirect2();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrmFormatModifierPropertiesListEXT::Builder& builder, VkDrmFormatModifierPropertiesListEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDrmFormatModifierCount((member.drmFormatModifierCount));}();
[&](){
            if ((member.pDrmFormatModifierProperties)==NULL){
                builder.initPDrmFormatModifierProperties(0);
            return; }
        auto proto_arr=builder.initPDrmFormatModifierProperties(member.drmFormatModifierCount);
        for(int ZzracqV=0; ZzracqV < member.drmFormatModifierCount; ZzracqV++){
            [&](){
            auto temp=proto_arr[ZzracqV];
            return serialize_struct(temp, ((member.pDrmFormatModifierProperties)[ZzracqV]));
            }();
        }
        }();
}

    VkDrmFormatModifierPropertiesListEXT deserialize_struct(stream::VkDrmFormatModifierPropertiesListEXT::Reader reader){
        auto result=VkDrmFormatModifierPropertiesListEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.drmFormatModifierCount)=reader.getDrmFormatModifierCount();}();
[&](){
            if (!reader.getPDrmFormatModifierProperties().size()==0){
                (result.pDrmFormatModifierProperties)=NULL;
            return; }{native_concat()}=(VkDrmFormatModifierPropertiesEXT*)malloc(result.drmFormatModifierCount*sizeof(VkDrmFormatModifierPropertiesEXT));
        auto proto_arr=reader.getPDrmFormatModifierProperties(result.drmFormatModifierCount);
        for(int ZzracqV=0; ZzracqV < result.drmFormatModifierCount; ZzracqV++){
            [&](){
            auto temp=proto_arr[ZzracqV];
            ((result.pDrmFormatModifierProperties)[ZzracqV])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrmFormatModifierPropertiesListEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrmFormatModifierPropertiesListEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrmFormatModifierPropertiesEXT::Builder& builder, VkDrmFormatModifierPropertiesEXT member){
        
    
[&](){return builder.setDrmFormatModifier((member.drmFormatModifier));}();
[&](){return builder.setDrmFormatModifierPlaneCount((member.drmFormatModifierPlaneCount));}();
[&](){[&](){[&](){return builder.setDrmFormatModifierTilingFeatures((member.drmFormatModifierTilingFeatures));}();}();}();
}

    VkDrmFormatModifierPropertiesEXT deserialize_struct(stream::VkDrmFormatModifierPropertiesEXT::Reader reader){
        auto result=VkDrmFormatModifierPropertiesEXT();
    
[&](){(result.drmFormatModifier)=reader.getDrmFormatModifier();}();
[&](){(result.drmFormatModifierPlaneCount)=reader.getDrmFormatModifierPlaneCount();}();
[&](){[&](){[&](){(result.drmFormatModifierTilingFeatures)=reader.getDrmFormatModifierTilingFeatures();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrmFormatModifierPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrmFormatModifierPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageDrmFormatModifierInfoEXT::Builder& builder, VkPhysicalDeviceImageDrmFormatModifierInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDrmFormatModifier((member.drmFormatModifier));}();
[&](){[&](){[&](){return builder.setSharingMode((member.sharingMode));}();}();}();
[&](){return builder.setQueueFamilyIndexCount((member.queueFamilyIndexCount));}();
[&](){
            if ((member.pQueueFamilyIndices)==NULL){
                builder.initPQueueFamilyIndices(0);
            return; }
        auto proto_arr=builder.initPQueueFamilyIndices(member.queueFamilyIndexCount);
        for(int rqZQqua=0; rqZQqua < member.queueFamilyIndexCount; rqZQqua++){
            [&](){return proto_arr.set(rqZQqua,((member.pQueueFamilyIndices)[rqZQqua]));}();
        }
        }();
}

    VkPhysicalDeviceImageDrmFormatModifierInfoEXT deserialize_struct(stream::VkPhysicalDeviceImageDrmFormatModifierInfoEXT::Reader reader){
        auto result=VkPhysicalDeviceImageDrmFormatModifierInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.drmFormatModifier)=reader.getDrmFormatModifier();}();
[&](){[&](){[&](){(result.sharingMode)=reader.getSharingMode();}();}();}();
[&](){(result.queueFamilyIndexCount)=reader.getQueueFamilyIndexCount();}();
[&](){ uint32_t* temp_NzZliok[&](){
            if (!reader.getPQueueFamilyIndices().size()==0){
                (result.pQueueFamilyIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.queueFamilyIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPQueueFamilyIndices(result.queueFamilyIndexCount);
        for(int JEqKTnG=0; JEqKTnG < result.queueFamilyIndexCount; JEqKTnG++){
            [&](){((result.pQueueFamilyIndices)[JEqKTnG])=proto_arr[JEqKTnG];}();
        }
        }();(result.pQueueFamilyIndices)=temp_NzZliok;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageDrmFormatModifierInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageDrmFormatModifierInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageDrmFormatModifierListCreateInfoEXT::Builder& builder, VkImageDrmFormatModifierListCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDrmFormatModifierCount((member.drmFormatModifierCount));}();
[&](){
            if ((member.pDrmFormatModifiers)==NULL){
                builder.initPDrmFormatModifiers(0);
            return; }
        auto proto_arr=builder.initPDrmFormatModifiers(member.drmFormatModifierCount);
        for(int XtcCAFc=0; XtcCAFc < member.drmFormatModifierCount; XtcCAFc++){
            [&](){return proto_arr.set(XtcCAFc,((member.pDrmFormatModifiers)[XtcCAFc]));}();
        }
        }();
}

    VkImageDrmFormatModifierListCreateInfoEXT deserialize_struct(stream::VkImageDrmFormatModifierListCreateInfoEXT::Reader reader){
        auto result=VkImageDrmFormatModifierListCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.drmFormatModifierCount)=reader.getDrmFormatModifierCount();}();
[&](){ uint64_t* temp_nqZHJUz[&](){
            if (!reader.getPDrmFormatModifiers().size()==0){
                (result.pDrmFormatModifiers)=NULL;
            return; }{native_concat()}=(uint64_t*)malloc(result.drmFormatModifierCount*sizeof(uint64_t));
        auto proto_arr=reader.getPDrmFormatModifiers(result.drmFormatModifierCount);
        for(int taWquMu=0; taWquMu < result.drmFormatModifierCount; taWquMu++){
            [&](){((result.pDrmFormatModifiers)[taWquMu])=proto_arr[taWquMu];}();
        }
        }();(result.pDrmFormatModifiers)=temp_nqZHJUz;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageDrmFormatModifierListCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageDrmFormatModifierListCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageDrmFormatModifierExplicitCreateInfoEXT::Builder& builder, VkImageDrmFormatModifierExplicitCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDrmFormatModifier((member.drmFormatModifier));}();
[&](){return builder.setDrmFormatModifierPlaneCount((member.drmFormatModifierPlaneCount));}();
[&](){
            if ((member.pPlaneLayouts)==NULL){
                builder.initPPlaneLayouts(0);
            return; }
        auto proto_arr=builder.initPPlaneLayouts(member.drmFormatModifierPlaneCount);
        for(int rPoQfMt=0; rPoQfMt < member.drmFormatModifierPlaneCount; rPoQfMt++){
            [&](){
            auto temp=proto_arr[rPoQfMt];
            return serialize_struct(temp, ((member.pPlaneLayouts)[rPoQfMt]));
            }();
        }
        }();
}

    VkImageDrmFormatModifierExplicitCreateInfoEXT deserialize_struct(stream::VkImageDrmFormatModifierExplicitCreateInfoEXT::Reader reader){
        auto result=VkImageDrmFormatModifierExplicitCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.drmFormatModifier)=reader.getDrmFormatModifier();}();
[&](){(result.drmFormatModifierPlaneCount)=reader.getDrmFormatModifierPlaneCount();}();
[&](){ VkSubresourceLayout* temp_VgEjCxw[&](){
            if (!reader.getPPlaneLayouts().size()==0){
                (result.pPlaneLayouts)=NULL;
            return; }{native_concat()}=(VkSubresourceLayout*)malloc(result.drmFormatModifierPlaneCount*sizeof(VkSubresourceLayout));
        auto proto_arr=reader.getPPlaneLayouts(result.drmFormatModifierPlaneCount);
        for(int sDRKXGQ=0; sDRKXGQ < result.drmFormatModifierPlaneCount; sDRKXGQ++){
            [&](){
            auto temp=proto_arr[sDRKXGQ];
            ((result.pPlaneLayouts)[sDRKXGQ])=deserialize_struct(temp);
            }();
        }
        }();(result.pPlaneLayouts)=temp_VgEjCxw;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageDrmFormatModifierExplicitCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageDrmFormatModifierExplicitCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageDrmFormatModifierPropertiesEXT::Builder& builder, VkImageDrmFormatModifierPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDrmFormatModifier((member.drmFormatModifier));}();
}

    VkImageDrmFormatModifierPropertiesEXT deserialize_struct(stream::VkImageDrmFormatModifierPropertiesEXT::Reader reader){
        auto result=VkImageDrmFormatModifierPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.drmFormatModifier)=reader.getDrmFormatModifier();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageDrmFormatModifierPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageDrmFormatModifierPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageStencilUsageCreateInfo::Builder& builder, VkImageStencilUsageCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setStencilUsage((member.stencilUsage));}();}();}();
}

    VkImageStencilUsageCreateInfo deserialize_struct(stream::VkImageStencilUsageCreateInfo::Reader reader){
        auto result=VkImageStencilUsageCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.stencilUsage)=reader.getStencilUsage();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageStencilUsageCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageStencilUsageCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceMemoryOverallocationCreateInfoAMD::Builder& builder, VkDeviceMemoryOverallocationCreateInfoAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setOverallocationBehavior((member.overallocationBehavior));}();}();}();
}

    VkDeviceMemoryOverallocationCreateInfoAMD deserialize_struct(stream::VkDeviceMemoryOverallocationCreateInfoAMD::Reader reader){
        auto result=VkDeviceMemoryOverallocationCreateInfoAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.overallocationBehavior)=reader.getOverallocationBehavior();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceMemoryOverallocationCreateInfoAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceMemoryOverallocationCreateInfoAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentDensityMapFeaturesEXT::Builder& builder, VkPhysicalDeviceFragmentDensityMapFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFragmentDensityMap((member.fragmentDensityMap));}();}();
[&](){[&](){return builder.setFragmentDensityMapDynamic((member.fragmentDensityMapDynamic));}();}();
[&](){[&](){return builder.setFragmentDensityMapNonSubsampledImages((member.fragmentDensityMapNonSubsampledImages));}();}();
}

    VkPhysicalDeviceFragmentDensityMapFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceFragmentDensityMapFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceFragmentDensityMapFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.fragmentDensityMap)=reader.getFragmentDensityMap();}();}();
[&](){[&](){(result.fragmentDensityMapDynamic)=reader.getFragmentDensityMapDynamic();}();}();
[&](){[&](){(result.fragmentDensityMapNonSubsampledImages)=reader.getFragmentDensityMapNonSubsampledImages();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentDensityMapFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentDensityMapFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentDensityMap2FeaturesEXT::Builder& builder, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFragmentDensityMapDeferred((member.fragmentDensityMapDeferred));}();}();
}

    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceFragmentDensityMap2FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceFragmentDensityMap2FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.fragmentDensityMapDeferred)=reader.getFragmentDensityMapDeferred();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::Builder& builder, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFragmentDensityMapOffset((member.fragmentDensityMapOffset));}();}();
}

    VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.fragmentDensityMapOffset)=reader.getFragmentDensityMapOffset();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentDensityMapPropertiesEXT::Builder& builder, VkPhysicalDeviceFragmentDensityMapPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initMinFragmentDensityTexelSize(minFragmentDensityTexelSize);
            return serialize_struct(temp, (member.minFragmentDensityTexelSize));
            }();
[&](){
            auto temp=builder.initMaxFragmentDensityTexelSize(maxFragmentDensityTexelSize);
            return serialize_struct(temp, (member.maxFragmentDensityTexelSize));
            }();
[&](){[&](){return builder.setFragmentDensityInvocations((member.fragmentDensityInvocations));}();}();
}

    VkPhysicalDeviceFragmentDensityMapPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceFragmentDensityMapPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceFragmentDensityMapPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinFragmentDensityTexelSize();
            (result.minFragmentDensityTexelSize)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxFragmentDensityTexelSize();
            (result.maxFragmentDensityTexelSize)=deserialize_struct(temp);
            }();
[&](){[&](){(result.fragmentDensityInvocations)=reader.getFragmentDensityInvocations();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentDensityMapPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentDensityMapPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::Builder& builder, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSubsampledLoads((member.subsampledLoads));}();}();
[&](){[&](){return builder.setSubsampledCoarseReconstructionEarlyAccess((member.subsampledCoarseReconstructionEarlyAccess));}();}();
[&](){return builder.setMaxSubsampledArrayLayers((member.maxSubsampledArrayLayers));}();
[&](){return builder.setMaxDescriptorSetSubsampledSamplers((member.maxDescriptorSetSubsampledSamplers));}();
}

    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT deserialize_struct(stream::VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceFragmentDensityMap2PropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.subsampledLoads)=reader.getSubsampledLoads();}();}();
[&](){[&](){(result.subsampledCoarseReconstructionEarlyAccess)=reader.getSubsampledCoarseReconstructionEarlyAccess();}();}();
[&](){(result.maxSubsampledArrayLayers)=reader.getMaxSubsampledArrayLayers();}();
[&](){(result.maxDescriptorSetSubsampledSamplers)=reader.getMaxDescriptorSetSubsampledSamplers();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM::Builder& builder, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initFragmentDensityOffsetGranularity(fragmentDensityOffsetGranularity);
            return serialize_struct(temp, (member.fragmentDensityOffsetGranularity));
            }();
}

    VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM deserialize_struct(stream::VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM::Reader reader){
        auto result=VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getFragmentDensityOffsetGranularity();
            (result.fragmentDensityOffsetGranularity)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassFragmentDensityMapCreateInfoEXT::Builder& builder, VkRenderPassFragmentDensityMapCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initFragmentDensityMapAttachment(fragmentDensityMapAttachment);
            return serialize_struct(temp, (member.fragmentDensityMapAttachment));
            }();
}

    VkRenderPassFragmentDensityMapCreateInfoEXT deserialize_struct(stream::VkRenderPassFragmentDensityMapCreateInfoEXT::Reader reader){
        auto result=VkRenderPassFragmentDensityMapCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getFragmentDensityMapAttachment();
            (result.fragmentDensityMapAttachment)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassFragmentDensityMapCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassFragmentDensityMapCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassFragmentDensityMapOffsetEndInfoQCOM::Builder& builder, VkSubpassFragmentDensityMapOffsetEndInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setFragmentDensityOffsetCount((member.fragmentDensityOffsetCount));}();
[&](){
            if ((member.pFragmentDensityOffsets)==NULL){
                builder.initPFragmentDensityOffsets(0);
            return; }
        auto proto_arr=builder.initPFragmentDensityOffsets(member.fragmentDensityOffsetCount);
        for(int lmMXhaF=0; lmMXhaF < member.fragmentDensityOffsetCount; lmMXhaF++){
            [&](){
            auto temp=proto_arr[lmMXhaF];
            return serialize_struct(temp, ((member.pFragmentDensityOffsets)[lmMXhaF]));
            }();
        }
        }();
}

    VkSubpassFragmentDensityMapOffsetEndInfoQCOM deserialize_struct(stream::VkSubpassFragmentDensityMapOffsetEndInfoQCOM::Reader reader){
        auto result=VkSubpassFragmentDensityMapOffsetEndInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.fragmentDensityOffsetCount)=reader.getFragmentDensityOffsetCount();}();
[&](){ VkOffset2D* temp_wuEjIZI[&](){
            if (!reader.getPFragmentDensityOffsets().size()==0){
                (result.pFragmentDensityOffsets)=NULL;
            return; }{native_concat()}=(VkOffset2D*)malloc(result.fragmentDensityOffsetCount*sizeof(VkOffset2D));
        auto proto_arr=reader.getPFragmentDensityOffsets(result.fragmentDensityOffsetCount);
        for(int rVUrFFp=0; rVUrFFp < result.fragmentDensityOffsetCount; rVUrFFp++){
            [&](){
            auto temp=proto_arr[rVUrFFp];
            ((result.pFragmentDensityOffsets)[rVUrFFp])=deserialize_struct(temp);
            }();
        }
        }();(result.pFragmentDensityOffsets)=temp_wuEjIZI;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassFragmentDensityMapOffsetEndInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassFragmentDensityMapOffsetEndInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceScalarBlockLayoutFeatures::Builder& builder, VkPhysicalDeviceScalarBlockLayoutFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setScalarBlockLayout((member.scalarBlockLayout));}();}();
}

    VkPhysicalDeviceScalarBlockLayoutFeatures deserialize_struct(stream::VkPhysicalDeviceScalarBlockLayoutFeatures::Reader reader){
        auto result=VkPhysicalDeviceScalarBlockLayoutFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.scalarBlockLayout)=reader.getScalarBlockLayout();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceScalarBlockLayoutFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceScalarBlockLayoutFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfaceProtectedCapabilitiesKHR::Builder& builder, VkSurfaceProtectedCapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSupportsProtected((member.supportsProtected));}();}();
}

    VkSurfaceProtectedCapabilitiesKHR deserialize_struct(stream::VkSurfaceProtectedCapabilitiesKHR::Reader reader){
        auto result=VkSurfaceProtectedCapabilitiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.supportsProtected)=reader.getSupportsProtected();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfaceProtectedCapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfaceProtectedCapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceUniformBufferStandardLayoutFeatures::Builder& builder, VkPhysicalDeviceUniformBufferStandardLayoutFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setUniformBufferStandardLayout((member.uniformBufferStandardLayout));}();}();
}

    VkPhysicalDeviceUniformBufferStandardLayoutFeatures deserialize_struct(stream::VkPhysicalDeviceUniformBufferStandardLayoutFeatures::Reader reader){
        auto result=VkPhysicalDeviceUniformBufferStandardLayoutFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.uniformBufferStandardLayout)=reader.getUniformBufferStandardLayout();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceUniformBufferStandardLayoutFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceUniformBufferStandardLayoutFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDepthClipEnableFeaturesEXT::Builder& builder, VkPhysicalDeviceDepthClipEnableFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDepthClipEnable((member.depthClipEnable));}();}();
}

    VkPhysicalDeviceDepthClipEnableFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceDepthClipEnableFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceDepthClipEnableFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.depthClipEnable)=reader.getDepthClipEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDepthClipEnableFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDepthClipEnableFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRasterizationDepthClipStateCreateInfoEXT::Builder& builder, VkPipelineRasterizationDepthClipStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setDepthClipEnable((member.depthClipEnable));}();}();
}

    VkPipelineRasterizationDepthClipStateCreateInfoEXT deserialize_struct(stream::VkPipelineRasterizationDepthClipStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineRasterizationDepthClipStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.depthClipEnable)=reader.getDepthClipEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRasterizationDepthClipStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRasterizationDepthClipStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMemoryBudgetPropertiesEXT::Builder& builder, VkPhysicalDeviceMemoryBudgetPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initHeapBudget(VK_MAX_MEMORY_HEAPS);
        for(int WasafRQ=0; WasafRQ < VK_MAX_MEMORY_HEAPS; WasafRQ++){
            [&](){[&](){return proto_arr.set(WasafRQ,((member.heapBudget)[WasafRQ]));}();}();
        }
        }();
[&](){
        auto proto_arr=builder.initHeapUsage(VK_MAX_MEMORY_HEAPS);
        for(int KcTGRVa=0; KcTGRVa < VK_MAX_MEMORY_HEAPS; KcTGRVa++){
            [&](){[&](){return proto_arr.set(KcTGRVa,((member.heapUsage)[KcTGRVa]));}();}();
        }
        }();
}

    VkPhysicalDeviceMemoryBudgetPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceMemoryBudgetPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceMemoryBudgetPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getHeapBudget(VK_MAX_MEMORY_HEAPS);
        for(int WasafRQ=0; WasafRQ < VK_MAX_MEMORY_HEAPS; WasafRQ++){
            [&](){[&](){((result.heapBudget)[WasafRQ])=proto_arr[WasafRQ];}();}();
        }
        }();
[&](){
        auto proto_arr=reader.getHeapUsage(VK_MAX_MEMORY_HEAPS);
        for(int KcTGRVa=0; KcTGRVa < VK_MAX_MEMORY_HEAPS; KcTGRVa++){
            [&](){[&](){((result.heapUsage)[KcTGRVa])=proto_arr[KcTGRVa];}();}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMemoryBudgetPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMemoryBudgetPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMemoryPriorityFeaturesEXT::Builder& builder, VkPhysicalDeviceMemoryPriorityFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMemoryPriority((member.memoryPriority));}();}();
}

    VkPhysicalDeviceMemoryPriorityFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceMemoryPriorityFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceMemoryPriorityFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.memoryPriority)=reader.getMemoryPriority();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMemoryPriorityFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMemoryPriorityFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryPriorityAllocateInfoEXT::Builder& builder, VkMemoryPriorityAllocateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPriority((member.priority));}();
}

    VkMemoryPriorityAllocateInfoEXT deserialize_struct(stream::VkMemoryPriorityAllocateInfoEXT::Reader reader){
        auto result=VkMemoryPriorityAllocateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.priority)=reader.getPriority();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryPriorityAllocateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryPriorityAllocateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT::Builder& builder, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPageableDeviceLocalMemory((member.pageableDeviceLocalMemory));}();}();
}

    VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT deserialize_struct(stream::VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pageableDeviceLocalMemory)=reader.getPageableDeviceLocalMemory();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceBufferDeviceAddressFeatures::Builder& builder, VkPhysicalDeviceBufferDeviceAddressFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setBufferDeviceAddress((member.bufferDeviceAddress));}();}();
[&](){[&](){return builder.setBufferDeviceAddressCaptureReplay((member.bufferDeviceAddressCaptureReplay));}();}();
[&](){[&](){return builder.setBufferDeviceAddressMultiDevice((member.bufferDeviceAddressMultiDevice));}();}();
}

    VkPhysicalDeviceBufferDeviceAddressFeatures deserialize_struct(stream::VkPhysicalDeviceBufferDeviceAddressFeatures::Reader reader){
        auto result=VkPhysicalDeviceBufferDeviceAddressFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.bufferDeviceAddress)=reader.getBufferDeviceAddress();}();}();
[&](){[&](){(result.bufferDeviceAddressCaptureReplay)=reader.getBufferDeviceAddressCaptureReplay();}();}();
[&](){[&](){(result.bufferDeviceAddressMultiDevice)=reader.getBufferDeviceAddressMultiDevice();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceBufferDeviceAddressFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceBufferDeviceAddressFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceBufferDeviceAddressFeaturesEXT::Builder& builder, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setBufferDeviceAddress((member.bufferDeviceAddress));}();}();
[&](){[&](){return builder.setBufferDeviceAddressCaptureReplay((member.bufferDeviceAddressCaptureReplay));}();}();
[&](){[&](){return builder.setBufferDeviceAddressMultiDevice((member.bufferDeviceAddressMultiDevice));}();}();
}

    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceBufferDeviceAddressFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceBufferDeviceAddressFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.bufferDeviceAddress)=reader.getBufferDeviceAddress();}();}();
[&](){[&](){(result.bufferDeviceAddressCaptureReplay)=reader.getBufferDeviceAddressCaptureReplay();}();}();
[&](){[&](){(result.bufferDeviceAddressMultiDevice)=reader.getBufferDeviceAddressMultiDevice();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferDeviceAddressInfo::Builder& builder, VkBufferDeviceAddressInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
}

    VkBufferDeviceAddressInfo deserialize_struct(stream::VkBufferDeviceAddressInfo::Reader reader){
        auto result=VkBufferDeviceAddressInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferDeviceAddressInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferDeviceAddressInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferOpaqueCaptureAddressCreateInfo::Builder& builder, VkBufferOpaqueCaptureAddressCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setOpaqueCaptureAddress((member.opaqueCaptureAddress));}();
}

    VkBufferOpaqueCaptureAddressCreateInfo deserialize_struct(stream::VkBufferOpaqueCaptureAddressCreateInfo::Reader reader){
        auto result=VkBufferOpaqueCaptureAddressCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.opaqueCaptureAddress)=reader.getOpaqueCaptureAddress();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferOpaqueCaptureAddressCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferOpaqueCaptureAddressCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferDeviceAddressCreateInfoEXT::Builder& builder, VkBufferDeviceAddressCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
}

    VkBufferDeviceAddressCreateInfoEXT deserialize_struct(stream::VkBufferDeviceAddressCreateInfoEXT::Reader reader){
        auto result=VkBufferDeviceAddressCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferDeviceAddressCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferDeviceAddressCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageViewImageFormatInfoEXT::Builder& builder, VkPhysicalDeviceImageViewImageFormatInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setImageViewType((member.imageViewType));}();}();}();
}

    VkPhysicalDeviceImageViewImageFormatInfoEXT deserialize_struct(stream::VkPhysicalDeviceImageViewImageFormatInfoEXT::Reader reader){
        auto result=VkPhysicalDeviceImageViewImageFormatInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.imageViewType)=reader.getImageViewType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageViewImageFormatInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageViewImageFormatInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFilterCubicImageViewImageFormatPropertiesEXT::Builder& builder, VkFilterCubicImageViewImageFormatPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFilterCubic((member.filterCubic));}();}();
[&](){[&](){return builder.setFilterCubicMinmax((member.filterCubicMinmax));}();}();
}

    VkFilterCubicImageViewImageFormatPropertiesEXT deserialize_struct(stream::VkFilterCubicImageViewImageFormatPropertiesEXT::Reader reader){
        auto result=VkFilterCubicImageViewImageFormatPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.filterCubic)=reader.getFilterCubic();}();}();
[&](){[&](){(result.filterCubicMinmax)=reader.getFilterCubicMinmax();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFilterCubicImageViewImageFormatPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFilterCubicImageViewImageFormatPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImagelessFramebufferFeatures::Builder& builder, VkPhysicalDeviceImagelessFramebufferFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setImagelessFramebuffer((member.imagelessFramebuffer));}();}();
}

    VkPhysicalDeviceImagelessFramebufferFeatures deserialize_struct(stream::VkPhysicalDeviceImagelessFramebufferFeatures::Reader reader){
        auto result=VkPhysicalDeviceImagelessFramebufferFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.imagelessFramebuffer)=reader.getImagelessFramebuffer();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImagelessFramebufferFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImagelessFramebufferFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFramebufferAttachmentsCreateInfo::Builder& builder, VkFramebufferAttachmentsCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAttachmentImageInfoCount((member.attachmentImageInfoCount));}();
[&](){
            if ((member.pAttachmentImageInfos)==NULL){
                builder.initPAttachmentImageInfos(0);
            return; }
        auto proto_arr=builder.initPAttachmentImageInfos(member.attachmentImageInfoCount);
        for(int rrcawDd=0; rrcawDd < member.attachmentImageInfoCount; rrcawDd++){
            [&](){
            auto temp=proto_arr[rrcawDd];
            return serialize_struct(temp, ((member.pAttachmentImageInfos)[rrcawDd]));
            }();
        }
        }();
}

    VkFramebufferAttachmentsCreateInfo deserialize_struct(stream::VkFramebufferAttachmentsCreateInfo::Reader reader){
        auto result=VkFramebufferAttachmentsCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.attachmentImageInfoCount)=reader.getAttachmentImageInfoCount();}();
[&](){ VkFramebufferAttachmentImageInfo* temp_owzzfjP[&](){
            if (!reader.getPAttachmentImageInfos().size()==0){
                (result.pAttachmentImageInfos)=NULL;
            return; }{native_concat()}=(VkFramebufferAttachmentImageInfo*)malloc(result.attachmentImageInfoCount*sizeof(VkFramebufferAttachmentImageInfo));
        auto proto_arr=reader.getPAttachmentImageInfos(result.attachmentImageInfoCount);
        for(int yZGrSaw=0; yZGrSaw < result.attachmentImageInfoCount; yZGrSaw++){
            [&](){
            auto temp=proto_arr[yZGrSaw];
            ((result.pAttachmentImageInfos)[yZGrSaw])=deserialize_struct(temp);
            }();
        }
        }();(result.pAttachmentImageInfos)=temp_owzzfjP;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFramebufferAttachmentsCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFramebufferAttachmentsCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFramebufferAttachmentImageInfo::Builder& builder, VkFramebufferAttachmentImageInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
[&](){return builder.setLayerCount((member.layerCount));}();
[&](){return builder.setViewFormatCount((member.viewFormatCount));}();
[&](){
            if ((member.pViewFormats)==NULL){
                builder.initPViewFormats(0);
            return; }
        auto proto_arr=builder.initPViewFormats(member.viewFormatCount);
        for(int JvKPhOq=0; JvKPhOq < member.viewFormatCount; JvKPhOq++){
            [&](){[&](){[&](){return proto_arr.set(JvKPhOq,((member.pViewFormats)[JvKPhOq]));}();}();}();
        }
        }();
}

    VkFramebufferAttachmentImageInfo deserialize_struct(stream::VkFramebufferAttachmentImageInfo::Reader reader){
        auto result=VkFramebufferAttachmentImageInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
[&](){(result.layerCount)=reader.getLayerCount();}();
[&](){(result.viewFormatCount)=reader.getViewFormatCount();}();
[&](){ VkFormat* temp_IZMfCii[&](){
            if (!reader.getPViewFormats().size()==0){
                (result.pViewFormats)=NULL;
            return; }{native_concat()}=(VkFormat*)malloc(result.viewFormatCount*sizeof(VkFormat));
        auto proto_arr=reader.getPViewFormats(result.viewFormatCount);
        for(int tWwlFTf=0; tWwlFTf < result.viewFormatCount; tWwlFTf++){
            [&](){[&](){[&](){((result.pViewFormats)[tWwlFTf])=proto_arr[tWwlFTf];}();}();}();
        }
        }();(result.pViewFormats)=temp_IZMfCii;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFramebufferAttachmentImageInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFramebufferAttachmentImageInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassAttachmentBeginInfo::Builder& builder, VkRenderPassAttachmentBeginInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAttachmentCount((member.attachmentCount));}();
[&](){
            if ((member.pAttachments)==NULL){
                builder.initPAttachments(0);
            return; }
        auto proto_arr=builder.initPAttachments(member.attachmentCount);
        for(int vjwDzkt=0; vjwDzkt < member.attachmentCount; vjwDzkt++){
            [&](){return proto_arr.set(vjwDzkt,serialize_handle((member.pAttachments)[vjwDzkt]));}();
        }
        }();
}

    VkRenderPassAttachmentBeginInfo deserialize_struct(stream::VkRenderPassAttachmentBeginInfo::Reader reader){
        auto result=VkRenderPassAttachmentBeginInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.attachmentCount)=reader.getAttachmentCount();}();
[&](){ VkImageView* temp_engXCXd[&](){
            if (!reader.getPAttachments().size()==0){
                (result.pAttachments)=NULL;
            return; }{native_concat()}=(VkImageView*)malloc(result.attachmentCount*sizeof(VkImageView));
        auto proto_arr=reader.getPAttachments(result.attachmentCount);
        for(int qNVUjmy=0; qNVUjmy < result.attachmentCount; qNVUjmy++){
            [&](){((result.pAttachments)[qNVUjmy])=deserialize_VkImageView(proto_arr[qNVUjmy]);}();
        }
        }();(result.pAttachments)=temp_engXCXd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassAttachmentBeginInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassAttachmentBeginInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTextureCompressionASTCHDRFeatures::Builder& builder, VkPhysicalDeviceTextureCompressionASTCHDRFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTextureCompressionASTCHDR((member.textureCompressionASTC_HDR));}();}();
}

    VkPhysicalDeviceTextureCompressionASTCHDRFeatures deserialize_struct(stream::VkPhysicalDeviceTextureCompressionASTCHDRFeatures::Reader reader){
        auto result=VkPhysicalDeviceTextureCompressionASTCHDRFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.textureCompressionASTC_HDR)=reader.getTextureCompressionASTCHDR();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTextureCompressionASTCHDRFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTextureCompressionASTCHDRFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCooperativeMatrixFeaturesNV::Builder& builder, VkPhysicalDeviceCooperativeMatrixFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCooperativeMatrix((member.cooperativeMatrix));}();}();
[&](){[&](){return builder.setCooperativeMatrixRobustBufferAccess((member.cooperativeMatrixRobustBufferAccess));}();}();
}

    VkPhysicalDeviceCooperativeMatrixFeaturesNV deserialize_struct(stream::VkPhysicalDeviceCooperativeMatrixFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceCooperativeMatrixFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.cooperativeMatrix)=reader.getCooperativeMatrix();}();}();
[&](){[&](){(result.cooperativeMatrixRobustBufferAccess)=reader.getCooperativeMatrixRobustBufferAccess();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCooperativeMatrixFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCooperativeMatrixFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCooperativeMatrixPropertiesNV::Builder& builder, VkPhysicalDeviceCooperativeMatrixPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCooperativeMatrixSupportedStages((member.cooperativeMatrixSupportedStages));}();}();}();
}

    VkPhysicalDeviceCooperativeMatrixPropertiesNV deserialize_struct(stream::VkPhysicalDeviceCooperativeMatrixPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceCooperativeMatrixPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.cooperativeMatrixSupportedStages)=reader.getCooperativeMatrixSupportedStages();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCooperativeMatrixPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCooperativeMatrixPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCooperativeMatrixPropertiesNV::Builder& builder, VkCooperativeMatrixPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMSize((member.MSize));}();
[&](){return builder.setNSize((member.NSize));}();
[&](){return builder.setKSize((member.KSize));}();
[&](){[&](){[&](){return builder.setAType((member.AType));}();}();}();
[&](){[&](){[&](){return builder.setBType((member.BType));}();}();}();
[&](){[&](){[&](){return builder.setCType((member.CType));}();}();}();
[&](){[&](){[&](){return builder.setDType((member.DType));}();}();}();
[&](){[&](){[&](){return builder.setScope((member.scope));}();}();}();
}

    VkCooperativeMatrixPropertiesNV deserialize_struct(stream::VkCooperativeMatrixPropertiesNV::Reader reader){
        auto result=VkCooperativeMatrixPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.MSize)=reader.getMSize();}();
[&](){(result.NSize)=reader.getNSize();}();
[&](){(result.KSize)=reader.getKSize();}();
[&](){[&](){[&](){(result.AType)=reader.getAType();}();}();}();
[&](){[&](){[&](){(result.BType)=reader.getBType();}();}();}();
[&](){[&](){[&](){(result.CType)=reader.getCType();}();}();}();
[&](){[&](){[&](){(result.DType)=reader.getDType();}();}();}();
[&](){[&](){[&](){(result.scope)=reader.getScope();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCooperativeMatrixPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCooperativeMatrixPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceYcbcrImageArraysFeaturesEXT::Builder& builder, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setYcbcrImageArrays((member.ycbcrImageArrays));}();}();
}

    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceYcbcrImageArraysFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceYcbcrImageArraysFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.ycbcrImageArrays)=reader.getYcbcrImageArrays();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewHandleInfoNVX::Builder& builder, VkImageViewHandleInfoNVX member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImageView(serialize_handle(member.imageView));}();
[&](){[&](){[&](){return builder.setDescriptorType((member.descriptorType));}();}();}();
[&](){return builder.setSampler(serialize_handle(member.sampler));}();
}

    VkImageViewHandleInfoNVX deserialize_struct(stream::VkImageViewHandleInfoNVX::Reader reader){
        auto result=VkImageViewHandleInfoNVX();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.imageView)=deserialize_VkImageView(reader.getImageView());}();
[&](){[&](){[&](){(result.descriptorType)=reader.getDescriptorType();}();}();}();
[&](){(result.sampler)=deserialize_VkSampler(reader.getSampler());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewHandleInfoNVX member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewHandleInfoNVX member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewAddressPropertiesNVX::Builder& builder, VkImageViewAddressPropertiesNVX member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkImageViewAddressPropertiesNVX deserialize_struct(stream::VkImageViewAddressPropertiesNVX::Reader reader){
        auto result=VkImageViewAddressPropertiesNVX();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewAddressPropertiesNVX member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewAddressPropertiesNVX member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCreationFeedback::Builder& builder, VkPipelineCreationFeedback member){
        
    
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setDuration((member.duration));}();
}

    VkPipelineCreationFeedback deserialize_struct(stream::VkPipelineCreationFeedback::Reader reader){
        auto result=VkPipelineCreationFeedback();
    
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.duration)=reader.getDuration();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCreationFeedback member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCreationFeedback member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCreationFeedbackCreateInfo::Builder& builder, VkPipelineCreationFeedbackCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pPipelineCreationFeedback)==NULL){
                builder.initPPipelineCreationFeedback(0);
            return; }
        auto proto_arr=builder.initPPipelineCreationFeedback(1);
        for(int tXpPWXb=0; tXpPWXb < 1; tXpPWXb++){
            [&](){
            auto temp=proto_arr[tXpPWXb];
            return serialize_struct(temp, ((member.pPipelineCreationFeedback)[tXpPWXb]));
            }();
        }
        }();
[&](){return builder.setPipelineStageCreationFeedbackCount((member.pipelineStageCreationFeedbackCount));}();
[&](){
            if ((member.pPipelineStageCreationFeedbacks)==NULL){
                builder.initPPipelineStageCreationFeedbacks(0);
            return; }
        auto proto_arr=builder.initPPipelineStageCreationFeedbacks(member.pipelineStageCreationFeedbackCount);
        for(int MaEvDCo=0; MaEvDCo < member.pipelineStageCreationFeedbackCount; MaEvDCo++){
            [&](){
            auto temp=proto_arr[MaEvDCo];
            return serialize_struct(temp, ((member.pPipelineStageCreationFeedbacks)[MaEvDCo]));
            }();
        }
        }();
}

    VkPipelineCreationFeedbackCreateInfo deserialize_struct(stream::VkPipelineCreationFeedbackCreateInfo::Reader reader){
        auto result=VkPipelineCreationFeedbackCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            if (!reader.getPPipelineCreationFeedback().size()==0){
                (result.pPipelineCreationFeedback)=NULL;
            return; }{native_concat()}=(VkPipelineCreationFeedback*)malloc(1*sizeof(VkPipelineCreationFeedback));
        auto proto_arr=reader.getPPipelineCreationFeedback(1);
        for(int tXpPWXb=0; tXpPWXb < 1; tXpPWXb++){
            [&](){
            auto temp=proto_arr[tXpPWXb];
            ((result.pPipelineCreationFeedback)[tXpPWXb])=deserialize_struct(temp);
            }();
        }
        }();
[&](){(result.pipelineStageCreationFeedbackCount)=reader.getPipelineStageCreationFeedbackCount();}();
[&](){
            if (!reader.getPPipelineStageCreationFeedbacks().size()==0){
                (result.pPipelineStageCreationFeedbacks)=NULL;
            return; }{native_concat()}=(VkPipelineCreationFeedback*)malloc(result.pipelineStageCreationFeedbackCount*sizeof(VkPipelineCreationFeedback));
        auto proto_arr=reader.getPPipelineStageCreationFeedbacks(result.pipelineStageCreationFeedbackCount);
        for(int MaEvDCo=0; MaEvDCo < result.pipelineStageCreationFeedbackCount; MaEvDCo++){
            [&](){
            auto temp=proto_arr[MaEvDCo];
            ((result.pPipelineStageCreationFeedbacks)[MaEvDCo])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCreationFeedbackCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCreationFeedbackCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePresentBarrierFeaturesNV::Builder& builder, VkPhysicalDevicePresentBarrierFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPresentBarrier((member.presentBarrier));}();}();
}

    VkPhysicalDevicePresentBarrierFeaturesNV deserialize_struct(stream::VkPhysicalDevicePresentBarrierFeaturesNV::Reader reader){
        auto result=VkPhysicalDevicePresentBarrierFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.presentBarrier)=reader.getPresentBarrier();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePresentBarrierFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePresentBarrierFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfaceCapabilitiesPresentBarrierNV::Builder& builder, VkSurfaceCapabilitiesPresentBarrierNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPresentBarrierSupported((member.presentBarrierSupported));}();}();
}

    VkSurfaceCapabilitiesPresentBarrierNV deserialize_struct(stream::VkSurfaceCapabilitiesPresentBarrierNV::Reader reader){
        auto result=VkSurfaceCapabilitiesPresentBarrierNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.presentBarrierSupported)=reader.getPresentBarrierSupported();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfaceCapabilitiesPresentBarrierNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfaceCapabilitiesPresentBarrierNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainPresentBarrierCreateInfoNV::Builder& builder, VkSwapchainPresentBarrierCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPresentBarrierEnable((member.presentBarrierEnable));}();}();
}

    VkSwapchainPresentBarrierCreateInfoNV deserialize_struct(stream::VkSwapchainPresentBarrierCreateInfoNV::Reader reader){
        auto result=VkSwapchainPresentBarrierCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.presentBarrierEnable)=reader.getPresentBarrierEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainPresentBarrierCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainPresentBarrierCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePerformanceQueryFeaturesKHR::Builder& builder, VkPhysicalDevicePerformanceQueryFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPerformanceCounterQueryPools((member.performanceCounterQueryPools));}();}();
[&](){[&](){return builder.setPerformanceCounterMultipleQueryPools((member.performanceCounterMultipleQueryPools));}();}();
}

    VkPhysicalDevicePerformanceQueryFeaturesKHR deserialize_struct(stream::VkPhysicalDevicePerformanceQueryFeaturesKHR::Reader reader){
        auto result=VkPhysicalDevicePerformanceQueryFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.performanceCounterQueryPools)=reader.getPerformanceCounterQueryPools();}();}();
[&](){[&](){(result.performanceCounterMultipleQueryPools)=reader.getPerformanceCounterMultipleQueryPools();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePerformanceQueryFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePerformanceQueryFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePerformanceQueryPropertiesKHR::Builder& builder, VkPhysicalDevicePerformanceQueryPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAllowCommandBufferQueryCopies((member.allowCommandBufferQueryCopies));}();}();
}

    VkPhysicalDevicePerformanceQueryPropertiesKHR deserialize_struct(stream::VkPhysicalDevicePerformanceQueryPropertiesKHR::Reader reader){
        auto result=VkPhysicalDevicePerformanceQueryPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.allowCommandBufferQueryCopies)=reader.getAllowCommandBufferQueryCopies();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePerformanceQueryPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePerformanceQueryPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceCounterKHR::Builder& builder, VkPerformanceCounterKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setUnit((member.unit));}();}();}();
[&](){[&](){[&](){return builder.setScope((member.scope));}();}();}();
[&](){[&](){[&](){return builder.setStorage((member.storage));}();}();}();
[&](){
        auto proto_arr=builder.initUuid(VK_UUID_SIZE);
        for(int vzBFmFc=0; vzBFmFc < VK_UUID_SIZE; vzBFmFc++){
            [&](){return proto_arr.set(vzBFmFc,((member.uuid)[vzBFmFc]));}();
        }
        }();
}

    VkPerformanceCounterKHR deserialize_struct(stream::VkPerformanceCounterKHR::Reader reader){
        auto result=VkPerformanceCounterKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.unit)=reader.getUnit();}();}();}();
[&](){[&](){[&](){(result.scope)=reader.getScope();}();}();}();
[&](){[&](){[&](){(result.storage)=reader.getStorage();}();}();}();
[&](){
        auto proto_arr=reader.getUuid(VK_UUID_SIZE);
        for(int vzBFmFc=0; vzBFmFc < VK_UUID_SIZE; vzBFmFc++){
            [&](){((result.uuid)[vzBFmFc])=proto_arr[vzBFmFc];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceCounterKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceCounterKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceCounterDescriptionKHR::Builder& builder, VkPerformanceCounterDescriptionKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
        auto proto_arr=builder.initName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){return proto_arr.set(hWobsSN,((member.name)[hWobsSN]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initCategory(VK_MAX_DESCRIPTION_SIZE);
        for(int nMrMOOK=0; nMrMOOK < VK_MAX_DESCRIPTION_SIZE; nMrMOOK++){
            [&](){return proto_arr.set(nMrMOOK,((member.category)[nMrMOOK]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
}

    VkPerformanceCounterDescriptionKHR deserialize_struct(stream::VkPerformanceCounterDescriptionKHR::Reader reader){
        auto result=VkPerformanceCounterDescriptionKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
        auto proto_arr=reader.getName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){((result.name)[hWobsSN])=proto_arr[hWobsSN];}();
        }
        }();
[&](){
        auto proto_arr=reader.getCategory(VK_MAX_DESCRIPTION_SIZE);
        for(int nMrMOOK=0; nMrMOOK < VK_MAX_DESCRIPTION_SIZE; nMrMOOK++){
            [&](){((result.category)[nMrMOOK])=proto_arr[nMrMOOK];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceCounterDescriptionKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceCounterDescriptionKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueryPoolPerformanceCreateInfoKHR::Builder& builder, VkQueryPoolPerformanceCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setQueueFamilyIndex((member.queueFamilyIndex));}();
[&](){return builder.setCounterIndexCount((member.counterIndexCount));}();
[&](){
            if ((member.pCounterIndices)==NULL){
                builder.initPCounterIndices(0);
            return; }
        auto proto_arr=builder.initPCounterIndices(member.counterIndexCount);
        for(int JseWCIa=0; JseWCIa < member.counterIndexCount; JseWCIa++){
            [&](){return proto_arr.set(JseWCIa,((member.pCounterIndices)[JseWCIa]));}();
        }
        }();
}

    VkQueryPoolPerformanceCreateInfoKHR deserialize_struct(stream::VkQueryPoolPerformanceCreateInfoKHR::Reader reader){
        auto result=VkQueryPoolPerformanceCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.queueFamilyIndex)=reader.getQueueFamilyIndex();}();
[&](){(result.counterIndexCount)=reader.getCounterIndexCount();}();
[&](){ uint32_t* temp_GtnxQvB[&](){
            if (!reader.getPCounterIndices().size()==0){
                (result.pCounterIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.counterIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPCounterIndices(result.counterIndexCount);
        for(int giXouEF=0; giXouEF < result.counterIndexCount; giXouEF++){
            [&](){((result.pCounterIndices)[giXouEF])=proto_arr[giXouEF];}();
        }
        }();(result.pCounterIndices)=temp_GtnxQvB;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueryPoolPerformanceCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueryPoolPerformanceCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceCounterResultKHR::Builder& builder, VkPerformanceCounterResultKHR member){
        
    
[&](){return builder.setInt32((member.int32));}();
[&](){return builder.setInt64((member.int64));}();
[&](){return builder.setUint32((member.uint32));}();
[&](){return builder.setUint64((member.uint64));}();
[&](){return builder.setFloat32((member.float32));}();
[&](){return builder.setFloat64((member.float64));}();
}

    VkPerformanceCounterResultKHR deserialize_struct(stream::VkPerformanceCounterResultKHR::Reader reader){
        auto result=VkPerformanceCounterResultKHR();
    
[&](){(result.int32)=reader.getInt32();}();
[&](){(result.int64)=reader.getInt64();}();
[&](){(result.uint32)=reader.getUint32();}();
[&](){(result.uint64)=reader.getUint64();}();
[&](){(result.float32)=reader.getFloat32();}();
[&](){(result.float64)=reader.getFloat64();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceCounterResultKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceCounterResultKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAcquireProfilingLockInfoKHR::Builder& builder, VkAcquireProfilingLockInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setTimeout((member.timeout));}();
}

    VkAcquireProfilingLockInfoKHR deserialize_struct(stream::VkAcquireProfilingLockInfoKHR::Reader reader){
        auto result=VkAcquireProfilingLockInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.timeout)=reader.getTimeout();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAcquireProfilingLockInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAcquireProfilingLockInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceQuerySubmitInfoKHR::Builder& builder, VkPerformanceQuerySubmitInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setCounterPassIndex((member.counterPassIndex));}();
}

    VkPerformanceQuerySubmitInfoKHR deserialize_struct(stream::VkPerformanceQuerySubmitInfoKHR::Reader reader){
        auto result=VkPerformanceQuerySubmitInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.counterPassIndex)=reader.getCounterPassIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceQuerySubmitInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceQuerySubmitInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkHeadlessSurfaceCreateInfoEXT::Builder& builder, VkHeadlessSurfaceCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkHeadlessSurfaceCreateInfoEXT deserialize_struct(stream::VkHeadlessSurfaceCreateInfoEXT::Reader reader){
        auto result=VkHeadlessSurfaceCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkHeadlessSurfaceCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkHeadlessSurfaceCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCoverageReductionModeFeaturesNV::Builder& builder, VkPhysicalDeviceCoverageReductionModeFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCoverageReductionMode((member.coverageReductionMode));}();}();
}

    VkPhysicalDeviceCoverageReductionModeFeaturesNV deserialize_struct(stream::VkPhysicalDeviceCoverageReductionModeFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceCoverageReductionModeFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.coverageReductionMode)=reader.getCoverageReductionMode();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCoverageReductionModeFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCoverageReductionModeFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCoverageReductionStateCreateInfoNV::Builder& builder, VkPipelineCoverageReductionStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setCoverageReductionMode((member.coverageReductionMode));}();}();}();
}

    VkPipelineCoverageReductionStateCreateInfoNV deserialize_struct(stream::VkPipelineCoverageReductionStateCreateInfoNV::Reader reader){
        auto result=VkPipelineCoverageReductionStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.coverageReductionMode)=reader.getCoverageReductionMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCoverageReductionStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCoverageReductionStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFramebufferMixedSamplesCombinationNV::Builder& builder, VkFramebufferMixedSamplesCombinationNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCoverageReductionMode((member.coverageReductionMode));}();}();}();
[&](){[&](){[&](){return builder.setRasterizationSamples((member.rasterizationSamples));}();}();}();
[&](){[&](){[&](){return builder.setDepthStencilSamples((member.depthStencilSamples));}();}();}();
[&](){[&](){[&](){return builder.setColorSamples((member.colorSamples));}();}();}();
}

    VkFramebufferMixedSamplesCombinationNV deserialize_struct(stream::VkFramebufferMixedSamplesCombinationNV::Reader reader){
        auto result=VkFramebufferMixedSamplesCombinationNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.coverageReductionMode)=reader.getCoverageReductionMode();}();}();}();
[&](){[&](){[&](){(result.rasterizationSamples)=reader.getRasterizationSamples();}();}();}();
[&](){[&](){[&](){(result.depthStencilSamples)=reader.getDepthStencilSamples();}();}();}();
[&](){[&](){[&](){(result.colorSamples)=reader.getColorSamples();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFramebufferMixedSamplesCombinationNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFramebufferMixedSamplesCombinationNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::Builder& builder, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderIntegerFunctions2((member.shaderIntegerFunctions2));}();}();
}

    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL deserialize_struct(stream::VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL::Reader reader){
        auto result=VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderIntegerFunctions2)=reader.getShaderIntegerFunctions2();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceValueDataINTEL::Builder& builder, VkPerformanceValueDataINTEL member){
        
    
[&](){return builder.setValue32((member.value32));}();
[&](){return builder.setValue64((member.value64));}();
[&](){return builder.setValueFloat((member.valueFloat));}();
[&](){[&](){return builder.setValueBool((member.valueBool));}();}();
[&](){
            if ((member.valueString)==NULL){
                builder.initValueString(0);
            return; }
        auto proto_arr=builder.initValueString(strlen((member.valueString))+1);
        for(int RsZQIXp=0; RsZQIXp < strlen((member.valueString))+1; RsZQIXp++){
            [&](){return proto_arr.set(RsZQIXp,((member.valueString)[RsZQIXp]));}();
        }
        }();
}

    VkPerformanceValueDataINTEL deserialize_struct(stream::VkPerformanceValueDataINTEL::Reader reader){
        auto result=VkPerformanceValueDataINTEL();
    
[&](){(result.value32)=reader.getValue32();}();
[&](){(result.value64)=reader.getValue64();}();
[&](){(result.valueFloat)=reader.getValueFloat();}();
[&](){[&](){(result.valueBool)=reader.getValueBool();}();}();
[&](){ char* temp_fJvAAoV[&](){
            if (!reader.getValueString().size()==0){
                (result.valueString)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getValueString().size();*sizeof(char));
        auto proto_arr=reader.getValueString(reader.getValueString().size(););
        for(int oRlonMs=0; oRlonMs < reader.getValueString().size();; oRlonMs++){
            [&](){((result.valueString)[oRlonMs])=proto_arr[oRlonMs];}();
        }
        }();(result.valueString)=temp_fJvAAoV;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceValueDataINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceValueDataINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceValueINTEL::Builder& builder, VkPerformanceValueINTEL member){
        
    
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){
            auto temp=builder.initData(data);
            return serialize_struct(temp, (member.data));
            }();
}

    VkPerformanceValueINTEL deserialize_struct(stream::VkPerformanceValueINTEL::Reader reader){
        auto result=VkPerformanceValueINTEL();
    
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){
            auto temp=reader.getData();
            (result.data)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceValueINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceValueINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkInitializePerformanceApiInfoINTEL::Builder& builder, VkInitializePerformanceApiInfoINTEL member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initPUserData(pUserData);
            return serialize_struct(temp, (member.pUserData));
            }();
}

    VkInitializePerformanceApiInfoINTEL deserialize_struct(stream::VkInitializePerformanceApiInfoINTEL::Reader reader){
        auto result=VkInitializePerformanceApiInfoINTEL();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getPUserData();
            (result.pUserData)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkInitializePerformanceApiInfoINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkInitializePerformanceApiInfoINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueryPoolPerformanceQueryCreateInfoINTEL::Builder& builder, VkQueryPoolPerformanceQueryCreateInfoINTEL member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPerformanceCountersSampling((member.performanceCountersSampling));}();}();}();
}

    VkQueryPoolPerformanceQueryCreateInfoINTEL deserialize_struct(stream::VkQueryPoolPerformanceQueryCreateInfoINTEL::Reader reader){
        auto result=VkQueryPoolPerformanceQueryCreateInfoINTEL();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.performanceCountersSampling)=reader.getPerformanceCountersSampling();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueryPoolPerformanceQueryCreateInfoINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueryPoolPerformanceQueryCreateInfoINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceMarkerInfoINTEL::Builder& builder, VkPerformanceMarkerInfoINTEL member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMarker((member.marker));}();
}

    VkPerformanceMarkerInfoINTEL deserialize_struct(stream::VkPerformanceMarkerInfoINTEL::Reader reader){
        auto result=VkPerformanceMarkerInfoINTEL();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.marker)=reader.getMarker();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceMarkerInfoINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceMarkerInfoINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceStreamMarkerInfoINTEL::Builder& builder, VkPerformanceStreamMarkerInfoINTEL member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMarker((member.marker));}();
}

    VkPerformanceStreamMarkerInfoINTEL deserialize_struct(stream::VkPerformanceStreamMarkerInfoINTEL::Reader reader){
        auto result=VkPerformanceStreamMarkerInfoINTEL();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.marker)=reader.getMarker();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceStreamMarkerInfoINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceStreamMarkerInfoINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceOverrideInfoINTEL::Builder& builder, VkPerformanceOverrideInfoINTEL member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){return builder.setEnable((member.enable));}();}();
[&](){return builder.setParameter((member.parameter));}();
}

    VkPerformanceOverrideInfoINTEL deserialize_struct(stream::VkPerformanceOverrideInfoINTEL::Reader reader){
        auto result=VkPerformanceOverrideInfoINTEL();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){(result.enable)=reader.getEnable();}();}();
[&](){(result.parameter)=reader.getParameter();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceOverrideInfoINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceOverrideInfoINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPerformanceConfigurationAcquireInfoINTEL::Builder& builder, VkPerformanceConfigurationAcquireInfoINTEL member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
}

    VkPerformanceConfigurationAcquireInfoINTEL deserialize_struct(stream::VkPerformanceConfigurationAcquireInfoINTEL::Reader reader){
        auto result=VkPerformanceConfigurationAcquireInfoINTEL();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPerformanceConfigurationAcquireInfoINTEL member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPerformanceConfigurationAcquireInfoINTEL member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderClockFeaturesKHR::Builder& builder, VkPhysicalDeviceShaderClockFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderSubgroupClock((member.shaderSubgroupClock));}();}();
[&](){[&](){return builder.setShaderDeviceClock((member.shaderDeviceClock));}();}();
}

    VkPhysicalDeviceShaderClockFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceShaderClockFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceShaderClockFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderSubgroupClock)=reader.getShaderSubgroupClock();}();}();
[&](){[&](){(result.shaderDeviceClock)=reader.getShaderDeviceClock();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderClockFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderClockFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceIndexTypeUint8FeaturesEXT::Builder& builder, VkPhysicalDeviceIndexTypeUint8FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setIndexTypeUint8((member.indexTypeUint8));}();}();
}

    VkPhysicalDeviceIndexTypeUint8FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceIndexTypeUint8FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceIndexTypeUint8FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.indexTypeUint8)=reader.getIndexTypeUint8();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceIndexTypeUint8FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceIndexTypeUint8FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderSMBuiltinsPropertiesNV::Builder& builder, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setShaderSMCount((member.shaderSMCount));}();
[&](){return builder.setShaderWarpsPerSM((member.shaderWarpsPerSM));}();
}

    VkPhysicalDeviceShaderSMBuiltinsPropertiesNV deserialize_struct(stream::VkPhysicalDeviceShaderSMBuiltinsPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceShaderSMBuiltinsPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.shaderSMCount)=reader.getShaderSMCount();}();
[&](){(result.shaderWarpsPerSM)=reader.getShaderWarpsPerSM();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderSMBuiltinsFeaturesNV::Builder& builder, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderSMBuiltins((member.shaderSMBuiltins));}();}();
}

    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV deserialize_struct(stream::VkPhysicalDeviceShaderSMBuiltinsFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceShaderSMBuiltinsFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderSMBuiltins)=reader.getShaderSMBuiltins();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::Builder& builder, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFragmentShaderSampleInterlock((member.fragmentShaderSampleInterlock));}();}();
[&](){[&](){return builder.setFragmentShaderPixelInterlock((member.fragmentShaderPixelInterlock));}();}();
[&](){[&](){return builder.setFragmentShaderShadingRateInterlock((member.fragmentShaderShadingRateInterlock));}();}();
}

    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.fragmentShaderSampleInterlock)=reader.getFragmentShaderSampleInterlock();}();}();
[&](){[&](){(result.fragmentShaderPixelInterlock)=reader.getFragmentShaderPixelInterlock();}();}();
[&](){[&](){(result.fragmentShaderShadingRateInterlock)=reader.getFragmentShaderShadingRateInterlock();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::Builder& builder, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSeparateDepthStencilLayouts((member.separateDepthStencilLayouts));}();}();
}

    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures deserialize_struct(stream::VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures::Reader reader){
        auto result=VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.separateDepthStencilLayouts)=reader.getSeparateDepthStencilLayouts();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentReferenceStencilLayout::Builder& builder, VkAttachmentReferenceStencilLayout member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setStencilLayout((member.stencilLayout));}();}();}();
}

    VkAttachmentReferenceStencilLayout deserialize_struct(stream::VkAttachmentReferenceStencilLayout::Reader reader){
        auto result=VkAttachmentReferenceStencilLayout();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.stencilLayout)=reader.getStencilLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentReferenceStencilLayout member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentReferenceStencilLayout member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT::Builder& builder, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPrimitiveTopologyListRestart((member.primitiveTopologyListRestart));}();}();
[&](){[&](){return builder.setPrimitiveTopologyPatchListRestart((member.primitiveTopologyPatchListRestart));}();}();
}

    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT deserialize_struct(stream::VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.primitiveTopologyListRestart)=reader.getPrimitiveTopologyListRestart();}();}();
[&](){[&](){(result.primitiveTopologyPatchListRestart)=reader.getPrimitiveTopologyPatchListRestart();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentDescriptionStencilLayout::Builder& builder, VkAttachmentDescriptionStencilLayout member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setStencilInitialLayout((member.stencilInitialLayout));}();}();}();
[&](){[&](){[&](){return builder.setStencilFinalLayout((member.stencilFinalLayout));}();}();}();
}

    VkAttachmentDescriptionStencilLayout deserialize_struct(stream::VkAttachmentDescriptionStencilLayout::Reader reader){
        auto result=VkAttachmentDescriptionStencilLayout();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.stencilInitialLayout)=reader.getStencilInitialLayout();}();}();}();
[&](){[&](){[&](){(result.stencilFinalLayout)=reader.getStencilFinalLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentDescriptionStencilLayout member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentDescriptionStencilLayout member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::Builder& builder, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPipelineExecutableInfo((member.pipelineExecutableInfo));}();}();
}

    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR deserialize_struct(stream::VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR::Reader reader){
        auto result=VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pipelineExecutableInfo)=reader.getPipelineExecutableInfo();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineInfoKHR::Builder& builder, VkPipelineInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPipeline(serialize_handle(member.pipeline));}();
}

    VkPipelineInfoKHR deserialize_struct(stream::VkPipelineInfoKHR::Reader reader){
        auto result=VkPipelineInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.pipeline)=deserialize_VkPipeline(reader.getPipeline());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineExecutablePropertiesKHR::Builder& builder, VkPipelineExecutablePropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setStages((member.stages));}();}();}();
[&](){
        auto proto_arr=builder.initName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){return proto_arr.set(hWobsSN,((member.name)[hWobsSN]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
[&](){return builder.setSubgroupSize((member.subgroupSize));}();
}

    VkPipelineExecutablePropertiesKHR deserialize_struct(stream::VkPipelineExecutablePropertiesKHR::Reader reader){
        auto result=VkPipelineExecutablePropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.stages)=reader.getStages();}();}();}();
[&](){
        auto proto_arr=reader.getName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){((result.name)[hWobsSN])=proto_arr[hWobsSN];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
[&](){(result.subgroupSize)=reader.getSubgroupSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineExecutablePropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineExecutablePropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineExecutableInfoKHR::Builder& builder, VkPipelineExecutableInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPipeline(serialize_handle(member.pipeline));}();
[&](){return builder.setExecutableIndex((member.executableIndex));}();
}

    VkPipelineExecutableInfoKHR deserialize_struct(stream::VkPipelineExecutableInfoKHR::Reader reader){
        auto result=VkPipelineExecutableInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.pipeline)=deserialize_VkPipeline(reader.getPipeline());}();
[&](){(result.executableIndex)=reader.getExecutableIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineExecutableInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineExecutableInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineExecutableStatisticValueKHR::Builder& builder, VkPipelineExecutableStatisticValueKHR member){
        
    
[&](){[&](){return builder.setB32((member.b32));}();}();
[&](){return builder.setI64((member.i64));}();
[&](){return builder.setU64((member.u64));}();
[&](){return builder.setF64((member.f64));}();
}

    VkPipelineExecutableStatisticValueKHR deserialize_struct(stream::VkPipelineExecutableStatisticValueKHR::Reader reader){
        auto result=VkPipelineExecutableStatisticValueKHR();
    
[&](){[&](){(result.b32)=reader.getB32();}();}();
[&](){(result.i64)=reader.getI64();}();
[&](){(result.u64)=reader.getU64();}();
[&](){(result.f64)=reader.getF64();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineExecutableStatisticValueKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineExecutableStatisticValueKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineExecutableStatisticKHR::Builder& builder, VkPipelineExecutableStatisticKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){return proto_arr.set(hWobsSN,((member.name)[hWobsSN]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){
            auto temp=builder.initValue(value);
            return serialize_struct(temp, (member.value));
            }();
}

    VkPipelineExecutableStatisticKHR deserialize_struct(stream::VkPipelineExecutableStatisticKHR::Reader reader){
        auto result=VkPipelineExecutableStatisticKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){((result.name)[hWobsSN])=proto_arr[hWobsSN];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){
            auto temp=reader.getValue();
            (result.value)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineExecutableStatisticKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineExecutableStatisticKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineExecutableInternalRepresentationKHR::Builder& builder, VkPipelineExecutableInternalRepresentationKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){return proto_arr.set(hWobsSN,((member.name)[hWobsSN]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
[&](){[&](){return builder.setIsText((member.isText));}();}();
[&](){return builder.setDataSize((member.dataSize));}();
[&](){
            if ((member.pData)==NULL){
                builder.initPData(0);
            return; }[&](){
            if (((char*)(member.pData).pData)==NULL){
                builder.initPData(0);
            return; }
        auto proto_arr=builder.initPData(member.dataSize);
        for(int AJXlqIY=0; AJXlqIY < member.dataSize; AJXlqIY++){
            [&](){return proto_arr.set(AJXlqIY,(((char*)(member.pData).pData)[AJXlqIY]));}();
        }
        }();}();
}

    VkPipelineExecutableInternalRepresentationKHR deserialize_struct(stream::VkPipelineExecutableInternalRepresentationKHR::Reader reader){
        auto result=VkPipelineExecutableInternalRepresentationKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getName(VK_MAX_DESCRIPTION_SIZE);
        for(int hWobsSN=0; hWobsSN < VK_MAX_DESCRIPTION_SIZE; hWobsSN++){
            [&](){((result.name)[hWobsSN])=proto_arr[hWobsSN];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
[&](){[&](){(result.isText)=reader.getIsText();}();}();
[&](){(result.dataSize)=reader.getDataSize();}();
[&](){
            if (!reader.getPData().size()==0){
                (result.pData)=NULL;
            return; }char* temp_THmQoYp;[&](){
            if (!reader.getPData().size()==0){
                (temp_THmQoYp.pData)=NULL;
            return; }{native_concat()}=(char*)malloc(result.dataSize*sizeof(char));
        auto proto_arr=reader.getPData(result.dataSize);
        for(int AJXlqIY=0; AJXlqIY < result.dataSize; AJXlqIY++){
            [&](){((temp_THmQoYp.pData)[AJXlqIY])=proto_arr[AJXlqIY];}();
        }
        }();(result.pData)=temp_THmQoYp;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineExecutableInternalRepresentationKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineExecutableInternalRepresentationKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures::Builder& builder, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderDemoteToHelperInvocation((member.shaderDemoteToHelperInvocation));}();}();
}

    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures deserialize_struct(stream::VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures::Reader reader){
        auto result=VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderDemoteToHelperInvocation)=reader.getShaderDemoteToHelperInvocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::Builder& builder, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTexelBufferAlignment((member.texelBufferAlignment));}();}();
}

    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.texelBufferAlignment)=reader.getTexelBufferAlignment();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTexelBufferAlignmentProperties::Builder& builder, VkPhysicalDeviceTexelBufferAlignmentProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setStorageTexelBufferOffsetAlignmentBytes((member.storageTexelBufferOffsetAlignmentBytes));}();}();
[&](){[&](){return builder.setStorageTexelBufferOffsetSingleTexelAlignment((member.storageTexelBufferOffsetSingleTexelAlignment));}();}();
[&](){[&](){return builder.setUniformTexelBufferOffsetAlignmentBytes((member.uniformTexelBufferOffsetAlignmentBytes));}();}();
[&](){[&](){return builder.setUniformTexelBufferOffsetSingleTexelAlignment((member.uniformTexelBufferOffsetSingleTexelAlignment));}();}();
}

    VkPhysicalDeviceTexelBufferAlignmentProperties deserialize_struct(stream::VkPhysicalDeviceTexelBufferAlignmentProperties::Reader reader){
        auto result=VkPhysicalDeviceTexelBufferAlignmentProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.storageTexelBufferOffsetAlignmentBytes)=reader.getStorageTexelBufferOffsetAlignmentBytes();}();}();
[&](){[&](){(result.storageTexelBufferOffsetSingleTexelAlignment)=reader.getStorageTexelBufferOffsetSingleTexelAlignment();}();}();
[&](){[&](){(result.uniformTexelBufferOffsetAlignmentBytes)=reader.getUniformTexelBufferOffsetAlignmentBytes();}();}();
[&](){[&](){(result.uniformTexelBufferOffsetSingleTexelAlignment)=reader.getUniformTexelBufferOffsetSingleTexelAlignment();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTexelBufferAlignmentProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTexelBufferAlignmentProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSubgroupSizeControlFeatures::Builder& builder, VkPhysicalDeviceSubgroupSizeControlFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSubgroupSizeControl((member.subgroupSizeControl));}();}();
[&](){[&](){return builder.setComputeFullSubgroups((member.computeFullSubgroups));}();}();
}

    VkPhysicalDeviceSubgroupSizeControlFeatures deserialize_struct(stream::VkPhysicalDeviceSubgroupSizeControlFeatures::Reader reader){
        auto result=VkPhysicalDeviceSubgroupSizeControlFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.subgroupSizeControl)=reader.getSubgroupSizeControl();}();}();
[&](){[&](){(result.computeFullSubgroups)=reader.getComputeFullSubgroups();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSubgroupSizeControlFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSubgroupSizeControlFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSubgroupSizeControlProperties::Builder& builder, VkPhysicalDeviceSubgroupSizeControlProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMinSubgroupSize((member.minSubgroupSize));}();
[&](){return builder.setMaxSubgroupSize((member.maxSubgroupSize));}();
[&](){return builder.setMaxComputeWorkgroupSubgroups((member.maxComputeWorkgroupSubgroups));}();
[&](){[&](){[&](){return builder.setRequiredSubgroupSizeStages((member.requiredSubgroupSizeStages));}();}();}();
}

    VkPhysicalDeviceSubgroupSizeControlProperties deserialize_struct(stream::VkPhysicalDeviceSubgroupSizeControlProperties::Reader reader){
        auto result=VkPhysicalDeviceSubgroupSizeControlProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.minSubgroupSize)=reader.getMinSubgroupSize();}();
[&](){(result.maxSubgroupSize)=reader.getMaxSubgroupSize();}();
[&](){(result.maxComputeWorkgroupSubgroups)=reader.getMaxComputeWorkgroupSubgroups();}();
[&](){[&](){[&](){(result.requiredSubgroupSizeStages)=reader.getRequiredSubgroupSizeStages();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSubgroupSizeControlProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSubgroupSizeControlProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::Builder& builder, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setRequiredSubgroupSize((member.requiredSubgroupSize));}();
}

    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo deserialize_struct(stream::VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::Reader reader){
        auto result=VkPipelineShaderStageRequiredSubgroupSizeCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.requiredSubgroupSize)=reader.getRequiredSubgroupSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineShaderStageRequiredSubgroupSizeCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassShadingPipelineCreateInfoHUAWEI::Builder& builder, VkSubpassShadingPipelineCreateInfoHUAWEI member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setRenderPass(serialize_handle(member.renderPass));}();
[&](){return builder.setSubpass((member.subpass));}();
}

    VkSubpassShadingPipelineCreateInfoHUAWEI deserialize_struct(stream::VkSubpassShadingPipelineCreateInfoHUAWEI::Reader reader){
        auto result=VkSubpassShadingPipelineCreateInfoHUAWEI();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.renderPass)=deserialize_VkRenderPass(reader.getRenderPass());}();
[&](){(result.subpass)=reader.getSubpass();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassShadingPipelineCreateInfoHUAWEI member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassShadingPipelineCreateInfoHUAWEI member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSubpassShadingPropertiesHUAWEI::Builder& builder, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxSubpassShadingWorkgroupSizeAspectRatio((member.maxSubpassShadingWorkgroupSizeAspectRatio));}();
}

    VkPhysicalDeviceSubpassShadingPropertiesHUAWEI deserialize_struct(stream::VkPhysicalDeviceSubpassShadingPropertiesHUAWEI::Reader reader){
        auto result=VkPhysicalDeviceSubpassShadingPropertiesHUAWEI();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxSubpassShadingWorkgroupSizeAspectRatio)=reader.getMaxSubpassShadingWorkgroupSizeAspectRatio();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::Builder& builder, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initMaxWorkGroupCount(3);
        for(int uxSgNpu=0; uxSgNpu < 3; uxSgNpu++){
            [&](){return proto_arr.set(uxSgNpu,((member.maxWorkGroupCount)[uxSgNpu]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initMaxWorkGroupSize(3);
        for(int JubkVsI=0; JubkVsI < 3; JubkVsI++){
            [&](){return proto_arr.set(JubkVsI,((member.maxWorkGroupSize)[JubkVsI]));}();
        }
        }();
[&](){return builder.setMaxOutputClusterCount((member.maxOutputClusterCount));}();
[&](){[&](){return builder.setIndirectBufferOffsetAlignment((member.indirectBufferOffsetAlignment));}();}();
}

    VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI deserialize_struct(stream::VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI::Reader reader){
        auto result=VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getMaxWorkGroupCount(3);
        for(int uxSgNpu=0; uxSgNpu < 3; uxSgNpu++){
            [&](){((result.maxWorkGroupCount)[uxSgNpu])=proto_arr[uxSgNpu];}();
        }
        }();
[&](){
        auto proto_arr=reader.getMaxWorkGroupSize(3);
        for(int JubkVsI=0; JubkVsI < 3; JubkVsI++){
            [&](){((result.maxWorkGroupSize)[JubkVsI])=proto_arr[JubkVsI];}();
        }
        }();
[&](){(result.maxOutputClusterCount)=reader.getMaxOutputClusterCount();}();
[&](){[&](){(result.indirectBufferOffsetAlignment)=reader.getIndirectBufferOffsetAlignment();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryOpaqueCaptureAddressAllocateInfo::Builder& builder, VkMemoryOpaqueCaptureAddressAllocateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setOpaqueCaptureAddress((member.opaqueCaptureAddress));}();
}

    VkMemoryOpaqueCaptureAddressAllocateInfo deserialize_struct(stream::VkMemoryOpaqueCaptureAddressAllocateInfo::Reader reader){
        auto result=VkMemoryOpaqueCaptureAddressAllocateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.opaqueCaptureAddress)=reader.getOpaqueCaptureAddress();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryOpaqueCaptureAddressAllocateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryOpaqueCaptureAddressAllocateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceMemoryOpaqueCaptureAddressInfo::Builder& builder, VkDeviceMemoryOpaqueCaptureAddressInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
}

    VkDeviceMemoryOpaqueCaptureAddressInfo deserialize_struct(stream::VkDeviceMemoryOpaqueCaptureAddressInfo::Reader reader){
        auto result=VkDeviceMemoryOpaqueCaptureAddressInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceMemoryOpaqueCaptureAddressInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceMemoryOpaqueCaptureAddressInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceLineRasterizationFeaturesEXT::Builder& builder, VkPhysicalDeviceLineRasterizationFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRectangularLines((member.rectangularLines));}();}();
[&](){[&](){return builder.setBresenhamLines((member.bresenhamLines));}();}();
[&](){[&](){return builder.setSmoothLines((member.smoothLines));}();}();
[&](){[&](){return builder.setStippledRectangularLines((member.stippledRectangularLines));}();}();
[&](){[&](){return builder.setStippledBresenhamLines((member.stippledBresenhamLines));}();}();
[&](){[&](){return builder.setStippledSmoothLines((member.stippledSmoothLines));}();}();
}

    VkPhysicalDeviceLineRasterizationFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceLineRasterizationFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceLineRasterizationFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rectangularLines)=reader.getRectangularLines();}();}();
[&](){[&](){(result.bresenhamLines)=reader.getBresenhamLines();}();}();
[&](){[&](){(result.smoothLines)=reader.getSmoothLines();}();}();
[&](){[&](){(result.stippledRectangularLines)=reader.getStippledRectangularLines();}();}();
[&](){[&](){(result.stippledBresenhamLines)=reader.getStippledBresenhamLines();}();}();
[&](){[&](){(result.stippledSmoothLines)=reader.getStippledSmoothLines();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceLineRasterizationFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceLineRasterizationFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceLineRasterizationPropertiesEXT::Builder& builder, VkPhysicalDeviceLineRasterizationPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setLineSubPixelPrecisionBits((member.lineSubPixelPrecisionBits));}();
}

    VkPhysicalDeviceLineRasterizationPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceLineRasterizationPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceLineRasterizationPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.lineSubPixelPrecisionBits)=reader.getLineSubPixelPrecisionBits();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceLineRasterizationPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceLineRasterizationPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRasterizationLineStateCreateInfoEXT::Builder& builder, VkPipelineRasterizationLineStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setLineRasterizationMode((member.lineRasterizationMode));}();}();}();
[&](){[&](){return builder.setStippledLineEnable((member.stippledLineEnable));}();}();
[&](){return builder.setLineStippleFactor((member.lineStippleFactor));}();
[&](){return builder.setLineStipplePattern((member.lineStipplePattern));}();
}

    VkPipelineRasterizationLineStateCreateInfoEXT deserialize_struct(stream::VkPipelineRasterizationLineStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineRasterizationLineStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.lineRasterizationMode)=reader.getLineRasterizationMode();}();}();}();
[&](){[&](){(result.stippledLineEnable)=reader.getStippledLineEnable();}();}();
[&](){(result.lineStippleFactor)=reader.getLineStippleFactor();}();
[&](){(result.lineStipplePattern)=reader.getLineStipplePattern();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRasterizationLineStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRasterizationLineStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePipelineCreationCacheControlFeatures::Builder& builder, VkPhysicalDevicePipelineCreationCacheControlFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPipelineCreationCacheControl((member.pipelineCreationCacheControl));}();}();
}

    VkPhysicalDevicePipelineCreationCacheControlFeatures deserialize_struct(stream::VkPhysicalDevicePipelineCreationCacheControlFeatures::Reader reader){
        auto result=VkPhysicalDevicePipelineCreationCacheControlFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pipelineCreationCacheControl)=reader.getPipelineCreationCacheControl();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePipelineCreationCacheControlFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePipelineCreationCacheControlFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVulkan11Features::Builder& builder, VkPhysicalDeviceVulkan11Features member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setStorageBuffer16BitAccess((member.storageBuffer16BitAccess));}();}();
[&](){[&](){return builder.setUniformAndStorageBuffer16BitAccess((member.uniformAndStorageBuffer16BitAccess));}();}();
[&](){[&](){return builder.setStoragePushConstant16((member.storagePushConstant16));}();}();
[&](){[&](){return builder.setStorageInputOutput16((member.storageInputOutput16));}();}();
[&](){[&](){return builder.setMultiview((member.multiview));}();}();
[&](){[&](){return builder.setMultiviewGeometryShader((member.multiviewGeometryShader));}();}();
[&](){[&](){return builder.setMultiviewTessellationShader((member.multiviewTessellationShader));}();}();
[&](){[&](){return builder.setVariablePointersStorageBuffer((member.variablePointersStorageBuffer));}();}();
[&](){[&](){return builder.setVariablePointers((member.variablePointers));}();}();
[&](){[&](){return builder.setProtectedMemory((member.protectedMemory));}();}();
[&](){[&](){return builder.setSamplerYcbcrConversion((member.samplerYcbcrConversion));}();}();
[&](){[&](){return builder.setShaderDrawParameters((member.shaderDrawParameters));}();}();
}

    VkPhysicalDeviceVulkan11Features deserialize_struct(stream::VkPhysicalDeviceVulkan11Features::Reader reader){
        auto result=VkPhysicalDeviceVulkan11Features();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.storageBuffer16BitAccess)=reader.getStorageBuffer16BitAccess();}();}();
[&](){[&](){(result.uniformAndStorageBuffer16BitAccess)=reader.getUniformAndStorageBuffer16BitAccess();}();}();
[&](){[&](){(result.storagePushConstant16)=reader.getStoragePushConstant16();}();}();
[&](){[&](){(result.storageInputOutput16)=reader.getStorageInputOutput16();}();}();
[&](){[&](){(result.multiview)=reader.getMultiview();}();}();
[&](){[&](){(result.multiviewGeometryShader)=reader.getMultiviewGeometryShader();}();}();
[&](){[&](){(result.multiviewTessellationShader)=reader.getMultiviewTessellationShader();}();}();
[&](){[&](){(result.variablePointersStorageBuffer)=reader.getVariablePointersStorageBuffer();}();}();
[&](){[&](){(result.variablePointers)=reader.getVariablePointers();}();}();
[&](){[&](){(result.protectedMemory)=reader.getProtectedMemory();}();}();
[&](){[&](){(result.samplerYcbcrConversion)=reader.getSamplerYcbcrConversion();}();}();
[&](){[&](){(result.shaderDrawParameters)=reader.getShaderDrawParameters();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVulkan11Features member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVulkan11Features member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVulkan11Properties::Builder& builder, VkPhysicalDeviceVulkan11Properties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initDeviceUUID(VK_UUID_SIZE);
        for(int LghVtrk=0; LghVtrk < VK_UUID_SIZE; LghVtrk++){
            [&](){return proto_arr.set(LghVtrk,((member.deviceUUID)[LghVtrk]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDriverUUID(VK_UUID_SIZE);
        for(int WbhUlZS=0; WbhUlZS < VK_UUID_SIZE; WbhUlZS++){
            [&](){return proto_arr.set(WbhUlZS,((member.driverUUID)[WbhUlZS]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDeviceLUID(VK_LUID_SIZE);
        for(int kitdKfY=0; kitdKfY < VK_LUID_SIZE; kitdKfY++){
            [&](){return proto_arr.set(kitdKfY,((member.deviceLUID)[kitdKfY]));}();
        }
        }();
[&](){return builder.setDeviceNodeMask((member.deviceNodeMask));}();
[&](){[&](){return builder.setDeviceLUIDValid((member.deviceLUIDValid));}();}();
[&](){return builder.setSubgroupSize((member.subgroupSize));}();
[&](){[&](){[&](){return builder.setSubgroupSupportedStages((member.subgroupSupportedStages));}();}();}();
[&](){[&](){[&](){return builder.setSubgroupSupportedOperations((member.subgroupSupportedOperations));}();}();}();
[&](){[&](){return builder.setSubgroupQuadOperationsInAllStages((member.subgroupQuadOperationsInAllStages));}();}();
[&](){[&](){[&](){return builder.setPointClippingBehavior((member.pointClippingBehavior));}();}();}();
[&](){return builder.setMaxMultiviewViewCount((member.maxMultiviewViewCount));}();
[&](){return builder.setMaxMultiviewInstanceIndex((member.maxMultiviewInstanceIndex));}();
[&](){[&](){return builder.setProtectedNoFault((member.protectedNoFault));}();}();
[&](){return builder.setMaxPerSetDescriptors((member.maxPerSetDescriptors));}();
[&](){[&](){return builder.setMaxMemoryAllocationSize((member.maxMemoryAllocationSize));}();}();
}

    VkPhysicalDeviceVulkan11Properties deserialize_struct(stream::VkPhysicalDeviceVulkan11Properties::Reader reader){
        auto result=VkPhysicalDeviceVulkan11Properties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getDeviceUUID(VK_UUID_SIZE);
        for(int LghVtrk=0; LghVtrk < VK_UUID_SIZE; LghVtrk++){
            [&](){((result.deviceUUID)[LghVtrk])=proto_arr[LghVtrk];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDriverUUID(VK_UUID_SIZE);
        for(int WbhUlZS=0; WbhUlZS < VK_UUID_SIZE; WbhUlZS++){
            [&](){((result.driverUUID)[WbhUlZS])=proto_arr[WbhUlZS];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDeviceLUID(VK_LUID_SIZE);
        for(int kitdKfY=0; kitdKfY < VK_LUID_SIZE; kitdKfY++){
            [&](){((result.deviceLUID)[kitdKfY])=proto_arr[kitdKfY];}();
        }
        }();
[&](){(result.deviceNodeMask)=reader.getDeviceNodeMask();}();
[&](){[&](){(result.deviceLUIDValid)=reader.getDeviceLUIDValid();}();}();
[&](){(result.subgroupSize)=reader.getSubgroupSize();}();
[&](){[&](){[&](){(result.subgroupSupportedStages)=reader.getSubgroupSupportedStages();}();}();}();
[&](){[&](){[&](){(result.subgroupSupportedOperations)=reader.getSubgroupSupportedOperations();}();}();}();
[&](){[&](){(result.subgroupQuadOperationsInAllStages)=reader.getSubgroupQuadOperationsInAllStages();}();}();
[&](){[&](){[&](){(result.pointClippingBehavior)=reader.getPointClippingBehavior();}();}();}();
[&](){(result.maxMultiviewViewCount)=reader.getMaxMultiviewViewCount();}();
[&](){(result.maxMultiviewInstanceIndex)=reader.getMaxMultiviewInstanceIndex();}();
[&](){[&](){(result.protectedNoFault)=reader.getProtectedNoFault();}();}();
[&](){(result.maxPerSetDescriptors)=reader.getMaxPerSetDescriptors();}();
[&](){[&](){(result.maxMemoryAllocationSize)=reader.getMaxMemoryAllocationSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVulkan11Properties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVulkan11Properties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVulkan12Features::Builder& builder, VkPhysicalDeviceVulkan12Features member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSamplerMirrorClampToEdge((member.samplerMirrorClampToEdge));}();}();
[&](){[&](){return builder.setDrawIndirectCount((member.drawIndirectCount));}();}();
[&](){[&](){return builder.setStorageBuffer8BitAccess((member.storageBuffer8BitAccess));}();}();
[&](){[&](){return builder.setUniformAndStorageBuffer8BitAccess((member.uniformAndStorageBuffer8BitAccess));}();}();
[&](){[&](){return builder.setStoragePushConstant8((member.storagePushConstant8));}();}();
[&](){[&](){return builder.setShaderBufferInt64Atomics((member.shaderBufferInt64Atomics));}();}();
[&](){[&](){return builder.setShaderSharedInt64Atomics((member.shaderSharedInt64Atomics));}();}();
[&](){[&](){return builder.setShaderFloat16((member.shaderFloat16));}();}();
[&](){[&](){return builder.setShaderInt8((member.shaderInt8));}();}();
[&](){[&](){return builder.setDescriptorIndexing((member.descriptorIndexing));}();}();
[&](){[&](){return builder.setShaderInputAttachmentArrayDynamicIndexing((member.shaderInputAttachmentArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderUniformTexelBufferArrayDynamicIndexing((member.shaderUniformTexelBufferArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderStorageTexelBufferArrayDynamicIndexing((member.shaderStorageTexelBufferArrayDynamicIndexing));}();}();
[&](){[&](){return builder.setShaderUniformBufferArrayNonUniformIndexing((member.shaderUniformBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderSampledImageArrayNonUniformIndexing((member.shaderSampledImageArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderStorageBufferArrayNonUniformIndexing((member.shaderStorageBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderStorageImageArrayNonUniformIndexing((member.shaderStorageImageArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderInputAttachmentArrayNonUniformIndexing((member.shaderInputAttachmentArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderUniformTexelBufferArrayNonUniformIndexing((member.shaderUniformTexelBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setShaderStorageTexelBufferArrayNonUniformIndexing((member.shaderStorageTexelBufferArrayNonUniformIndexing));}();}();
[&](){[&](){return builder.setDescriptorBindingUniformBufferUpdateAfterBind((member.descriptorBindingUniformBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingSampledImageUpdateAfterBind((member.descriptorBindingSampledImageUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingStorageImageUpdateAfterBind((member.descriptorBindingStorageImageUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingStorageBufferUpdateAfterBind((member.descriptorBindingStorageBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingUniformTexelBufferUpdateAfterBind((member.descriptorBindingUniformTexelBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingStorageTexelBufferUpdateAfterBind((member.descriptorBindingStorageTexelBufferUpdateAfterBind));}();}();
[&](){[&](){return builder.setDescriptorBindingUpdateUnusedWhilePending((member.descriptorBindingUpdateUnusedWhilePending));}();}();
[&](){[&](){return builder.setDescriptorBindingPartiallyBound((member.descriptorBindingPartiallyBound));}();}();
[&](){[&](){return builder.setDescriptorBindingVariableDescriptorCount((member.descriptorBindingVariableDescriptorCount));}();}();
[&](){[&](){return builder.setRuntimeDescriptorArray((member.runtimeDescriptorArray));}();}();
[&](){[&](){return builder.setSamplerFilterMinmax((member.samplerFilterMinmax));}();}();
[&](){[&](){return builder.setScalarBlockLayout((member.scalarBlockLayout));}();}();
[&](){[&](){return builder.setImagelessFramebuffer((member.imagelessFramebuffer));}();}();
[&](){[&](){return builder.setUniformBufferStandardLayout((member.uniformBufferStandardLayout));}();}();
[&](){[&](){return builder.setShaderSubgroupExtendedTypes((member.shaderSubgroupExtendedTypes));}();}();
[&](){[&](){return builder.setSeparateDepthStencilLayouts((member.separateDepthStencilLayouts));}();}();
[&](){[&](){return builder.setHostQueryReset((member.hostQueryReset));}();}();
[&](){[&](){return builder.setTimelineSemaphore((member.timelineSemaphore));}();}();
[&](){[&](){return builder.setBufferDeviceAddress((member.bufferDeviceAddress));}();}();
[&](){[&](){return builder.setBufferDeviceAddressCaptureReplay((member.bufferDeviceAddressCaptureReplay));}();}();
[&](){[&](){return builder.setBufferDeviceAddressMultiDevice((member.bufferDeviceAddressMultiDevice));}();}();
[&](){[&](){return builder.setVulkanMemoryModel((member.vulkanMemoryModel));}();}();
[&](){[&](){return builder.setVulkanMemoryModelDeviceScope((member.vulkanMemoryModelDeviceScope));}();}();
[&](){[&](){return builder.setVulkanMemoryModelAvailabilityVisibilityChains((member.vulkanMemoryModelAvailabilityVisibilityChains));}();}();
[&](){[&](){return builder.setShaderOutputViewportIndex((member.shaderOutputViewportIndex));}();}();
[&](){[&](){return builder.setShaderOutputLayer((member.shaderOutputLayer));}();}();
[&](){[&](){return builder.setSubgroupBroadcastDynamicId((member.subgroupBroadcastDynamicId));}();}();
}

    VkPhysicalDeviceVulkan12Features deserialize_struct(stream::VkPhysicalDeviceVulkan12Features::Reader reader){
        auto result=VkPhysicalDeviceVulkan12Features();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.samplerMirrorClampToEdge)=reader.getSamplerMirrorClampToEdge();}();}();
[&](){[&](){(result.drawIndirectCount)=reader.getDrawIndirectCount();}();}();
[&](){[&](){(result.storageBuffer8BitAccess)=reader.getStorageBuffer8BitAccess();}();}();
[&](){[&](){(result.uniformAndStorageBuffer8BitAccess)=reader.getUniformAndStorageBuffer8BitAccess();}();}();
[&](){[&](){(result.storagePushConstant8)=reader.getStoragePushConstant8();}();}();
[&](){[&](){(result.shaderBufferInt64Atomics)=reader.getShaderBufferInt64Atomics();}();}();
[&](){[&](){(result.shaderSharedInt64Atomics)=reader.getShaderSharedInt64Atomics();}();}();
[&](){[&](){(result.shaderFloat16)=reader.getShaderFloat16();}();}();
[&](){[&](){(result.shaderInt8)=reader.getShaderInt8();}();}();
[&](){[&](){(result.descriptorIndexing)=reader.getDescriptorIndexing();}();}();
[&](){[&](){(result.shaderInputAttachmentArrayDynamicIndexing)=reader.getShaderInputAttachmentArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderUniformTexelBufferArrayDynamicIndexing)=reader.getShaderUniformTexelBufferArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderStorageTexelBufferArrayDynamicIndexing)=reader.getShaderStorageTexelBufferArrayDynamicIndexing();}();}();
[&](){[&](){(result.shaderUniformBufferArrayNonUniformIndexing)=reader.getShaderUniformBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderSampledImageArrayNonUniformIndexing)=reader.getShaderSampledImageArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderStorageBufferArrayNonUniformIndexing)=reader.getShaderStorageBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderStorageImageArrayNonUniformIndexing)=reader.getShaderStorageImageArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderInputAttachmentArrayNonUniformIndexing)=reader.getShaderInputAttachmentArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderUniformTexelBufferArrayNonUniformIndexing)=reader.getShaderUniformTexelBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.shaderStorageTexelBufferArrayNonUniformIndexing)=reader.getShaderStorageTexelBufferArrayNonUniformIndexing();}();}();
[&](){[&](){(result.descriptorBindingUniformBufferUpdateAfterBind)=reader.getDescriptorBindingUniformBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingSampledImageUpdateAfterBind)=reader.getDescriptorBindingSampledImageUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingStorageImageUpdateAfterBind)=reader.getDescriptorBindingStorageImageUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingStorageBufferUpdateAfterBind)=reader.getDescriptorBindingStorageBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingUniformTexelBufferUpdateAfterBind)=reader.getDescriptorBindingUniformTexelBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingStorageTexelBufferUpdateAfterBind)=reader.getDescriptorBindingStorageTexelBufferUpdateAfterBind();}();}();
[&](){[&](){(result.descriptorBindingUpdateUnusedWhilePending)=reader.getDescriptorBindingUpdateUnusedWhilePending();}();}();
[&](){[&](){(result.descriptorBindingPartiallyBound)=reader.getDescriptorBindingPartiallyBound();}();}();
[&](){[&](){(result.descriptorBindingVariableDescriptorCount)=reader.getDescriptorBindingVariableDescriptorCount();}();}();
[&](){[&](){(result.runtimeDescriptorArray)=reader.getRuntimeDescriptorArray();}();}();
[&](){[&](){(result.samplerFilterMinmax)=reader.getSamplerFilterMinmax();}();}();
[&](){[&](){(result.scalarBlockLayout)=reader.getScalarBlockLayout();}();}();
[&](){[&](){(result.imagelessFramebuffer)=reader.getImagelessFramebuffer();}();}();
[&](){[&](){(result.uniformBufferStandardLayout)=reader.getUniformBufferStandardLayout();}();}();
[&](){[&](){(result.shaderSubgroupExtendedTypes)=reader.getShaderSubgroupExtendedTypes();}();}();
[&](){[&](){(result.separateDepthStencilLayouts)=reader.getSeparateDepthStencilLayouts();}();}();
[&](){[&](){(result.hostQueryReset)=reader.getHostQueryReset();}();}();
[&](){[&](){(result.timelineSemaphore)=reader.getTimelineSemaphore();}();}();
[&](){[&](){(result.bufferDeviceAddress)=reader.getBufferDeviceAddress();}();}();
[&](){[&](){(result.bufferDeviceAddressCaptureReplay)=reader.getBufferDeviceAddressCaptureReplay();}();}();
[&](){[&](){(result.bufferDeviceAddressMultiDevice)=reader.getBufferDeviceAddressMultiDevice();}();}();
[&](){[&](){(result.vulkanMemoryModel)=reader.getVulkanMemoryModel();}();}();
[&](){[&](){(result.vulkanMemoryModelDeviceScope)=reader.getVulkanMemoryModelDeviceScope();}();}();
[&](){[&](){(result.vulkanMemoryModelAvailabilityVisibilityChains)=reader.getVulkanMemoryModelAvailabilityVisibilityChains();}();}();
[&](){[&](){(result.shaderOutputViewportIndex)=reader.getShaderOutputViewportIndex();}();}();
[&](){[&](){(result.shaderOutputLayer)=reader.getShaderOutputLayer();}();}();
[&](){[&](){(result.subgroupBroadcastDynamicId)=reader.getSubgroupBroadcastDynamicId();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVulkan12Features member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVulkan12Features member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVulkan12Properties::Builder& builder, VkPhysicalDeviceVulkan12Properties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDriverID((member.driverID));}();}();}();
[&](){
        auto proto_arr=builder.initDriverName(VK_MAX_DRIVER_NAME_SIZE);
        for(int eglnjYG=0; eglnjYG < VK_MAX_DRIVER_NAME_SIZE; eglnjYG++){
            [&](){return proto_arr.set(eglnjYG,((member.driverName)[eglnjYG]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initDriverInfo(VK_MAX_DRIVER_INFO_SIZE);
        for(int ygBYlpo=0; ygBYlpo < VK_MAX_DRIVER_INFO_SIZE; ygBYlpo++){
            [&](){return proto_arr.set(ygBYlpo,((member.driverInfo)[ygBYlpo]));}();
        }
        }();
[&](){
            auto temp=builder.initConformanceVersion(conformanceVersion);
            return serialize_struct(temp, (member.conformanceVersion));
            }();
[&](){[&](){[&](){return builder.setDenormBehaviorIndependence((member.denormBehaviorIndependence));}();}();}();
[&](){[&](){[&](){return builder.setRoundingModeIndependence((member.roundingModeIndependence));}();}();}();
[&](){[&](){return builder.setShaderSignedZeroInfNanPreserveFloat16((member.shaderSignedZeroInfNanPreserveFloat16));}();}();
[&](){[&](){return builder.setShaderSignedZeroInfNanPreserveFloat32((member.shaderSignedZeroInfNanPreserveFloat32));}();}();
[&](){[&](){return builder.setShaderSignedZeroInfNanPreserveFloat64((member.shaderSignedZeroInfNanPreserveFloat64));}();}();
[&](){[&](){return builder.setShaderDenormPreserveFloat16((member.shaderDenormPreserveFloat16));}();}();
[&](){[&](){return builder.setShaderDenormPreserveFloat32((member.shaderDenormPreserveFloat32));}();}();
[&](){[&](){return builder.setShaderDenormPreserveFloat64((member.shaderDenormPreserveFloat64));}();}();
[&](){[&](){return builder.setShaderDenormFlushToZeroFloat16((member.shaderDenormFlushToZeroFloat16));}();}();
[&](){[&](){return builder.setShaderDenormFlushToZeroFloat32((member.shaderDenormFlushToZeroFloat32));}();}();
[&](){[&](){return builder.setShaderDenormFlushToZeroFloat64((member.shaderDenormFlushToZeroFloat64));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTEFloat16((member.shaderRoundingModeRTEFloat16));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTEFloat32((member.shaderRoundingModeRTEFloat32));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTEFloat64((member.shaderRoundingModeRTEFloat64));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTZFloat16((member.shaderRoundingModeRTZFloat16));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTZFloat32((member.shaderRoundingModeRTZFloat32));}();}();
[&](){[&](){return builder.setShaderRoundingModeRTZFloat64((member.shaderRoundingModeRTZFloat64));}();}();
[&](){return builder.setMaxUpdateAfterBindDescriptorsInAllPools((member.maxUpdateAfterBindDescriptorsInAllPools));}();
[&](){[&](){return builder.setShaderUniformBufferArrayNonUniformIndexingNative((member.shaderUniformBufferArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderSampledImageArrayNonUniformIndexingNative((member.shaderSampledImageArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderStorageBufferArrayNonUniformIndexingNative((member.shaderStorageBufferArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderStorageImageArrayNonUniformIndexingNative((member.shaderStorageImageArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setShaderInputAttachmentArrayNonUniformIndexingNative((member.shaderInputAttachmentArrayNonUniformIndexingNative));}();}();
[&](){[&](){return builder.setRobustBufferAccessUpdateAfterBind((member.robustBufferAccessUpdateAfterBind));}();}();
[&](){[&](){return builder.setQuadDivergentImplicitLod((member.quadDivergentImplicitLod));}();}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindSamplers((member.maxPerStageDescriptorUpdateAfterBindSamplers));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindUniformBuffers((member.maxPerStageDescriptorUpdateAfterBindUniformBuffers));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindStorageBuffers((member.maxPerStageDescriptorUpdateAfterBindStorageBuffers));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindSampledImages((member.maxPerStageDescriptorUpdateAfterBindSampledImages));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindStorageImages((member.maxPerStageDescriptorUpdateAfterBindStorageImages));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindInputAttachments((member.maxPerStageDescriptorUpdateAfterBindInputAttachments));}();
[&](){return builder.setMaxPerStageUpdateAfterBindResources((member.maxPerStageUpdateAfterBindResources));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindSamplers((member.maxDescriptorSetUpdateAfterBindSamplers));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindUniformBuffers((member.maxDescriptorSetUpdateAfterBindUniformBuffers));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic((member.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindStorageBuffers((member.maxDescriptorSetUpdateAfterBindStorageBuffers));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic((member.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindSampledImages((member.maxDescriptorSetUpdateAfterBindSampledImages));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindStorageImages((member.maxDescriptorSetUpdateAfterBindStorageImages));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindInputAttachments((member.maxDescriptorSetUpdateAfterBindInputAttachments));}();
[&](){[&](){[&](){return builder.setSupportedDepthResolveModes((member.supportedDepthResolveModes));}();}();}();
[&](){[&](){[&](){return builder.setSupportedStencilResolveModes((member.supportedStencilResolveModes));}();}();}();
[&](){[&](){return builder.setIndependentResolveNone((member.independentResolveNone));}();}();
[&](){[&](){return builder.setIndependentResolve((member.independentResolve));}();}();
[&](){[&](){return builder.setFilterMinmaxSingleComponentFormats((member.filterMinmaxSingleComponentFormats));}();}();
[&](){[&](){return builder.setFilterMinmaxImageComponentMapping((member.filterMinmaxImageComponentMapping));}();}();
[&](){return builder.setMaxTimelineSemaphoreValueDifference((member.maxTimelineSemaphoreValueDifference));}();
[&](){[&](){[&](){return builder.setFramebufferIntegerColorSampleCounts((member.framebufferIntegerColorSampleCounts));}();}();}();
}

    VkPhysicalDeviceVulkan12Properties deserialize_struct(stream::VkPhysicalDeviceVulkan12Properties::Reader reader){
        auto result=VkPhysicalDeviceVulkan12Properties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.driverID)=reader.getDriverID();}();}();}();
[&](){
        auto proto_arr=reader.getDriverName(VK_MAX_DRIVER_NAME_SIZE);
        for(int eglnjYG=0; eglnjYG < VK_MAX_DRIVER_NAME_SIZE; eglnjYG++){
            [&](){((result.driverName)[eglnjYG])=proto_arr[eglnjYG];}();
        }
        }();
[&](){
        auto proto_arr=reader.getDriverInfo(VK_MAX_DRIVER_INFO_SIZE);
        for(int ygBYlpo=0; ygBYlpo < VK_MAX_DRIVER_INFO_SIZE; ygBYlpo++){
            [&](){((result.driverInfo)[ygBYlpo])=proto_arr[ygBYlpo];}();
        }
        }();
[&](){
            auto temp=reader.getConformanceVersion();
            (result.conformanceVersion)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.denormBehaviorIndependence)=reader.getDenormBehaviorIndependence();}();}();}();
[&](){[&](){[&](){(result.roundingModeIndependence)=reader.getRoundingModeIndependence();}();}();}();
[&](){[&](){(result.shaderSignedZeroInfNanPreserveFloat16)=reader.getShaderSignedZeroInfNanPreserveFloat16();}();}();
[&](){[&](){(result.shaderSignedZeroInfNanPreserveFloat32)=reader.getShaderSignedZeroInfNanPreserveFloat32();}();}();
[&](){[&](){(result.shaderSignedZeroInfNanPreserveFloat64)=reader.getShaderSignedZeroInfNanPreserveFloat64();}();}();
[&](){[&](){(result.shaderDenormPreserveFloat16)=reader.getShaderDenormPreserveFloat16();}();}();
[&](){[&](){(result.shaderDenormPreserveFloat32)=reader.getShaderDenormPreserveFloat32();}();}();
[&](){[&](){(result.shaderDenormPreserveFloat64)=reader.getShaderDenormPreserveFloat64();}();}();
[&](){[&](){(result.shaderDenormFlushToZeroFloat16)=reader.getShaderDenormFlushToZeroFloat16();}();}();
[&](){[&](){(result.shaderDenormFlushToZeroFloat32)=reader.getShaderDenormFlushToZeroFloat32();}();}();
[&](){[&](){(result.shaderDenormFlushToZeroFloat64)=reader.getShaderDenormFlushToZeroFloat64();}();}();
[&](){[&](){(result.shaderRoundingModeRTEFloat16)=reader.getShaderRoundingModeRTEFloat16();}();}();
[&](){[&](){(result.shaderRoundingModeRTEFloat32)=reader.getShaderRoundingModeRTEFloat32();}();}();
[&](){[&](){(result.shaderRoundingModeRTEFloat64)=reader.getShaderRoundingModeRTEFloat64();}();}();
[&](){[&](){(result.shaderRoundingModeRTZFloat16)=reader.getShaderRoundingModeRTZFloat16();}();}();
[&](){[&](){(result.shaderRoundingModeRTZFloat32)=reader.getShaderRoundingModeRTZFloat32();}();}();
[&](){[&](){(result.shaderRoundingModeRTZFloat64)=reader.getShaderRoundingModeRTZFloat64();}();}();
[&](){(result.maxUpdateAfterBindDescriptorsInAllPools)=reader.getMaxUpdateAfterBindDescriptorsInAllPools();}();
[&](){[&](){(result.shaderUniformBufferArrayNonUniformIndexingNative)=reader.getShaderUniformBufferArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderSampledImageArrayNonUniformIndexingNative)=reader.getShaderSampledImageArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderStorageBufferArrayNonUniformIndexingNative)=reader.getShaderStorageBufferArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderStorageImageArrayNonUniformIndexingNative)=reader.getShaderStorageImageArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.shaderInputAttachmentArrayNonUniformIndexingNative)=reader.getShaderInputAttachmentArrayNonUniformIndexingNative();}();}();
[&](){[&](){(result.robustBufferAccessUpdateAfterBind)=reader.getRobustBufferAccessUpdateAfterBind();}();}();
[&](){[&](){(result.quadDivergentImplicitLod)=reader.getQuadDivergentImplicitLod();}();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindSamplers)=reader.getMaxPerStageDescriptorUpdateAfterBindSamplers();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindUniformBuffers)=reader.getMaxPerStageDescriptorUpdateAfterBindUniformBuffers();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindStorageBuffers)=reader.getMaxPerStageDescriptorUpdateAfterBindStorageBuffers();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindSampledImages)=reader.getMaxPerStageDescriptorUpdateAfterBindSampledImages();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindStorageImages)=reader.getMaxPerStageDescriptorUpdateAfterBindStorageImages();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindInputAttachments)=reader.getMaxPerStageDescriptorUpdateAfterBindInputAttachments();}();
[&](){(result.maxPerStageUpdateAfterBindResources)=reader.getMaxPerStageUpdateAfterBindResources();}();
[&](){(result.maxDescriptorSetUpdateAfterBindSamplers)=reader.getMaxDescriptorSetUpdateAfterBindSamplers();}();
[&](){(result.maxDescriptorSetUpdateAfterBindUniformBuffers)=reader.getMaxDescriptorSetUpdateAfterBindUniformBuffers();}();
[&](){(result.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)=reader.getMaxDescriptorSetUpdateAfterBindUniformBuffersDynamic();}();
[&](){(result.maxDescriptorSetUpdateAfterBindStorageBuffers)=reader.getMaxDescriptorSetUpdateAfterBindStorageBuffers();}();
[&](){(result.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)=reader.getMaxDescriptorSetUpdateAfterBindStorageBuffersDynamic();}();
[&](){(result.maxDescriptorSetUpdateAfterBindSampledImages)=reader.getMaxDescriptorSetUpdateAfterBindSampledImages();}();
[&](){(result.maxDescriptorSetUpdateAfterBindStorageImages)=reader.getMaxDescriptorSetUpdateAfterBindStorageImages();}();
[&](){(result.maxDescriptorSetUpdateAfterBindInputAttachments)=reader.getMaxDescriptorSetUpdateAfterBindInputAttachments();}();
[&](){[&](){[&](){(result.supportedDepthResolveModes)=reader.getSupportedDepthResolveModes();}();}();}();
[&](){[&](){[&](){(result.supportedStencilResolveModes)=reader.getSupportedStencilResolveModes();}();}();}();
[&](){[&](){(result.independentResolveNone)=reader.getIndependentResolveNone();}();}();
[&](){[&](){(result.independentResolve)=reader.getIndependentResolve();}();}();
[&](){[&](){(result.filterMinmaxSingleComponentFormats)=reader.getFilterMinmaxSingleComponentFormats();}();}();
[&](){[&](){(result.filterMinmaxImageComponentMapping)=reader.getFilterMinmaxImageComponentMapping();}();}();
[&](){(result.maxTimelineSemaphoreValueDifference)=reader.getMaxTimelineSemaphoreValueDifference();}();
[&](){[&](){[&](){(result.framebufferIntegerColorSampleCounts)=reader.getFramebufferIntegerColorSampleCounts();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVulkan12Properties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVulkan12Properties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVulkan13Features::Builder& builder, VkPhysicalDeviceVulkan13Features member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRobustImageAccess((member.robustImageAccess));}();}();
[&](){[&](){return builder.setInlineUniformBlock((member.inlineUniformBlock));}();}();
[&](){[&](){return builder.setDescriptorBindingInlineUniformBlockUpdateAfterBind((member.descriptorBindingInlineUniformBlockUpdateAfterBind));}();}();
[&](){[&](){return builder.setPipelineCreationCacheControl((member.pipelineCreationCacheControl));}();}();
[&](){[&](){return builder.setPrivateData((member.privateData));}();}();
[&](){[&](){return builder.setShaderDemoteToHelperInvocation((member.shaderDemoteToHelperInvocation));}();}();
[&](){[&](){return builder.setShaderTerminateInvocation((member.shaderTerminateInvocation));}();}();
[&](){[&](){return builder.setSubgroupSizeControl((member.subgroupSizeControl));}();}();
[&](){[&](){return builder.setComputeFullSubgroups((member.computeFullSubgroups));}();}();
[&](){[&](){return builder.setSynchronization2((member.synchronization2));}();}();
[&](){[&](){return builder.setTextureCompressionASTCHDR((member.textureCompressionASTC_HDR));}();}();
[&](){[&](){return builder.setShaderZeroInitializeWorkgroupMemory((member.shaderZeroInitializeWorkgroupMemory));}();}();
[&](){[&](){return builder.setDynamicRendering((member.dynamicRendering));}();}();
[&](){[&](){return builder.setShaderIntegerDotProduct((member.shaderIntegerDotProduct));}();}();
[&](){[&](){return builder.setMaintenance4((member.maintenance4));}();}();
}

    VkPhysicalDeviceVulkan13Features deserialize_struct(stream::VkPhysicalDeviceVulkan13Features::Reader reader){
        auto result=VkPhysicalDeviceVulkan13Features();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.robustImageAccess)=reader.getRobustImageAccess();}();}();
[&](){[&](){(result.inlineUniformBlock)=reader.getInlineUniformBlock();}();}();
[&](){[&](){(result.descriptorBindingInlineUniformBlockUpdateAfterBind)=reader.getDescriptorBindingInlineUniformBlockUpdateAfterBind();}();}();
[&](){[&](){(result.pipelineCreationCacheControl)=reader.getPipelineCreationCacheControl();}();}();
[&](){[&](){(result.privateData)=reader.getPrivateData();}();}();
[&](){[&](){(result.shaderDemoteToHelperInvocation)=reader.getShaderDemoteToHelperInvocation();}();}();
[&](){[&](){(result.shaderTerminateInvocation)=reader.getShaderTerminateInvocation();}();}();
[&](){[&](){(result.subgroupSizeControl)=reader.getSubgroupSizeControl();}();}();
[&](){[&](){(result.computeFullSubgroups)=reader.getComputeFullSubgroups();}();}();
[&](){[&](){(result.synchronization2)=reader.getSynchronization2();}();}();
[&](){[&](){(result.textureCompressionASTC_HDR)=reader.getTextureCompressionASTCHDR();}();}();
[&](){[&](){(result.shaderZeroInitializeWorkgroupMemory)=reader.getShaderZeroInitializeWorkgroupMemory();}();}();
[&](){[&](){(result.dynamicRendering)=reader.getDynamicRendering();}();}();
[&](){[&](){(result.shaderIntegerDotProduct)=reader.getShaderIntegerDotProduct();}();}();
[&](){[&](){(result.maintenance4)=reader.getMaintenance4();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVulkan13Features member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVulkan13Features member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVulkan13Properties::Builder& builder, VkPhysicalDeviceVulkan13Properties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMinSubgroupSize((member.minSubgroupSize));}();
[&](){return builder.setMaxSubgroupSize((member.maxSubgroupSize));}();
[&](){return builder.setMaxComputeWorkgroupSubgroups((member.maxComputeWorkgroupSubgroups));}();
[&](){[&](){[&](){return builder.setRequiredSubgroupSizeStages((member.requiredSubgroupSizeStages));}();}();}();
[&](){return builder.setMaxInlineUniformBlockSize((member.maxInlineUniformBlockSize));}();
[&](){return builder.setMaxPerStageDescriptorInlineUniformBlocks((member.maxPerStageDescriptorInlineUniformBlocks));}();
[&](){return builder.setMaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks((member.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks));}();
[&](){return builder.setMaxDescriptorSetInlineUniformBlocks((member.maxDescriptorSetInlineUniformBlocks));}();
[&](){return builder.setMaxDescriptorSetUpdateAfterBindInlineUniformBlocks((member.maxDescriptorSetUpdateAfterBindInlineUniformBlocks));}();
[&](){return builder.setMaxInlineUniformTotalSize((member.maxInlineUniformTotalSize));}();
[&](){[&](){return builder.setIntegerDotProduct8BitUnsignedAccelerated((member.integerDotProduct8BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct8BitSignedAccelerated((member.integerDotProduct8BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct8BitMixedSignednessAccelerated((member.integerDotProduct8BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct4x8BitPackedUnsignedAccelerated((member.integerDotProduct4x8BitPackedUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct4x8BitPackedSignedAccelerated((member.integerDotProduct4x8BitPackedSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct4x8BitPackedMixedSignednessAccelerated((member.integerDotProduct4x8BitPackedMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct16BitUnsignedAccelerated((member.integerDotProduct16BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct16BitSignedAccelerated((member.integerDotProduct16BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct16BitMixedSignednessAccelerated((member.integerDotProduct16BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct32BitUnsignedAccelerated((member.integerDotProduct32BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct32BitSignedAccelerated((member.integerDotProduct32BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct32BitMixedSignednessAccelerated((member.integerDotProduct32BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct64BitUnsignedAccelerated((member.integerDotProduct64BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct64BitSignedAccelerated((member.integerDotProduct64BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct64BitMixedSignednessAccelerated((member.integerDotProduct64BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating8BitSignedAccelerated((member.integerDotProductAccumulatingSaturating8BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated((member.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated((member.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating16BitSignedAccelerated((member.integerDotProductAccumulatingSaturating16BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating32BitSignedAccelerated((member.integerDotProductAccumulatingSaturating32BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating64BitSignedAccelerated((member.integerDotProductAccumulatingSaturating64BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setStorageTexelBufferOffsetAlignmentBytes((member.storageTexelBufferOffsetAlignmentBytes));}();}();
[&](){[&](){return builder.setStorageTexelBufferOffsetSingleTexelAlignment((member.storageTexelBufferOffsetSingleTexelAlignment));}();}();
[&](){[&](){return builder.setUniformTexelBufferOffsetAlignmentBytes((member.uniformTexelBufferOffsetAlignmentBytes));}();}();
[&](){[&](){return builder.setUniformTexelBufferOffsetSingleTexelAlignment((member.uniformTexelBufferOffsetSingleTexelAlignment));}();}();
[&](){[&](){return builder.setMaxBufferSize((member.maxBufferSize));}();}();
}

    VkPhysicalDeviceVulkan13Properties deserialize_struct(stream::VkPhysicalDeviceVulkan13Properties::Reader reader){
        auto result=VkPhysicalDeviceVulkan13Properties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.minSubgroupSize)=reader.getMinSubgroupSize();}();
[&](){(result.maxSubgroupSize)=reader.getMaxSubgroupSize();}();
[&](){(result.maxComputeWorkgroupSubgroups)=reader.getMaxComputeWorkgroupSubgroups();}();
[&](){[&](){[&](){(result.requiredSubgroupSizeStages)=reader.getRequiredSubgroupSizeStages();}();}();}();
[&](){(result.maxInlineUniformBlockSize)=reader.getMaxInlineUniformBlockSize();}();
[&](){(result.maxPerStageDescriptorInlineUniformBlocks)=reader.getMaxPerStageDescriptorInlineUniformBlocks();}();
[&](){(result.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)=reader.getMaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks();}();
[&](){(result.maxDescriptorSetInlineUniformBlocks)=reader.getMaxDescriptorSetInlineUniformBlocks();}();
[&](){(result.maxDescriptorSetUpdateAfterBindInlineUniformBlocks)=reader.getMaxDescriptorSetUpdateAfterBindInlineUniformBlocks();}();
[&](){(result.maxInlineUniformTotalSize)=reader.getMaxInlineUniformTotalSize();}();
[&](){[&](){(result.integerDotProduct8BitUnsignedAccelerated)=reader.getIntegerDotProduct8BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct8BitSignedAccelerated)=reader.getIntegerDotProduct8BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct8BitMixedSignednessAccelerated)=reader.getIntegerDotProduct8BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct4x8BitPackedUnsignedAccelerated)=reader.getIntegerDotProduct4x8BitPackedUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct4x8BitPackedSignedAccelerated)=reader.getIntegerDotProduct4x8BitPackedSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct4x8BitPackedMixedSignednessAccelerated)=reader.getIntegerDotProduct4x8BitPackedMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct16BitUnsignedAccelerated)=reader.getIntegerDotProduct16BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct16BitSignedAccelerated)=reader.getIntegerDotProduct16BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct16BitMixedSignednessAccelerated)=reader.getIntegerDotProduct16BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct32BitUnsignedAccelerated)=reader.getIntegerDotProduct32BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct32BitSignedAccelerated)=reader.getIntegerDotProduct32BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct32BitMixedSignednessAccelerated)=reader.getIntegerDotProduct32BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct64BitUnsignedAccelerated)=reader.getIntegerDotProduct64BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct64BitSignedAccelerated)=reader.getIntegerDotProduct64BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct64BitMixedSignednessAccelerated)=reader.getIntegerDotProduct64BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating8BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating8BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating16BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating16BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating32BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating32BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating64BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating64BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.storageTexelBufferOffsetAlignmentBytes)=reader.getStorageTexelBufferOffsetAlignmentBytes();}();}();
[&](){[&](){(result.storageTexelBufferOffsetSingleTexelAlignment)=reader.getStorageTexelBufferOffsetSingleTexelAlignment();}();}();
[&](){[&](){(result.uniformTexelBufferOffsetAlignmentBytes)=reader.getUniformTexelBufferOffsetAlignmentBytes();}();}();
[&](){[&](){(result.uniformTexelBufferOffsetSingleTexelAlignment)=reader.getUniformTexelBufferOffsetSingleTexelAlignment();}();}();
[&](){[&](){(result.maxBufferSize)=reader.getMaxBufferSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVulkan13Properties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVulkan13Properties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineCompilerControlCreateInfoAMD::Builder& builder, VkPipelineCompilerControlCreateInfoAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCompilerControlFlags((member.compilerControlFlags));}();}();}();
}

    VkPipelineCompilerControlCreateInfoAMD deserialize_struct(stream::VkPipelineCompilerControlCreateInfoAMD::Reader reader){
        auto result=VkPipelineCompilerControlCreateInfoAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.compilerControlFlags)=reader.getCompilerControlFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineCompilerControlCreateInfoAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineCompilerControlCreateInfoAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCoherentMemoryFeaturesAMD::Builder& builder, VkPhysicalDeviceCoherentMemoryFeaturesAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceCoherentMemory((member.deviceCoherentMemory));}();}();
}

    VkPhysicalDeviceCoherentMemoryFeaturesAMD deserialize_struct(stream::VkPhysicalDeviceCoherentMemoryFeaturesAMD::Reader reader){
        auto result=VkPhysicalDeviceCoherentMemoryFeaturesAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.deviceCoherentMemory)=reader.getDeviceCoherentMemory();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCoherentMemoryFeaturesAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCoherentMemoryFeaturesAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceToolProperties::Builder& builder, VkPhysicalDeviceToolProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initName(VK_MAX_EXTENSION_NAME_SIZE);
        for(int acRPAEG=0; acRPAEG < VK_MAX_EXTENSION_NAME_SIZE; acRPAEG++){
            [&](){return proto_arr.set(acRPAEG,((member.name)[acRPAEG]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initVersion(VK_MAX_EXTENSION_NAME_SIZE);
        for(int IKwHmbc=0; IKwHmbc < VK_MAX_EXTENSION_NAME_SIZE; IKwHmbc++){
            [&](){return proto_arr.set(IKwHmbc,((member.version)[IKwHmbc]));}();
        }
        }();
[&](){[&](){[&](){return builder.setPurposes((member.purposes));}();}();}();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
[&](){
        auto proto_arr=builder.initLayer(VK_MAX_EXTENSION_NAME_SIZE);
        for(int UTJjPWd=0; UTJjPWd < VK_MAX_EXTENSION_NAME_SIZE; UTJjPWd++){
            [&](){return proto_arr.set(UTJjPWd,((member.layer)[UTJjPWd]));}();
        }
        }();
}

    VkPhysicalDeviceToolProperties deserialize_struct(stream::VkPhysicalDeviceToolProperties::Reader reader){
        auto result=VkPhysicalDeviceToolProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getName(VK_MAX_EXTENSION_NAME_SIZE);
        for(int acRPAEG=0; acRPAEG < VK_MAX_EXTENSION_NAME_SIZE; acRPAEG++){
            [&](){((result.name)[acRPAEG])=proto_arr[acRPAEG];}();
        }
        }();
[&](){
        auto proto_arr=reader.getVersion(VK_MAX_EXTENSION_NAME_SIZE);
        for(int IKwHmbc=0; IKwHmbc < VK_MAX_EXTENSION_NAME_SIZE; IKwHmbc++){
            [&](){((result.version)[IKwHmbc])=proto_arr[IKwHmbc];}();
        }
        }();
[&](){[&](){[&](){(result.purposes)=reader.getPurposes();}();}();}();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
[&](){
        auto proto_arr=reader.getLayer(VK_MAX_EXTENSION_NAME_SIZE);
        for(int UTJjPWd=0; UTJjPWd < VK_MAX_EXTENSION_NAME_SIZE; UTJjPWd++){
            [&](){((result.layer)[UTJjPWd])=proto_arr[UTJjPWd];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceToolProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceToolProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerCustomBorderColorCreateInfoEXT::Builder& builder, VkSamplerCustomBorderColorCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initCustomBorderColor(customBorderColor);
            return serialize_struct(temp, (member.customBorderColor));
            }();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
}

    VkSamplerCustomBorderColorCreateInfoEXT deserialize_struct(stream::VkSamplerCustomBorderColorCreateInfoEXT::Reader reader){
        auto result=VkSamplerCustomBorderColorCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getCustomBorderColor();
            (result.customBorderColor)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerCustomBorderColorCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerCustomBorderColorCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCustomBorderColorPropertiesEXT::Builder& builder, VkPhysicalDeviceCustomBorderColorPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxCustomBorderColorSamplers((member.maxCustomBorderColorSamplers));}();
}

    VkPhysicalDeviceCustomBorderColorPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceCustomBorderColorPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceCustomBorderColorPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxCustomBorderColorSamplers)=reader.getMaxCustomBorderColorSamplers();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCustomBorderColorPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCustomBorderColorPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCustomBorderColorFeaturesEXT::Builder& builder, VkPhysicalDeviceCustomBorderColorFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCustomBorderColors((member.customBorderColors));}();}();
[&](){[&](){return builder.setCustomBorderColorWithoutFormat((member.customBorderColorWithoutFormat));}();}();
}

    VkPhysicalDeviceCustomBorderColorFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceCustomBorderColorFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceCustomBorderColorFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.customBorderColors)=reader.getCustomBorderColors();}();}();
[&](){[&](){(result.customBorderColorWithoutFormat)=reader.getCustomBorderColorWithoutFormat();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCustomBorderColorFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCustomBorderColorFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerBorderColorComponentMappingCreateInfoEXT::Builder& builder, VkSamplerBorderColorComponentMappingCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initComponents(components);
            return serialize_struct(temp, (member.components));
            }();
[&](){[&](){return builder.setSrgb((member.srgb));}();}();
}

    VkSamplerBorderColorComponentMappingCreateInfoEXT deserialize_struct(stream::VkSamplerBorderColorComponentMappingCreateInfoEXT::Reader reader){
        auto result=VkSamplerBorderColorComponentMappingCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getComponents();
            (result.components)=deserialize_struct(temp);
            }();
[&](){[&](){(result.srgb)=reader.getSrgb();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerBorderColorComponentMappingCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerBorderColorComponentMappingCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceBorderColorSwizzleFeaturesEXT::Builder& builder, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setBorderColorSwizzle((member.borderColorSwizzle));}();}();
[&](){[&](){return builder.setBorderColorSwizzleFromImage((member.borderColorSwizzleFromImage));}();}();
}

    VkPhysicalDeviceBorderColorSwizzleFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceBorderColorSwizzleFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceBorderColorSwizzleFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.borderColorSwizzle)=reader.getBorderColorSwizzle();}();}();
[&](){[&](){(result.borderColorSwizzleFromImage)=reader.getBorderColorSwizzleFromImage();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceOrHostAddressKHR::Builder& builder, VkDeviceOrHostAddressKHR member){
        
    
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
[&](){
            if ((member.hostAddress)==NULL){
                builder.initHostAddress(0);
            return; }[&](){
            if (((char*)(member.hostAddress).hostAddress)==NULL){
                builder.initHostAddress(0);
            return; }
        auto proto_arr=builder.initHostAddress(strlen(((char*)(member.hostAddress).hostAddress))+1);
        for(int UYQdwVY=0; UYQdwVY < strlen(((char*)(member.hostAddress).hostAddress))+1; UYQdwVY++){
            [&](){return proto_arr.set(UYQdwVY,(((char*)(member.hostAddress).hostAddress)[UYQdwVY]));}();
        }
        }();}();
}

    VkDeviceOrHostAddressKHR deserialize_struct(stream::VkDeviceOrHostAddressKHR::Reader reader){
        auto result=VkDeviceOrHostAddressKHR();
    
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
[&](){
            if (!reader.getHostAddress().size()==0){
                (result.hostAddress)=NULL;
            return; }char* temp_hkOvUOp;[&](){
            if (!reader.getHostAddress().size()==0){
                (temp_hkOvUOp.hostAddress)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getHostAddress().size();*sizeof(char));
        auto proto_arr=reader.getHostAddress(reader.getHostAddress().size(););
        for(int UYQdwVY=0; UYQdwVY < reader.getHostAddress().size();; UYQdwVY++){
            [&](){((temp_hkOvUOp.hostAddress)[UYQdwVY])=proto_arr[UYQdwVY];}();
        }
        }();(result.hostAddress)=temp_hkOvUOp;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceOrHostAddressKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceOrHostAddressKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceOrHostAddressConstKHR::Builder& builder, VkDeviceOrHostAddressConstKHR member){
        
    
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
[&](){
            if ((member.hostAddress)==NULL){
                builder.initHostAddress(0);
            return; }[&](){
            if (((char*)(member.hostAddress).hostAddress)==NULL){
                builder.initHostAddress(0);
            return; }
        auto proto_arr=builder.initHostAddress(strlen(((char*)(member.hostAddress).hostAddress))+1);
        for(int VRRvftU=0; VRRvftU < strlen(((char*)(member.hostAddress).hostAddress))+1; VRRvftU++){
            [&](){return proto_arr.set(VRRvftU,(((char*)(member.hostAddress).hostAddress)[VRRvftU]));}();
        }
        }();}();
}

    VkDeviceOrHostAddressConstKHR deserialize_struct(stream::VkDeviceOrHostAddressConstKHR::Reader reader){
        auto result=VkDeviceOrHostAddressConstKHR();
    
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
[&](){ void* temp_BaTEZDg[&](){
            if (!reader.getHostAddress().size()==0){
                (result.hostAddress)=NULL;
            return; }char* temp_huVSMIu;[&](){
            if (!reader.getHostAddress().size()==0){
                (temp_huVSMIu.hostAddress)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getHostAddress().size();*sizeof(char));
        auto proto_arr=reader.getHostAddress(reader.getHostAddress().size(););
        for(int HqoDSMo=0; HqoDSMo < reader.getHostAddress().size();; HqoDSMo++){
            [&](){((temp_huVSMIu.hostAddress)[HqoDSMo])=proto_arr[HqoDSMo];}();
        }
        }();(result.hostAddress)=temp_huVSMIu;}();(result.hostAddress)=temp_BaTEZDg;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceOrHostAddressConstKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceOrHostAddressConstKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureGeometryTrianglesDataKHR::Builder& builder, VkAccelerationStructureGeometryTrianglesDataKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setVertexFormat((member.vertexFormat));}();}();}();
[&](){
            auto temp=builder.initVertexData(vertexData);
            return serialize_struct(temp, (member.vertexData));
            }();
[&](){[&](){return builder.setVertexStride((member.vertexStride));}();}();
[&](){return builder.setMaxVertex((member.maxVertex));}();
[&](){[&](){[&](){return builder.setIndexType((member.indexType));}();}();}();
[&](){
            auto temp=builder.initIndexData(indexData);
            return serialize_struct(temp, (member.indexData));
            }();
[&](){
            auto temp=builder.initTransformData(transformData);
            return serialize_struct(temp, (member.transformData));
            }();
}

    VkAccelerationStructureGeometryTrianglesDataKHR deserialize_struct(stream::VkAccelerationStructureGeometryTrianglesDataKHR::Reader reader){
        auto result=VkAccelerationStructureGeometryTrianglesDataKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.vertexFormat)=reader.getVertexFormat();}();}();}();
[&](){
            auto temp=reader.getVertexData();
            (result.vertexData)=deserialize_struct(temp);
            }();
[&](){[&](){(result.vertexStride)=reader.getVertexStride();}();}();
[&](){(result.maxVertex)=reader.getMaxVertex();}();
[&](){[&](){[&](){(result.indexType)=reader.getIndexType();}();}();}();
[&](){
            auto temp=reader.getIndexData();
            (result.indexData)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getTransformData();
            (result.transformData)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureGeometryTrianglesDataKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureGeometryTrianglesDataKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureGeometryAabbsDataKHR::Builder& builder, VkAccelerationStructureGeometryAabbsDataKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initData(data);
            return serialize_struct(temp, (member.data));
            }();
[&](){[&](){return builder.setStride((member.stride));}();}();
}

    VkAccelerationStructureGeometryAabbsDataKHR deserialize_struct(stream::VkAccelerationStructureGeometryAabbsDataKHR::Reader reader){
        auto result=VkAccelerationStructureGeometryAabbsDataKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getData();
            (result.data)=deserialize_struct(temp);
            }();
[&](){[&](){(result.stride)=reader.getStride();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureGeometryAabbsDataKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureGeometryAabbsDataKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureGeometryInstancesDataKHR::Builder& builder, VkAccelerationStructureGeometryInstancesDataKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setArrayOfPointers((member.arrayOfPointers));}();}();
[&](){
            auto temp=builder.initData(data);
            return serialize_struct(temp, (member.data));
            }();
}

    VkAccelerationStructureGeometryInstancesDataKHR deserialize_struct(stream::VkAccelerationStructureGeometryInstancesDataKHR::Reader reader){
        auto result=VkAccelerationStructureGeometryInstancesDataKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.arrayOfPointers)=reader.getArrayOfPointers();}();}();
[&](){
            auto temp=reader.getData();
            (result.data)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureGeometryInstancesDataKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureGeometryInstancesDataKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureGeometryDataKHR::Builder& builder, VkAccelerationStructureGeometryDataKHR member){
        
    
[&](){
            auto temp=builder.initTriangles(triangles);
            return serialize_struct(temp, (member.triangles));
            }();
[&](){
            auto temp=builder.initAabbs(aabbs);
            return serialize_struct(temp, (member.aabbs));
            }();
[&](){
            auto temp=builder.initInstances(instances);
            return serialize_struct(temp, (member.instances));
            }();
}

    VkAccelerationStructureGeometryDataKHR deserialize_struct(stream::VkAccelerationStructureGeometryDataKHR::Reader reader){
        auto result=VkAccelerationStructureGeometryDataKHR();
    
[&](){
            auto temp=reader.getTriangles();
            (result.triangles)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getAabbs();
            (result.aabbs)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getInstances();
            (result.instances)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureGeometryDataKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureGeometryDataKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureGeometryKHR::Builder& builder, VkAccelerationStructureGeometryKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setGeometryType((member.geometryType));}();}();}();
[&](){
            auto temp=builder.initGeometry(geometry);
            return serialize_struct(temp, (member.geometry));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkAccelerationStructureGeometryKHR deserialize_struct(stream::VkAccelerationStructureGeometryKHR::Reader reader){
        auto result=VkAccelerationStructureGeometryKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.geometryType)=reader.getGeometryType();}();}();}();
[&](){
            auto temp=reader.getGeometry();
            (result.geometry)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureGeometryKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureGeometryKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureBuildGeometryInfoKHR::Builder& builder, VkAccelerationStructureBuildGeometryInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
[&](){return builder.setSrcAccelerationStructure(serialize_handle(member.srcAccelerationStructure));}();
[&](){return builder.setDstAccelerationStructure(serialize_handle(member.dstAccelerationStructure));}();
[&](){return builder.setGeometryCount((member.geometryCount));}();
[&](){
            if ((member.pGeometries)==NULL){
                builder.initPGeometries(0);
            return; }
        auto proto_arr=builder.initPGeometries(member.geometryCount);
        for(int fhUWMAC=0; fhUWMAC < member.geometryCount; fhUWMAC++){
            [&](){
            auto temp=proto_arr[fhUWMAC];
            return serialize_struct(temp, ((member.pGeometries)[fhUWMAC]));
            }();
        }
        }();
[&](){
            if ((member.ppGeometries)==NULL){
                builder.initPpGeometries(0);
            return; }
        auto proto_arr=builder.initPpGeometries(member.geometryCount);
        for(int TtQPDAY=0; TtQPDAY < member.geometryCount; TtQPDAY++){
            [&](){
            if (((member.ppGeometries)[TtQPDAY])==NULL){
                proto_arr[TtQPDAY];
            return; }
        auto proto_arr=proto_arr[TtQPDAY];
        for(int wscYZjA=0; wscYZjA < 1; wscYZjA++){
            [&](){
            auto temp=proto_arr[wscYZjA];
            return serialize_struct(temp, (((member.ppGeometries)[TtQPDAY])[wscYZjA]));
            }();
        }
        }();
        }
        }();
[&](){
            auto temp=builder.initScratchData(scratchData);
            return serialize_struct(temp, (member.scratchData));
            }();
}

    VkAccelerationStructureBuildGeometryInfoKHR deserialize_struct(stream::VkAccelerationStructureBuildGeometryInfoKHR::Reader reader){
        auto result=VkAccelerationStructureBuildGeometryInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
[&](){(result.srcAccelerationStructure)=deserialize_VkAccelerationStructureKHR(reader.getSrcAccelerationStructure());}();
[&](){(result.dstAccelerationStructure)=deserialize_VkAccelerationStructureKHR(reader.getDstAccelerationStructure());}();
[&](){(result.geometryCount)=reader.getGeometryCount();}();
[&](){ VkAccelerationStructureGeometryKHR* temp_CbaTjUS[&](){
            if (!reader.getPGeometries().size()==0){
                (result.pGeometries)=NULL;
            return; }{native_concat()}=(VkAccelerationStructureGeometryKHR*)malloc(result.geometryCount*sizeof(VkAccelerationStructureGeometryKHR));
        auto proto_arr=reader.getPGeometries(result.geometryCount);
        for(int OecFmyq=0; OecFmyq < result.geometryCount; OecFmyq++){
            [&](){
            auto temp=proto_arr[OecFmyq];
            ((result.pGeometries)[OecFmyq])=deserialize_struct(temp);
            }();
        }
        }();(result.pGeometries)=temp_CbaTjUS;}();
[&](){ VkAccelerationStructureGeometryKHR* * temp_RCDjEBm[&](){
            if (!reader.getPpGeometries().size()==0){
                (result.ppGeometries)=NULL;
            return; }{native_concat()}=(VkAccelerationStructureGeometryKHR**)malloc(result.geometryCount*sizeof(VkAccelerationStructureGeometryKHR*));
        auto proto_arr=reader.getPpGeometries(result.geometryCount);
        for(int EgklKvE=0; EgklKvE < result.geometryCount; EgklKvE++){
            [&](){
            if (!proto_arr[EgklKvE].size()==0){
                ((result.ppGeometries)[EgklKvE])=NULL;
            return; }{native_concat()}=(VkAccelerationStructureGeometryKHR*)malloc(1*sizeof(VkAccelerationStructureGeometryKHR));
        auto proto_arr=proto_arr[EgklKvE];
        for(int WnVxJDd=0; WnVxJDd < 1; WnVxJDd++){
            [&](){
            auto temp=proto_arr[WnVxJDd];
            (((result.ppGeometries)[EgklKvE])[WnVxJDd])=deserialize_struct(temp);
            }();
        }
        }();
        }
        }();(result.ppGeometries)=temp_RCDjEBm;}();
[&](){
            auto temp=reader.getScratchData();
            (result.scratchData)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureBuildGeometryInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureBuildGeometryInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureBuildRangeInfoKHR::Builder& builder, VkAccelerationStructureBuildRangeInfoKHR member){
        
    
[&](){return builder.setPrimitiveCount((member.primitiveCount));}();
[&](){return builder.setPrimitiveOffset((member.primitiveOffset));}();
[&](){return builder.setFirstVertex((member.firstVertex));}();
[&](){return builder.setTransformOffset((member.transformOffset));}();
}

    VkAccelerationStructureBuildRangeInfoKHR deserialize_struct(stream::VkAccelerationStructureBuildRangeInfoKHR::Reader reader){
        auto result=VkAccelerationStructureBuildRangeInfoKHR();
    
[&](){(result.primitiveCount)=reader.getPrimitiveCount();}();
[&](){(result.primitiveOffset)=reader.getPrimitiveOffset();}();
[&](){(result.firstVertex)=reader.getFirstVertex();}();
[&](){(result.transformOffset)=reader.getTransformOffset();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureBuildRangeInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureBuildRangeInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureCreateInfoKHR::Builder& builder, VkAccelerationStructureCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCreateFlags((member.createFlags));}();}();}();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
}

    VkAccelerationStructureCreateInfoKHR deserialize_struct(stream::VkAccelerationStructureCreateInfoKHR::Reader reader){
        auto result=VkAccelerationStructureCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.createFlags)=reader.getCreateFlags();}();}();}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAabbPositionsKHR::Builder& builder, VkAabbPositionsKHR member){
        
    
[&](){return builder.setMinX((member.minX));}();
[&](){return builder.setMinY((member.minY));}();
[&](){return builder.setMinZ((member.minZ));}();
[&](){return builder.setMaxX((member.maxX));}();
[&](){return builder.setMaxY((member.maxY));}();
[&](){return builder.setMaxZ((member.maxZ));}();
}

    VkAabbPositionsKHR deserialize_struct(stream::VkAabbPositionsKHR::Reader reader){
        auto result=VkAabbPositionsKHR();
    
[&](){(result.minX)=reader.getMinX();}();
[&](){(result.minY)=reader.getMinY();}();
[&](){(result.minZ)=reader.getMinZ();}();
[&](){(result.maxX)=reader.getMaxX();}();
[&](){(result.maxY)=reader.getMaxY();}();
[&](){(result.maxZ)=reader.getMaxZ();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAabbPositionsKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAabbPositionsKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkTransformMatrixKHR::Builder& builder, VkTransformMatrixKHR member){
        
    
[&](){
        auto proto_arr=builder.initMatrix(3);
        for(int HGQDLyT=0; HGQDLyT < 3; HGQDLyT++){
            [&](){
        auto proto_arr=proto_arr[HGQDLyT];
        for(int jdKOchF=0; jdKOchF < 4; jdKOchF++){
            [&](){return proto_arr.set(jdKOchF,(((member.matrix)[HGQDLyT])[jdKOchF]));}();
        }
        }();
        }
        }();
}

    VkTransformMatrixKHR deserialize_struct(stream::VkTransformMatrixKHR::Reader reader){
        auto result=VkTransformMatrixKHR();
    
[&](){
        auto proto_arr=reader.getMatrix(3);
        for(int HGQDLyT=0; HGQDLyT < 3; HGQDLyT++){
            [&](){
        auto proto_arr=proto_arr[HGQDLyT];
        for(int jdKOchF=0; jdKOchF < 4; jdKOchF++){
            [&](){(((result.matrix)[HGQDLyT])[jdKOchF])=proto_arr[jdKOchF];}();
        }
        }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkTransformMatrixKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkTransformMatrixKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureInstanceKHR::Builder& builder, VkAccelerationStructureInstanceKHR member){
        
    
[&](){
            auto temp=builder.initTransform(transform);
            return serialize_struct(temp, (member.transform));
            }();
[&](){return builder.setInstanceCustomIndex((member.instanceCustomIndex));}();
[&](){return builder.setMask((member.mask));}();
[&](){return builder.setInstanceShaderBindingTableRecordOffset((member.instanceShaderBindingTableRecordOffset));}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setAccelerationStructureReference((member.accelerationStructureReference));}();
}

    VkAccelerationStructureInstanceKHR deserialize_struct(stream::VkAccelerationStructureInstanceKHR::Reader reader){
        auto result=VkAccelerationStructureInstanceKHR();
    
[&](){
            auto temp=reader.getTransform();
            (result.transform)=deserialize_struct(temp);
            }();
[&](){(result.instanceCustomIndex)=reader.getInstanceCustomIndex();}();
[&](){(result.mask)=reader.getMask();}();
[&](){(result.instanceShaderBindingTableRecordOffset)=reader.getInstanceShaderBindingTableRecordOffset();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.accelerationStructureReference)=reader.getAccelerationStructureReference();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureInstanceKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureInstanceKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureDeviceAddressInfoKHR::Builder& builder, VkAccelerationStructureDeviceAddressInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAccelerationStructure(serialize_handle(member.accelerationStructure));}();
}

    VkAccelerationStructureDeviceAddressInfoKHR deserialize_struct(stream::VkAccelerationStructureDeviceAddressInfoKHR::Reader reader){
        auto result=VkAccelerationStructureDeviceAddressInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.accelerationStructure)=deserialize_VkAccelerationStructureKHR(reader.getAccelerationStructure());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureDeviceAddressInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureDeviceAddressInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureVersionInfoKHR::Builder& builder, VkAccelerationStructureVersionInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pVersionData)==NULL){
                builder.initPVersionData(0);
            return; }
        auto proto_arr=builder.initPVersionData(2*VK_UUID_SIZE);
        for(int UXnQvHZ=0; UXnQvHZ < 2*VK_UUID_SIZE; UXnQvHZ++){
            [&](){return proto_arr.set(UXnQvHZ,((member.pVersionData)[UXnQvHZ]));}();
        }
        }();
}

    VkAccelerationStructureVersionInfoKHR deserialize_struct(stream::VkAccelerationStructureVersionInfoKHR::Reader reader){
        auto result=VkAccelerationStructureVersionInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ uint8_t* temp_kcsYiSk[&](){
            if (!reader.getPVersionData().size()==0){
                (result.pVersionData)=NULL;
            return; }{native_concat()}=(uint8_t*)malloc(2*VK_UUID_SIZE*sizeof(uint8_t));
        auto proto_arr=reader.getPVersionData(2*VK_UUID_SIZE);
        for(int aPYYtKH=0; aPYYtKH < 2*VK_UUID_SIZE; aPYYtKH++){
            [&](){((result.pVersionData)[aPYYtKH])=proto_arr[aPYYtKH];}();
        }
        }();(result.pVersionData)=temp_kcsYiSk;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureVersionInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureVersionInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyAccelerationStructureInfoKHR::Builder& builder, VkCopyAccelerationStructureInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrc(serialize_handle(member.src));}();
[&](){return builder.setDst(serialize_handle(member.dst));}();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
}

    VkCopyAccelerationStructureInfoKHR deserialize_struct(stream::VkCopyAccelerationStructureInfoKHR::Reader reader){
        auto result=VkCopyAccelerationStructureInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.src)=deserialize_VkAccelerationStructureKHR(reader.getSrc());}();
[&](){(result.dst)=deserialize_VkAccelerationStructureKHR(reader.getDst());}();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyAccelerationStructureInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyAccelerationStructureInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyAccelerationStructureToMemoryInfoKHR::Builder& builder, VkCopyAccelerationStructureToMemoryInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrc(serialize_handle(member.src));}();
[&](){
            auto temp=builder.initDst(dst);
            return serialize_struct(temp, (member.dst));
            }();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
}

    VkCopyAccelerationStructureToMemoryInfoKHR deserialize_struct(stream::VkCopyAccelerationStructureToMemoryInfoKHR::Reader reader){
        auto result=VkCopyAccelerationStructureToMemoryInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.src)=deserialize_VkAccelerationStructureKHR(reader.getSrc());}();
[&](){
            auto temp=reader.getDst();
            (result.dst)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyAccelerationStructureToMemoryInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyAccelerationStructureToMemoryInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyMemoryToAccelerationStructureInfoKHR::Builder& builder, VkCopyMemoryToAccelerationStructureInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSrc(src);
            return serialize_struct(temp, (member.src));
            }();
[&](){return builder.setDst(serialize_handle(member.dst));}();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
}

    VkCopyMemoryToAccelerationStructureInfoKHR deserialize_struct(stream::VkCopyMemoryToAccelerationStructureInfoKHR::Reader reader){
        auto result=VkCopyMemoryToAccelerationStructureInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getSrc();
            (result.src)=deserialize_struct(temp);
            }();
[&](){(result.dst)=deserialize_VkAccelerationStructureKHR(reader.getDst());}();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyMemoryToAccelerationStructureInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyMemoryToAccelerationStructureInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRayTracingPipelineInterfaceCreateInfoKHR::Builder& builder, VkRayTracingPipelineInterfaceCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxPipelineRayPayloadSize((member.maxPipelineRayPayloadSize));}();
[&](){return builder.setMaxPipelineRayHitAttributeSize((member.maxPipelineRayHitAttributeSize));}();
}

    VkRayTracingPipelineInterfaceCreateInfoKHR deserialize_struct(stream::VkRayTracingPipelineInterfaceCreateInfoKHR::Reader reader){
        auto result=VkRayTracingPipelineInterfaceCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.maxPipelineRayPayloadSize)=reader.getMaxPipelineRayPayloadSize();}();
[&](){(result.maxPipelineRayHitAttributeSize)=reader.getMaxPipelineRayHitAttributeSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRayTracingPipelineInterfaceCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRayTracingPipelineInterfaceCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineLibraryCreateInfoKHR::Builder& builder, VkPipelineLibraryCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setLibraryCount((member.libraryCount));}();
[&](){
            if ((member.pLibraries)==NULL){
                builder.initPLibraries(0);
            return; }
        auto proto_arr=builder.initPLibraries(member.libraryCount);
        for(int nmCoQWf=0; nmCoQWf < member.libraryCount; nmCoQWf++){
            [&](){return proto_arr.set(nmCoQWf,serialize_handle((member.pLibraries)[nmCoQWf]));}();
        }
        }();
}

    VkPipelineLibraryCreateInfoKHR deserialize_struct(stream::VkPipelineLibraryCreateInfoKHR::Reader reader){
        auto result=VkPipelineLibraryCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.libraryCount)=reader.getLibraryCount();}();
[&](){ VkPipeline* temp_CtvAqgB[&](){
            if (!reader.getPLibraries().size()==0){
                (result.pLibraries)=NULL;
            return; }{native_concat()}=(VkPipeline*)malloc(result.libraryCount*sizeof(VkPipeline));
        auto proto_arr=reader.getPLibraries(result.libraryCount);
        for(int jSFoMUK=0; jSFoMUK < result.libraryCount; jSFoMUK++){
            [&](){((result.pLibraries)[jSFoMUK])=deserialize_VkPipeline(proto_arr[jSFoMUK]);}();
        }
        }();(result.pLibraries)=temp_CtvAqgB;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineLibraryCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineLibraryCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExtendedDynamicStateFeaturesEXT::Builder& builder, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setExtendedDynamicState((member.extendedDynamicState));}();}();
}

    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceExtendedDynamicStateFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceExtendedDynamicStateFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.extendedDynamicState)=reader.getExtendedDynamicState();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExtendedDynamicState2FeaturesEXT::Builder& builder, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setExtendedDynamicState2((member.extendedDynamicState2));}();}();
[&](){[&](){return builder.setExtendedDynamicState2LogicOp((member.extendedDynamicState2LogicOp));}();}();
[&](){[&](){return builder.setExtendedDynamicState2PatchControlPoints((member.extendedDynamicState2PatchControlPoints));}();}();
}

    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceExtendedDynamicState2FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceExtendedDynamicState2FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.extendedDynamicState2)=reader.getExtendedDynamicState2();}();}();
[&](){[&](){(result.extendedDynamicState2LogicOp)=reader.getExtendedDynamicState2LogicOp();}();}();
[&](){[&](){(result.extendedDynamicState2PatchControlPoints)=reader.getExtendedDynamicState2PatchControlPoints();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::Builder& builder, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setExtendedDynamicState3TessellationDomainOrigin((member.extendedDynamicState3TessellationDomainOrigin));}();}();
[&](){[&](){return builder.setExtendedDynamicState3DepthClampEnable((member.extendedDynamicState3DepthClampEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3PolygonMode((member.extendedDynamicState3PolygonMode));}();}();
[&](){[&](){return builder.setExtendedDynamicState3RasterizationSamples((member.extendedDynamicState3RasterizationSamples));}();}();
[&](){[&](){return builder.setExtendedDynamicState3SampleMask((member.extendedDynamicState3SampleMask));}();}();
[&](){[&](){return builder.setExtendedDynamicState3AlphaToCoverageEnable((member.extendedDynamicState3AlphaToCoverageEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3AlphaToOneEnable((member.extendedDynamicState3AlphaToOneEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3LogicOpEnable((member.extendedDynamicState3LogicOpEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ColorBlendEnable((member.extendedDynamicState3ColorBlendEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ColorBlendEquation((member.extendedDynamicState3ColorBlendEquation));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ColorWriteMask((member.extendedDynamicState3ColorWriteMask));}();}();
[&](){[&](){return builder.setExtendedDynamicState3RasterizationStream((member.extendedDynamicState3RasterizationStream));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ConservativeRasterizationMode((member.extendedDynamicState3ConservativeRasterizationMode));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ExtraPrimitiveOverestimationSize((member.extendedDynamicState3ExtraPrimitiveOverestimationSize));}();}();
[&](){[&](){return builder.setExtendedDynamicState3DepthClipEnable((member.extendedDynamicState3DepthClipEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3SampleLocationsEnable((member.extendedDynamicState3SampleLocationsEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ColorBlendAdvanced((member.extendedDynamicState3ColorBlendAdvanced));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ProvokingVertexMode((member.extendedDynamicState3ProvokingVertexMode));}();}();
[&](){[&](){return builder.setExtendedDynamicState3LineRasterizationMode((member.extendedDynamicState3LineRasterizationMode));}();}();
[&](){[&](){return builder.setExtendedDynamicState3LineStippleEnable((member.extendedDynamicState3LineStippleEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3DepthClipNegativeOneToOne((member.extendedDynamicState3DepthClipNegativeOneToOne));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ViewportWScalingEnable((member.extendedDynamicState3ViewportWScalingEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ViewportSwizzle((member.extendedDynamicState3ViewportSwizzle));}();}();
[&](){[&](){return builder.setExtendedDynamicState3CoverageToColorEnable((member.extendedDynamicState3CoverageToColorEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3CoverageToColorLocation((member.extendedDynamicState3CoverageToColorLocation));}();}();
[&](){[&](){return builder.setExtendedDynamicState3CoverageModulationMode((member.extendedDynamicState3CoverageModulationMode));}();}();
[&](){[&](){return builder.setExtendedDynamicState3CoverageModulationTableEnable((member.extendedDynamicState3CoverageModulationTableEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3CoverageModulationTable((member.extendedDynamicState3CoverageModulationTable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3CoverageReductionMode((member.extendedDynamicState3CoverageReductionMode));}();}();
[&](){[&](){return builder.setExtendedDynamicState3RepresentativeFragmentTestEnable((member.extendedDynamicState3RepresentativeFragmentTestEnable));}();}();
[&](){[&](){return builder.setExtendedDynamicState3ShadingRateImageEnable((member.extendedDynamicState3ShadingRateImageEnable));}();}();
}

    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceExtendedDynamicState3FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.extendedDynamicState3TessellationDomainOrigin)=reader.getExtendedDynamicState3TessellationDomainOrigin();}();}();
[&](){[&](){(result.extendedDynamicState3DepthClampEnable)=reader.getExtendedDynamicState3DepthClampEnable();}();}();
[&](){[&](){(result.extendedDynamicState3PolygonMode)=reader.getExtendedDynamicState3PolygonMode();}();}();
[&](){[&](){(result.extendedDynamicState3RasterizationSamples)=reader.getExtendedDynamicState3RasterizationSamples();}();}();
[&](){[&](){(result.extendedDynamicState3SampleMask)=reader.getExtendedDynamicState3SampleMask();}();}();
[&](){[&](){(result.extendedDynamicState3AlphaToCoverageEnable)=reader.getExtendedDynamicState3AlphaToCoverageEnable();}();}();
[&](){[&](){(result.extendedDynamicState3AlphaToOneEnable)=reader.getExtendedDynamicState3AlphaToOneEnable();}();}();
[&](){[&](){(result.extendedDynamicState3LogicOpEnable)=reader.getExtendedDynamicState3LogicOpEnable();}();}();
[&](){[&](){(result.extendedDynamicState3ColorBlendEnable)=reader.getExtendedDynamicState3ColorBlendEnable();}();}();
[&](){[&](){(result.extendedDynamicState3ColorBlendEquation)=reader.getExtendedDynamicState3ColorBlendEquation();}();}();
[&](){[&](){(result.extendedDynamicState3ColorWriteMask)=reader.getExtendedDynamicState3ColorWriteMask();}();}();
[&](){[&](){(result.extendedDynamicState3RasterizationStream)=reader.getExtendedDynamicState3RasterizationStream();}();}();
[&](){[&](){(result.extendedDynamicState3ConservativeRasterizationMode)=reader.getExtendedDynamicState3ConservativeRasterizationMode();}();}();
[&](){[&](){(result.extendedDynamicState3ExtraPrimitiveOverestimationSize)=reader.getExtendedDynamicState3ExtraPrimitiveOverestimationSize();}();}();
[&](){[&](){(result.extendedDynamicState3DepthClipEnable)=reader.getExtendedDynamicState3DepthClipEnable();}();}();
[&](){[&](){(result.extendedDynamicState3SampleLocationsEnable)=reader.getExtendedDynamicState3SampleLocationsEnable();}();}();
[&](){[&](){(result.extendedDynamicState3ColorBlendAdvanced)=reader.getExtendedDynamicState3ColorBlendAdvanced();}();}();
[&](){[&](){(result.extendedDynamicState3ProvokingVertexMode)=reader.getExtendedDynamicState3ProvokingVertexMode();}();}();
[&](){[&](){(result.extendedDynamicState3LineRasterizationMode)=reader.getExtendedDynamicState3LineRasterizationMode();}();}();
[&](){[&](){(result.extendedDynamicState3LineStippleEnable)=reader.getExtendedDynamicState3LineStippleEnable();}();}();
[&](){[&](){(result.extendedDynamicState3DepthClipNegativeOneToOne)=reader.getExtendedDynamicState3DepthClipNegativeOneToOne();}();}();
[&](){[&](){(result.extendedDynamicState3ViewportWScalingEnable)=reader.getExtendedDynamicState3ViewportWScalingEnable();}();}();
[&](){[&](){(result.extendedDynamicState3ViewportSwizzle)=reader.getExtendedDynamicState3ViewportSwizzle();}();}();
[&](){[&](){(result.extendedDynamicState3CoverageToColorEnable)=reader.getExtendedDynamicState3CoverageToColorEnable();}();}();
[&](){[&](){(result.extendedDynamicState3CoverageToColorLocation)=reader.getExtendedDynamicState3CoverageToColorLocation();}();}();
[&](){[&](){(result.extendedDynamicState3CoverageModulationMode)=reader.getExtendedDynamicState3CoverageModulationMode();}();}();
[&](){[&](){(result.extendedDynamicState3CoverageModulationTableEnable)=reader.getExtendedDynamicState3CoverageModulationTableEnable();}();}();
[&](){[&](){(result.extendedDynamicState3CoverageModulationTable)=reader.getExtendedDynamicState3CoverageModulationTable();}();}();
[&](){[&](){(result.extendedDynamicState3CoverageReductionMode)=reader.getExtendedDynamicState3CoverageReductionMode();}();}();
[&](){[&](){(result.extendedDynamicState3RepresentativeFragmentTestEnable)=reader.getExtendedDynamicState3RepresentativeFragmentTestEnable();}();}();
[&](){[&](){(result.extendedDynamicState3ShadingRateImageEnable)=reader.getExtendedDynamicState3ShadingRateImageEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExtendedDynamicState3PropertiesEXT::Builder& builder, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDynamicPrimitiveTopologyUnrestricted((member.dynamicPrimitiveTopologyUnrestricted));}();}();
}

    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT deserialize_struct(stream::VkPhysicalDeviceExtendedDynamicState3PropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceExtendedDynamicState3PropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.dynamicPrimitiveTopologyUnrestricted)=reader.getDynamicPrimitiveTopologyUnrestricted();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkColorBlendEquationEXT::Builder& builder, VkColorBlendEquationEXT member){
        
    
[&](){[&](){[&](){return builder.setSrcColorBlendFactor((member.srcColorBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setDstColorBlendFactor((member.dstColorBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setColorBlendOp((member.colorBlendOp));}();}();}();
[&](){[&](){[&](){return builder.setSrcAlphaBlendFactor((member.srcAlphaBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setDstAlphaBlendFactor((member.dstAlphaBlendFactor));}();}();}();
[&](){[&](){[&](){return builder.setAlphaBlendOp((member.alphaBlendOp));}();}();}();
}

    VkColorBlendEquationEXT deserialize_struct(stream::VkColorBlendEquationEXT::Reader reader){
        auto result=VkColorBlendEquationEXT();
    
[&](){[&](){[&](){(result.srcColorBlendFactor)=reader.getSrcColorBlendFactor();}();}();}();
[&](){[&](){[&](){(result.dstColorBlendFactor)=reader.getDstColorBlendFactor();}();}();}();
[&](){[&](){[&](){(result.colorBlendOp)=reader.getColorBlendOp();}();}();}();
[&](){[&](){[&](){(result.srcAlphaBlendFactor)=reader.getSrcAlphaBlendFactor();}();}();}();
[&](){[&](){[&](){(result.dstAlphaBlendFactor)=reader.getDstAlphaBlendFactor();}();}();}();
[&](){[&](){[&](){(result.alphaBlendOp)=reader.getAlphaBlendOp();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkColorBlendEquationEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkColorBlendEquationEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkColorBlendAdvancedEXT::Builder& builder, VkColorBlendAdvancedEXT member){
        
    
[&](){[&](){[&](){return builder.setAdvancedBlendOp((member.advancedBlendOp));}();}();}();
[&](){[&](){return builder.setSrcPremultiplied((member.srcPremultiplied));}();}();
[&](){[&](){return builder.setDstPremultiplied((member.dstPremultiplied));}();}();
[&](){[&](){[&](){return builder.setBlendOverlap((member.blendOverlap));}();}();}();
[&](){[&](){return builder.setClampResults((member.clampResults));}();}();
}

    VkColorBlendAdvancedEXT deserialize_struct(stream::VkColorBlendAdvancedEXT::Reader reader){
        auto result=VkColorBlendAdvancedEXT();
    
[&](){[&](){[&](){(result.advancedBlendOp)=reader.getAdvancedBlendOp();}();}();}();
[&](){[&](){(result.srcPremultiplied)=reader.getSrcPremultiplied();}();}();
[&](){[&](){(result.dstPremultiplied)=reader.getDstPremultiplied();}();}();
[&](){[&](){[&](){(result.blendOverlap)=reader.getBlendOverlap();}();}();}();
[&](){[&](){(result.clampResults)=reader.getClampResults();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkColorBlendAdvancedEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkColorBlendAdvancedEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassTransformBeginInfoQCOM::Builder& builder, VkRenderPassTransformBeginInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setTransform((member.transform));}();}();}();
}

    VkRenderPassTransformBeginInfoQCOM deserialize_struct(stream::VkRenderPassTransformBeginInfoQCOM::Reader reader){
        auto result=VkRenderPassTransformBeginInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.transform)=reader.getTransform();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassTransformBeginInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassTransformBeginInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyCommandTransformInfoQCOM::Builder& builder, VkCopyCommandTransformInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setTransform((member.transform));}();}();}();
}

    VkCopyCommandTransformInfoQCOM deserialize_struct(stream::VkCopyCommandTransformInfoQCOM::Reader reader){
        auto result=VkCopyCommandTransformInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.transform)=reader.getTransform();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyCommandTransformInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyCommandTransformInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferInheritanceRenderPassTransformInfoQCOM::Builder& builder, VkCommandBufferInheritanceRenderPassTransformInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setTransform((member.transform));}();}();}();
[&](){
            auto temp=builder.initRenderArea(renderArea);
            return serialize_struct(temp, (member.renderArea));
            }();
}

    VkCommandBufferInheritanceRenderPassTransformInfoQCOM deserialize_struct(stream::VkCommandBufferInheritanceRenderPassTransformInfoQCOM::Reader reader){
        auto result=VkCommandBufferInheritanceRenderPassTransformInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.transform)=reader.getTransform();}();}();}();
[&](){
            auto temp=reader.getRenderArea();
            (result.renderArea)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferInheritanceRenderPassTransformInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferInheritanceRenderPassTransformInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDiagnosticsConfigFeaturesNV::Builder& builder, VkPhysicalDeviceDiagnosticsConfigFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDiagnosticsConfig((member.diagnosticsConfig));}();}();
}

    VkPhysicalDeviceDiagnosticsConfigFeaturesNV deserialize_struct(stream::VkPhysicalDeviceDiagnosticsConfigFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceDiagnosticsConfigFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.diagnosticsConfig)=reader.getDiagnosticsConfig();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDiagnosticsConfigFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDiagnosticsConfigFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceDiagnosticsConfigCreateInfoNV::Builder& builder, VkDeviceDiagnosticsConfigCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkDeviceDiagnosticsConfigCreateInfoNV deserialize_struct(stream::VkDeviceDiagnosticsConfigCreateInfoNV::Reader reader){
        auto result=VkDeviceDiagnosticsConfigCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceDiagnosticsConfigCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceDiagnosticsConfigCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures::Builder& builder, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderZeroInitializeWorkgroupMemory((member.shaderZeroInitializeWorkgroupMemory));}();}();
}

    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures deserialize_struct(stream::VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures::Reader reader){
        auto result=VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderZeroInitializeWorkgroupMemory)=reader.getShaderZeroInitializeWorkgroupMemory();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::Builder& builder, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderSubgroupUniformControlFlow((member.shaderSubgroupUniformControlFlow));}();}();
}

    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderSubgroupUniformControlFlow)=reader.getShaderSubgroupUniformControlFlow();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRobustness2FeaturesEXT::Builder& builder, VkPhysicalDeviceRobustness2FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRobustBufferAccess2((member.robustBufferAccess2));}();}();
[&](){[&](){return builder.setRobustImageAccess2((member.robustImageAccess2));}();}();
[&](){[&](){return builder.setNullDescriptor((member.nullDescriptor));}();}();
}

    VkPhysicalDeviceRobustness2FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceRobustness2FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceRobustness2FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.robustBufferAccess2)=reader.getRobustBufferAccess2();}();}();
[&](){[&](){(result.robustImageAccess2)=reader.getRobustImageAccess2();}();}();
[&](){[&](){(result.nullDescriptor)=reader.getNullDescriptor();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRobustness2FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRobustness2FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRobustness2PropertiesEXT::Builder& builder, VkPhysicalDeviceRobustness2PropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRobustStorageBufferAccessSizeAlignment((member.robustStorageBufferAccessSizeAlignment));}();}();
[&](){[&](){return builder.setRobustUniformBufferAccessSizeAlignment((member.robustUniformBufferAccessSizeAlignment));}();}();
}

    VkPhysicalDeviceRobustness2PropertiesEXT deserialize_struct(stream::VkPhysicalDeviceRobustness2PropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceRobustness2PropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.robustStorageBufferAccessSizeAlignment)=reader.getRobustStorageBufferAccessSizeAlignment();}();}();
[&](){[&](){(result.robustUniformBufferAccessSizeAlignment)=reader.getRobustUniformBufferAccessSizeAlignment();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRobustness2PropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRobustness2PropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageRobustnessFeatures::Builder& builder, VkPhysicalDeviceImageRobustnessFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRobustImageAccess((member.robustImageAccess));}();}();
}

    VkPhysicalDeviceImageRobustnessFeatures deserialize_struct(stream::VkPhysicalDeviceImageRobustnessFeatures::Reader reader){
        auto result=VkPhysicalDeviceImageRobustnessFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.robustImageAccess)=reader.getRobustImageAccess();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageRobustnessFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageRobustnessFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::Builder& builder, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setWorkgroupMemoryExplicitLayout((member.workgroupMemoryExplicitLayout));}();}();
[&](){[&](){return builder.setWorkgroupMemoryExplicitLayoutScalarBlockLayout((member.workgroupMemoryExplicitLayoutScalarBlockLayout));}();}();
[&](){[&](){return builder.setWorkgroupMemoryExplicitLayout8BitAccess((member.workgroupMemoryExplicitLayout8BitAccess));}();}();
[&](){[&](){return builder.setWorkgroupMemoryExplicitLayout16BitAccess((member.workgroupMemoryExplicitLayout16BitAccess));}();}();
}

    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.workgroupMemoryExplicitLayout)=reader.getWorkgroupMemoryExplicitLayout();}();}();
[&](){[&](){(result.workgroupMemoryExplicitLayoutScalarBlockLayout)=reader.getWorkgroupMemoryExplicitLayoutScalarBlockLayout();}();}();
[&](){[&](){(result.workgroupMemoryExplicitLayout8BitAccess)=reader.getWorkgroupMemoryExplicitLayout8BitAccess();}();}();
[&](){[&](){(result.workgroupMemoryExplicitLayout16BitAccess)=reader.getWorkgroupMemoryExplicitLayout16BitAccess();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevice4444FormatsFeaturesEXT::Builder& builder, VkPhysicalDevice4444FormatsFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFormatA4R4G4B4((member.formatA4R4G4B4));}();}();
[&](){[&](){return builder.setFormatA4B4G4R4((member.formatA4B4G4R4));}();}();
}

    VkPhysicalDevice4444FormatsFeaturesEXT deserialize_struct(stream::VkPhysicalDevice4444FormatsFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevice4444FormatsFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.formatA4R4G4B4)=reader.getFormatA4R4G4B4();}();}();
[&](){[&](){(result.formatA4B4G4R4)=reader.getFormatA4B4G4R4();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevice4444FormatsFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevice4444FormatsFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSubpassShadingFeaturesHUAWEI::Builder& builder, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSubpassShading((member.subpassShading));}();}();
}

    VkPhysicalDeviceSubpassShadingFeaturesHUAWEI deserialize_struct(stream::VkPhysicalDeviceSubpassShadingFeaturesHUAWEI::Reader reader){
        auto result=VkPhysicalDeviceSubpassShadingFeaturesHUAWEI();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.subpassShading)=reader.getSubpassShading();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI::Builder& builder, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setClustercullingShader((member.clustercullingShader));}();}();
[&](){[&](){return builder.setMultiviewClusterCullingShader((member.multiviewClusterCullingShader));}();}();
}

    VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI deserialize_struct(stream::VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI::Reader reader){
        auto result=VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.clustercullingShader)=reader.getClustercullingShader();}();}();
[&](){[&](){(result.multiviewClusterCullingShader)=reader.getMultiviewClusterCullingShader();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferCopy2::Builder& builder, VkBufferCopy2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSrcOffset((member.srcOffset));}();}();
[&](){[&](){return builder.setDstOffset((member.dstOffset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkBufferCopy2 deserialize_struct(stream::VkBufferCopy2::Reader reader){
        auto result=VkBufferCopy2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.srcOffset)=reader.getSrcOffset();}();}();
[&](){[&](){(result.dstOffset)=reader.getDstOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferCopy2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferCopy2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageCopy2::Builder& builder, VkImageCopy2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSrcSubresource(srcSubresource);
            return serialize_struct(temp, (member.srcSubresource));
            }();
[&](){
            auto temp=builder.initSrcOffset(srcOffset);
            return serialize_struct(temp, (member.srcOffset));
            }();
[&](){
            auto temp=builder.initDstSubresource(dstSubresource);
            return serialize_struct(temp, (member.dstSubresource));
            }();
[&](){
            auto temp=builder.initDstOffset(dstOffset);
            return serialize_struct(temp, (member.dstOffset));
            }();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
}

    VkImageCopy2 deserialize_struct(stream::VkImageCopy2::Reader reader){
        auto result=VkImageCopy2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getSrcSubresource();
            (result.srcSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSrcOffset();
            (result.srcOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstSubresource();
            (result.dstSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstOffset();
            (result.dstOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageCopy2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageCopy2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageBlit2::Builder& builder, VkImageBlit2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSrcSubresource(srcSubresource);
            return serialize_struct(temp, (member.srcSubresource));
            }();
[&](){
        auto proto_arr=builder.initSrcOffsets(2);
        for(int jRYlQCC=0; jRYlQCC < 2; jRYlQCC++){
            [&](){
            auto temp=proto_arr[jRYlQCC];
            return serialize_struct(temp, ((member.srcOffsets)[jRYlQCC]));
            }();
        }
        }();
[&](){
            auto temp=builder.initDstSubresource(dstSubresource);
            return serialize_struct(temp, (member.dstSubresource));
            }();
[&](){
        auto proto_arr=builder.initDstOffsets(2);
        for(int dYmXuSG=0; dYmXuSG < 2; dYmXuSG++){
            [&](){
            auto temp=proto_arr[dYmXuSG];
            return serialize_struct(temp, ((member.dstOffsets)[dYmXuSG]));
            }();
        }
        }();
}

    VkImageBlit2 deserialize_struct(stream::VkImageBlit2::Reader reader){
        auto result=VkImageBlit2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getSrcSubresource();
            (result.srcSubresource)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getSrcOffsets(2);
        for(int jRYlQCC=0; jRYlQCC < 2; jRYlQCC++){
            [&](){
            auto temp=proto_arr[jRYlQCC];
            ((result.srcOffsets)[jRYlQCC])=deserialize_struct(temp);
            }();
        }
        }();
[&](){
            auto temp=reader.getDstSubresource();
            (result.dstSubresource)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getDstOffsets(2);
        for(int dYmXuSG=0; dYmXuSG < 2; dYmXuSG++){
            [&](){
            auto temp=proto_arr[dYmXuSG];
            ((result.dstOffsets)[dYmXuSG])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageBlit2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageBlit2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferImageCopy2::Builder& builder, VkBufferImageCopy2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setBufferOffset((member.bufferOffset));}();}();
[&](){return builder.setBufferRowLength((member.bufferRowLength));}();
[&](){return builder.setBufferImageHeight((member.bufferImageHeight));}();
[&](){
            auto temp=builder.initImageSubresource(imageSubresource);
            return serialize_struct(temp, (member.imageSubresource));
            }();
[&](){
            auto temp=builder.initImageOffset(imageOffset);
            return serialize_struct(temp, (member.imageOffset));
            }();
[&](){
            auto temp=builder.initImageExtent(imageExtent);
            return serialize_struct(temp, (member.imageExtent));
            }();
}

    VkBufferImageCopy2 deserialize_struct(stream::VkBufferImageCopy2::Reader reader){
        auto result=VkBufferImageCopy2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.bufferOffset)=reader.getBufferOffset();}();}();
[&](){(result.bufferRowLength)=reader.getBufferRowLength();}();
[&](){(result.bufferImageHeight)=reader.getBufferImageHeight();}();
[&](){
            auto temp=reader.getImageSubresource();
            (result.imageSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageOffset();
            (result.imageOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageExtent();
            (result.imageExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferImageCopy2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferImageCopy2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageResolve2::Builder& builder, VkImageResolve2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSrcSubresource(srcSubresource);
            return serialize_struct(temp, (member.srcSubresource));
            }();
[&](){
            auto temp=builder.initSrcOffset(srcOffset);
            return serialize_struct(temp, (member.srcOffset));
            }();
[&](){
            auto temp=builder.initDstSubresource(dstSubresource);
            return serialize_struct(temp, (member.dstSubresource));
            }();
[&](){
            auto temp=builder.initDstOffset(dstOffset);
            return serialize_struct(temp, (member.dstOffset));
            }();
[&](){
            auto temp=builder.initExtent(extent);
            return serialize_struct(temp, (member.extent));
            }();
}

    VkImageResolve2 deserialize_struct(stream::VkImageResolve2::Reader reader){
        auto result=VkImageResolve2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getSrcSubresource();
            (result.srcSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSrcOffset();
            (result.srcOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstSubresource();
            (result.dstSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getDstOffset();
            (result.dstOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getExtent();
            (result.extent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageResolve2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageResolve2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyBufferInfo2::Builder& builder, VkCopyBufferInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcBuffer(serialize_handle(member.srcBuffer));}();
[&](){return builder.setDstBuffer(serialize_handle(member.dstBuffer));}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int DGFUXUH=0; DGFUXUH < member.regionCount; DGFUXUH++){
            [&](){
            auto temp=proto_arr[DGFUXUH];
            return serialize_struct(temp, ((member.pRegions)[DGFUXUH]));
            }();
        }
        }();
}

    VkCopyBufferInfo2 deserialize_struct(stream::VkCopyBufferInfo2::Reader reader){
        auto result=VkCopyBufferInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcBuffer)=deserialize_VkBuffer(reader.getSrcBuffer());}();
[&](){(result.dstBuffer)=deserialize_VkBuffer(reader.getDstBuffer());}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkBufferCopy2* temp_IGDXIQe[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkBufferCopy2*)malloc(result.regionCount*sizeof(VkBufferCopy2));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int qxtkDyM=0; qxtkDyM < result.regionCount; qxtkDyM++){
            [&](){
            auto temp=proto_arr[qxtkDyM];
            ((result.pRegions)[qxtkDyM])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_IGDXIQe;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyBufferInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyBufferInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyImageInfo2::Builder& builder, VkCopyImageInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcImage(serialize_handle(member.srcImage));}();
[&](){[&](){[&](){return builder.setSrcImageLayout((member.srcImageLayout));}();}();}();
[&](){return builder.setDstImage(serialize_handle(member.dstImage));}();
[&](){[&](){[&](){return builder.setDstImageLayout((member.dstImageLayout));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int UKtqPyM=0; UKtqPyM < member.regionCount; UKtqPyM++){
            [&](){
            auto temp=proto_arr[UKtqPyM];
            return serialize_struct(temp, ((member.pRegions)[UKtqPyM]));
            }();
        }
        }();
}

    VkCopyImageInfo2 deserialize_struct(stream::VkCopyImageInfo2::Reader reader){
        auto result=VkCopyImageInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcImage)=deserialize_VkImage(reader.getSrcImage());}();
[&](){[&](){[&](){(result.srcImageLayout)=reader.getSrcImageLayout();}();}();}();
[&](){(result.dstImage)=deserialize_VkImage(reader.getDstImage());}();
[&](){[&](){[&](){(result.dstImageLayout)=reader.getDstImageLayout();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkImageCopy2* temp_mdeoncL[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkImageCopy2*)malloc(result.regionCount*sizeof(VkImageCopy2));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int RcpKxBk=0; RcpKxBk < result.regionCount; RcpKxBk++){
            [&](){
            auto temp=proto_arr[RcpKxBk];
            ((result.pRegions)[RcpKxBk])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_mdeoncL;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyImageInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyImageInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBlitImageInfo2::Builder& builder, VkBlitImageInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcImage(serialize_handle(member.srcImage));}();
[&](){[&](){[&](){return builder.setSrcImageLayout((member.srcImageLayout));}();}();}();
[&](){return builder.setDstImage(serialize_handle(member.dstImage));}();
[&](){[&](){[&](){return builder.setDstImageLayout((member.dstImageLayout));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int eyuNqxm=0; eyuNqxm < member.regionCount; eyuNqxm++){
            [&](){
            auto temp=proto_arr[eyuNqxm];
            return serialize_struct(temp, ((member.pRegions)[eyuNqxm]));
            }();
        }
        }();
[&](){[&](){[&](){return builder.setFilter((member.filter));}();}();}();
}

    VkBlitImageInfo2 deserialize_struct(stream::VkBlitImageInfo2::Reader reader){
        auto result=VkBlitImageInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcImage)=deserialize_VkImage(reader.getSrcImage());}();
[&](){[&](){[&](){(result.srcImageLayout)=reader.getSrcImageLayout();}();}();}();
[&](){(result.dstImage)=deserialize_VkImage(reader.getDstImage());}();
[&](){[&](){[&](){(result.dstImageLayout)=reader.getDstImageLayout();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkImageBlit2* temp_jiuoxLM[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkImageBlit2*)malloc(result.regionCount*sizeof(VkImageBlit2));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int vAwDVQE=0; vAwDVQE < result.regionCount; vAwDVQE++){
            [&](){
            auto temp=proto_arr[vAwDVQE];
            ((result.pRegions)[vAwDVQE])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_jiuoxLM;}();
[&](){[&](){[&](){(result.filter)=reader.getFilter();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBlitImageInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBlitImageInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyBufferToImageInfo2::Builder& builder, VkCopyBufferToImageInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcBuffer(serialize_handle(member.srcBuffer));}();
[&](){return builder.setDstImage(serialize_handle(member.dstImage));}();
[&](){[&](){[&](){return builder.setDstImageLayout((member.dstImageLayout));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int NlBTicW=0; NlBTicW < member.regionCount; NlBTicW++){
            [&](){
            auto temp=proto_arr[NlBTicW];
            return serialize_struct(temp, ((member.pRegions)[NlBTicW]));
            }();
        }
        }();
}

    VkCopyBufferToImageInfo2 deserialize_struct(stream::VkCopyBufferToImageInfo2::Reader reader){
        auto result=VkCopyBufferToImageInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcBuffer)=deserialize_VkBuffer(reader.getSrcBuffer());}();
[&](){(result.dstImage)=deserialize_VkImage(reader.getDstImage());}();
[&](){[&](){[&](){(result.dstImageLayout)=reader.getDstImageLayout();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkBufferImageCopy2* temp_neWMapE[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkBufferImageCopy2*)malloc(result.regionCount*sizeof(VkBufferImageCopy2));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int YLeVual=0; YLeVual < result.regionCount; YLeVual++){
            [&](){
            auto temp=proto_arr[YLeVual];
            ((result.pRegions)[YLeVual])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_neWMapE;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyBufferToImageInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyBufferToImageInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyImageToBufferInfo2::Builder& builder, VkCopyImageToBufferInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcImage(serialize_handle(member.srcImage));}();
[&](){[&](){[&](){return builder.setSrcImageLayout((member.srcImageLayout));}();}();}();
[&](){return builder.setDstBuffer(serialize_handle(member.dstBuffer));}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int NlBTicW=0; NlBTicW < member.regionCount; NlBTicW++){
            [&](){
            auto temp=proto_arr[NlBTicW];
            return serialize_struct(temp, ((member.pRegions)[NlBTicW]));
            }();
        }
        }();
}

    VkCopyImageToBufferInfo2 deserialize_struct(stream::VkCopyImageToBufferInfo2::Reader reader){
        auto result=VkCopyImageToBufferInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcImage)=deserialize_VkImage(reader.getSrcImage());}();
[&](){[&](){[&](){(result.srcImageLayout)=reader.getSrcImageLayout();}();}();}();
[&](){(result.dstBuffer)=deserialize_VkBuffer(reader.getDstBuffer());}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkBufferImageCopy2* temp_neWMapE[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkBufferImageCopy2*)malloc(result.regionCount*sizeof(VkBufferImageCopy2));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int YLeVual=0; YLeVual < result.regionCount; YLeVual++){
            [&](){
            auto temp=proto_arr[YLeVual];
            ((result.pRegions)[YLeVual])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_neWMapE;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyImageToBufferInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyImageToBufferInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkResolveImageInfo2::Builder& builder, VkResolveImageInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrcImage(serialize_handle(member.srcImage));}();
[&](){[&](){[&](){return builder.setSrcImageLayout((member.srcImageLayout));}();}();}();
[&](){return builder.setDstImage(serialize_handle(member.dstImage));}();
[&](){[&](){[&](){return builder.setDstImageLayout((member.dstImageLayout));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int YWPZXmz=0; YWPZXmz < member.regionCount; YWPZXmz++){
            [&](){
            auto temp=proto_arr[YWPZXmz];
            return serialize_struct(temp, ((member.pRegions)[YWPZXmz]));
            }();
        }
        }();
}

    VkResolveImageInfo2 deserialize_struct(stream::VkResolveImageInfo2::Reader reader){
        auto result=VkResolveImageInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.srcImage)=deserialize_VkImage(reader.getSrcImage());}();
[&](){[&](){[&](){(result.srcImageLayout)=reader.getSrcImageLayout();}();}();}();
[&](){(result.dstImage)=deserialize_VkImage(reader.getDstImage());}();
[&](){[&](){[&](){(result.dstImageLayout)=reader.getDstImageLayout();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkImageResolve2* temp_gNJAvXi[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkImageResolve2*)malloc(result.regionCount*sizeof(VkImageResolve2));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int cQwfEVG=0; cQwfEVG < result.regionCount; cQwfEVG++){
            [&](){
            auto temp=proto_arr[cQwfEVG];
            ((result.pRegions)[cQwfEVG])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_gNJAvXi;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkResolveImageInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkResolveImageInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::Builder& builder, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderImageInt64Atomics((member.shaderImageInt64Atomics));}();}();
[&](){[&](){return builder.setSparseImageInt64Atomics((member.sparseImageInt64Atomics));}();}();
}

    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderImageInt64Atomics)=reader.getShaderImageInt64Atomics();}();}();
[&](){[&](){(result.sparseImageInt64Atomics)=reader.getSparseImageInt64Atomics();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFragmentShadingRateAttachmentInfoKHR::Builder& builder, VkFragmentShadingRateAttachmentInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pFragmentShadingRateAttachment)==NULL){
                builder.initPFragmentShadingRateAttachment(0);
            return; }
        auto proto_arr=builder.initPFragmentShadingRateAttachment(1);
        for(int eUKVzmp=0; eUKVzmp < 1; eUKVzmp++){
            [&](){
            auto temp=proto_arr[eUKVzmp];
            return serialize_struct(temp, ((member.pFragmentShadingRateAttachment)[eUKVzmp]));
            }();
        }
        }();
[&](){
            auto temp=builder.initShadingRateAttachmentTexelSize(shadingRateAttachmentTexelSize);
            return serialize_struct(temp, (member.shadingRateAttachmentTexelSize));
            }();
}

    VkFragmentShadingRateAttachmentInfoKHR deserialize_struct(stream::VkFragmentShadingRateAttachmentInfoKHR::Reader reader){
        auto result=VkFragmentShadingRateAttachmentInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ VkAttachmentReference2* temp_zmCwYqJ[&](){
            if (!reader.getPFragmentShadingRateAttachment().size()==0){
                (result.pFragmentShadingRateAttachment)=NULL;
            return; }{native_concat()}=(VkAttachmentReference2*)malloc(1*sizeof(VkAttachmentReference2));
        auto proto_arr=reader.getPFragmentShadingRateAttachment(1);
        for(int CJUwLOb=0; CJUwLOb < 1; CJUwLOb++){
            [&](){
            auto temp=proto_arr[CJUwLOb];
            ((result.pFragmentShadingRateAttachment)[CJUwLOb])=deserialize_struct(temp);
            }();
        }
        }();(result.pFragmentShadingRateAttachment)=temp_zmCwYqJ;}();
[&](){
            auto temp=reader.getShadingRateAttachmentTexelSize();
            (result.shadingRateAttachmentTexelSize)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFragmentShadingRateAttachmentInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFragmentShadingRateAttachmentInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineFragmentShadingRateStateCreateInfoKHR::Builder& builder, VkPipelineFragmentShadingRateStateCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initFragmentSize(fragmentSize);
            return serialize_struct(temp, (member.fragmentSize));
            }();
[&](){
        auto proto_arr=builder.initCombinerOps(2);
        for(int FpqnVre=0; FpqnVre < 2; FpqnVre++){
            [&](){[&](){[&](){return proto_arr.set(FpqnVre,((member.combinerOps)[FpqnVre]));}();}();}();
        }
        }();
}

    VkPipelineFragmentShadingRateStateCreateInfoKHR deserialize_struct(stream::VkPipelineFragmentShadingRateStateCreateInfoKHR::Reader reader){
        auto result=VkPipelineFragmentShadingRateStateCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getFragmentSize();
            (result.fragmentSize)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getCombinerOps(2);
        for(int FpqnVre=0; FpqnVre < 2; FpqnVre++){
            [&](){[&](){[&](){((result.combinerOps)[FpqnVre])=proto_arr[FpqnVre];}();}();}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineFragmentShadingRateStateCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineFragmentShadingRateStateCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShadingRateFeaturesKHR::Builder& builder, VkPhysicalDeviceFragmentShadingRateFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPipelineFragmentShadingRate((member.pipelineFragmentShadingRate));}();}();
[&](){[&](){return builder.setPrimitiveFragmentShadingRate((member.primitiveFragmentShadingRate));}();}();
[&](){[&](){return builder.setAttachmentFragmentShadingRate((member.attachmentFragmentShadingRate));}();}();
}

    VkPhysicalDeviceFragmentShadingRateFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceFragmentShadingRateFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceFragmentShadingRateFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pipelineFragmentShadingRate)=reader.getPipelineFragmentShadingRate();}();}();
[&](){[&](){(result.primitiveFragmentShadingRate)=reader.getPrimitiveFragmentShadingRate();}();}();
[&](){[&](){(result.attachmentFragmentShadingRate)=reader.getAttachmentFragmentShadingRate();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShadingRateFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShadingRateFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShadingRatePropertiesKHR::Builder& builder, VkPhysicalDeviceFragmentShadingRatePropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initMinFragmentShadingRateAttachmentTexelSize(minFragmentShadingRateAttachmentTexelSize);
            return serialize_struct(temp, (member.minFragmentShadingRateAttachmentTexelSize));
            }();
[&](){
            auto temp=builder.initMaxFragmentShadingRateAttachmentTexelSize(maxFragmentShadingRateAttachmentTexelSize);
            return serialize_struct(temp, (member.maxFragmentShadingRateAttachmentTexelSize));
            }();
[&](){return builder.setMaxFragmentShadingRateAttachmentTexelSizeAspectRatio((member.maxFragmentShadingRateAttachmentTexelSizeAspectRatio));}();
[&](){[&](){return builder.setPrimitiveFragmentShadingRateWithMultipleViewports((member.primitiveFragmentShadingRateWithMultipleViewports));}();}();
[&](){[&](){return builder.setLayeredShadingRateAttachments((member.layeredShadingRateAttachments));}();}();
[&](){[&](){return builder.setFragmentShadingRateNonTrivialCombinerOps((member.fragmentShadingRateNonTrivialCombinerOps));}();}();
[&](){
            auto temp=builder.initMaxFragmentSize(maxFragmentSize);
            return serialize_struct(temp, (member.maxFragmentSize));
            }();
[&](){return builder.setMaxFragmentSizeAspectRatio((member.maxFragmentSizeAspectRatio));}();
[&](){return builder.setMaxFragmentShadingRateCoverageSamples((member.maxFragmentShadingRateCoverageSamples));}();
[&](){[&](){[&](){return builder.setMaxFragmentShadingRateRasterizationSamples((member.maxFragmentShadingRateRasterizationSamples));}();}();}();
[&](){[&](){return builder.setFragmentShadingRateWithShaderDepthStencilWrites((member.fragmentShadingRateWithShaderDepthStencilWrites));}();}();
[&](){[&](){return builder.setFragmentShadingRateWithSampleMask((member.fragmentShadingRateWithSampleMask));}();}();
[&](){[&](){return builder.setFragmentShadingRateWithShaderSampleMask((member.fragmentShadingRateWithShaderSampleMask));}();}();
[&](){[&](){return builder.setFragmentShadingRateWithConservativeRasterization((member.fragmentShadingRateWithConservativeRasterization));}();}();
[&](){[&](){return builder.setFragmentShadingRateWithFragmentShaderInterlock((member.fragmentShadingRateWithFragmentShaderInterlock));}();}();
[&](){[&](){return builder.setFragmentShadingRateWithCustomSampleLocations((member.fragmentShadingRateWithCustomSampleLocations));}();}();
[&](){[&](){return builder.setFragmentShadingRateStrictMultiplyCombiner((member.fragmentShadingRateStrictMultiplyCombiner));}();}();
}

    VkPhysicalDeviceFragmentShadingRatePropertiesKHR deserialize_struct(stream::VkPhysicalDeviceFragmentShadingRatePropertiesKHR::Reader reader){
        auto result=VkPhysicalDeviceFragmentShadingRatePropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinFragmentShadingRateAttachmentTexelSize();
            (result.minFragmentShadingRateAttachmentTexelSize)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxFragmentShadingRateAttachmentTexelSize();
            (result.maxFragmentShadingRateAttachmentTexelSize)=deserialize_struct(temp);
            }();
[&](){(result.maxFragmentShadingRateAttachmentTexelSizeAspectRatio)=reader.getMaxFragmentShadingRateAttachmentTexelSizeAspectRatio();}();
[&](){[&](){(result.primitiveFragmentShadingRateWithMultipleViewports)=reader.getPrimitiveFragmentShadingRateWithMultipleViewports();}();}();
[&](){[&](){(result.layeredShadingRateAttachments)=reader.getLayeredShadingRateAttachments();}();}();
[&](){[&](){(result.fragmentShadingRateNonTrivialCombinerOps)=reader.getFragmentShadingRateNonTrivialCombinerOps();}();}();
[&](){
            auto temp=reader.getMaxFragmentSize();
            (result.maxFragmentSize)=deserialize_struct(temp);
            }();
[&](){(result.maxFragmentSizeAspectRatio)=reader.getMaxFragmentSizeAspectRatio();}();
[&](){(result.maxFragmentShadingRateCoverageSamples)=reader.getMaxFragmentShadingRateCoverageSamples();}();
[&](){[&](){[&](){(result.maxFragmentShadingRateRasterizationSamples)=reader.getMaxFragmentShadingRateRasterizationSamples();}();}();}();
[&](){[&](){(result.fragmentShadingRateWithShaderDepthStencilWrites)=reader.getFragmentShadingRateWithShaderDepthStencilWrites();}();}();
[&](){[&](){(result.fragmentShadingRateWithSampleMask)=reader.getFragmentShadingRateWithSampleMask();}();}();
[&](){[&](){(result.fragmentShadingRateWithShaderSampleMask)=reader.getFragmentShadingRateWithShaderSampleMask();}();}();
[&](){[&](){(result.fragmentShadingRateWithConservativeRasterization)=reader.getFragmentShadingRateWithConservativeRasterization();}();}();
[&](){[&](){(result.fragmentShadingRateWithFragmentShaderInterlock)=reader.getFragmentShadingRateWithFragmentShaderInterlock();}();}();
[&](){[&](){(result.fragmentShadingRateWithCustomSampleLocations)=reader.getFragmentShadingRateWithCustomSampleLocations();}();}();
[&](){[&](){(result.fragmentShadingRateStrictMultiplyCombiner)=reader.getFragmentShadingRateStrictMultiplyCombiner();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShadingRatePropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShadingRatePropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShadingRateKHR::Builder& builder, VkPhysicalDeviceFragmentShadingRateKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSampleCounts((member.sampleCounts));}();}();}();
[&](){
            auto temp=builder.initFragmentSize(fragmentSize);
            return serialize_struct(temp, (member.fragmentSize));
            }();
}

    VkPhysicalDeviceFragmentShadingRateKHR deserialize_struct(stream::VkPhysicalDeviceFragmentShadingRateKHR::Reader reader){
        auto result=VkPhysicalDeviceFragmentShadingRateKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.sampleCounts)=reader.getSampleCounts();}();}();}();
[&](){
            auto temp=reader.getFragmentSize();
            (result.fragmentSize)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShadingRateKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShadingRateKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderTerminateInvocationFeatures::Builder& builder, VkPhysicalDeviceShaderTerminateInvocationFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderTerminateInvocation((member.shaderTerminateInvocation));}();}();
}

    VkPhysicalDeviceShaderTerminateInvocationFeatures deserialize_struct(stream::VkPhysicalDeviceShaderTerminateInvocationFeatures::Reader reader){
        auto result=VkPhysicalDeviceShaderTerminateInvocationFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderTerminateInvocation)=reader.getShaderTerminateInvocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderTerminateInvocationFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderTerminateInvocationFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::Builder& builder, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFragmentShadingRateEnums((member.fragmentShadingRateEnums));}();}();
[&](){[&](){return builder.setSupersampleFragmentShadingRates((member.supersampleFragmentShadingRates));}();}();
[&](){[&](){return builder.setNoInvocationFragmentShadingRates((member.noInvocationFragmentShadingRates));}();}();
}

    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV deserialize_struct(stream::VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.fragmentShadingRateEnums)=reader.getFragmentShadingRateEnums();}();}();
[&](){[&](){(result.supersampleFragmentShadingRates)=reader.getSupersampleFragmentShadingRates();}();}();
[&](){[&](){(result.noInvocationFragmentShadingRates)=reader.getNoInvocationFragmentShadingRates();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::Builder& builder, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setMaxFragmentShadingRateInvocationCount((member.maxFragmentShadingRateInvocationCount));}();}();}();
}

    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV deserialize_struct(stream::VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.maxFragmentShadingRateInvocationCount)=reader.getMaxFragmentShadingRateInvocationCount();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineFragmentShadingRateEnumStateCreateInfoNV::Builder& builder, VkPipelineFragmentShadingRateEnumStateCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setShadingRateType((member.shadingRateType));}();}();}();
[&](){[&](){[&](){return builder.setShadingRate((member.shadingRate));}();}();}();
[&](){
        auto proto_arr=builder.initCombinerOps(2);
        for(int FpqnVre=0; FpqnVre < 2; FpqnVre++){
            [&](){[&](){[&](){return proto_arr.set(FpqnVre,((member.combinerOps)[FpqnVre]));}();}();}();
        }
        }();
}

    VkPipelineFragmentShadingRateEnumStateCreateInfoNV deserialize_struct(stream::VkPipelineFragmentShadingRateEnumStateCreateInfoNV::Reader reader){
        auto result=VkPipelineFragmentShadingRateEnumStateCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.shadingRateType)=reader.getShadingRateType();}();}();}();
[&](){[&](){[&](){(result.shadingRate)=reader.getShadingRate();}();}();}();
[&](){
        auto proto_arr=reader.getCombinerOps(2);
        for(int FpqnVre=0; FpqnVre < 2; FpqnVre++){
            [&](){[&](){[&](){((result.combinerOps)[FpqnVre])=proto_arr[FpqnVre];}();}();}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineFragmentShadingRateEnumStateCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineFragmentShadingRateEnumStateCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureBuildSizesInfoKHR::Builder& builder, VkAccelerationStructureBuildSizesInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAccelerationStructureSize((member.accelerationStructureSize));}();}();
[&](){[&](){return builder.setUpdateScratchSize((member.updateScratchSize));}();}();
[&](){[&](){return builder.setBuildScratchSize((member.buildScratchSize));}();}();
}

    VkAccelerationStructureBuildSizesInfoKHR deserialize_struct(stream::VkAccelerationStructureBuildSizesInfoKHR::Reader reader){
        auto result=VkAccelerationStructureBuildSizesInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.accelerationStructureSize)=reader.getAccelerationStructureSize();}();}();
[&](){[&](){(result.updateScratchSize)=reader.getUpdateScratchSize();}();}();
[&](){[&](){(result.buildScratchSize)=reader.getBuildScratchSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureBuildSizesInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureBuildSizesInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImage2DViewOf3DFeaturesEXT::Builder& builder, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setImage2DViewOf3D((member.image2DViewOf3D));}();}();
[&](){[&](){return builder.setSampler2DViewOf3D((member.sampler2DViewOf3D));}();}();
}

    VkPhysicalDeviceImage2DViewOf3DFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceImage2DViewOf3DFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceImage2DViewOf3DFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.image2DViewOf3D)=reader.getImage2DViewOf3D();}();}();
[&](){[&](){(result.sampler2DViewOf3D)=reader.getSampler2DViewOf3D();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT::Builder& builder, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setImageSlicedViewOf3D((member.imageSlicedViewOf3D));}();}();
}

    VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.imageSlicedViewOf3D)=reader.getImageSlicedViewOf3D();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT::Builder& builder, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAttachmentFeedbackLoopDynamicState((member.attachmentFeedbackLoopDynamicState));}();}();
}

    VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.attachmentFeedbackLoopDynamicState)=reader.getAttachmentFeedbackLoopDynamicState();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::Builder& builder, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMutableDescriptorType((member.mutableDescriptorType));}();}();
}

    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.mutableDescriptorType)=reader.getMutableDescriptorType();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMutableDescriptorTypeListEXT::Builder& builder, VkMutableDescriptorTypeListEXT member){
        
    
[&](){return builder.setDescriptorTypeCount((member.descriptorTypeCount));}();
[&](){
            if ((member.pDescriptorTypes)==NULL){
                builder.initPDescriptorTypes(0);
            return; }
        auto proto_arr=builder.initPDescriptorTypes(member.descriptorTypeCount);
        for(int mMCdMcl=0; mMCdMcl < member.descriptorTypeCount; mMCdMcl++){
            [&](){[&](){[&](){return proto_arr.set(mMCdMcl,((member.pDescriptorTypes)[mMCdMcl]));}();}();}();
        }
        }();
}

    VkMutableDescriptorTypeListEXT deserialize_struct(stream::VkMutableDescriptorTypeListEXT::Reader reader){
        auto result=VkMutableDescriptorTypeListEXT();
    
[&](){(result.descriptorTypeCount)=reader.getDescriptorTypeCount();}();
[&](){ VkDescriptorType* temp_lcgnzTl[&](){
            if (!reader.getPDescriptorTypes().size()==0){
                (result.pDescriptorTypes)=NULL;
            return; }{native_concat()}=(VkDescriptorType*)malloc(result.descriptorTypeCount*sizeof(VkDescriptorType));
        auto proto_arr=reader.getPDescriptorTypes(result.descriptorTypeCount);
        for(int hFwMthy=0; hFwMthy < result.descriptorTypeCount; hFwMthy++){
            [&](){[&](){[&](){((result.pDescriptorTypes)[hFwMthy])=proto_arr[hFwMthy];}();}();}();
        }
        }();(result.pDescriptorTypes)=temp_lcgnzTl;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMutableDescriptorTypeListEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMutableDescriptorTypeListEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMutableDescriptorTypeCreateInfoEXT::Builder& builder, VkMutableDescriptorTypeCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMutableDescriptorTypeListCount((member.mutableDescriptorTypeListCount));}();
[&](){
            if ((member.pMutableDescriptorTypeLists)==NULL){
                builder.initPMutableDescriptorTypeLists(0);
            return; }
        auto proto_arr=builder.initPMutableDescriptorTypeLists(member.mutableDescriptorTypeListCount);
        for(int aVFhYgk=0; aVFhYgk < member.mutableDescriptorTypeListCount; aVFhYgk++){
            [&](){
            auto temp=proto_arr[aVFhYgk];
            return serialize_struct(temp, ((member.pMutableDescriptorTypeLists)[aVFhYgk]));
            }();
        }
        }();
}

    VkMutableDescriptorTypeCreateInfoEXT deserialize_struct(stream::VkMutableDescriptorTypeCreateInfoEXT::Reader reader){
        auto result=VkMutableDescriptorTypeCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.mutableDescriptorTypeListCount)=reader.getMutableDescriptorTypeListCount();}();
[&](){ VkMutableDescriptorTypeListEXT* temp_NYqnwHi[&](){
            if (!reader.getPMutableDescriptorTypeLists().size()==0){
                (result.pMutableDescriptorTypeLists)=NULL;
            return; }{native_concat()}=(VkMutableDescriptorTypeListEXT*)malloc(result.mutableDescriptorTypeListCount*sizeof(VkMutableDescriptorTypeListEXT));
        auto proto_arr=reader.getPMutableDescriptorTypeLists(result.mutableDescriptorTypeListCount);
        for(int LfvNpBl=0; LfvNpBl < result.mutableDescriptorTypeListCount; LfvNpBl++){
            [&](){
            auto temp=proto_arr[LfvNpBl];
            ((result.pMutableDescriptorTypeLists)[LfvNpBl])=deserialize_struct(temp);
            }();
        }
        }();(result.pMutableDescriptorTypeLists)=temp_NYqnwHi;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMutableDescriptorTypeCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMutableDescriptorTypeCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDepthClipControlFeaturesEXT::Builder& builder, VkPhysicalDeviceDepthClipControlFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDepthClipControl((member.depthClipControl));}();}();
}

    VkPhysicalDeviceDepthClipControlFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceDepthClipControlFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceDepthClipControlFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.depthClipControl)=reader.getDepthClipControl();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDepthClipControlFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDepthClipControlFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineViewportDepthClipControlCreateInfoEXT::Builder& builder, VkPipelineViewportDepthClipControlCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setNegativeOneToOne((member.negativeOneToOne));}();}();
}

    VkPipelineViewportDepthClipControlCreateInfoEXT deserialize_struct(stream::VkPipelineViewportDepthClipControlCreateInfoEXT::Reader reader){
        auto result=VkPipelineViewportDepthClipControlCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.negativeOneToOne)=reader.getNegativeOneToOne();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineViewportDepthClipControlCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineViewportDepthClipControlCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::Builder& builder, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setVertexInputDynamicState((member.vertexInputDynamicState));}();}();
}

    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.vertexInputDynamicState)=reader.getVertexInputDynamicState();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceExternalMemoryRDMAFeaturesNV::Builder& builder, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setExternalMemoryRDMA((member.externalMemoryRDMA));}();}();
}

    VkPhysicalDeviceExternalMemoryRDMAFeaturesNV deserialize_struct(stream::VkPhysicalDeviceExternalMemoryRDMAFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceExternalMemoryRDMAFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.externalMemoryRDMA)=reader.getExternalMemoryRDMA();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVertexInputBindingDescription2EXT::Builder& builder, VkVertexInputBindingDescription2EXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBinding((member.binding));}();
[&](){return builder.setStride((member.stride));}();
[&](){[&](){[&](){return builder.setInputRate((member.inputRate));}();}();}();
[&](){return builder.setDivisor((member.divisor));}();
}

    VkVertexInputBindingDescription2EXT deserialize_struct(stream::VkVertexInputBindingDescription2EXT::Reader reader){
        auto result=VkVertexInputBindingDescription2EXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.binding)=reader.getBinding();}();
[&](){(result.stride)=reader.getStride();}();
[&](){[&](){[&](){(result.inputRate)=reader.getInputRate();}();}();}();
[&](){(result.divisor)=reader.getDivisor();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVertexInputBindingDescription2EXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVertexInputBindingDescription2EXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVertexInputAttributeDescription2EXT::Builder& builder, VkVertexInputAttributeDescription2EXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setLocation((member.location));}();
[&](){return builder.setBinding((member.binding));}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){return builder.setOffset((member.offset));}();
}

    VkVertexInputAttributeDescription2EXT deserialize_struct(stream::VkVertexInputAttributeDescription2EXT::Reader reader){
        auto result=VkVertexInputAttributeDescription2EXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.location)=reader.getLocation();}();
[&](){(result.binding)=reader.getBinding();}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){(result.offset)=reader.getOffset();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVertexInputAttributeDescription2EXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVertexInputAttributeDescription2EXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceColorWriteEnableFeaturesEXT::Builder& builder, VkPhysicalDeviceColorWriteEnableFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setColorWriteEnable((member.colorWriteEnable));}();}();
}

    VkPhysicalDeviceColorWriteEnableFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceColorWriteEnableFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceColorWriteEnableFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.colorWriteEnable)=reader.getColorWriteEnable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceColorWriteEnableFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceColorWriteEnableFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineColorWriteCreateInfoEXT::Builder& builder, VkPipelineColorWriteCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAttachmentCount((member.attachmentCount));}();
[&](){
            if ((member.pColorWriteEnables)==NULL){
                builder.initPColorWriteEnables(0);
            return; }
        auto proto_arr=builder.initPColorWriteEnables(member.attachmentCount);
        for(int yIAOqhJ=0; yIAOqhJ < member.attachmentCount; yIAOqhJ++){
            [&](){[&](){return proto_arr.set(yIAOqhJ,((member.pColorWriteEnables)[yIAOqhJ]));}();}();
        }
        }();
}

    VkPipelineColorWriteCreateInfoEXT deserialize_struct(stream::VkPipelineColorWriteCreateInfoEXT::Reader reader){
        auto result=VkPipelineColorWriteCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.attachmentCount)=reader.getAttachmentCount();}();
[&](){ VkBool32* temp_ZYFOgyc[&](){
            if (!reader.getPColorWriteEnables().size()==0){
                (result.pColorWriteEnables)=NULL;
            return; }{native_concat()}=(VkBool32*)malloc(result.attachmentCount*sizeof(VkBool32));
        auto proto_arr=reader.getPColorWriteEnables(result.attachmentCount);
        for(int DHTXFpH=0; DHTXFpH < result.attachmentCount; DHTXFpH++){
            [&](){[&](){((result.pColorWriteEnables)[DHTXFpH])=proto_arr[DHTXFpH];}();}();
        }
        }();(result.pColorWriteEnables)=temp_ZYFOgyc;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineColorWriteCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineColorWriteCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryBarrier2::Builder& builder, VkMemoryBarrier2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSrcStageMask((member.srcStageMask));}();}();}();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstStageMask((member.dstStageMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
}

    VkMemoryBarrier2 deserialize_struct(stream::VkMemoryBarrier2::Reader reader){
        auto result=VkMemoryBarrier2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.srcStageMask)=reader.getSrcStageMask();}();}();}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstStageMask)=reader.getDstStageMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryBarrier2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryBarrier2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageMemoryBarrier2::Builder& builder, VkImageMemoryBarrier2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSrcStageMask((member.srcStageMask));}();}();}();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstStageMask((member.dstStageMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setOldLayout((member.oldLayout));}();}();}();
[&](){[&](){[&](){return builder.setNewLayout((member.newLayout));}();}();}();
[&](){return builder.setSrcQueueFamilyIndex((member.srcQueueFamilyIndex));}();
[&](){return builder.setDstQueueFamilyIndex((member.dstQueueFamilyIndex));}();
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){
            auto temp=builder.initSubresourceRange(subresourceRange);
            return serialize_struct(temp, (member.subresourceRange));
            }();
}

    VkImageMemoryBarrier2 deserialize_struct(stream::VkImageMemoryBarrier2::Reader reader){
        auto result=VkImageMemoryBarrier2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.srcStageMask)=reader.getSrcStageMask();}();}();}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstStageMask)=reader.getDstStageMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
[&](){[&](){[&](){(result.oldLayout)=reader.getOldLayout();}();}();}();
[&](){[&](){[&](){(result.newLayout)=reader.getNewLayout();}();}();}();
[&](){(result.srcQueueFamilyIndex)=reader.getSrcQueueFamilyIndex();}();
[&](){(result.dstQueueFamilyIndex)=reader.getDstQueueFamilyIndex();}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){
            auto temp=reader.getSubresourceRange();
            (result.subresourceRange)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageMemoryBarrier2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageMemoryBarrier2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferMemoryBarrier2::Builder& builder, VkBufferMemoryBarrier2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSrcStageMask((member.srcStageMask));}();}();}();
[&](){[&](){[&](){return builder.setSrcAccessMask((member.srcAccessMask));}();}();}();
[&](){[&](){[&](){return builder.setDstStageMask((member.dstStageMask));}();}();}();
[&](){[&](){[&](){return builder.setDstAccessMask((member.dstAccessMask));}();}();}();
[&](){return builder.setSrcQueueFamilyIndex((member.srcQueueFamilyIndex));}();
[&](){return builder.setDstQueueFamilyIndex((member.dstQueueFamilyIndex));}();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkBufferMemoryBarrier2 deserialize_struct(stream::VkBufferMemoryBarrier2::Reader reader){
        auto result=VkBufferMemoryBarrier2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.srcStageMask)=reader.getSrcStageMask();}();}();}();
[&](){[&](){[&](){(result.srcAccessMask)=reader.getSrcAccessMask();}();}();}();
[&](){[&](){[&](){(result.dstStageMask)=reader.getDstStageMask();}();}();}();
[&](){[&](){[&](){(result.dstAccessMask)=reader.getDstAccessMask();}();}();}();
[&](){(result.srcQueueFamilyIndex)=reader.getSrcQueueFamilyIndex();}();
[&](){(result.dstQueueFamilyIndex)=reader.getDstQueueFamilyIndex();}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferMemoryBarrier2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferMemoryBarrier2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDependencyInfo::Builder& builder, VkDependencyInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDependencyFlags((member.dependencyFlags));}();}();}();
[&](){return builder.setMemoryBarrierCount((member.memoryBarrierCount));}();
[&](){
            if ((member.pMemoryBarriers)==NULL){
                builder.initPMemoryBarriers(0);
            return; }
        auto proto_arr=builder.initPMemoryBarriers(member.memoryBarrierCount);
        for(int TLpIbmO=0; TLpIbmO < member.memoryBarrierCount; TLpIbmO++){
            [&](){
            auto temp=proto_arr[TLpIbmO];
            return serialize_struct(temp, ((member.pMemoryBarriers)[TLpIbmO]));
            }();
        }
        }();
[&](){return builder.setBufferMemoryBarrierCount((member.bufferMemoryBarrierCount));}();
[&](){
            if ((member.pBufferMemoryBarriers)==NULL){
                builder.initPBufferMemoryBarriers(0);
            return; }
        auto proto_arr=builder.initPBufferMemoryBarriers(member.bufferMemoryBarrierCount);
        for(int bKIYONz=0; bKIYONz < member.bufferMemoryBarrierCount; bKIYONz++){
            [&](){
            auto temp=proto_arr[bKIYONz];
            return serialize_struct(temp, ((member.pBufferMemoryBarriers)[bKIYONz]));
            }();
        }
        }();
[&](){return builder.setImageMemoryBarrierCount((member.imageMemoryBarrierCount));}();
[&](){
            if ((member.pImageMemoryBarriers)==NULL){
                builder.initPImageMemoryBarriers(0);
            return; }
        auto proto_arr=builder.initPImageMemoryBarriers(member.imageMemoryBarrierCount);
        for(int GWgQpPD=0; GWgQpPD < member.imageMemoryBarrierCount; GWgQpPD++){
            [&](){
            auto temp=proto_arr[GWgQpPD];
            return serialize_struct(temp, ((member.pImageMemoryBarriers)[GWgQpPD]));
            }();
        }
        }();
}

    VkDependencyInfo deserialize_struct(stream::VkDependencyInfo::Reader reader){
        auto result=VkDependencyInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.dependencyFlags)=reader.getDependencyFlags();}();}();}();
[&](){(result.memoryBarrierCount)=reader.getMemoryBarrierCount();}();
[&](){ VkMemoryBarrier2* temp_drvMaAZ[&](){
            if (!reader.getPMemoryBarriers().size()==0){
                (result.pMemoryBarriers)=NULL;
            return; }{native_concat()}=(VkMemoryBarrier2*)malloc(result.memoryBarrierCount*sizeof(VkMemoryBarrier2));
        auto proto_arr=reader.getPMemoryBarriers(result.memoryBarrierCount);
        for(int MhoHkAx=0; MhoHkAx < result.memoryBarrierCount; MhoHkAx++){
            [&](){
            auto temp=proto_arr[MhoHkAx];
            ((result.pMemoryBarriers)[MhoHkAx])=deserialize_struct(temp);
            }();
        }
        }();(result.pMemoryBarriers)=temp_drvMaAZ;}();
[&](){(result.bufferMemoryBarrierCount)=reader.getBufferMemoryBarrierCount();}();
[&](){ VkBufferMemoryBarrier2* temp_dAKfGvU[&](){
            if (!reader.getPBufferMemoryBarriers().size()==0){
                (result.pBufferMemoryBarriers)=NULL;
            return; }{native_concat()}=(VkBufferMemoryBarrier2*)malloc(result.bufferMemoryBarrierCount*sizeof(VkBufferMemoryBarrier2));
        auto proto_arr=reader.getPBufferMemoryBarriers(result.bufferMemoryBarrierCount);
        for(int NYJDAKD=0; NYJDAKD < result.bufferMemoryBarrierCount; NYJDAKD++){
            [&](){
            auto temp=proto_arr[NYJDAKD];
            ((result.pBufferMemoryBarriers)[NYJDAKD])=deserialize_struct(temp);
            }();
        }
        }();(result.pBufferMemoryBarriers)=temp_dAKfGvU;}();
[&](){(result.imageMemoryBarrierCount)=reader.getImageMemoryBarrierCount();}();
[&](){ VkImageMemoryBarrier2* temp_AsuNyRQ[&](){
            if (!reader.getPImageMemoryBarriers().size()==0){
                (result.pImageMemoryBarriers)=NULL;
            return; }{native_concat()}=(VkImageMemoryBarrier2*)malloc(result.imageMemoryBarrierCount*sizeof(VkImageMemoryBarrier2));
        auto proto_arr=reader.getPImageMemoryBarriers(result.imageMemoryBarrierCount);
        for(int wOgpYvu=0; wOgpYvu < result.imageMemoryBarrierCount; wOgpYvu++){
            [&](){
            auto temp=proto_arr[wOgpYvu];
            ((result.pImageMemoryBarriers)[wOgpYvu])=deserialize_struct(temp);
            }();
        }
        }();(result.pImageMemoryBarriers)=temp_AsuNyRQ;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDependencyInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDependencyInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSemaphoreSubmitInfo::Builder& builder, VkSemaphoreSubmitInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSemaphore(serialize_handle(member.semaphore));}();
[&](){return builder.setValue((member.value));}();
[&](){[&](){[&](){return builder.setStageMask((member.stageMask));}();}();}();
[&](){return builder.setDeviceIndex((member.deviceIndex));}();
}

    VkSemaphoreSubmitInfo deserialize_struct(stream::VkSemaphoreSubmitInfo::Reader reader){
        auto result=VkSemaphoreSubmitInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.semaphore)=deserialize_VkSemaphore(reader.getSemaphore());}();
[&](){(result.value)=reader.getValue();}();
[&](){[&](){[&](){(result.stageMask)=reader.getStageMask();}();}();}();
[&](){(result.deviceIndex)=reader.getDeviceIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSemaphoreSubmitInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSemaphoreSubmitInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferSubmitInfo::Builder& builder, VkCommandBufferSubmitInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setCommandBuffer(serialize_handle(member.commandBuffer));}();
[&](){return builder.setDeviceMask((member.deviceMask));}();
}

    VkCommandBufferSubmitInfo deserialize_struct(stream::VkCommandBufferSubmitInfo::Reader reader){
        auto result=VkCommandBufferSubmitInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.commandBuffer)=deserialize_VkCommandBuffer(reader.getCommandBuffer());}();
[&](){(result.deviceMask)=reader.getDeviceMask();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferSubmitInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferSubmitInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubmitInfo2::Builder& builder, VkSubmitInfo2 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setWaitSemaphoreInfoCount((member.waitSemaphoreInfoCount));}();
[&](){
            if ((member.pWaitSemaphoreInfos)==NULL){
                builder.initPWaitSemaphoreInfos(0);
            return; }
        auto proto_arr=builder.initPWaitSemaphoreInfos(member.waitSemaphoreInfoCount);
        for(int gGUzyVR=0; gGUzyVR < member.waitSemaphoreInfoCount; gGUzyVR++){
            [&](){
            auto temp=proto_arr[gGUzyVR];
            return serialize_struct(temp, ((member.pWaitSemaphoreInfos)[gGUzyVR]));
            }();
        }
        }();
[&](){return builder.setCommandBufferInfoCount((member.commandBufferInfoCount));}();
[&](){
            if ((member.pCommandBufferInfos)==NULL){
                builder.initPCommandBufferInfos(0);
            return; }
        auto proto_arr=builder.initPCommandBufferInfos(member.commandBufferInfoCount);
        for(int fzyXatx=0; fzyXatx < member.commandBufferInfoCount; fzyXatx++){
            [&](){
            auto temp=proto_arr[fzyXatx];
            return serialize_struct(temp, ((member.pCommandBufferInfos)[fzyXatx]));
            }();
        }
        }();
[&](){return builder.setSignalSemaphoreInfoCount((member.signalSemaphoreInfoCount));}();
[&](){
            if ((member.pSignalSemaphoreInfos)==NULL){
                builder.initPSignalSemaphoreInfos(0);
            return; }
        auto proto_arr=builder.initPSignalSemaphoreInfos(member.signalSemaphoreInfoCount);
        for(int UDwXunL=0; UDwXunL < member.signalSemaphoreInfoCount; UDwXunL++){
            [&](){
            auto temp=proto_arr[UDwXunL];
            return serialize_struct(temp, ((member.pSignalSemaphoreInfos)[UDwXunL]));
            }();
        }
        }();
}

    VkSubmitInfo2 deserialize_struct(stream::VkSubmitInfo2::Reader reader){
        auto result=VkSubmitInfo2();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.waitSemaphoreInfoCount)=reader.getWaitSemaphoreInfoCount();}();
[&](){ VkSemaphoreSubmitInfo* temp_cazotEN[&](){
            if (!reader.getPWaitSemaphoreInfos().size()==0){
                (result.pWaitSemaphoreInfos)=NULL;
            return; }{native_concat()}=(VkSemaphoreSubmitInfo*)malloc(result.waitSemaphoreInfoCount*sizeof(VkSemaphoreSubmitInfo));
        auto proto_arr=reader.getPWaitSemaphoreInfos(result.waitSemaphoreInfoCount);
        for(int ENNkfbt=0; ENNkfbt < result.waitSemaphoreInfoCount; ENNkfbt++){
            [&](){
            auto temp=proto_arr[ENNkfbt];
            ((result.pWaitSemaphoreInfos)[ENNkfbt])=deserialize_struct(temp);
            }();
        }
        }();(result.pWaitSemaphoreInfos)=temp_cazotEN;}();
[&](){(result.commandBufferInfoCount)=reader.getCommandBufferInfoCount();}();
[&](){ VkCommandBufferSubmitInfo* temp_rjjWTGb[&](){
            if (!reader.getPCommandBufferInfos().size()==0){
                (result.pCommandBufferInfos)=NULL;
            return; }{native_concat()}=(VkCommandBufferSubmitInfo*)malloc(result.commandBufferInfoCount*sizeof(VkCommandBufferSubmitInfo));
        auto proto_arr=reader.getPCommandBufferInfos(result.commandBufferInfoCount);
        for(int gNNiXEC=0; gNNiXEC < result.commandBufferInfoCount; gNNiXEC++){
            [&](){
            auto temp=proto_arr[gNNiXEC];
            ((result.pCommandBufferInfos)[gNNiXEC])=deserialize_struct(temp);
            }();
        }
        }();(result.pCommandBufferInfos)=temp_rjjWTGb;}();
[&](){(result.signalSemaphoreInfoCount)=reader.getSignalSemaphoreInfoCount();}();
[&](){ VkSemaphoreSubmitInfo* temp_jVoIWsZ[&](){
            if (!reader.getPSignalSemaphoreInfos().size()==0){
                (result.pSignalSemaphoreInfos)=NULL;
            return; }{native_concat()}=(VkSemaphoreSubmitInfo*)malloc(result.signalSemaphoreInfoCount*sizeof(VkSemaphoreSubmitInfo));
        auto proto_arr=reader.getPSignalSemaphoreInfos(result.signalSemaphoreInfoCount);
        for(int sLMGTGF=0; sLMGTGF < result.signalSemaphoreInfoCount; sLMGTGF++){
            [&](){
            auto temp=proto_arr[sLMGTGF];
            ((result.pSignalSemaphoreInfos)[sLMGTGF])=deserialize_struct(temp);
            }();
        }
        }();(result.pSignalSemaphoreInfos)=temp_jVoIWsZ;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubmitInfo2 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubmitInfo2 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueueFamilyCheckpointProperties2NV::Builder& builder, VkQueueFamilyCheckpointProperties2NV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCheckpointExecutionStageMask((member.checkpointExecutionStageMask));}();}();}();
}

    VkQueueFamilyCheckpointProperties2NV deserialize_struct(stream::VkQueueFamilyCheckpointProperties2NV::Reader reader){
        auto result=VkQueueFamilyCheckpointProperties2NV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.checkpointExecutionStageMask)=reader.getCheckpointExecutionStageMask();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueueFamilyCheckpointProperties2NV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueueFamilyCheckpointProperties2NV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCheckpointData2NV::Builder& builder, VkCheckpointData2NV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setStage((member.stage));}();}();}();
[&](){
            if ((member.pCheckpointMarker)==NULL){
                builder.initPCheckpointMarker(0);
            return; }[&](){
            if (((char*)(member.pCheckpointMarker).pCheckpointMarker)==NULL){
                builder.initPCheckpointMarker(0);
            return; }
        auto proto_arr=builder.initPCheckpointMarker(strlen(((char*)(member.pCheckpointMarker).pCheckpointMarker))+1);
        for(int ROoHiBu=0; ROoHiBu < strlen(((char*)(member.pCheckpointMarker).pCheckpointMarker))+1; ROoHiBu++){
            [&](){return proto_arr.set(ROoHiBu,(((char*)(member.pCheckpointMarker).pCheckpointMarker)[ROoHiBu]));}();
        }
        }();}();
}

    VkCheckpointData2NV deserialize_struct(stream::VkCheckpointData2NV::Reader reader){
        auto result=VkCheckpointData2NV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.stage)=reader.getStage();}();}();}();
[&](){
            if (!reader.getPCheckpointMarker().size()==0){
                (result.pCheckpointMarker)=NULL;
            return; }char* temp_PEjVDYf;[&](){
            if (!reader.getPCheckpointMarker().size()==0){
                (temp_PEjVDYf.pCheckpointMarker)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPCheckpointMarker().size();*sizeof(char));
        auto proto_arr=reader.getPCheckpointMarker(reader.getPCheckpointMarker().size(););
        for(int ROoHiBu=0; ROoHiBu < reader.getPCheckpointMarker().size();; ROoHiBu++){
            [&](){((temp_PEjVDYf.pCheckpointMarker)[ROoHiBu])=proto_arr[ROoHiBu];}();
        }
        }();(result.pCheckpointMarker)=temp_PEjVDYf;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCheckpointData2NV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCheckpointData2NV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSynchronization2Features::Builder& builder, VkPhysicalDeviceSynchronization2Features member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSynchronization2((member.synchronization2));}();}();
}

    VkPhysicalDeviceSynchronization2Features deserialize_struct(stream::VkPhysicalDeviceSynchronization2Features::Reader reader){
        auto result=VkPhysicalDeviceSynchronization2Features();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.synchronization2)=reader.getSynchronization2();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSynchronization2Features member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSynchronization2Features member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceHostImageCopyFeaturesEXT::Builder& builder, VkPhysicalDeviceHostImageCopyFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setHostImageCopy((member.hostImageCopy));}();}();
}

    VkPhysicalDeviceHostImageCopyFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceHostImageCopyFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceHostImageCopyFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.hostImageCopy)=reader.getHostImageCopy();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceHostImageCopyFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceHostImageCopyFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceHostImageCopyPropertiesEXT::Builder& builder, VkPhysicalDeviceHostImageCopyPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setCopySrcLayoutCount((member.copySrcLayoutCount));}();
[&](){
            if ((member.pCopySrcLayouts)==NULL){
                builder.initPCopySrcLayouts(0);
            return; }
        auto proto_arr=builder.initPCopySrcLayouts(member.copySrcLayoutCount);
        for(int Mkgnnkd=0; Mkgnnkd < member.copySrcLayoutCount; Mkgnnkd++){
            [&](){[&](){[&](){return proto_arr.set(Mkgnnkd,((member.pCopySrcLayouts)[Mkgnnkd]));}();}();}();
        }
        }();
[&](){return builder.setCopyDstLayoutCount((member.copyDstLayoutCount));}();
[&](){
            if ((member.pCopyDstLayouts)==NULL){
                builder.initPCopyDstLayouts(0);
            return; }
        auto proto_arr=builder.initPCopyDstLayouts(member.copyDstLayoutCount);
        for(int ynYdKwH=0; ynYdKwH < member.copyDstLayoutCount; ynYdKwH++){
            [&](){[&](){[&](){return proto_arr.set(ynYdKwH,((member.pCopyDstLayouts)[ynYdKwH]));}();}();}();
        }
        }();
[&](){
        auto proto_arr=builder.initOptimalTilingLayoutUUID(VK_UUID_SIZE);
        for(int rBEMEhH=0; rBEMEhH < VK_UUID_SIZE; rBEMEhH++){
            [&](){return proto_arr.set(rBEMEhH,((member.optimalTilingLayoutUUID)[rBEMEhH]));}();
        }
        }();
[&](){[&](){return builder.setIdenticalMemoryTypeRequirements((member.identicalMemoryTypeRequirements));}();}();
}

    VkPhysicalDeviceHostImageCopyPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceHostImageCopyPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceHostImageCopyPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.copySrcLayoutCount)=reader.getCopySrcLayoutCount();}();
[&](){
            if (!reader.getPCopySrcLayouts().size()==0){
                (result.pCopySrcLayouts)=NULL;
            return; }{native_concat()}=(VkImageLayout*)malloc(result.copySrcLayoutCount*sizeof(VkImageLayout));
        auto proto_arr=reader.getPCopySrcLayouts(result.copySrcLayoutCount);
        for(int Mkgnnkd=0; Mkgnnkd < result.copySrcLayoutCount; Mkgnnkd++){
            [&](){[&](){[&](){((result.pCopySrcLayouts)[Mkgnnkd])=proto_arr[Mkgnnkd];}();}();}();
        }
        }();
[&](){(result.copyDstLayoutCount)=reader.getCopyDstLayoutCount();}();
[&](){
            if (!reader.getPCopyDstLayouts().size()==0){
                (result.pCopyDstLayouts)=NULL;
            return; }{native_concat()}=(VkImageLayout*)malloc(result.copyDstLayoutCount*sizeof(VkImageLayout));
        auto proto_arr=reader.getPCopyDstLayouts(result.copyDstLayoutCount);
        for(int ynYdKwH=0; ynYdKwH < result.copyDstLayoutCount; ynYdKwH++){
            [&](){[&](){[&](){((result.pCopyDstLayouts)[ynYdKwH])=proto_arr[ynYdKwH];}();}();}();
        }
        }();
[&](){
        auto proto_arr=reader.getOptimalTilingLayoutUUID(VK_UUID_SIZE);
        for(int rBEMEhH=0; rBEMEhH < VK_UUID_SIZE; rBEMEhH++){
            [&](){((result.optimalTilingLayoutUUID)[rBEMEhH])=proto_arr[rBEMEhH];}();
        }
        }();
[&](){[&](){(result.identicalMemoryTypeRequirements)=reader.getIdenticalMemoryTypeRequirements();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceHostImageCopyPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceHostImageCopyPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryToImageCopyEXT::Builder& builder, VkMemoryToImageCopyEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pHostPointer)==NULL){
                builder.initPHostPointer(0);
            return; }[&](){
            if (((char*)(member.pHostPointer).pHostPointer)==NULL){
                builder.initPHostPointer(0);
            return; }
        auto proto_arr=builder.initPHostPointer(strlen(((char*)(member.pHostPointer).pHostPointer))+1);
        for(int MgtLJyk=0; MgtLJyk < strlen(((char*)(member.pHostPointer).pHostPointer))+1; MgtLJyk++){
            [&](){return proto_arr.set(MgtLJyk,(((char*)(member.pHostPointer).pHostPointer)[MgtLJyk]));}();
        }
        }();}();
[&](){return builder.setMemoryRowLength((member.memoryRowLength));}();
[&](){return builder.setMemoryImageHeight((member.memoryImageHeight));}();
[&](){
            auto temp=builder.initImageSubresource(imageSubresource);
            return serialize_struct(temp, (member.imageSubresource));
            }();
[&](){
            auto temp=builder.initImageOffset(imageOffset);
            return serialize_struct(temp, (member.imageOffset));
            }();
[&](){
            auto temp=builder.initImageExtent(imageExtent);
            return serialize_struct(temp, (member.imageExtent));
            }();
}

    VkMemoryToImageCopyEXT deserialize_struct(stream::VkMemoryToImageCopyEXT::Reader reader){
        auto result=VkMemoryToImageCopyEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ void* temp_rSssuyn[&](){
            if (!reader.getPHostPointer().size()==0){
                (result.pHostPointer)=NULL;
            return; }char* temp_hThmjkZ;[&](){
            if (!reader.getPHostPointer().size()==0){
                (temp_hThmjkZ.pHostPointer)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPHostPointer().size();*sizeof(char));
        auto proto_arr=reader.getPHostPointer(reader.getPHostPointer().size(););
        for(int PdKAgKO=0; PdKAgKO < reader.getPHostPointer().size();; PdKAgKO++){
            [&](){((temp_hThmjkZ.pHostPointer)[PdKAgKO])=proto_arr[PdKAgKO];}();
        }
        }();(result.pHostPointer)=temp_hThmjkZ;}();(result.pHostPointer)=temp_rSssuyn;}();
[&](){(result.memoryRowLength)=reader.getMemoryRowLength();}();
[&](){(result.memoryImageHeight)=reader.getMemoryImageHeight();}();
[&](){
            auto temp=reader.getImageSubresource();
            (result.imageSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageOffset();
            (result.imageOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageExtent();
            (result.imageExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryToImageCopyEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryToImageCopyEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageToMemoryCopyEXT::Builder& builder, VkImageToMemoryCopyEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pHostPointer)==NULL){
                builder.initPHostPointer(0);
            return; }[&](){
            if (((char*)(member.pHostPointer).pHostPointer)==NULL){
                builder.initPHostPointer(0);
            return; }
        auto proto_arr=builder.initPHostPointer(100000);
        for(int XfuwLTM=0; XfuwLTM < 100000; XfuwLTM++){
            [&](){return proto_arr.set(XfuwLTM,(((char*)(member.pHostPointer).pHostPointer)[XfuwLTM]));}();
        }
        }();}();
[&](){return builder.setMemoryRowLength((member.memoryRowLength));}();
[&](){return builder.setMemoryImageHeight((member.memoryImageHeight));}();
[&](){
            auto temp=builder.initImageSubresource(imageSubresource);
            return serialize_struct(temp, (member.imageSubresource));
            }();
[&](){
            auto temp=builder.initImageOffset(imageOffset);
            return serialize_struct(temp, (member.imageOffset));
            }();
[&](){
            auto temp=builder.initImageExtent(imageExtent);
            return serialize_struct(temp, (member.imageExtent));
            }();
}

    VkImageToMemoryCopyEXT deserialize_struct(stream::VkImageToMemoryCopyEXT::Reader reader){
        auto result=VkImageToMemoryCopyEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            if (!reader.getPHostPointer().size()==0){
                (result.pHostPointer)=NULL;
            return; }char* temp_dFikxRP;[&](){
            if (!reader.getPHostPointer().size()==0){
                (temp_dFikxRP.pHostPointer)=NULL;
            return; }{native_concat()}=(char*)malloc(100000*sizeof(char));
        auto proto_arr=reader.getPHostPointer(100000);
        for(int XfuwLTM=0; XfuwLTM < 100000; XfuwLTM++){
            [&](){((temp_dFikxRP.pHostPointer)[XfuwLTM])=proto_arr[XfuwLTM];}();
        }
        }();(result.pHostPointer)=temp_dFikxRP;}();
[&](){(result.memoryRowLength)=reader.getMemoryRowLength();}();
[&](){(result.memoryImageHeight)=reader.getMemoryImageHeight();}();
[&](){
            auto temp=reader.getImageSubresource();
            (result.imageSubresource)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageOffset();
            (result.imageOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageExtent();
            (result.imageExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageToMemoryCopyEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageToMemoryCopyEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyMemoryToImageInfoEXT::Builder& builder, VkCopyMemoryToImageInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setDstImage(serialize_handle(member.dstImage));}();
[&](){[&](){[&](){return builder.setDstImageLayout((member.dstImageLayout));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int FNfhlFN=0; FNfhlFN < member.regionCount; FNfhlFN++){
            [&](){
            auto temp=proto_arr[FNfhlFN];
            return serialize_struct(temp, ((member.pRegions)[FNfhlFN]));
            }();
        }
        }();
}

    VkCopyMemoryToImageInfoEXT deserialize_struct(stream::VkCopyMemoryToImageInfoEXT::Reader reader){
        auto result=VkCopyMemoryToImageInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.dstImage)=deserialize_VkImage(reader.getDstImage());}();
[&](){[&](){[&](){(result.dstImageLayout)=reader.getDstImageLayout();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkMemoryToImageCopyEXT* temp_qitPGkX[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkMemoryToImageCopyEXT*)malloc(result.regionCount*sizeof(VkMemoryToImageCopyEXT));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int yGaZjSW=0; yGaZjSW < result.regionCount; yGaZjSW++){
            [&](){
            auto temp=proto_arr[yGaZjSW];
            ((result.pRegions)[yGaZjSW])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_qitPGkX;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyMemoryToImageInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyMemoryToImageInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyImageToMemoryInfoEXT::Builder& builder, VkCopyImageToMemoryInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setSrcImage(serialize_handle(member.srcImage));}();
[&](){[&](){[&](){return builder.setSrcImageLayout((member.srcImageLayout));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int OCYScIs=0; OCYScIs < member.regionCount; OCYScIs++){
            [&](){
            auto temp=proto_arr[OCYScIs];
            return serialize_struct(temp, ((member.pRegions)[OCYScIs]));
            }();
        }
        }();
}

    VkCopyImageToMemoryInfoEXT deserialize_struct(stream::VkCopyImageToMemoryInfoEXT::Reader reader){
        auto result=VkCopyImageToMemoryInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.srcImage)=deserialize_VkImage(reader.getSrcImage());}();
[&](){[&](){[&](){(result.srcImageLayout)=reader.getSrcImageLayout();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkImageToMemoryCopyEXT* temp_xngjqoI[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkImageToMemoryCopyEXT*)malloc(result.regionCount*sizeof(VkImageToMemoryCopyEXT));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int LJBmGct=0; LJBmGct < result.regionCount; LJBmGct++){
            [&](){
            auto temp=proto_arr[LJBmGct];
            ((result.pRegions)[LJBmGct])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_xngjqoI;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyImageToMemoryInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyImageToMemoryInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyImageToImageInfoEXT::Builder& builder, VkCopyImageToImageInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setSrcImage(serialize_handle(member.srcImage));}();
[&](){[&](){[&](){return builder.setSrcImageLayout((member.srcImageLayout));}();}();}();
[&](){return builder.setDstImage(serialize_handle(member.dstImage));}();
[&](){[&](){[&](){return builder.setDstImageLayout((member.dstImageLayout));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int UKtqPyM=0; UKtqPyM < member.regionCount; UKtqPyM++){
            [&](){
            auto temp=proto_arr[UKtqPyM];
            return serialize_struct(temp, ((member.pRegions)[UKtqPyM]));
            }();
        }
        }();
}

    VkCopyImageToImageInfoEXT deserialize_struct(stream::VkCopyImageToImageInfoEXT::Reader reader){
        auto result=VkCopyImageToImageInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.srcImage)=deserialize_VkImage(reader.getSrcImage());}();
[&](){[&](){[&](){(result.srcImageLayout)=reader.getSrcImageLayout();}();}();}();
[&](){(result.dstImage)=deserialize_VkImage(reader.getDstImage());}();
[&](){[&](){[&](){(result.dstImageLayout)=reader.getDstImageLayout();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkImageCopy2* temp_mdeoncL[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkImageCopy2*)malloc(result.regionCount*sizeof(VkImageCopy2));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int RcpKxBk=0; RcpKxBk < result.regionCount; RcpKxBk++){
            [&](){
            auto temp=proto_arr[RcpKxBk];
            ((result.pRegions)[RcpKxBk])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_mdeoncL;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyImageToImageInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyImageToImageInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkHostImageLayoutTransitionInfoEXT::Builder& builder, VkHostImageLayoutTransitionInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImage(serialize_handle(member.image));}();
[&](){[&](){[&](){return builder.setOldLayout((member.oldLayout));}();}();}();
[&](){[&](){[&](){return builder.setNewLayout((member.newLayout));}();}();}();
[&](){
            auto temp=builder.initSubresourceRange(subresourceRange);
            return serialize_struct(temp, (member.subresourceRange));
            }();
}

    VkHostImageLayoutTransitionInfoEXT deserialize_struct(stream::VkHostImageLayoutTransitionInfoEXT::Reader reader){
        auto result=VkHostImageLayoutTransitionInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
[&](){[&](){[&](){(result.oldLayout)=reader.getOldLayout();}();}();}();
[&](){[&](){[&](){(result.newLayout)=reader.getNewLayout();}();}();}();
[&](){
            auto temp=reader.getSubresourceRange();
            (result.subresourceRange)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkHostImageLayoutTransitionInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkHostImageLayoutTransitionInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubresourceHostMemcpySizeEXT::Builder& builder, VkSubresourceHostMemcpySizeEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkSubresourceHostMemcpySizeEXT deserialize_struct(stream::VkSubresourceHostMemcpySizeEXT::Reader reader){
        auto result=VkSubresourceHostMemcpySizeEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubresourceHostMemcpySizeEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubresourceHostMemcpySizeEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkHostImageCopyDevicePerformanceQueryEXT::Builder& builder, VkHostImageCopyDevicePerformanceQueryEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setOptimalDeviceAccess((member.optimalDeviceAccess));}();}();
[&](){[&](){return builder.setIdenticalMemoryLayout((member.identicalMemoryLayout));}();}();
}

    VkHostImageCopyDevicePerformanceQueryEXT deserialize_struct(stream::VkHostImageCopyDevicePerformanceQueryEXT::Reader reader){
        auto result=VkHostImageCopyDevicePerformanceQueryEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.optimalDeviceAccess)=reader.getOptimalDeviceAccess();}();}();
[&](){[&](){(result.identicalMemoryLayout)=reader.getIdenticalMemoryLayout();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkHostImageCopyDevicePerformanceQueryEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkHostImageCopyDevicePerformanceQueryEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT::Builder& builder, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPrimitivesGeneratedQuery((member.primitivesGeneratedQuery));}();}();
[&](){[&](){return builder.setPrimitivesGeneratedQueryWithRasterizerDiscard((member.primitivesGeneratedQueryWithRasterizerDiscard));}();}();
[&](){[&](){return builder.setPrimitivesGeneratedQueryWithNonZeroStreams((member.primitivesGeneratedQueryWithNonZeroStreams));}();}();
}

    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT deserialize_struct(stream::VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.primitivesGeneratedQuery)=reader.getPrimitivesGeneratedQuery();}();}();
[&](){[&](){(result.primitivesGeneratedQueryWithRasterizerDiscard)=reader.getPrimitivesGeneratedQueryWithRasterizerDiscard();}();}();
[&](){[&](){(result.primitivesGeneratedQueryWithNonZeroStreams)=reader.getPrimitivesGeneratedQueryWithNonZeroStreams();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceLegacyDitheringFeaturesEXT::Builder& builder, VkPhysicalDeviceLegacyDitheringFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setLegacyDithering((member.legacyDithering));}();}();
}

    VkPhysicalDeviceLegacyDitheringFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceLegacyDitheringFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceLegacyDitheringFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.legacyDithering)=reader.getLegacyDithering();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceLegacyDitheringFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceLegacyDitheringFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT::Builder& builder, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMultisampledRenderToSingleSampled((member.multisampledRenderToSingleSampled));}();}();
}

    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.multisampledRenderToSingleSampled)=reader.getMultisampledRenderToSingleSampled();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubpassResolvePerformanceQueryEXT::Builder& builder, VkSubpassResolvePerformanceQueryEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setOptimal((member.optimal));}();}();
}

    VkSubpassResolvePerformanceQueryEXT deserialize_struct(stream::VkSubpassResolvePerformanceQueryEXT::Reader reader){
        auto result=VkSubpassResolvePerformanceQueryEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.optimal)=reader.getOptimal();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubpassResolvePerformanceQueryEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubpassResolvePerformanceQueryEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMultisampledRenderToSingleSampledInfoEXT::Builder& builder, VkMultisampledRenderToSingleSampledInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMultisampledRenderToSingleSampledEnable((member.multisampledRenderToSingleSampledEnable));}();}();
[&](){[&](){[&](){return builder.setRasterizationSamples((member.rasterizationSamples));}();}();}();
}

    VkMultisampledRenderToSingleSampledInfoEXT deserialize_struct(stream::VkMultisampledRenderToSingleSampledInfoEXT::Reader reader){
        auto result=VkMultisampledRenderToSingleSampledInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.multisampledRenderToSingleSampledEnable)=reader.getMultisampledRenderToSingleSampledEnable();}();}();
[&](){[&](){[&](){(result.rasterizationSamples)=reader.getRasterizationSamples();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMultisampledRenderToSingleSampledInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMultisampledRenderToSingleSampledInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePipelineProtectedAccessFeaturesEXT::Builder& builder, VkPhysicalDevicePipelineProtectedAccessFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPipelineProtectedAccess((member.pipelineProtectedAccess));}();}();
}

    VkPhysicalDevicePipelineProtectedAccessFeaturesEXT deserialize_struct(stream::VkPhysicalDevicePipelineProtectedAccessFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevicePipelineProtectedAccessFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pipelineProtectedAccess)=reader.getPipelineProtectedAccess();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePipelineProtectedAccessFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePipelineProtectedAccessFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueueFamilyVideoPropertiesKHR::Builder& builder, VkQueueFamilyVideoPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setVideoCodecOperations((member.videoCodecOperations));}();}();}();
}

    VkQueueFamilyVideoPropertiesKHR deserialize_struct(stream::VkQueueFamilyVideoPropertiesKHR::Reader reader){
        auto result=VkQueueFamilyVideoPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.videoCodecOperations)=reader.getVideoCodecOperations();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueueFamilyVideoPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueueFamilyVideoPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueueFamilyQueryResultStatusPropertiesKHR::Builder& builder, VkQueueFamilyQueryResultStatusPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setQueryResultStatusSupport((member.queryResultStatusSupport));}();}();
}

    VkQueueFamilyQueryResultStatusPropertiesKHR deserialize_struct(stream::VkQueueFamilyQueryResultStatusPropertiesKHR::Reader reader){
        auto result=VkQueueFamilyQueryResultStatusPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.queryResultStatusSupport)=reader.getQueryResultStatusSupport();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueueFamilyQueryResultStatusPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueueFamilyQueryResultStatusPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoProfileListInfoKHR::Builder& builder, VkVideoProfileListInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setProfileCount((member.profileCount));}();
[&](){
            if ((member.pProfiles)==NULL){
                builder.initPProfiles(0);
            return; }
        auto proto_arr=builder.initPProfiles(member.profileCount);
        for(int eTTbcXY=0; eTTbcXY < member.profileCount; eTTbcXY++){
            [&](){
            auto temp=proto_arr[eTTbcXY];
            return serialize_struct(temp, ((member.pProfiles)[eTTbcXY]));
            }();
        }
        }();
}

    VkVideoProfileListInfoKHR deserialize_struct(stream::VkVideoProfileListInfoKHR::Reader reader){
        auto result=VkVideoProfileListInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.profileCount)=reader.getProfileCount();}();
[&](){ VkVideoProfileInfoKHR* temp_UMuFnDv[&](){
            if (!reader.getPProfiles().size()==0){
                (result.pProfiles)=NULL;
            return; }{native_concat()}=(VkVideoProfileInfoKHR*)malloc(result.profileCount*sizeof(VkVideoProfileInfoKHR));
        auto proto_arr=reader.getPProfiles(result.profileCount);
        for(int keIVVNm=0; keIVVNm < result.profileCount; keIVVNm++){
            [&](){
            auto temp=proto_arr[keIVVNm];
            ((result.pProfiles)[keIVVNm])=deserialize_struct(temp);
            }();
        }
        }();(result.pProfiles)=temp_UMuFnDv;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoProfileListInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoProfileListInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceVideoFormatInfoKHR::Builder& builder, VkPhysicalDeviceVideoFormatInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setImageUsage((member.imageUsage));}();}();}();
}

    VkPhysicalDeviceVideoFormatInfoKHR deserialize_struct(stream::VkPhysicalDeviceVideoFormatInfoKHR::Reader reader){
        auto result=VkPhysicalDeviceVideoFormatInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.imageUsage)=reader.getImageUsage();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceVideoFormatInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceVideoFormatInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoFormatPropertiesKHR::Builder& builder, VkVideoFormatPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
[&](){
            auto temp=builder.initComponentMapping(componentMapping);
            return serialize_struct(temp, (member.componentMapping));
            }();
[&](){[&](){[&](){return builder.setImageCreateFlags((member.imageCreateFlags));}();}();}();
[&](){[&](){[&](){return builder.setImageType((member.imageType));}();}();}();
[&](){[&](){[&](){return builder.setImageTiling((member.imageTiling));}();}();}();
[&](){[&](){[&](){return builder.setImageUsageFlags((member.imageUsageFlags));}();}();}();
}

    VkVideoFormatPropertiesKHR deserialize_struct(stream::VkVideoFormatPropertiesKHR::Reader reader){
        auto result=VkVideoFormatPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
[&](){
            auto temp=reader.getComponentMapping();
            (result.componentMapping)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.imageCreateFlags)=reader.getImageCreateFlags();}();}();}();
[&](){[&](){[&](){(result.imageType)=reader.getImageType();}();}();}();
[&](){[&](){[&](){(result.imageTiling)=reader.getImageTiling();}();}();}();
[&](){[&](){[&](){(result.imageUsageFlags)=reader.getImageUsageFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoFormatPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoFormatPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoProfileInfoKHR::Builder& builder, VkVideoProfileInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setVideoCodecOperation((member.videoCodecOperation));}();}();}();
[&](){[&](){[&](){return builder.setChromaSubsampling((member.chromaSubsampling));}();}();}();
[&](){[&](){[&](){return builder.setLumaBitDepth((member.lumaBitDepth));}();}();}();
[&](){[&](){[&](){return builder.setChromaBitDepth((member.chromaBitDepth));}();}();}();
}

    VkVideoProfileInfoKHR deserialize_struct(stream::VkVideoProfileInfoKHR::Reader reader){
        auto result=VkVideoProfileInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.videoCodecOperation)=reader.getVideoCodecOperation();}();}();}();
[&](){[&](){[&](){(result.chromaSubsampling)=reader.getChromaSubsampling();}();}();}();
[&](){[&](){[&](){(result.lumaBitDepth)=reader.getLumaBitDepth();}();}();}();
[&](){[&](){[&](){(result.chromaBitDepth)=reader.getChromaBitDepth();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoProfileInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoProfileInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoCapabilitiesKHR::Builder& builder, VkVideoCapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setMinBitstreamBufferOffsetAlignment((member.minBitstreamBufferOffsetAlignment));}();}();
[&](){[&](){return builder.setMinBitstreamBufferSizeAlignment((member.minBitstreamBufferSizeAlignment));}();}();
[&](){
            auto temp=builder.initPictureAccessGranularity(pictureAccessGranularity);
            return serialize_struct(temp, (member.pictureAccessGranularity));
            }();
[&](){
            auto temp=builder.initMinCodedExtent(minCodedExtent);
            return serialize_struct(temp, (member.minCodedExtent));
            }();
[&](){
            auto temp=builder.initMaxCodedExtent(maxCodedExtent);
            return serialize_struct(temp, (member.maxCodedExtent));
            }();
[&](){return builder.setMaxDpbSlots((member.maxDpbSlots));}();
[&](){return builder.setMaxActiveReferencePictures((member.maxActiveReferencePictures));}();
[&](){
            auto temp=builder.initStdHeaderVersion(stdHeaderVersion);
            return serialize_struct(temp, (member.stdHeaderVersion));
            }();
}

    VkVideoCapabilitiesKHR deserialize_struct(stream::VkVideoCapabilitiesKHR::Reader reader){
        auto result=VkVideoCapabilitiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.minBitstreamBufferOffsetAlignment)=reader.getMinBitstreamBufferOffsetAlignment();}();}();
[&](){[&](){(result.minBitstreamBufferSizeAlignment)=reader.getMinBitstreamBufferSizeAlignment();}();}();
[&](){
            auto temp=reader.getPictureAccessGranularity();
            (result.pictureAccessGranularity)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMinCodedExtent();
            (result.minCodedExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxCodedExtent();
            (result.maxCodedExtent)=deserialize_struct(temp);
            }();
[&](){(result.maxDpbSlots)=reader.getMaxDpbSlots();}();
[&](){(result.maxActiveReferencePictures)=reader.getMaxActiveReferencePictures();}();
[&](){
            auto temp=reader.getStdHeaderVersion();
            (result.stdHeaderVersion)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoCapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoCapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoSessionMemoryRequirementsKHR::Builder& builder, VkVideoSessionMemoryRequirementsKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemoryBindIndex((member.memoryBindIndex));}();
[&](){
            auto temp=builder.initMemoryRequirements(memoryRequirements);
            return serialize_struct(temp, (member.memoryRequirements));
            }();
}

    VkVideoSessionMemoryRequirementsKHR deserialize_struct(stream::VkVideoSessionMemoryRequirementsKHR::Reader reader){
        auto result=VkVideoSessionMemoryRequirementsKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.memoryBindIndex)=reader.getMemoryBindIndex();}();
[&](){
            auto temp=reader.getMemoryRequirements();
            (result.memoryRequirements)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoSessionMemoryRequirementsKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoSessionMemoryRequirementsKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBindVideoSessionMemoryInfoKHR::Builder& builder, VkBindVideoSessionMemoryInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemoryBindIndex((member.memoryBindIndex));}();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setMemoryOffset((member.memoryOffset));}();}();
[&](){[&](){return builder.setMemorySize((member.memorySize));}();}();
}

    VkBindVideoSessionMemoryInfoKHR deserialize_struct(stream::VkBindVideoSessionMemoryInfoKHR::Reader reader){
        auto result=VkBindVideoSessionMemoryInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.memoryBindIndex)=reader.getMemoryBindIndex();}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.memoryOffset)=reader.getMemoryOffset();}();}();
[&](){[&](){(result.memorySize)=reader.getMemorySize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBindVideoSessionMemoryInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBindVideoSessionMemoryInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoPictureResourceInfoKHR::Builder& builder, VkVideoPictureResourceInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initCodedOffset(codedOffset);
            return serialize_struct(temp, (member.codedOffset));
            }();
[&](){
            auto temp=builder.initCodedExtent(codedExtent);
            return serialize_struct(temp, (member.codedExtent));
            }();
[&](){return builder.setBaseArrayLayer((member.baseArrayLayer));}();
[&](){return builder.setImageViewBinding(serialize_handle(member.imageViewBinding));}();
}

    VkVideoPictureResourceInfoKHR deserialize_struct(stream::VkVideoPictureResourceInfoKHR::Reader reader){
        auto result=VkVideoPictureResourceInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getCodedOffset();
            (result.codedOffset)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getCodedExtent();
            (result.codedExtent)=deserialize_struct(temp);
            }();
[&](){(result.baseArrayLayer)=reader.getBaseArrayLayer();}();
[&](){(result.imageViewBinding)=deserialize_VkImageView(reader.getImageViewBinding());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoPictureResourceInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoPictureResourceInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoReferenceSlotInfoKHR::Builder& builder, VkVideoReferenceSlotInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSlotIndex((member.slotIndex));}();
[&](){
            if ((member.pPictureResource)==NULL){
                builder.initPPictureResource(0);
            return; }
        auto proto_arr=builder.initPPictureResource(1);
        for(int evqJarY=0; evqJarY < 1; evqJarY++){
            [&](){
            auto temp=proto_arr[evqJarY];
            return serialize_struct(temp, ((member.pPictureResource)[evqJarY]));
            }();
        }
        }();
}

    VkVideoReferenceSlotInfoKHR deserialize_struct(stream::VkVideoReferenceSlotInfoKHR::Reader reader){
        auto result=VkVideoReferenceSlotInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.slotIndex)=reader.getSlotIndex();}();
[&](){ VkVideoPictureResourceInfoKHR* temp_RcpzVVQ[&](){
            if (!reader.getPPictureResource().size()==0){
                (result.pPictureResource)=NULL;
            return; }{native_concat()}=(VkVideoPictureResourceInfoKHR*)malloc(1*sizeof(VkVideoPictureResourceInfoKHR));
        auto proto_arr=reader.getPPictureResource(1);
        for(int WoaGUEX=0; WoaGUEX < 1; WoaGUEX++){
            [&](){
            auto temp=proto_arr[WoaGUEX];
            ((result.pPictureResource)[WoaGUEX])=deserialize_struct(temp);
            }();
        }
        }();(result.pPictureResource)=temp_RcpzVVQ;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoReferenceSlotInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoReferenceSlotInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeCapabilitiesKHR::Builder& builder, VkVideoDecodeCapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkVideoDecodeCapabilitiesKHR deserialize_struct(stream::VkVideoDecodeCapabilitiesKHR::Reader reader){
        auto result=VkVideoDecodeCapabilitiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeCapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeCapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeUsageInfoKHR::Builder& builder, VkVideoDecodeUsageInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setVideoUsageHints((member.videoUsageHints));}();}();}();
}

    VkVideoDecodeUsageInfoKHR deserialize_struct(stream::VkVideoDecodeUsageInfoKHR::Reader reader){
        auto result=VkVideoDecodeUsageInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.videoUsageHints)=reader.getVideoUsageHints();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeUsageInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeUsageInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeInfoKHR::Builder& builder, VkVideoDecodeInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setSrcBuffer(serialize_handle(member.srcBuffer));}();
[&](){[&](){return builder.setSrcBufferOffset((member.srcBufferOffset));}();}();
[&](){[&](){return builder.setSrcBufferRange((member.srcBufferRange));}();}();
[&](){
            auto temp=builder.initDstPictureResource(dstPictureResource);
            return serialize_struct(temp, (member.dstPictureResource));
            }();
[&](){
            if ((member.pSetupReferenceSlot)==NULL){
                builder.initPSetupReferenceSlot(0);
            return; }
        auto proto_arr=builder.initPSetupReferenceSlot(1);
        for(int MYiEGbW=0; MYiEGbW < 1; MYiEGbW++){
            [&](){
            auto temp=proto_arr[MYiEGbW];
            return serialize_struct(temp, ((member.pSetupReferenceSlot)[MYiEGbW]));
            }();
        }
        }();
[&](){return builder.setReferenceSlotCount((member.referenceSlotCount));}();
[&](){
            if ((member.pReferenceSlots)==NULL){
                builder.initPReferenceSlots(0);
            return; }
        auto proto_arr=builder.initPReferenceSlots(member.referenceSlotCount);
        for(int qhYgHtG=0; qhYgHtG < member.referenceSlotCount; qhYgHtG++){
            [&](){
            auto temp=proto_arr[qhYgHtG];
            return serialize_struct(temp, ((member.pReferenceSlots)[qhYgHtG]));
            }();
        }
        }();
}

    VkVideoDecodeInfoKHR deserialize_struct(stream::VkVideoDecodeInfoKHR::Reader reader){
        auto result=VkVideoDecodeInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.srcBuffer)=deserialize_VkBuffer(reader.getSrcBuffer());}();
[&](){[&](){(result.srcBufferOffset)=reader.getSrcBufferOffset();}();}();
[&](){[&](){(result.srcBufferRange)=reader.getSrcBufferRange();}();}();
[&](){
            auto temp=reader.getDstPictureResource();
            (result.dstPictureResource)=deserialize_struct(temp);
            }();
[&](){ VkVideoReferenceSlotInfoKHR* temp_gTPLFDJ[&](){
            if (!reader.getPSetupReferenceSlot().size()==0){
                (result.pSetupReferenceSlot)=NULL;
            return; }{native_concat()}=(VkVideoReferenceSlotInfoKHR*)malloc(1*sizeof(VkVideoReferenceSlotInfoKHR));
        auto proto_arr=reader.getPSetupReferenceSlot(1);
        for(int wXzHASH=0; wXzHASH < 1; wXzHASH++){
            [&](){
            auto temp=proto_arr[wXzHASH];
            ((result.pSetupReferenceSlot)[wXzHASH])=deserialize_struct(temp);
            }();
        }
        }();(result.pSetupReferenceSlot)=temp_gTPLFDJ;}();
[&](){(result.referenceSlotCount)=reader.getReferenceSlotCount();}();
[&](){ VkVideoReferenceSlotInfoKHR* temp_EbPkpwd[&](){
            if (!reader.getPReferenceSlots().size()==0){
                (result.pReferenceSlots)=NULL;
            return; }{native_concat()}=(VkVideoReferenceSlotInfoKHR*)malloc(result.referenceSlotCount*sizeof(VkVideoReferenceSlotInfoKHR));
        auto proto_arr=reader.getPReferenceSlots(result.referenceSlotCount);
        for(int fqLTYsR=0; fqLTYsR < result.referenceSlotCount; fqLTYsR++){
            [&](){
            auto temp=proto_arr[fqLTYsR];
            ((result.pReferenceSlots)[fqLTYsR])=deserialize_struct(temp);
            }();
        }
        }();(result.pReferenceSlots)=temp_EbPkpwd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH264ProfileInfoKHR::Builder& builder, VkVideoDecodeH264ProfileInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){builder.setStdProfileIdc((uintptr_t)(member.stdProfileIdc));}();
[&](){[&](){[&](){return builder.setPictureLayout((member.pictureLayout));}();}();}();
}

    VkVideoDecodeH264ProfileInfoKHR deserialize_struct(stream::VkVideoDecodeH264ProfileInfoKHR::Reader reader){
        auto result=VkVideoDecodeH264ProfileInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.stdProfileIdc)=(uintptr_t)reader.getStdProfileIdc();}();
[&](){[&](){[&](){(result.pictureLayout)=reader.getPictureLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH264ProfileInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH264ProfileInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH264CapabilitiesKHR::Builder& builder, VkVideoDecodeH264CapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){builder.setMaxLevelIdc((uintptr_t)(member.maxLevelIdc));}();
[&](){
            auto temp=builder.initFieldOffsetGranularity(fieldOffsetGranularity);
            return serialize_struct(temp, (member.fieldOffsetGranularity));
            }();
}

    VkVideoDecodeH264CapabilitiesKHR deserialize_struct(stream::VkVideoDecodeH264CapabilitiesKHR::Reader reader){
        auto result=VkVideoDecodeH264CapabilitiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxLevelIdc)=(uintptr_t)reader.getMaxLevelIdc();}();
[&](){
            auto temp=reader.getFieldOffsetGranularity();
            (result.fieldOffsetGranularity)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH264CapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH264CapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH264SessionParametersAddInfoKHR::Builder& builder, VkVideoDecodeH264SessionParametersAddInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setStdSPSCount((member.stdSPSCount));}();
[&](){
            if ((member.pStdSPSs)==NULL){
                builder.initPStdSPSs(0);
            return; }builder.setPStdSPSs((uintptr_t)(member.pStdSPSs));}();
[&](){return builder.setStdPPSCount((member.stdPPSCount));}();
[&](){
            if ((member.pStdPPSs)==NULL){
                builder.initPStdPPSs(0);
            return; }builder.setPStdPPSs((uintptr_t)(member.pStdPPSs));}();
}

    VkVideoDecodeH264SessionParametersAddInfoKHR deserialize_struct(stream::VkVideoDecodeH264SessionParametersAddInfoKHR::Reader reader){
        auto result=VkVideoDecodeH264SessionParametersAddInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.stdSPSCount)=reader.getStdSPSCount();}();
[&](){ StdVideoH264SequenceParameterSet* temp_dqnFfFo[&](){
            if (!reader.getPStdSPSs().size()==0){
                (result.pStdSPSs)=NULL;
            return; }(result.pStdSPSs)=(uintptr_t)reader.getPStdSPSs();}();(result.pStdSPSs)=temp_dqnFfFo;}();
[&](){(result.stdPPSCount)=reader.getStdPPSCount();}();
[&](){ StdVideoH264PictureParameterSet* temp_dYWGmCm[&](){
            if (!reader.getPStdPPSs().size()==0){
                (result.pStdPPSs)=NULL;
            return; }(result.pStdPPSs)=(uintptr_t)reader.getPStdPPSs();}();(result.pStdPPSs)=temp_dYWGmCm;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH264SessionParametersAddInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH264SessionParametersAddInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH264SessionParametersCreateInfoKHR::Builder& builder, VkVideoDecodeH264SessionParametersCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxStdSPSCount((member.maxStdSPSCount));}();
[&](){return builder.setMaxStdPPSCount((member.maxStdPPSCount));}();
[&](){
            if ((member.pParametersAddInfo)==NULL){
                builder.initPParametersAddInfo(0);
            return; }
        auto proto_arr=builder.initPParametersAddInfo(1);
        for(int zjiJYDr=0; zjiJYDr < 1; zjiJYDr++){
            [&](){
            auto temp=proto_arr[zjiJYDr];
            return serialize_struct(temp, ((member.pParametersAddInfo)[zjiJYDr]));
            }();
        }
        }();
}

    VkVideoDecodeH264SessionParametersCreateInfoKHR deserialize_struct(stream::VkVideoDecodeH264SessionParametersCreateInfoKHR::Reader reader){
        auto result=VkVideoDecodeH264SessionParametersCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.maxStdSPSCount)=reader.getMaxStdSPSCount();}();
[&](){(result.maxStdPPSCount)=reader.getMaxStdPPSCount();}();
[&](){ VkVideoDecodeH264SessionParametersAddInfoKHR* temp_WinEbhG[&](){
            if (!reader.getPParametersAddInfo().size()==0){
                (result.pParametersAddInfo)=NULL;
            return; }{native_concat()}=(VkVideoDecodeH264SessionParametersAddInfoKHR*)malloc(1*sizeof(VkVideoDecodeH264SessionParametersAddInfoKHR));
        auto proto_arr=reader.getPParametersAddInfo(1);
        for(int wOtWEgo=0; wOtWEgo < 1; wOtWEgo++){
            [&](){
            auto temp=proto_arr[wOtWEgo];
            ((result.pParametersAddInfo)[wOtWEgo])=deserialize_struct(temp);
            }();
        }
        }();(result.pParametersAddInfo)=temp_WinEbhG;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH264SessionParametersCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH264SessionParametersCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH264PictureInfoKHR::Builder& builder, VkVideoDecodeH264PictureInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pStdPictureInfo)==NULL){
                builder.initPStdPictureInfo(0);
            return; }builder.setPStdPictureInfo((uintptr_t)(member.pStdPictureInfo));}();
[&](){return builder.setSliceCount((member.sliceCount));}();
[&](){
            if ((member.pSliceOffsets)==NULL){
                builder.initPSliceOffsets(0);
            return; }
        auto proto_arr=builder.initPSliceOffsets(member.sliceCount);
        for(int EGgLcXn=0; EGgLcXn < member.sliceCount; EGgLcXn++){
            [&](){return proto_arr.set(EGgLcXn,((member.pSliceOffsets)[EGgLcXn]));}();
        }
        }();
}

    VkVideoDecodeH264PictureInfoKHR deserialize_struct(stream::VkVideoDecodeH264PictureInfoKHR::Reader reader){
        auto result=VkVideoDecodeH264PictureInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ StdVideoDecodeH264PictureInfo* temp_qpvDkWK[&](){
            if (!reader.getPStdPictureInfo().size()==0){
                (result.pStdPictureInfo)=NULL;
            return; }(result.pStdPictureInfo)=(uintptr_t)reader.getPStdPictureInfo();}();(result.pStdPictureInfo)=temp_qpvDkWK;}();
[&](){(result.sliceCount)=reader.getSliceCount();}();
[&](){ uint32_t* temp_iaNUVWb[&](){
            if (!reader.getPSliceOffsets().size()==0){
                (result.pSliceOffsets)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.sliceCount*sizeof(uint32_t));
        auto proto_arr=reader.getPSliceOffsets(result.sliceCount);
        for(int KicFNTx=0; KicFNTx < result.sliceCount; KicFNTx++){
            [&](){((result.pSliceOffsets)[KicFNTx])=proto_arr[KicFNTx];}();
        }
        }();(result.pSliceOffsets)=temp_iaNUVWb;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH264PictureInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH264PictureInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH264DpbSlotInfoKHR::Builder& builder, VkVideoDecodeH264DpbSlotInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pStdReferenceInfo)==NULL){
                builder.initPStdReferenceInfo(0);
            return; }builder.setPStdReferenceInfo((uintptr_t)(member.pStdReferenceInfo));}();
}

    VkVideoDecodeH264DpbSlotInfoKHR deserialize_struct(stream::VkVideoDecodeH264DpbSlotInfoKHR::Reader reader){
        auto result=VkVideoDecodeH264DpbSlotInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ StdVideoDecodeH264ReferenceInfo* temp_PbZvQmC[&](){
            if (!reader.getPStdReferenceInfo().size()==0){
                (result.pStdReferenceInfo)=NULL;
            return; }(result.pStdReferenceInfo)=(uintptr_t)reader.getPStdReferenceInfo();}();(result.pStdReferenceInfo)=temp_PbZvQmC;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH264DpbSlotInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH264DpbSlotInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH265ProfileInfoKHR::Builder& builder, VkVideoDecodeH265ProfileInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){builder.setStdProfileIdc((uintptr_t)(member.stdProfileIdc));}();
}

    VkVideoDecodeH265ProfileInfoKHR deserialize_struct(stream::VkVideoDecodeH265ProfileInfoKHR::Reader reader){
        auto result=VkVideoDecodeH265ProfileInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.stdProfileIdc)=(uintptr_t)reader.getStdProfileIdc();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH265ProfileInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH265ProfileInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH265CapabilitiesKHR::Builder& builder, VkVideoDecodeH265CapabilitiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){builder.setMaxLevelIdc((uintptr_t)(member.maxLevelIdc));}();
}

    VkVideoDecodeH265CapabilitiesKHR deserialize_struct(stream::VkVideoDecodeH265CapabilitiesKHR::Reader reader){
        auto result=VkVideoDecodeH265CapabilitiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxLevelIdc)=(uintptr_t)reader.getMaxLevelIdc();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH265CapabilitiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH265CapabilitiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH265SessionParametersAddInfoKHR::Builder& builder, VkVideoDecodeH265SessionParametersAddInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setStdVPSCount((member.stdVPSCount));}();
[&](){
            if ((member.pStdVPSs)==NULL){
                builder.initPStdVPSs(0);
            return; }builder.setPStdVPSs((uintptr_t)(member.pStdVPSs));}();
[&](){return builder.setStdSPSCount((member.stdSPSCount));}();
[&](){
            if ((member.pStdSPSs)==NULL){
                builder.initPStdSPSs(0);
            return; }builder.setPStdSPSs((uintptr_t)(member.pStdSPSs));}();
[&](){return builder.setStdPPSCount((member.stdPPSCount));}();
[&](){
            if ((member.pStdPPSs)==NULL){
                builder.initPStdPPSs(0);
            return; }builder.setPStdPPSs((uintptr_t)(member.pStdPPSs));}();
}

    VkVideoDecodeH265SessionParametersAddInfoKHR deserialize_struct(stream::VkVideoDecodeH265SessionParametersAddInfoKHR::Reader reader){
        auto result=VkVideoDecodeH265SessionParametersAddInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.stdVPSCount)=reader.getStdVPSCount();}();
[&](){ StdVideoH265VideoParameterSet* temp_naBOKnC[&](){
            if (!reader.getPStdVPSs().size()==0){
                (result.pStdVPSs)=NULL;
            return; }(result.pStdVPSs)=(uintptr_t)reader.getPStdVPSs();}();(result.pStdVPSs)=temp_naBOKnC;}();
[&](){(result.stdSPSCount)=reader.getStdSPSCount();}();
[&](){ StdVideoH265SequenceParameterSet* temp_eVfMKnS[&](){
            if (!reader.getPStdSPSs().size()==0){
                (result.pStdSPSs)=NULL;
            return; }(result.pStdSPSs)=(uintptr_t)reader.getPStdSPSs();}();(result.pStdSPSs)=temp_eVfMKnS;}();
[&](){(result.stdPPSCount)=reader.getStdPPSCount();}();
[&](){ StdVideoH265PictureParameterSet* temp_eYnhpbZ[&](){
            if (!reader.getPStdPPSs().size()==0){
                (result.pStdPPSs)=NULL;
            return; }(result.pStdPPSs)=(uintptr_t)reader.getPStdPPSs();}();(result.pStdPPSs)=temp_eYnhpbZ;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH265SessionParametersAddInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH265SessionParametersAddInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH265SessionParametersCreateInfoKHR::Builder& builder, VkVideoDecodeH265SessionParametersCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxStdVPSCount((member.maxStdVPSCount));}();
[&](){return builder.setMaxStdSPSCount((member.maxStdSPSCount));}();
[&](){return builder.setMaxStdPPSCount((member.maxStdPPSCount));}();
[&](){
            if ((member.pParametersAddInfo)==NULL){
                builder.initPParametersAddInfo(0);
            return; }
        auto proto_arr=builder.initPParametersAddInfo(1);
        for(int IoqzVQV=0; IoqzVQV < 1; IoqzVQV++){
            [&](){
            auto temp=proto_arr[IoqzVQV];
            return serialize_struct(temp, ((member.pParametersAddInfo)[IoqzVQV]));
            }();
        }
        }();
}

    VkVideoDecodeH265SessionParametersCreateInfoKHR deserialize_struct(stream::VkVideoDecodeH265SessionParametersCreateInfoKHR::Reader reader){
        auto result=VkVideoDecodeH265SessionParametersCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.maxStdVPSCount)=reader.getMaxStdVPSCount();}();
[&](){(result.maxStdSPSCount)=reader.getMaxStdSPSCount();}();
[&](){(result.maxStdPPSCount)=reader.getMaxStdPPSCount();}();
[&](){ VkVideoDecodeH265SessionParametersAddInfoKHR* temp_nDENJWV[&](){
            if (!reader.getPParametersAddInfo().size()==0){
                (result.pParametersAddInfo)=NULL;
            return; }{native_concat()}=(VkVideoDecodeH265SessionParametersAddInfoKHR*)malloc(1*sizeof(VkVideoDecodeH265SessionParametersAddInfoKHR));
        auto proto_arr=reader.getPParametersAddInfo(1);
        for(int SZNcaCU=0; SZNcaCU < 1; SZNcaCU++){
            [&](){
            auto temp=proto_arr[SZNcaCU];
            ((result.pParametersAddInfo)[SZNcaCU])=deserialize_struct(temp);
            }();
        }
        }();(result.pParametersAddInfo)=temp_nDENJWV;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH265SessionParametersCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH265SessionParametersCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH265PictureInfoKHR::Builder& builder, VkVideoDecodeH265PictureInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pStdPictureInfo)==NULL){
                builder.initPStdPictureInfo(0);
            return; }builder.setPStdPictureInfo((uintptr_t)(member.pStdPictureInfo));}();
[&](){return builder.setSliceSegmentCount((member.sliceSegmentCount));}();
[&](){
            if ((member.pSliceSegmentOffsets)==NULL){
                builder.initPSliceSegmentOffsets(0);
            return; }
        auto proto_arr=builder.initPSliceSegmentOffsets(member.sliceSegmentCount);
        for(int YXObous=0; YXObous < member.sliceSegmentCount; YXObous++){
            [&](){return proto_arr.set(YXObous,((member.pSliceSegmentOffsets)[YXObous]));}();
        }
        }();
}

    VkVideoDecodeH265PictureInfoKHR deserialize_struct(stream::VkVideoDecodeH265PictureInfoKHR::Reader reader){
        auto result=VkVideoDecodeH265PictureInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ StdVideoDecodeH265PictureInfo* temp_bcpKudK[&](){
            if (!reader.getPStdPictureInfo().size()==0){
                (result.pStdPictureInfo)=NULL;
            return; }(result.pStdPictureInfo)=(uintptr_t)reader.getPStdPictureInfo();}();(result.pStdPictureInfo)=temp_bcpKudK;}();
[&](){(result.sliceSegmentCount)=reader.getSliceSegmentCount();}();
[&](){ uint32_t* temp_sPLCWQo[&](){
            if (!reader.getPSliceSegmentOffsets().size()==0){
                (result.pSliceSegmentOffsets)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.sliceSegmentCount*sizeof(uint32_t));
        auto proto_arr=reader.getPSliceSegmentOffsets(result.sliceSegmentCount);
        for(int bIoEGZU=0; bIoEGZU < result.sliceSegmentCount; bIoEGZU++){
            [&](){((result.pSliceSegmentOffsets)[bIoEGZU])=proto_arr[bIoEGZU];}();
        }
        }();(result.pSliceSegmentOffsets)=temp_sPLCWQo;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH265PictureInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH265PictureInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoDecodeH265DpbSlotInfoKHR::Builder& builder, VkVideoDecodeH265DpbSlotInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pStdReferenceInfo)==NULL){
                builder.initPStdReferenceInfo(0);
            return; }builder.setPStdReferenceInfo((uintptr_t)(member.pStdReferenceInfo));}();
}

    VkVideoDecodeH265DpbSlotInfoKHR deserialize_struct(stream::VkVideoDecodeH265DpbSlotInfoKHR::Reader reader){
        auto result=VkVideoDecodeH265DpbSlotInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ StdVideoDecodeH265ReferenceInfo* temp_ZuBuGOK[&](){
            if (!reader.getPStdReferenceInfo().size()==0){
                (result.pStdReferenceInfo)=NULL;
            return; }(result.pStdReferenceInfo)=(uintptr_t)reader.getPStdReferenceInfo();}();(result.pStdReferenceInfo)=temp_ZuBuGOK;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoDecodeH265DpbSlotInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoDecodeH265DpbSlotInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoSessionCreateInfoKHR::Builder& builder, VkVideoSessionCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setQueueFamilyIndex((member.queueFamilyIndex));}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            if ((member.pVideoProfile)==NULL){
                builder.initPVideoProfile(0);
            return; }
        auto proto_arr=builder.initPVideoProfile(1);
        for(int bzdcboe=0; bzdcboe < 1; bzdcboe++){
            [&](){
            auto temp=proto_arr[bzdcboe];
            return serialize_struct(temp, ((member.pVideoProfile)[bzdcboe]));
            }();
        }
        }();
[&](){[&](){[&](){return builder.setPictureFormat((member.pictureFormat));}();}();}();
[&](){
            auto temp=builder.initMaxCodedExtent(maxCodedExtent);
            return serialize_struct(temp, (member.maxCodedExtent));
            }();
[&](){[&](){[&](){return builder.setReferencePictureFormat((member.referencePictureFormat));}();}();}();
[&](){return builder.setMaxDpbSlots((member.maxDpbSlots));}();
[&](){return builder.setMaxActiveReferencePictures((member.maxActiveReferencePictures));}();
[&](){
            if ((member.pStdHeaderVersion)==NULL){
                builder.initPStdHeaderVersion(0);
            return; }
        auto proto_arr=builder.initPStdHeaderVersion(1);
        for(int UonLNWm=0; UonLNWm < 1; UonLNWm++){
            [&](){
            auto temp=proto_arr[UonLNWm];
            return serialize_struct(temp, ((member.pStdHeaderVersion)[UonLNWm]));
            }();
        }
        }();
}

    VkVideoSessionCreateInfoKHR deserialize_struct(stream::VkVideoSessionCreateInfoKHR::Reader reader){
        auto result=VkVideoSessionCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.queueFamilyIndex)=reader.getQueueFamilyIndex();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){ VkVideoProfileInfoKHR* temp_CEmjoqs[&](){
            if (!reader.getPVideoProfile().size()==0){
                (result.pVideoProfile)=NULL;
            return; }{native_concat()}=(VkVideoProfileInfoKHR*)malloc(1*sizeof(VkVideoProfileInfoKHR));
        auto proto_arr=reader.getPVideoProfile(1);
        for(int SupZTTs=0; SupZTTs < 1; SupZTTs++){
            [&](){
            auto temp=proto_arr[SupZTTs];
            ((result.pVideoProfile)[SupZTTs])=deserialize_struct(temp);
            }();
        }
        }();(result.pVideoProfile)=temp_CEmjoqs;}();
[&](){[&](){[&](){(result.pictureFormat)=reader.getPictureFormat();}();}();}();
[&](){
            auto temp=reader.getMaxCodedExtent();
            (result.maxCodedExtent)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.referencePictureFormat)=reader.getReferencePictureFormat();}();}();}();
[&](){(result.maxDpbSlots)=reader.getMaxDpbSlots();}();
[&](){(result.maxActiveReferencePictures)=reader.getMaxActiveReferencePictures();}();
[&](){ VkExtensionProperties* temp_bgSJaQk[&](){
            if (!reader.getPStdHeaderVersion().size()==0){
                (result.pStdHeaderVersion)=NULL;
            return; }{native_concat()}=(VkExtensionProperties*)malloc(1*sizeof(VkExtensionProperties));
        auto proto_arr=reader.getPStdHeaderVersion(1);
        for(int AoXHhyO=0; AoXHhyO < 1; AoXHhyO++){
            [&](){
            auto temp=proto_arr[AoXHhyO];
            ((result.pStdHeaderVersion)[AoXHhyO])=deserialize_struct(temp);
            }();
        }
        }();(result.pStdHeaderVersion)=temp_bgSJaQk;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoSessionCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoSessionCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoSessionParametersCreateInfoKHR::Builder& builder, VkVideoSessionParametersCreateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setVideoSessionParametersTemplate(serialize_handle(member.videoSessionParametersTemplate));}();
[&](){return builder.setVideoSession(serialize_handle(member.videoSession));}();
}

    VkVideoSessionParametersCreateInfoKHR deserialize_struct(stream::VkVideoSessionParametersCreateInfoKHR::Reader reader){
        auto result=VkVideoSessionParametersCreateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.videoSessionParametersTemplate)=deserialize_VkVideoSessionParametersKHR(reader.getVideoSessionParametersTemplate());}();
[&](){(result.videoSession)=deserialize_VkVideoSessionKHR(reader.getVideoSession());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoSessionParametersCreateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoSessionParametersCreateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoSessionParametersUpdateInfoKHR::Builder& builder, VkVideoSessionParametersUpdateInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setUpdateSequenceCount((member.updateSequenceCount));}();
}

    VkVideoSessionParametersUpdateInfoKHR deserialize_struct(stream::VkVideoSessionParametersUpdateInfoKHR::Reader reader){
        auto result=VkVideoSessionParametersUpdateInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.updateSequenceCount)=reader.getUpdateSequenceCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoSessionParametersUpdateInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoSessionParametersUpdateInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoBeginCodingInfoKHR::Builder& builder, VkVideoBeginCodingInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setVideoSession(serialize_handle(member.videoSession));}();
[&](){return builder.setVideoSessionParameters(serialize_handle(member.videoSessionParameters));}();
[&](){return builder.setReferenceSlotCount((member.referenceSlotCount));}();
[&](){
            if ((member.pReferenceSlots)==NULL){
                builder.initPReferenceSlots(0);
            return; }
        auto proto_arr=builder.initPReferenceSlots(member.referenceSlotCount);
        for(int qhYgHtG=0; qhYgHtG < member.referenceSlotCount; qhYgHtG++){
            [&](){
            auto temp=proto_arr[qhYgHtG];
            return serialize_struct(temp, ((member.pReferenceSlots)[qhYgHtG]));
            }();
        }
        }();
}

    VkVideoBeginCodingInfoKHR deserialize_struct(stream::VkVideoBeginCodingInfoKHR::Reader reader){
        auto result=VkVideoBeginCodingInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.videoSession)=deserialize_VkVideoSessionKHR(reader.getVideoSession());}();
[&](){(result.videoSessionParameters)=deserialize_VkVideoSessionParametersKHR(reader.getVideoSessionParameters());}();
[&](){(result.referenceSlotCount)=reader.getReferenceSlotCount();}();
[&](){ VkVideoReferenceSlotInfoKHR* temp_EbPkpwd[&](){
            if (!reader.getPReferenceSlots().size()==0){
                (result.pReferenceSlots)=NULL;
            return; }{native_concat()}=(VkVideoReferenceSlotInfoKHR*)malloc(result.referenceSlotCount*sizeof(VkVideoReferenceSlotInfoKHR));
        auto proto_arr=reader.getPReferenceSlots(result.referenceSlotCount);
        for(int fqLTYsR=0; fqLTYsR < result.referenceSlotCount; fqLTYsR++){
            [&](){
            auto temp=proto_arr[fqLTYsR];
            ((result.pReferenceSlots)[fqLTYsR])=deserialize_struct(temp);
            }();
        }
        }();(result.pReferenceSlots)=temp_EbPkpwd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoBeginCodingInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoBeginCodingInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoEndCodingInfoKHR::Builder& builder, VkVideoEndCodingInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkVideoEndCodingInfoKHR deserialize_struct(stream::VkVideoEndCodingInfoKHR::Reader reader){
        auto result=VkVideoEndCodingInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoEndCodingInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoEndCodingInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkVideoCodingControlInfoKHR::Builder& builder, VkVideoCodingControlInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkVideoCodingControlInfoKHR deserialize_struct(stream::VkVideoCodingControlInfoKHR::Reader reader){
        auto result=VkVideoCodingControlInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkVideoCodingControlInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkVideoCodingControlInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceInheritedViewportScissorFeaturesNV::Builder& builder, VkPhysicalDeviceInheritedViewportScissorFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setInheritedViewportScissor2D((member.inheritedViewportScissor2D));}();}();
}

    VkPhysicalDeviceInheritedViewportScissorFeaturesNV deserialize_struct(stream::VkPhysicalDeviceInheritedViewportScissorFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceInheritedViewportScissorFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.inheritedViewportScissor2D)=reader.getInheritedViewportScissor2D();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceInheritedViewportScissorFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceInheritedViewportScissorFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferInheritanceViewportScissorInfoNV::Builder& builder, VkCommandBufferInheritanceViewportScissorInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setViewportScissor2D((member.viewportScissor2D));}();}();
[&](){return builder.setViewportDepthCount((member.viewportDepthCount));}();
[&](){
            if ((member.pViewportDepths)==NULL){
                builder.initPViewportDepths(0);
            return; }
        auto proto_arr=builder.initPViewportDepths(1);
        for(int KFySZWi=0; KFySZWi < 1; KFySZWi++){
            [&](){
            auto temp=proto_arr[KFySZWi];
            return serialize_struct(temp, ((member.pViewportDepths)[KFySZWi]));
            }();
        }
        }();
}

    VkCommandBufferInheritanceViewportScissorInfoNV deserialize_struct(stream::VkCommandBufferInheritanceViewportScissorInfoNV::Reader reader){
        auto result=VkCommandBufferInheritanceViewportScissorInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.viewportScissor2D)=reader.getViewportScissor2D();}();}();
[&](){(result.viewportDepthCount)=reader.getViewportDepthCount();}();
[&](){ VkViewport* temp_CRBZiiw[&](){
            if (!reader.getPViewportDepths().size()==0){
                (result.pViewportDepths)=NULL;
            return; }{native_concat()}=(VkViewport*)malloc(1*sizeof(VkViewport));
        auto proto_arr=reader.getPViewportDepths(1);
        for(int TlLmxhB=0; TlLmxhB < 1; TlLmxhB++){
            [&](){
            auto temp=proto_arr[TlLmxhB];
            ((result.pViewportDepths)[TlLmxhB])=deserialize_struct(temp);
            }();
        }
        }();(result.pViewportDepths)=temp_CRBZiiw;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferInheritanceViewportScissorInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferInheritanceViewportScissorInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::Builder& builder, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setYcbcr2plane444Formats((member.ycbcr2plane444Formats));}();}();
}

    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.ycbcr2plane444Formats)=reader.getYcbcr2plane444Formats();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceProvokingVertexFeaturesEXT::Builder& builder, VkPhysicalDeviceProvokingVertexFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setProvokingVertexLast((member.provokingVertexLast));}();}();
[&](){[&](){return builder.setTransformFeedbackPreservesProvokingVertex((member.transformFeedbackPreservesProvokingVertex));}();}();
}

    VkPhysicalDeviceProvokingVertexFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceProvokingVertexFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceProvokingVertexFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.provokingVertexLast)=reader.getProvokingVertexLast();}();}();
[&](){[&](){(result.transformFeedbackPreservesProvokingVertex)=reader.getTransformFeedbackPreservesProvokingVertex();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceProvokingVertexFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceProvokingVertexFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceProvokingVertexPropertiesEXT::Builder& builder, VkPhysicalDeviceProvokingVertexPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setProvokingVertexModePerPipeline((member.provokingVertexModePerPipeline));}();}();
[&](){[&](){return builder.setTransformFeedbackPreservesTriangleFanProvokingVertex((member.transformFeedbackPreservesTriangleFanProvokingVertex));}();}();
}

    VkPhysicalDeviceProvokingVertexPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceProvokingVertexPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceProvokingVertexPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.provokingVertexModePerPipeline)=reader.getProvokingVertexModePerPipeline();}();}();
[&](){[&](){(result.transformFeedbackPreservesTriangleFanProvokingVertex)=reader.getTransformFeedbackPreservesTriangleFanProvokingVertex();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceProvokingVertexPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceProvokingVertexPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRasterizationProvokingVertexStateCreateInfoEXT::Builder& builder, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setProvokingVertexMode((member.provokingVertexMode));}();}();}();
}

    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT deserialize_struct(stream::VkPipelineRasterizationProvokingVertexStateCreateInfoEXT::Reader reader){
        auto result=VkPipelineRasterizationProvokingVertexStateCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.provokingVertexMode)=reader.getProvokingVertexMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRasterizationProvokingVertexStateCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCuModuleCreateInfoNVX::Builder& builder, VkCuModuleCreateInfoNVX member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDataSize((member.dataSize));}();
[&](){
            if ((member.pData)==NULL){
                builder.initPData(0);
            return; }[&](){
            if (((char*)(member.pData).pData)==NULL){
                builder.initPData(0);
            return; }
        auto proto_arr=builder.initPData(member.dataSize);
        for(int KUeyATI=0; KUeyATI < member.dataSize; KUeyATI++){
            [&](){return proto_arr.set(KUeyATI,(((char*)(member.pData).pData)[KUeyATI]));}();
        }
        }();}();
}

    VkCuModuleCreateInfoNVX deserialize_struct(stream::VkCuModuleCreateInfoNVX::Reader reader){
        auto result=VkCuModuleCreateInfoNVX();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.dataSize)=reader.getDataSize();}();
[&](){ void* temp_RUIzmiy[&](){
            if (!reader.getPData().size()==0){
                (result.pData)=NULL;
            return; }char* temp_KoPqpjZ;[&](){
            if (!reader.getPData().size()==0){
                (temp_KoPqpjZ.pData)=NULL;
            return; }{native_concat()}=(char*)malloc(result.dataSize*sizeof(char));
        auto proto_arr=reader.getPData(result.dataSize);
        for(int OCmuZGI=0; OCmuZGI < result.dataSize; OCmuZGI++){
            [&](){((temp_KoPqpjZ.pData)[OCmuZGI])=proto_arr[OCmuZGI];}();
        }
        }();(result.pData)=temp_KoPqpjZ;}();(result.pData)=temp_RUIzmiy;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCuModuleCreateInfoNVX member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCuModuleCreateInfoNVX member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCuFunctionCreateInfoNVX::Builder& builder, VkCuFunctionCreateInfoNVX member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setModule(serialize_handle(member.module));}();
[&](){
            if ((member.pName)==NULL){
                builder.initPName(0);
            return; }
        auto proto_arr=builder.initPName(strlen((member.pName))+1);
        for(int opTkazg=0; opTkazg < strlen((member.pName))+1; opTkazg++){
            [&](){return proto_arr.set(opTkazg,((member.pName)[opTkazg]));}();
        }
        }();
}

    VkCuFunctionCreateInfoNVX deserialize_struct(stream::VkCuFunctionCreateInfoNVX::Reader reader){
        auto result=VkCuFunctionCreateInfoNVX();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.module)=deserialize_VkCuModuleNVX(reader.getModule());}();
[&](){ char* temp_xDKNBiw[&](){
            if (!reader.getPName().size()==0){
                (result.pName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPName().size();*sizeof(char));
        auto proto_arr=reader.getPName(reader.getPName().size(););
        for(int zzMOHXu=0; zzMOHXu < reader.getPName().size();; zzMOHXu++){
            [&](){((result.pName)[zzMOHXu])=proto_arr[zzMOHXu];}();
        }
        }();(result.pName)=temp_xDKNBiw;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCuFunctionCreateInfoNVX member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCuFunctionCreateInfoNVX member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCuLaunchInfoNVX::Builder& builder, VkCuLaunchInfoNVX member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setFunction(serialize_handle(member.function));}();
[&](){return builder.setGridDimX((member.gridDimX));}();
[&](){return builder.setGridDimY((member.gridDimY));}();
[&](){return builder.setGridDimZ((member.gridDimZ));}();
[&](){return builder.setBlockDimX((member.blockDimX));}();
[&](){return builder.setBlockDimY((member.blockDimY));}();
[&](){return builder.setBlockDimZ((member.blockDimZ));}();
[&](){return builder.setSharedMemBytes((member.sharedMemBytes));}();
[&](){return builder.setParamCount((member.paramCount));}();
[&](){
            if ((member.pParams)==NULL){
                builder.initPParams(0);
            return; }
        auto proto_arr=builder.initPParams(member.paramCount);
        for(int bHZRMGd=0; bHZRMGd < member.paramCount; bHZRMGd++){
            [&](){
            if (((member.pParams)[bHZRMGd])==NULL){
                proto_arr[bHZRMGd];
            return; }[&](){
            if (((char*)((member.pParams)[bHZRMGd])[bHZRMGd])==NULL){
                proto_arr.init(bHZRMGd,0);
            return; }
        auto proto_arr=proto_arr[bHZRMGd];
        for(int sDEDPvj=0; sDEDPvj < strlen(((char*)((member.pParams)[bHZRMGd])[bHZRMGd]))+1; sDEDPvj++){
            [&](){return proto_arr.set(sDEDPvj,(((char*)((member.pParams)[bHZRMGd])[bHZRMGd])[sDEDPvj]));}();
        }
        }();}();
        }
        }();
[&](){return builder.setExtraCount((member.extraCount));}();
[&](){
            if ((member.pExtras)==NULL){
                builder.initPExtras(0);
            return; }
        auto proto_arr=builder.initPExtras(member.extraCount);
        for(int qZYmIyj=0; qZYmIyj < member.extraCount; qZYmIyj++){
            [&](){
            if (((member.pExtras)[qZYmIyj])==NULL){
                proto_arr[qZYmIyj];
            return; }[&](){
            if (((char*)((member.pExtras)[qZYmIyj])[qZYmIyj])==NULL){
                proto_arr.init(qZYmIyj,0);
            return; }
        auto proto_arr=proto_arr[qZYmIyj];
        for(int MSLRWeC=0; MSLRWeC < strlen(((char*)((member.pExtras)[qZYmIyj])[qZYmIyj]))+1; MSLRWeC++){
            [&](){return proto_arr.set(MSLRWeC,(((char*)((member.pExtras)[qZYmIyj])[qZYmIyj])[MSLRWeC]));}();
        }
        }();}();
        }
        }();
}

    VkCuLaunchInfoNVX deserialize_struct(stream::VkCuLaunchInfoNVX::Reader reader){
        auto result=VkCuLaunchInfoNVX();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.function)=deserialize_VkCuFunctionNVX(reader.getFunction());}();
[&](){(result.gridDimX)=reader.getGridDimX();}();
[&](){(result.gridDimY)=reader.getGridDimY();}();
[&](){(result.gridDimZ)=reader.getGridDimZ();}();
[&](){(result.blockDimX)=reader.getBlockDimX();}();
[&](){(result.blockDimY)=reader.getBlockDimY();}();
[&](){(result.blockDimZ)=reader.getBlockDimZ();}();
[&](){(result.sharedMemBytes)=reader.getSharedMemBytes();}();
[&](){(result.paramCount)=reader.getParamCount();}();
[&](){ void*  * temp_JgSRbZl[&](){
            if (!reader.getPParams().size()==0){
                (result.pParams)=NULL;
            return; }{native_concat()}=(void**)malloc(result.paramCount*sizeof(void*));
        auto proto_arr=reader.getPParams(result.paramCount);
        for(int cDEiPBr=0; cDEiPBr < result.paramCount; cDEiPBr++){
            [&](){
            if (!proto_arr[cDEiPBr].size()==0){
                ((result.pParams)[cDEiPBr])=NULL;
            return; }char* temp_ilfkVLB;[&](){
            if (!proto_arr[cDEiPBr].size()==0){
                (temp_ilfkVLB[cDEiPBr])=NULL;
            return; }{native_concat()}=(char*)malloc(proto_arr[cDEiPBr].size();*sizeof(char));
        auto proto_arr=proto_arr[cDEiPBr];
        for(int JdATHGc=0; JdATHGc < proto_arr[cDEiPBr].size();; JdATHGc++){
            [&](){((temp_ilfkVLB[cDEiPBr])[JdATHGc])=proto_arr[JdATHGc];}();
        }
        }();((result.pParams)[cDEiPBr])=temp_ilfkVLB;}();
        }
        }();(result.pParams)=temp_JgSRbZl;}();
[&](){(result.extraCount)=reader.getExtraCount();}();
[&](){ void*  * temp_uZgtcph[&](){
            if (!reader.getPExtras().size()==0){
                (result.pExtras)=NULL;
            return; }{native_concat()}=(void**)malloc(result.extraCount*sizeof(void*));
        auto proto_arr=reader.getPExtras(result.extraCount);
        for(int NqvQMTa=0; NqvQMTa < result.extraCount; NqvQMTa++){
            [&](){
            if (!proto_arr[NqvQMTa].size()==0){
                ((result.pExtras)[NqvQMTa])=NULL;
            return; }char* temp_pfmICcn;[&](){
            if (!proto_arr[NqvQMTa].size()==0){
                (temp_pfmICcn[NqvQMTa])=NULL;
            return; }{native_concat()}=(char*)malloc(proto_arr[NqvQMTa].size();*sizeof(char));
        auto proto_arr=proto_arr[NqvQMTa];
        for(int jWwSwFD=0; jWwSwFD < proto_arr[NqvQMTa].size();; jWwSwFD++){
            [&](){((temp_pfmICcn[NqvQMTa])[jWwSwFD])=proto_arr[jWwSwFD];}();
        }
        }();((result.pExtras)[NqvQMTa])=temp_pfmICcn;}();
        }
        }();(result.pExtras)=temp_uZgtcph;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCuLaunchInfoNVX member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCuLaunchInfoNVX member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDescriptorBufferFeaturesEXT::Builder& builder, VkPhysicalDeviceDescriptorBufferFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDescriptorBuffer((member.descriptorBuffer));}();}();
[&](){[&](){return builder.setDescriptorBufferCaptureReplay((member.descriptorBufferCaptureReplay));}();}();
[&](){[&](){return builder.setDescriptorBufferImageLayoutIgnored((member.descriptorBufferImageLayoutIgnored));}();}();
[&](){[&](){return builder.setDescriptorBufferPushDescriptors((member.descriptorBufferPushDescriptors));}();}();
}

    VkPhysicalDeviceDescriptorBufferFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceDescriptorBufferFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceDescriptorBufferFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.descriptorBuffer)=reader.getDescriptorBuffer();}();}();
[&](){[&](){(result.descriptorBufferCaptureReplay)=reader.getDescriptorBufferCaptureReplay();}();}();
[&](){[&](){(result.descriptorBufferImageLayoutIgnored)=reader.getDescriptorBufferImageLayoutIgnored();}();}();
[&](){[&](){(result.descriptorBufferPushDescriptors)=reader.getDescriptorBufferPushDescriptors();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDescriptorBufferFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDescriptorBufferFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDescriptorBufferPropertiesEXT::Builder& builder, VkPhysicalDeviceDescriptorBufferPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCombinedImageSamplerDescriptorSingleArray((member.combinedImageSamplerDescriptorSingleArray));}();}();
[&](){[&](){return builder.setBufferlessPushDescriptors((member.bufferlessPushDescriptors));}();}();
[&](){[&](){return builder.setAllowSamplerImageViewPostSubmitCreation((member.allowSamplerImageViewPostSubmitCreation));}();}();
[&](){[&](){return builder.setDescriptorBufferOffsetAlignment((member.descriptorBufferOffsetAlignment));}();}();
[&](){return builder.setMaxDescriptorBufferBindings((member.maxDescriptorBufferBindings));}();
[&](){return builder.setMaxResourceDescriptorBufferBindings((member.maxResourceDescriptorBufferBindings));}();
[&](){return builder.setMaxSamplerDescriptorBufferBindings((member.maxSamplerDescriptorBufferBindings));}();
[&](){return builder.setMaxEmbeddedImmutableSamplerBindings((member.maxEmbeddedImmutableSamplerBindings));}();
[&](){return builder.setMaxEmbeddedImmutableSamplers((member.maxEmbeddedImmutableSamplers));}();
[&](){return builder.setBufferCaptureReplayDescriptorDataSize((member.bufferCaptureReplayDescriptorDataSize));}();
[&](){return builder.setImageCaptureReplayDescriptorDataSize((member.imageCaptureReplayDescriptorDataSize));}();
[&](){return builder.setImageViewCaptureReplayDescriptorDataSize((member.imageViewCaptureReplayDescriptorDataSize));}();
[&](){return builder.setSamplerCaptureReplayDescriptorDataSize((member.samplerCaptureReplayDescriptorDataSize));}();
[&](){return builder.setAccelerationStructureCaptureReplayDescriptorDataSize((member.accelerationStructureCaptureReplayDescriptorDataSize));}();
[&](){return builder.setSamplerDescriptorSize((member.samplerDescriptorSize));}();
[&](){return builder.setCombinedImageSamplerDescriptorSize((member.combinedImageSamplerDescriptorSize));}();
[&](){return builder.setSampledImageDescriptorSize((member.sampledImageDescriptorSize));}();
[&](){return builder.setStorageImageDescriptorSize((member.storageImageDescriptorSize));}();
[&](){return builder.setUniformTexelBufferDescriptorSize((member.uniformTexelBufferDescriptorSize));}();
[&](){return builder.setRobustUniformTexelBufferDescriptorSize((member.robustUniformTexelBufferDescriptorSize));}();
[&](){return builder.setStorageTexelBufferDescriptorSize((member.storageTexelBufferDescriptorSize));}();
[&](){return builder.setRobustStorageTexelBufferDescriptorSize((member.robustStorageTexelBufferDescriptorSize));}();
[&](){return builder.setUniformBufferDescriptorSize((member.uniformBufferDescriptorSize));}();
[&](){return builder.setRobustUniformBufferDescriptorSize((member.robustUniformBufferDescriptorSize));}();
[&](){return builder.setStorageBufferDescriptorSize((member.storageBufferDescriptorSize));}();
[&](){return builder.setRobustStorageBufferDescriptorSize((member.robustStorageBufferDescriptorSize));}();
[&](){return builder.setInputAttachmentDescriptorSize((member.inputAttachmentDescriptorSize));}();
[&](){return builder.setAccelerationStructureDescriptorSize((member.accelerationStructureDescriptorSize));}();
[&](){[&](){return builder.setMaxSamplerDescriptorBufferRange((member.maxSamplerDescriptorBufferRange));}();}();
[&](){[&](){return builder.setMaxResourceDescriptorBufferRange((member.maxResourceDescriptorBufferRange));}();}();
[&](){[&](){return builder.setSamplerDescriptorBufferAddressSpaceSize((member.samplerDescriptorBufferAddressSpaceSize));}();}();
[&](){[&](){return builder.setResourceDescriptorBufferAddressSpaceSize((member.resourceDescriptorBufferAddressSpaceSize));}();}();
[&](){[&](){return builder.setDescriptorBufferAddressSpaceSize((member.descriptorBufferAddressSpaceSize));}();}();
}

    VkPhysicalDeviceDescriptorBufferPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceDescriptorBufferPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceDescriptorBufferPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.combinedImageSamplerDescriptorSingleArray)=reader.getCombinedImageSamplerDescriptorSingleArray();}();}();
[&](){[&](){(result.bufferlessPushDescriptors)=reader.getBufferlessPushDescriptors();}();}();
[&](){[&](){(result.allowSamplerImageViewPostSubmitCreation)=reader.getAllowSamplerImageViewPostSubmitCreation();}();}();
[&](){[&](){(result.descriptorBufferOffsetAlignment)=reader.getDescriptorBufferOffsetAlignment();}();}();
[&](){(result.maxDescriptorBufferBindings)=reader.getMaxDescriptorBufferBindings();}();
[&](){(result.maxResourceDescriptorBufferBindings)=reader.getMaxResourceDescriptorBufferBindings();}();
[&](){(result.maxSamplerDescriptorBufferBindings)=reader.getMaxSamplerDescriptorBufferBindings();}();
[&](){(result.maxEmbeddedImmutableSamplerBindings)=reader.getMaxEmbeddedImmutableSamplerBindings();}();
[&](){(result.maxEmbeddedImmutableSamplers)=reader.getMaxEmbeddedImmutableSamplers();}();
[&](){(result.bufferCaptureReplayDescriptorDataSize)=reader.getBufferCaptureReplayDescriptorDataSize();}();
[&](){(result.imageCaptureReplayDescriptorDataSize)=reader.getImageCaptureReplayDescriptorDataSize();}();
[&](){(result.imageViewCaptureReplayDescriptorDataSize)=reader.getImageViewCaptureReplayDescriptorDataSize();}();
[&](){(result.samplerCaptureReplayDescriptorDataSize)=reader.getSamplerCaptureReplayDescriptorDataSize();}();
[&](){(result.accelerationStructureCaptureReplayDescriptorDataSize)=reader.getAccelerationStructureCaptureReplayDescriptorDataSize();}();
[&](){(result.samplerDescriptorSize)=reader.getSamplerDescriptorSize();}();
[&](){(result.combinedImageSamplerDescriptorSize)=reader.getCombinedImageSamplerDescriptorSize();}();
[&](){(result.sampledImageDescriptorSize)=reader.getSampledImageDescriptorSize();}();
[&](){(result.storageImageDescriptorSize)=reader.getStorageImageDescriptorSize();}();
[&](){(result.uniformTexelBufferDescriptorSize)=reader.getUniformTexelBufferDescriptorSize();}();
[&](){(result.robustUniformTexelBufferDescriptorSize)=reader.getRobustUniformTexelBufferDescriptorSize();}();
[&](){(result.storageTexelBufferDescriptorSize)=reader.getStorageTexelBufferDescriptorSize();}();
[&](){(result.robustStorageTexelBufferDescriptorSize)=reader.getRobustStorageTexelBufferDescriptorSize();}();
[&](){(result.uniformBufferDescriptorSize)=reader.getUniformBufferDescriptorSize();}();
[&](){(result.robustUniformBufferDescriptorSize)=reader.getRobustUniformBufferDescriptorSize();}();
[&](){(result.storageBufferDescriptorSize)=reader.getStorageBufferDescriptorSize();}();
[&](){(result.robustStorageBufferDescriptorSize)=reader.getRobustStorageBufferDescriptorSize();}();
[&](){(result.inputAttachmentDescriptorSize)=reader.getInputAttachmentDescriptorSize();}();
[&](){(result.accelerationStructureDescriptorSize)=reader.getAccelerationStructureDescriptorSize();}();
[&](){[&](){(result.maxSamplerDescriptorBufferRange)=reader.getMaxSamplerDescriptorBufferRange();}();}();
[&](){[&](){(result.maxResourceDescriptorBufferRange)=reader.getMaxResourceDescriptorBufferRange();}();}();
[&](){[&](){(result.samplerDescriptorBufferAddressSpaceSize)=reader.getSamplerDescriptorBufferAddressSpaceSize();}();}();
[&](){[&](){(result.resourceDescriptorBufferAddressSpaceSize)=reader.getResourceDescriptorBufferAddressSpaceSize();}();}();
[&](){[&](){(result.descriptorBufferAddressSpaceSize)=reader.getDescriptorBufferAddressSpaceSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDescriptorBufferPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDescriptorBufferPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::Builder& builder, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setCombinedImageSamplerDensityMapDescriptorSize((member.combinedImageSamplerDensityMapDescriptorSize));}();
}

    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.combinedImageSamplerDensityMapDescriptorSize)=reader.getCombinedImageSamplerDensityMapDescriptorSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorAddressInfoEXT::Builder& builder, VkDescriptorAddressInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAddress((member.address));}();}();
[&](){[&](){return builder.setRange((member.range));}();}();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
}

    VkDescriptorAddressInfoEXT deserialize_struct(stream::VkDescriptorAddressInfoEXT::Reader reader){
        auto result=VkDescriptorAddressInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.address)=reader.getAddress();}();}();
[&](){[&](){(result.range)=reader.getRange();}();}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorAddressInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorAddressInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorBufferBindingInfoEXT::Builder& builder, VkDescriptorBufferBindingInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAddress((member.address));}();}();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
}

    VkDescriptorBufferBindingInfoEXT deserialize_struct(stream::VkDescriptorBufferBindingInfoEXT::Reader reader){
        auto result=VkDescriptorBufferBindingInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.address)=reader.getAddress();}();}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorBufferBindingInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorBufferBindingInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorBufferBindingPushDescriptorBufferHandleEXT::Builder& builder, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
}

    VkDescriptorBufferBindingPushDescriptorBufferHandleEXT deserialize_struct(stream::VkDescriptorBufferBindingPushDescriptorBufferHandleEXT::Reader reader){
        auto result=VkDescriptorBufferBindingPushDescriptorBufferHandleEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorBufferBindingPushDescriptorBufferHandleEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorDataEXT::Builder& builder, VkDescriptorDataEXT member){
        
    
[&](){
            if ((member.pSampler)==NULL){
                builder.initPSampler(0);
            return; }
        auto proto_arr=builder.initPSampler(1);
        for(int RcemeEi=0; RcemeEi < 1; RcemeEi++){
            [&](){return proto_arr.set(RcemeEi,serialize_handle((member.pSampler)[RcemeEi]));}();
        }
        }();
[&](){
            if ((member.pCombinedImageSampler)==NULL){
                builder.initPCombinedImageSampler(0);
            return; }
        auto proto_arr=builder.initPCombinedImageSampler(1);
        for(int bIddDFU=0; bIddDFU < 1; bIddDFU++){
            [&](){
            auto temp=proto_arr[bIddDFU];
            return serialize_struct(temp, ((member.pCombinedImageSampler)[bIddDFU]));
            }();
        }
        }();
[&](){
            if ((member.pInputAttachmentImage)==NULL){
                builder.initPInputAttachmentImage(0);
            return; }
        auto proto_arr=builder.initPInputAttachmentImage(1);
        for(int XGpUdoM=0; XGpUdoM < 1; XGpUdoM++){
            [&](){
            auto temp=proto_arr[XGpUdoM];
            return serialize_struct(temp, ((member.pInputAttachmentImage)[XGpUdoM]));
            }();
        }
        }();
[&](){
            if ((member.pSampledImage)==NULL){
                builder.initPSampledImage(0);
            return; }
        auto proto_arr=builder.initPSampledImage(1);
        for(int GYVkRpE=0; GYVkRpE < 1; GYVkRpE++){
            [&](){
            auto temp=proto_arr[GYVkRpE];
            return serialize_struct(temp, ((member.pSampledImage)[GYVkRpE]));
            }();
        }
        }();
[&](){
            if ((member.pStorageImage)==NULL){
                builder.initPStorageImage(0);
            return; }
        auto proto_arr=builder.initPStorageImage(1);
        for(int tQAXyuk=0; tQAXyuk < 1; tQAXyuk++){
            [&](){
            auto temp=proto_arr[tQAXyuk];
            return serialize_struct(temp, ((member.pStorageImage)[tQAXyuk]));
            }();
        }
        }();
[&](){
            if ((member.pUniformTexelBuffer)==NULL){
                builder.initPUniformTexelBuffer(0);
            return; }
        auto proto_arr=builder.initPUniformTexelBuffer(1);
        for(int zdWGhKu=0; zdWGhKu < 1; zdWGhKu++){
            [&](){
            auto temp=proto_arr[zdWGhKu];
            return serialize_struct(temp, ((member.pUniformTexelBuffer)[zdWGhKu]));
            }();
        }
        }();
[&](){
            if ((member.pStorageTexelBuffer)==NULL){
                builder.initPStorageTexelBuffer(0);
            return; }
        auto proto_arr=builder.initPStorageTexelBuffer(1);
        for(int djGqQAT=0; djGqQAT < 1; djGqQAT++){
            [&](){
            auto temp=proto_arr[djGqQAT];
            return serialize_struct(temp, ((member.pStorageTexelBuffer)[djGqQAT]));
            }();
        }
        }();
[&](){
            if ((member.pUniformBuffer)==NULL){
                builder.initPUniformBuffer(0);
            return; }
        auto proto_arr=builder.initPUniformBuffer(1);
        for(int BBFrOWx=0; BBFrOWx < 1; BBFrOWx++){
            [&](){
            auto temp=proto_arr[BBFrOWx];
            return serialize_struct(temp, ((member.pUniformBuffer)[BBFrOWx]));
            }();
        }
        }();
[&](){
            if ((member.pStorageBuffer)==NULL){
                builder.initPStorageBuffer(0);
            return; }
        auto proto_arr=builder.initPStorageBuffer(1);
        for(int byTbsmB=0; byTbsmB < 1; byTbsmB++){
            [&](){
            auto temp=proto_arr[byTbsmB];
            return serialize_struct(temp, ((member.pStorageBuffer)[byTbsmB]));
            }();
        }
        }();
[&](){[&](){return builder.setAccelerationStructure((member.accelerationStructure));}();}();
}

    VkDescriptorDataEXT deserialize_struct(stream::VkDescriptorDataEXT::Reader reader){
        auto result=VkDescriptorDataEXT();
    
[&](){ VkSampler* temp_mLUUZDO[&](){
            if (!reader.getPSampler().size()==0){
                (result.pSampler)=NULL;
            return; }{native_concat()}=(VkSampler*)malloc(1*sizeof(VkSampler));
        auto proto_arr=reader.getPSampler(1);
        for(int JbHkUhn=0; JbHkUhn < 1; JbHkUhn++){
            [&](){((result.pSampler)[JbHkUhn])=deserialize_VkSampler(proto_arr[JbHkUhn]);}();
        }
        }();(result.pSampler)=temp_mLUUZDO;}();
[&](){ VkDescriptorImageInfo* temp_mkaSzbY[&](){
            if (!reader.getPCombinedImageSampler().size()==0){
                (result.pCombinedImageSampler)=NULL;
            return; }{native_concat()}=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto proto_arr=reader.getPCombinedImageSampler(1);
        for(int ksnKPgj=0; ksnKPgj < 1; ksnKPgj++){
            [&](){
            auto temp=proto_arr[ksnKPgj];
            ((result.pCombinedImageSampler)[ksnKPgj])=deserialize_struct(temp);
            }();
        }
        }();(result.pCombinedImageSampler)=temp_mkaSzbY;}();
[&](){ VkDescriptorImageInfo* temp_SsiWQTq[&](){
            if (!reader.getPInputAttachmentImage().size()==0){
                (result.pInputAttachmentImage)=NULL;
            return; }{native_concat()}=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto proto_arr=reader.getPInputAttachmentImage(1);
        for(int jCdsXYL=0; jCdsXYL < 1; jCdsXYL++){
            [&](){
            auto temp=proto_arr[jCdsXYL];
            ((result.pInputAttachmentImage)[jCdsXYL])=deserialize_struct(temp);
            }();
        }
        }();(result.pInputAttachmentImage)=temp_SsiWQTq;}();
[&](){ VkDescriptorImageInfo* temp_cXSmOFR[&](){
            if (!reader.getPSampledImage().size()==0){
                (result.pSampledImage)=NULL;
            return; }{native_concat()}=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto proto_arr=reader.getPSampledImage(1);
        for(int peiDxWp=0; peiDxWp < 1; peiDxWp++){
            [&](){
            auto temp=proto_arr[peiDxWp];
            ((result.pSampledImage)[peiDxWp])=deserialize_struct(temp);
            }();
        }
        }();(result.pSampledImage)=temp_cXSmOFR;}();
[&](){ VkDescriptorImageInfo* temp_nzyLCXh[&](){
            if (!reader.getPStorageImage().size()==0){
                (result.pStorageImage)=NULL;
            return; }{native_concat()}=(VkDescriptorImageInfo*)malloc(1*sizeof(VkDescriptorImageInfo));
        auto proto_arr=reader.getPStorageImage(1);
        for(int DwQgfdS=0; DwQgfdS < 1; DwQgfdS++){
            [&](){
            auto temp=proto_arr[DwQgfdS];
            ((result.pStorageImage)[DwQgfdS])=deserialize_struct(temp);
            }();
        }
        }();(result.pStorageImage)=temp_nzyLCXh;}();
[&](){ VkDescriptorAddressInfoEXT* temp_kcYHBjY[&](){
            if (!reader.getPUniformTexelBuffer().size()==0){
                (result.pUniformTexelBuffer)=NULL;
            return; }{native_concat()}=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto proto_arr=reader.getPUniformTexelBuffer(1);
        for(int xaarJir=0; xaarJir < 1; xaarJir++){
            [&](){
            auto temp=proto_arr[xaarJir];
            ((result.pUniformTexelBuffer)[xaarJir])=deserialize_struct(temp);
            }();
        }
        }();(result.pUniformTexelBuffer)=temp_kcYHBjY;}();
[&](){ VkDescriptorAddressInfoEXT* temp_vCLJhGF[&](){
            if (!reader.getPStorageTexelBuffer().size()==0){
                (result.pStorageTexelBuffer)=NULL;
            return; }{native_concat()}=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto proto_arr=reader.getPStorageTexelBuffer(1);
        for(int xqfIrOh=0; xqfIrOh < 1; xqfIrOh++){
            [&](){
            auto temp=proto_arr[xqfIrOh];
            ((result.pStorageTexelBuffer)[xqfIrOh])=deserialize_struct(temp);
            }();
        }
        }();(result.pStorageTexelBuffer)=temp_vCLJhGF;}();
[&](){ VkDescriptorAddressInfoEXT* temp_WRvjAst[&](){
            if (!reader.getPUniformBuffer().size()==0){
                (result.pUniformBuffer)=NULL;
            return; }{native_concat()}=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto proto_arr=reader.getPUniformBuffer(1);
        for(int khYkBAw=0; khYkBAw < 1; khYkBAw++){
            [&](){
            auto temp=proto_arr[khYkBAw];
            ((result.pUniformBuffer)[khYkBAw])=deserialize_struct(temp);
            }();
        }
        }();(result.pUniformBuffer)=temp_WRvjAst;}();
[&](){ VkDescriptorAddressInfoEXT* temp_GGgEJaD[&](){
            if (!reader.getPStorageBuffer().size()==0){
                (result.pStorageBuffer)=NULL;
            return; }{native_concat()}=(VkDescriptorAddressInfoEXT*)malloc(1*sizeof(VkDescriptorAddressInfoEXT));
        auto proto_arr=reader.getPStorageBuffer(1);
        for(int UWDCkLS=0; UWDCkLS < 1; UWDCkLS++){
            [&](){
            auto temp=proto_arr[UWDCkLS];
            ((result.pStorageBuffer)[UWDCkLS])=deserialize_struct(temp);
            }();
        }
        }();(result.pStorageBuffer)=temp_GGgEJaD;}();
[&](){[&](){(result.accelerationStructure)=reader.getAccelerationStructure();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorDataEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorDataEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorGetInfoEXT::Builder& builder, VkDescriptorGetInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){
            auto temp=builder.initData(data);
            return serialize_struct(temp, (member.data));
            }();
}

    VkDescriptorGetInfoEXT deserialize_struct(stream::VkDescriptorGetInfoEXT::Reader reader){
        auto result=VkDescriptorGetInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){
            auto temp=reader.getData();
            (result.data)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorGetInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorGetInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBufferCaptureDescriptorDataInfoEXT::Builder& builder, VkBufferCaptureDescriptorDataInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
}

    VkBufferCaptureDescriptorDataInfoEXT deserialize_struct(stream::VkBufferCaptureDescriptorDataInfoEXT::Reader reader){
        auto result=VkBufferCaptureDescriptorDataInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBufferCaptureDescriptorDataInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBufferCaptureDescriptorDataInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageCaptureDescriptorDataInfoEXT::Builder& builder, VkImageCaptureDescriptorDataInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImage(serialize_handle(member.image));}();
}

    VkImageCaptureDescriptorDataInfoEXT deserialize_struct(stream::VkImageCaptureDescriptorDataInfoEXT::Reader reader){
        auto result=VkImageCaptureDescriptorDataInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.image)=deserialize_VkImage(reader.getImage());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageCaptureDescriptorDataInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageCaptureDescriptorDataInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewCaptureDescriptorDataInfoEXT::Builder& builder, VkImageViewCaptureDescriptorDataInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImageView(serialize_handle(member.imageView));}();
}

    VkImageViewCaptureDescriptorDataInfoEXT deserialize_struct(stream::VkImageViewCaptureDescriptorDataInfoEXT::Reader reader){
        auto result=VkImageViewCaptureDescriptorDataInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.imageView)=deserialize_VkImageView(reader.getImageView());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewCaptureDescriptorDataInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewCaptureDescriptorDataInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerCaptureDescriptorDataInfoEXT::Builder& builder, VkSamplerCaptureDescriptorDataInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSampler(serialize_handle(member.sampler));}();
}

    VkSamplerCaptureDescriptorDataInfoEXT deserialize_struct(stream::VkSamplerCaptureDescriptorDataInfoEXT::Reader reader){
        auto result=VkSamplerCaptureDescriptorDataInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.sampler)=deserialize_VkSampler(reader.getSampler());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerCaptureDescriptorDataInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerCaptureDescriptorDataInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureCaptureDescriptorDataInfoEXT::Builder& builder, VkAccelerationStructureCaptureDescriptorDataInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAccelerationStructure(serialize_handle(member.accelerationStructure));}();
[&](){return builder.setAccelerationStructureNV(serialize_handle(member.accelerationStructureNV));}();
}

    VkAccelerationStructureCaptureDescriptorDataInfoEXT deserialize_struct(stream::VkAccelerationStructureCaptureDescriptorDataInfoEXT::Reader reader){
        auto result=VkAccelerationStructureCaptureDescriptorDataInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.accelerationStructure)=deserialize_VkAccelerationStructureKHR(reader.getAccelerationStructure());}();
[&](){(result.accelerationStructureNV)=deserialize_VkAccelerationStructureNV(reader.getAccelerationStructureNV());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureCaptureDescriptorDataInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureCaptureDescriptorDataInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOpaqueCaptureDescriptorDataCreateInfoEXT::Builder& builder, VkOpaqueCaptureDescriptorDataCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.opaqueCaptureDescriptorData)==NULL){
                builder.initOpaqueCaptureDescriptorData(0);
            return; }[&](){
            if (((char*)(member.opaqueCaptureDescriptorData).opaqueCaptureDescriptorData)==NULL){
                builder.initOpaqueCaptureDescriptorData(0);
            return; }
        auto proto_arr=builder.initOpaqueCaptureDescriptorData(strlen(((char*)(member.opaqueCaptureDescriptorData).opaqueCaptureDescriptorData))+1);
        for(int DBqaZyV=0; DBqaZyV < strlen(((char*)(member.opaqueCaptureDescriptorData).opaqueCaptureDescriptorData))+1; DBqaZyV++){
            [&](){return proto_arr.set(DBqaZyV,(((char*)(member.opaqueCaptureDescriptorData).opaqueCaptureDescriptorData)[DBqaZyV]));}();
        }
        }();}();
}

    VkOpaqueCaptureDescriptorDataCreateInfoEXT deserialize_struct(stream::VkOpaqueCaptureDescriptorDataCreateInfoEXT::Reader reader){
        auto result=VkOpaqueCaptureDescriptorDataCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ void* temp_aKlUxQv[&](){
            if (!reader.getOpaqueCaptureDescriptorData().size()==0){
                (result.opaqueCaptureDescriptorData)=NULL;
            return; }char* temp_QATXnVH;[&](){
            if (!reader.getOpaqueCaptureDescriptorData().size()==0){
                (temp_QATXnVH.opaqueCaptureDescriptorData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getOpaqueCaptureDescriptorData().size();*sizeof(char));
        auto proto_arr=reader.getOpaqueCaptureDescriptorData(reader.getOpaqueCaptureDescriptorData().size(););
        for(int GrXpdLW=0; GrXpdLW < reader.getOpaqueCaptureDescriptorData().size();; GrXpdLW++){
            [&](){((temp_QATXnVH.opaqueCaptureDescriptorData)[GrXpdLW])=proto_arr[GrXpdLW];}();
        }
        }();(result.opaqueCaptureDescriptorData)=temp_QATXnVH;}();(result.opaqueCaptureDescriptorData)=temp_aKlUxQv;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOpaqueCaptureDescriptorDataCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOpaqueCaptureDescriptorDataCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderIntegerDotProductFeatures::Builder& builder, VkPhysicalDeviceShaderIntegerDotProductFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderIntegerDotProduct((member.shaderIntegerDotProduct));}();}();
}

    VkPhysicalDeviceShaderIntegerDotProductFeatures deserialize_struct(stream::VkPhysicalDeviceShaderIntegerDotProductFeatures::Reader reader){
        auto result=VkPhysicalDeviceShaderIntegerDotProductFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderIntegerDotProduct)=reader.getShaderIntegerDotProduct();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderIntegerDotProductFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderIntegerDotProductFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderIntegerDotProductProperties::Builder& builder, VkPhysicalDeviceShaderIntegerDotProductProperties member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setIntegerDotProduct8BitUnsignedAccelerated((member.integerDotProduct8BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct8BitSignedAccelerated((member.integerDotProduct8BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct8BitMixedSignednessAccelerated((member.integerDotProduct8BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct4x8BitPackedUnsignedAccelerated((member.integerDotProduct4x8BitPackedUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct4x8BitPackedSignedAccelerated((member.integerDotProduct4x8BitPackedSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct4x8BitPackedMixedSignednessAccelerated((member.integerDotProduct4x8BitPackedMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct16BitUnsignedAccelerated((member.integerDotProduct16BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct16BitSignedAccelerated((member.integerDotProduct16BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct16BitMixedSignednessAccelerated((member.integerDotProduct16BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct32BitUnsignedAccelerated((member.integerDotProduct32BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct32BitSignedAccelerated((member.integerDotProduct32BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct32BitMixedSignednessAccelerated((member.integerDotProduct32BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct64BitUnsignedAccelerated((member.integerDotProduct64BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct64BitSignedAccelerated((member.integerDotProduct64BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProduct64BitMixedSignednessAccelerated((member.integerDotProduct64BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating8BitSignedAccelerated((member.integerDotProductAccumulatingSaturating8BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated((member.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated((member.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating16BitSignedAccelerated((member.integerDotProductAccumulatingSaturating16BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating32BitSignedAccelerated((member.integerDotProductAccumulatingSaturating32BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated((member.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating64BitSignedAccelerated((member.integerDotProductAccumulatingSaturating64BitSignedAccelerated));}();}();
[&](){[&](){return builder.setIntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated((member.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated));}();}();
}

    VkPhysicalDeviceShaderIntegerDotProductProperties deserialize_struct(stream::VkPhysicalDeviceShaderIntegerDotProductProperties::Reader reader){
        auto result=VkPhysicalDeviceShaderIntegerDotProductProperties();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.integerDotProduct8BitUnsignedAccelerated)=reader.getIntegerDotProduct8BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct8BitSignedAccelerated)=reader.getIntegerDotProduct8BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct8BitMixedSignednessAccelerated)=reader.getIntegerDotProduct8BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct4x8BitPackedUnsignedAccelerated)=reader.getIntegerDotProduct4x8BitPackedUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct4x8BitPackedSignedAccelerated)=reader.getIntegerDotProduct4x8BitPackedSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct4x8BitPackedMixedSignednessAccelerated)=reader.getIntegerDotProduct4x8BitPackedMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct16BitUnsignedAccelerated)=reader.getIntegerDotProduct16BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct16BitSignedAccelerated)=reader.getIntegerDotProduct16BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct16BitMixedSignednessAccelerated)=reader.getIntegerDotProduct16BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct32BitUnsignedAccelerated)=reader.getIntegerDotProduct32BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct32BitSignedAccelerated)=reader.getIntegerDotProduct32BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct32BitMixedSignednessAccelerated)=reader.getIntegerDotProduct32BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProduct64BitUnsignedAccelerated)=reader.getIntegerDotProduct64BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct64BitSignedAccelerated)=reader.getIntegerDotProduct64BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProduct64BitMixedSignednessAccelerated)=reader.getIntegerDotProduct64BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating8BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating8BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating8BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating16BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating16BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating16BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating32BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating32BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating32BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating64BitUnsignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating64BitSignedAccelerated)=reader.getIntegerDotProductAccumulatingSaturating64BitSignedAccelerated();}();}();
[&](){[&](){(result.integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)=reader.getIntegerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderIntegerDotProductProperties member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderIntegerDotProductProperties member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDrmPropertiesEXT::Builder& builder, VkPhysicalDeviceDrmPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setHasPrimary((member.hasPrimary));}();}();
[&](){[&](){return builder.setHasRender((member.hasRender));}();}();
[&](){return builder.setPrimaryMajor((member.primaryMajor));}();
[&](){return builder.setPrimaryMinor((member.primaryMinor));}();
[&](){return builder.setRenderMajor((member.renderMajor));}();
[&](){return builder.setRenderMinor((member.renderMinor));}();
}

    VkPhysicalDeviceDrmPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceDrmPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceDrmPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.hasPrimary)=reader.getHasPrimary();}();}();
[&](){[&](){(result.hasRender)=reader.getHasRender();}();}();
[&](){(result.primaryMajor)=reader.getPrimaryMajor();}();
[&](){(result.primaryMinor)=reader.getPrimaryMinor();}();
[&](){(result.renderMajor)=reader.getRenderMajor();}();
[&](){(result.renderMinor)=reader.getRenderMinor();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDrmPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDrmPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR::Builder& builder, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFragmentShaderBarycentric((member.fragmentShaderBarycentric));}();}();
}

    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.fragmentShaderBarycentric)=reader.getFragmentShaderBarycentric();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR::Builder& builder, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTriStripVertexOrderIndependentOfProvokingVertex((member.triStripVertexOrderIndependentOfProvokingVertex));}();}();
}

    VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR deserialize_struct(stream::VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR::Reader reader){
        auto result=VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.triStripVertexOrderIndependentOfProvokingVertex)=reader.getTriStripVertexOrderIndependentOfProvokingVertex();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingMotionBlurFeaturesNV::Builder& builder, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRayTracingMotionBlur((member.rayTracingMotionBlur));}();}();
[&](){[&](){return builder.setRayTracingMotionBlurPipelineTraceRaysIndirect((member.rayTracingMotionBlurPipelineTraceRaysIndirect));}();}();
}

    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV deserialize_struct(stream::VkPhysicalDeviceRayTracingMotionBlurFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceRayTracingMotionBlurFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rayTracingMotionBlur)=reader.getRayTracingMotionBlur();}();}();
[&](){[&](){(result.rayTracingMotionBlurPipelineTraceRaysIndirect)=reader.getRayTracingMotionBlurPipelineTraceRaysIndirect();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureGeometryMotionTrianglesDataNV::Builder& builder, VkAccelerationStructureGeometryMotionTrianglesDataNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initVertexData(vertexData);
            return serialize_struct(temp, (member.vertexData));
            }();
}

    VkAccelerationStructureGeometryMotionTrianglesDataNV deserialize_struct(stream::VkAccelerationStructureGeometryMotionTrianglesDataNV::Reader reader){
        auto result=VkAccelerationStructureGeometryMotionTrianglesDataNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getVertexData();
            (result.vertexData)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureGeometryMotionTrianglesDataNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureGeometryMotionTrianglesDataNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureMotionInfoNV::Builder& builder, VkAccelerationStructureMotionInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxInstances((member.maxInstances));}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkAccelerationStructureMotionInfoNV deserialize_struct(stream::VkAccelerationStructureMotionInfoNV::Reader reader){
        auto result=VkAccelerationStructureMotionInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.maxInstances)=reader.getMaxInstances();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureMotionInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureMotionInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSRTDataNV::Builder& builder, VkSRTDataNV member){
        
    
[&](){return builder.setSx((member.sx));}();
[&](){return builder.setA((member.a));}();
[&](){return builder.setB((member.b));}();
[&](){return builder.setPvx((member.pvx));}();
[&](){return builder.setSy((member.sy));}();
[&](){return builder.setC((member.c));}();
[&](){return builder.setPvy((member.pvy));}();
[&](){return builder.setSz((member.sz));}();
[&](){return builder.setPvz((member.pvz));}();
[&](){return builder.setQx((member.qx));}();
[&](){return builder.setQy((member.qy));}();
[&](){return builder.setQz((member.qz));}();
[&](){return builder.setQw((member.qw));}();
[&](){return builder.setTx((member.tx));}();
[&](){return builder.setTy((member.ty));}();
[&](){return builder.setTz((member.tz));}();
}

    VkSRTDataNV deserialize_struct(stream::VkSRTDataNV::Reader reader){
        auto result=VkSRTDataNV();
    
[&](){(result.sx)=reader.getSx();}();
[&](){(result.a)=reader.getA();}();
[&](){(result.b)=reader.getB();}();
[&](){(result.pvx)=reader.getPvx();}();
[&](){(result.sy)=reader.getSy();}();
[&](){(result.c)=reader.getC();}();
[&](){(result.pvy)=reader.getPvy();}();
[&](){(result.sz)=reader.getSz();}();
[&](){(result.pvz)=reader.getPvz();}();
[&](){(result.qx)=reader.getQx();}();
[&](){(result.qy)=reader.getQy();}();
[&](){(result.qz)=reader.getQz();}();
[&](){(result.qw)=reader.getQw();}();
[&](){(result.tx)=reader.getTx();}();
[&](){(result.ty)=reader.getTy();}();
[&](){(result.tz)=reader.getTz();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSRTDataNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSRTDataNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureSRTMotionInstanceNV::Builder& builder, VkAccelerationStructureSRTMotionInstanceNV member){
        
    
[&](){
            auto temp=builder.initTransformT0(transformT0);
            return serialize_struct(temp, (member.transformT0));
            }();
[&](){
            auto temp=builder.initTransformT1(transformT1);
            return serialize_struct(temp, (member.transformT1));
            }();
[&](){return builder.setInstanceCustomIndex((member.instanceCustomIndex));}();
[&](){return builder.setMask((member.mask));}();
[&](){return builder.setInstanceShaderBindingTableRecordOffset((member.instanceShaderBindingTableRecordOffset));}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setAccelerationStructureReference((member.accelerationStructureReference));}();
}

    VkAccelerationStructureSRTMotionInstanceNV deserialize_struct(stream::VkAccelerationStructureSRTMotionInstanceNV::Reader reader){
        auto result=VkAccelerationStructureSRTMotionInstanceNV();
    
[&](){
            auto temp=reader.getTransformT0();
            (result.transformT0)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getTransformT1();
            (result.transformT1)=deserialize_struct(temp);
            }();
[&](){(result.instanceCustomIndex)=reader.getInstanceCustomIndex();}();
[&](){(result.mask)=reader.getMask();}();
[&](){(result.instanceShaderBindingTableRecordOffset)=reader.getInstanceShaderBindingTableRecordOffset();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.accelerationStructureReference)=reader.getAccelerationStructureReference();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureSRTMotionInstanceNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureSRTMotionInstanceNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureMatrixMotionInstanceNV::Builder& builder, VkAccelerationStructureMatrixMotionInstanceNV member){
        
    
[&](){
            auto temp=builder.initTransformT0(transformT0);
            return serialize_struct(temp, (member.transformT0));
            }();
[&](){
            auto temp=builder.initTransformT1(transformT1);
            return serialize_struct(temp, (member.transformT1));
            }();
[&](){return builder.setInstanceCustomIndex((member.instanceCustomIndex));}();
[&](){return builder.setMask((member.mask));}();
[&](){return builder.setInstanceShaderBindingTableRecordOffset((member.instanceShaderBindingTableRecordOffset));}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setAccelerationStructureReference((member.accelerationStructureReference));}();
}

    VkAccelerationStructureMatrixMotionInstanceNV deserialize_struct(stream::VkAccelerationStructureMatrixMotionInstanceNV::Reader reader){
        auto result=VkAccelerationStructureMatrixMotionInstanceNV();
    
[&](){
            auto temp=reader.getTransformT0();
            (result.transformT0)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getTransformT1();
            (result.transformT1)=deserialize_struct(temp);
            }();
[&](){(result.instanceCustomIndex)=reader.getInstanceCustomIndex();}();
[&](){(result.mask)=reader.getMask();}();
[&](){(result.instanceShaderBindingTableRecordOffset)=reader.getInstanceShaderBindingTableRecordOffset();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.accelerationStructureReference)=reader.getAccelerationStructureReference();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureMatrixMotionInstanceNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureMatrixMotionInstanceNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureMotionInstanceDataNV::Builder& builder, VkAccelerationStructureMotionInstanceDataNV member){
        
    
[&](){
            auto temp=builder.initStaticInstance(staticInstance);
            return serialize_struct(temp, (member.staticInstance));
            }();
[&](){
            auto temp=builder.initMatrixMotionInstance(matrixMotionInstance);
            return serialize_struct(temp, (member.matrixMotionInstance));
            }();
[&](){
            auto temp=builder.initSrtMotionInstance(srtMotionInstance);
            return serialize_struct(temp, (member.srtMotionInstance));
            }();
}

    VkAccelerationStructureMotionInstanceDataNV deserialize_struct(stream::VkAccelerationStructureMotionInstanceDataNV::Reader reader){
        auto result=VkAccelerationStructureMotionInstanceDataNV();
    
[&](){
            auto temp=reader.getStaticInstance();
            (result.staticInstance)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMatrixMotionInstance();
            (result.matrixMotionInstance)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSrtMotionInstance();
            (result.srtMotionInstance)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureMotionInstanceDataNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureMotionInstanceDataNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureMotionInstanceNV::Builder& builder, VkAccelerationStructureMotionInstanceNV member){
        
    
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            auto temp=builder.initData(data);
            return serialize_struct(temp, (member.data));
            }();
}

    VkAccelerationStructureMotionInstanceNV deserialize_struct(stream::VkAccelerationStructureMotionInstanceNV::Reader reader){
        auto result=VkAccelerationStructureMotionInstanceNV();
    
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
            auto temp=reader.getData();
            (result.data)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureMotionInstanceNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureMotionInstanceNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryGetRemoteAddressInfoNV::Builder& builder, VkMemoryGetRemoteAddressInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){[&](){return builder.setHandleType((member.handleType));}();}();}();
}

    VkMemoryGetRemoteAddressInfoNV deserialize_struct(stream::VkMemoryGetRemoteAddressInfoNV::Reader reader){
        auto result=VkMemoryGetRemoteAddressInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){[&](){(result.handleType)=reader.getHandleType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryGetRemoteAddressInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryGetRemoteAddressInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT::Builder& builder, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFormatRgba10x6WithoutYCbCrSampler((member.formatRgba10x6WithoutYCbCrSampler));}();}();
}

    VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.formatRgba10x6WithoutYCbCrSampler)=reader.getFormatRgba10x6WithoutYCbCrSampler();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFormatProperties3::Builder& builder, VkFormatProperties3 member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setLinearTilingFeatures((member.linearTilingFeatures));}();}();}();
[&](){[&](){[&](){return builder.setOptimalTilingFeatures((member.optimalTilingFeatures));}();}();}();
[&](){[&](){[&](){return builder.setBufferFeatures((member.bufferFeatures));}();}();}();
}

    VkFormatProperties3 deserialize_struct(stream::VkFormatProperties3::Reader reader){
        auto result=VkFormatProperties3();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.linearTilingFeatures)=reader.getLinearTilingFeatures();}();}();}();
[&](){[&](){[&](){(result.optimalTilingFeatures)=reader.getOptimalTilingFeatures();}();}();}();
[&](){[&](){[&](){(result.bufferFeatures)=reader.getBufferFeatures();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFormatProperties3 member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFormatProperties3 member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrmFormatModifierPropertiesList2EXT::Builder& builder, VkDrmFormatModifierPropertiesList2EXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDrmFormatModifierCount((member.drmFormatModifierCount));}();
[&](){
            if ((member.pDrmFormatModifierProperties)==NULL){
                builder.initPDrmFormatModifierProperties(0);
            return; }
        auto proto_arr=builder.initPDrmFormatModifierProperties(member.drmFormatModifierCount);
        for(int llWReeu=0; llWReeu < member.drmFormatModifierCount; llWReeu++){
            [&](){
            auto temp=proto_arr[llWReeu];
            return serialize_struct(temp, ((member.pDrmFormatModifierProperties)[llWReeu]));
            }();
        }
        }();
}

    VkDrmFormatModifierPropertiesList2EXT deserialize_struct(stream::VkDrmFormatModifierPropertiesList2EXT::Reader reader){
        auto result=VkDrmFormatModifierPropertiesList2EXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.drmFormatModifierCount)=reader.getDrmFormatModifierCount();}();
[&](){
            if (!reader.getPDrmFormatModifierProperties().size()==0){
                (result.pDrmFormatModifierProperties)=NULL;
            return; }{native_concat()}=(VkDrmFormatModifierProperties2EXT*)malloc(result.drmFormatModifierCount*sizeof(VkDrmFormatModifierProperties2EXT));
        auto proto_arr=reader.getPDrmFormatModifierProperties(result.drmFormatModifierCount);
        for(int llWReeu=0; llWReeu < result.drmFormatModifierCount; llWReeu++){
            [&](){
            auto temp=proto_arr[llWReeu];
            ((result.pDrmFormatModifierProperties)[llWReeu])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrmFormatModifierPropertiesList2EXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrmFormatModifierPropertiesList2EXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDrmFormatModifierProperties2EXT::Builder& builder, VkDrmFormatModifierProperties2EXT member){
        
    
[&](){return builder.setDrmFormatModifier((member.drmFormatModifier));}();
[&](){return builder.setDrmFormatModifierPlaneCount((member.drmFormatModifierPlaneCount));}();
[&](){[&](){[&](){return builder.setDrmFormatModifierTilingFeatures((member.drmFormatModifierTilingFeatures));}();}();}();
}

    VkDrmFormatModifierProperties2EXT deserialize_struct(stream::VkDrmFormatModifierProperties2EXT::Reader reader){
        auto result=VkDrmFormatModifierProperties2EXT();
    
[&](){(result.drmFormatModifier)=reader.getDrmFormatModifier();}();
[&](){(result.drmFormatModifierPlaneCount)=reader.getDrmFormatModifierPlaneCount();}();
[&](){[&](){[&](){(result.drmFormatModifierTilingFeatures)=reader.getDrmFormatModifierTilingFeatures();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDrmFormatModifierProperties2EXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDrmFormatModifierProperties2EXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRenderingCreateInfo::Builder& builder, VkPipelineRenderingCreateInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setViewMask((member.viewMask));}();
[&](){return builder.setColorAttachmentCount((member.colorAttachmentCount));}();
[&](){
            if ((member.pColorAttachmentFormats)==NULL){
                builder.initPColorAttachmentFormats(0);
            return; }
        auto proto_arr=builder.initPColorAttachmentFormats(member.colorAttachmentCount);
        for(int wEZNsRI=0; wEZNsRI < member.colorAttachmentCount; wEZNsRI++){
            [&](){[&](){[&](){return proto_arr.set(wEZNsRI,((member.pColorAttachmentFormats)[wEZNsRI]));}();}();}();
        }
        }();
[&](){[&](){[&](){return builder.setDepthAttachmentFormat((member.depthAttachmentFormat));}();}();}();
[&](){[&](){[&](){return builder.setStencilAttachmentFormat((member.stencilAttachmentFormat));}();}();}();
}

    VkPipelineRenderingCreateInfo deserialize_struct(stream::VkPipelineRenderingCreateInfo::Reader reader){
        auto result=VkPipelineRenderingCreateInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.viewMask)=reader.getViewMask();}();
[&](){(result.colorAttachmentCount)=reader.getColorAttachmentCount();}();
[&](){ VkFormat* temp_PrgeUSF[&](){
            if (!reader.getPColorAttachmentFormats().size()==0){
                (result.pColorAttachmentFormats)=NULL;
            return; }{native_concat()}=(VkFormat*)malloc(result.colorAttachmentCount*sizeof(VkFormat));
        auto proto_arr=reader.getPColorAttachmentFormats(result.colorAttachmentCount);
        for(int XcfMUtc=0; XcfMUtc < result.colorAttachmentCount; XcfMUtc++){
            [&](){[&](){[&](){((result.pColorAttachmentFormats)[XcfMUtc])=proto_arr[XcfMUtc];}();}();}();
        }
        }();(result.pColorAttachmentFormats)=temp_PrgeUSF;}();
[&](){[&](){[&](){(result.depthAttachmentFormat)=reader.getDepthAttachmentFormat();}();}();}();
[&](){[&](){[&](){(result.stencilAttachmentFormat)=reader.getStencilAttachmentFormat();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRenderingCreateInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRenderingCreateInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderingInfo::Builder& builder, VkRenderingInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            auto temp=builder.initRenderArea(renderArea);
            return serialize_struct(temp, (member.renderArea));
            }();
[&](){return builder.setLayerCount((member.layerCount));}();
[&](){return builder.setViewMask((member.viewMask));}();
[&](){return builder.setColorAttachmentCount((member.colorAttachmentCount));}();
[&](){
            if ((member.pColorAttachments)==NULL){
                builder.initPColorAttachments(0);
            return; }
        auto proto_arr=builder.initPColorAttachments(member.colorAttachmentCount);
        for(int cibkfru=0; cibkfru < member.colorAttachmentCount; cibkfru++){
            [&](){
            auto temp=proto_arr[cibkfru];
            return serialize_struct(temp, ((member.pColorAttachments)[cibkfru]));
            }();
        }
        }();
[&](){
            if ((member.pDepthAttachment)==NULL){
                builder.initPDepthAttachment(0);
            return; }
        auto proto_arr=builder.initPDepthAttachment(1);
        for(int kxTATsQ=0; kxTATsQ < 1; kxTATsQ++){
            [&](){
            auto temp=proto_arr[kxTATsQ];
            return serialize_struct(temp, ((member.pDepthAttachment)[kxTATsQ]));
            }();
        }
        }();
[&](){
            if ((member.pStencilAttachment)==NULL){
                builder.initPStencilAttachment(0);
            return; }
        auto proto_arr=builder.initPStencilAttachment(1);
        for(int uJrHPnT=0; uJrHPnT < 1; uJrHPnT++){
            [&](){
            auto temp=proto_arr[uJrHPnT];
            return serialize_struct(temp, ((member.pStencilAttachment)[uJrHPnT]));
            }();
        }
        }();
}

    VkRenderingInfo deserialize_struct(stream::VkRenderingInfo::Reader reader){
        auto result=VkRenderingInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
            auto temp=reader.getRenderArea();
            (result.renderArea)=deserialize_struct(temp);
            }();
[&](){(result.layerCount)=reader.getLayerCount();}();
[&](){(result.viewMask)=reader.getViewMask();}();
[&](){(result.colorAttachmentCount)=reader.getColorAttachmentCount();}();
[&](){ VkRenderingAttachmentInfo* temp_osnAtxY[&](){
            if (!reader.getPColorAttachments().size()==0){
                (result.pColorAttachments)=NULL;
            return; }{native_concat()}=(VkRenderingAttachmentInfo*)malloc(result.colorAttachmentCount*sizeof(VkRenderingAttachmentInfo));
        auto proto_arr=reader.getPColorAttachments(result.colorAttachmentCount);
        for(int cGsnvAo=0; cGsnvAo < result.colorAttachmentCount; cGsnvAo++){
            [&](){
            auto temp=proto_arr[cGsnvAo];
            ((result.pColorAttachments)[cGsnvAo])=deserialize_struct(temp);
            }();
        }
        }();(result.pColorAttachments)=temp_osnAtxY;}();
[&](){ VkRenderingAttachmentInfo* temp_CEKgFvq[&](){
            if (!reader.getPDepthAttachment().size()==0){
                (result.pDepthAttachment)=NULL;
            return; }{native_concat()}=(VkRenderingAttachmentInfo*)malloc(1*sizeof(VkRenderingAttachmentInfo));
        auto proto_arr=reader.getPDepthAttachment(1);
        for(int ZYEKxYk=0; ZYEKxYk < 1; ZYEKxYk++){
            [&](){
            auto temp=proto_arr[ZYEKxYk];
            ((result.pDepthAttachment)[ZYEKxYk])=deserialize_struct(temp);
            }();
        }
        }();(result.pDepthAttachment)=temp_CEKgFvq;}();
[&](){ VkRenderingAttachmentInfo* temp_tzErIXV[&](){
            if (!reader.getPStencilAttachment().size()==0){
                (result.pStencilAttachment)=NULL;
            return; }{native_concat()}=(VkRenderingAttachmentInfo*)malloc(1*sizeof(VkRenderingAttachmentInfo));
        auto proto_arr=reader.getPStencilAttachment(1);
        for(int WFCqNwK=0; WFCqNwK < 1; WFCqNwK++){
            [&](){
            auto temp=proto_arr[WFCqNwK];
            ((result.pStencilAttachment)[WFCqNwK])=deserialize_struct(temp);
            }();
        }
        }();(result.pStencilAttachment)=temp_tzErIXV;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderingInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderingInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderingAttachmentInfo::Builder& builder, VkRenderingAttachmentInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImageView(serialize_handle(member.imageView));}();
[&](){[&](){[&](){return builder.setImageLayout((member.imageLayout));}();}();}();
[&](){[&](){[&](){return builder.setResolveMode((member.resolveMode));}();}();}();
[&](){return builder.setResolveImageView(serialize_handle(member.resolveImageView));}();
[&](){[&](){[&](){return builder.setResolveImageLayout((member.resolveImageLayout));}();}();}();
[&](){[&](){[&](){return builder.setLoadOp((member.loadOp));}();}();}();
[&](){[&](){[&](){return builder.setStoreOp((member.storeOp));}();}();}();
[&](){
            auto temp=builder.initClearValue(clearValue);
            return serialize_struct(temp, (member.clearValue));
            }();
}

    VkRenderingAttachmentInfo deserialize_struct(stream::VkRenderingAttachmentInfo::Reader reader){
        auto result=VkRenderingAttachmentInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.imageView)=deserialize_VkImageView(reader.getImageView());}();
[&](){[&](){[&](){(result.imageLayout)=reader.getImageLayout();}();}();}();
[&](){[&](){[&](){(result.resolveMode)=reader.getResolveMode();}();}();}();
[&](){(result.resolveImageView)=deserialize_VkImageView(reader.getResolveImageView());}();
[&](){[&](){[&](){(result.resolveImageLayout)=reader.getResolveImageLayout();}();}();}();
[&](){[&](){[&](){(result.loadOp)=reader.getLoadOp();}();}();}();
[&](){[&](){[&](){(result.storeOp)=reader.getStoreOp();}();}();}();
[&](){
            auto temp=reader.getClearValue();
            (result.clearValue)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderingAttachmentInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderingAttachmentInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderingFragmentShadingRateAttachmentInfoKHR::Builder& builder, VkRenderingFragmentShadingRateAttachmentInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImageView(serialize_handle(member.imageView));}();
[&](){[&](){[&](){return builder.setImageLayout((member.imageLayout));}();}();}();
[&](){
            auto temp=builder.initShadingRateAttachmentTexelSize(shadingRateAttachmentTexelSize);
            return serialize_struct(temp, (member.shadingRateAttachmentTexelSize));
            }();
}

    VkRenderingFragmentShadingRateAttachmentInfoKHR deserialize_struct(stream::VkRenderingFragmentShadingRateAttachmentInfoKHR::Reader reader){
        auto result=VkRenderingFragmentShadingRateAttachmentInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.imageView)=deserialize_VkImageView(reader.getImageView());}();
[&](){[&](){[&](){(result.imageLayout)=reader.getImageLayout();}();}();}();
[&](){
            auto temp=reader.getShadingRateAttachmentTexelSize();
            (result.shadingRateAttachmentTexelSize)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderingFragmentShadingRateAttachmentInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderingFragmentShadingRateAttachmentInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderingFragmentDensityMapAttachmentInfoEXT::Builder& builder, VkRenderingFragmentDensityMapAttachmentInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setImageView(serialize_handle(member.imageView));}();
[&](){[&](){[&](){return builder.setImageLayout((member.imageLayout));}();}();}();
}

    VkRenderingFragmentDensityMapAttachmentInfoEXT deserialize_struct(stream::VkRenderingFragmentDensityMapAttachmentInfoEXT::Reader reader){
        auto result=VkRenderingFragmentDensityMapAttachmentInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.imageView)=deserialize_VkImageView(reader.getImageView());}();
[&](){[&](){[&](){(result.imageLayout)=reader.getImageLayout();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderingFragmentDensityMapAttachmentInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderingFragmentDensityMapAttachmentInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDynamicRenderingFeatures::Builder& builder, VkPhysicalDeviceDynamicRenderingFeatures member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDynamicRendering((member.dynamicRendering));}();}();
}

    VkPhysicalDeviceDynamicRenderingFeatures deserialize_struct(stream::VkPhysicalDeviceDynamicRenderingFeatures::Reader reader){
        auto result=VkPhysicalDeviceDynamicRenderingFeatures();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.dynamicRendering)=reader.getDynamicRendering();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDynamicRenderingFeatures member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDynamicRenderingFeatures member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCommandBufferInheritanceRenderingInfo::Builder& builder, VkCommandBufferInheritanceRenderingInfo member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setViewMask((member.viewMask));}();
[&](){return builder.setColorAttachmentCount((member.colorAttachmentCount));}();
[&](){
            if ((member.pColorAttachmentFormats)==NULL){
                builder.initPColorAttachmentFormats(0);
            return; }
        auto proto_arr=builder.initPColorAttachmentFormats(member.colorAttachmentCount);
        for(int wEZNsRI=0; wEZNsRI < member.colorAttachmentCount; wEZNsRI++){
            [&](){[&](){[&](){return proto_arr.set(wEZNsRI,((member.pColorAttachmentFormats)[wEZNsRI]));}();}();}();
        }
        }();
[&](){[&](){[&](){return builder.setDepthAttachmentFormat((member.depthAttachmentFormat));}();}();}();
[&](){[&](){[&](){return builder.setStencilAttachmentFormat((member.stencilAttachmentFormat));}();}();}();
[&](){[&](){[&](){return builder.setRasterizationSamples((member.rasterizationSamples));}();}();}();
}

    VkCommandBufferInheritanceRenderingInfo deserialize_struct(stream::VkCommandBufferInheritanceRenderingInfo::Reader reader){
        auto result=VkCommandBufferInheritanceRenderingInfo();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.viewMask)=reader.getViewMask();}();
[&](){(result.colorAttachmentCount)=reader.getColorAttachmentCount();}();
[&](){ VkFormat* temp_PrgeUSF[&](){
            if (!reader.getPColorAttachmentFormats().size()==0){
                (result.pColorAttachmentFormats)=NULL;
            return; }{native_concat()}=(VkFormat*)malloc(result.colorAttachmentCount*sizeof(VkFormat));
        auto proto_arr=reader.getPColorAttachmentFormats(result.colorAttachmentCount);
        for(int XcfMUtc=0; XcfMUtc < result.colorAttachmentCount; XcfMUtc++){
            [&](){[&](){[&](){((result.pColorAttachmentFormats)[XcfMUtc])=proto_arr[XcfMUtc];}();}();}();
        }
        }();(result.pColorAttachmentFormats)=temp_PrgeUSF;}();
[&](){[&](){[&](){(result.depthAttachmentFormat)=reader.getDepthAttachmentFormat();}();}();}();
[&](){[&](){[&](){(result.stencilAttachmentFormat)=reader.getStencilAttachmentFormat();}();}();}();
[&](){[&](){[&](){(result.rasterizationSamples)=reader.getRasterizationSamples();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCommandBufferInheritanceRenderingInfo member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCommandBufferInheritanceRenderingInfo member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAttachmentSampleCountInfoAMD::Builder& builder, VkAttachmentSampleCountInfoAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setColorAttachmentCount((member.colorAttachmentCount));}();
[&](){
            if ((member.pColorAttachmentSamples)==NULL){
                builder.initPColorAttachmentSamples(0);
            return; }
        auto proto_arr=builder.initPColorAttachmentSamples(member.colorAttachmentCount);
        for(int DxAFsfK=0; DxAFsfK < member.colorAttachmentCount; DxAFsfK++){
            [&](){[&](){[&](){return proto_arr.set(DxAFsfK,((member.pColorAttachmentSamples)[DxAFsfK]));}();}();}();
        }
        }();
[&](){[&](){[&](){return builder.setDepthStencilAttachmentSamples((member.depthStencilAttachmentSamples));}();}();}();
}

    VkAttachmentSampleCountInfoAMD deserialize_struct(stream::VkAttachmentSampleCountInfoAMD::Reader reader){
        auto result=VkAttachmentSampleCountInfoAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.colorAttachmentCount)=reader.getColorAttachmentCount();}();
[&](){ VkSampleCountFlagBits* temp_hpxudCQ[&](){
            if (!reader.getPColorAttachmentSamples().size()==0){
                (result.pColorAttachmentSamples)=NULL;
            return; }{native_concat()}=(VkSampleCountFlagBits*)malloc(result.colorAttachmentCount*sizeof(VkSampleCountFlagBits));
        auto proto_arr=reader.getPColorAttachmentSamples(result.colorAttachmentCount);
        for(int qSJXYKL=0; qSJXYKL < result.colorAttachmentCount; qSJXYKL++){
            [&](){[&](){[&](){((result.pColorAttachmentSamples)[qSJXYKL])=proto_arr[qSJXYKL];}();}();}();
        }
        }();(result.pColorAttachmentSamples)=temp_hpxudCQ;}();
[&](){[&](){[&](){(result.depthStencilAttachmentSamples)=reader.getDepthStencilAttachmentSamples();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAttachmentSampleCountInfoAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAttachmentSampleCountInfoAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMultiviewPerViewAttributesInfoNVX::Builder& builder, VkMultiviewPerViewAttributesInfoNVX member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPerViewAttributes((member.perViewAttributes));}();}();
[&](){[&](){return builder.setPerViewAttributesPositionXOnly((member.perViewAttributesPositionXOnly));}();}();
}

    VkMultiviewPerViewAttributesInfoNVX deserialize_struct(stream::VkMultiviewPerViewAttributesInfoNVX::Reader reader){
        auto result=VkMultiviewPerViewAttributesInfoNVX();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.perViewAttributes)=reader.getPerViewAttributes();}();}();
[&](){[&](){(result.perViewAttributesPositionXOnly)=reader.getPerViewAttributesPositionXOnly();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMultiviewPerViewAttributesInfoNVX member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMultiviewPerViewAttributesInfoNVX member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageViewMinLodFeaturesEXT::Builder& builder, VkPhysicalDeviceImageViewMinLodFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMinLod((member.minLod));}();}();
}

    VkPhysicalDeviceImageViewMinLodFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceImageViewMinLodFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceImageViewMinLodFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.minLod)=reader.getMinLod();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageViewMinLodFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageViewMinLodFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewMinLodCreateInfoEXT::Builder& builder, VkImageViewMinLodCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMinLod((member.minLod));}();
}

    VkImageViewMinLodCreateInfoEXT deserialize_struct(stream::VkImageViewMinLodCreateInfoEXT::Reader reader){
        auto result=VkImageViewMinLodCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.minLod)=reader.getMinLod();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewMinLodCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewMinLodCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT::Builder& builder, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRasterizationOrderColorAttachmentAccess((member.rasterizationOrderColorAttachmentAccess));}();}();
[&](){[&](){return builder.setRasterizationOrderDepthAttachmentAccess((member.rasterizationOrderDepthAttachmentAccess));}();}();
[&](){[&](){return builder.setRasterizationOrderStencilAttachmentAccess((member.rasterizationOrderStencilAttachmentAccess));}();}();
}

    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rasterizationOrderColorAttachmentAccess)=reader.getRasterizationOrderColorAttachmentAccess();}();}();
[&](){[&](){(result.rasterizationOrderDepthAttachmentAccess)=reader.getRasterizationOrderDepthAttachmentAccess();}();}();
[&](){[&](){(result.rasterizationOrderStencilAttachmentAccess)=reader.getRasterizationOrderStencilAttachmentAccess();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceLinearColorAttachmentFeaturesNV::Builder& builder, VkPhysicalDeviceLinearColorAttachmentFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setLinearColorAttachment((member.linearColorAttachment));}();}();
}

    VkPhysicalDeviceLinearColorAttachmentFeaturesNV deserialize_struct(stream::VkPhysicalDeviceLinearColorAttachmentFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceLinearColorAttachmentFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.linearColorAttachment)=reader.getLinearColorAttachment();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceLinearColorAttachmentFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceLinearColorAttachmentFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT::Builder& builder, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setGraphicsPipelineLibrary((member.graphicsPipelineLibrary));}();}();
}

    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.graphicsPipelineLibrary)=reader.getGraphicsPipelineLibrary();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT::Builder& builder, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setGraphicsPipelineLibraryFastLinking((member.graphicsPipelineLibraryFastLinking));}();}();
[&](){[&](){return builder.setGraphicsPipelineLibraryIndependentInterpolationDecoration((member.graphicsPipelineLibraryIndependentInterpolationDecoration));}();}();
}

    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.graphicsPipelineLibraryFastLinking)=reader.getGraphicsPipelineLibraryFastLinking();}();}();
[&](){[&](){(result.graphicsPipelineLibraryIndependentInterpolationDecoration)=reader.getGraphicsPipelineLibraryIndependentInterpolationDecoration();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkGraphicsPipelineLibraryCreateInfoEXT::Builder& builder, VkGraphicsPipelineLibraryCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkGraphicsPipelineLibraryCreateInfoEXT deserialize_struct(stream::VkGraphicsPipelineLibraryCreateInfoEXT::Reader reader){
        auto result=VkGraphicsPipelineLibraryCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkGraphicsPipelineLibraryCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkGraphicsPipelineLibraryCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE::Builder& builder, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDescriptorSetHostMapping((member.descriptorSetHostMapping));}();}();
}

    VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE deserialize_struct(stream::VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE::Reader reader){
        auto result=VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.descriptorSetHostMapping)=reader.getDescriptorSetHostMapping();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetBindingReferenceVALVE::Builder& builder, VkDescriptorSetBindingReferenceVALVE member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDescriptorSetLayout(serialize_handle(member.descriptorSetLayout));}();
[&](){return builder.setBinding((member.binding));}();
}

    VkDescriptorSetBindingReferenceVALVE deserialize_struct(stream::VkDescriptorSetBindingReferenceVALVE::Reader reader){
        auto result=VkDescriptorSetBindingReferenceVALVE();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.descriptorSetLayout)=deserialize_VkDescriptorSetLayout(reader.getDescriptorSetLayout());}();
[&](){(result.binding)=reader.getBinding();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetBindingReferenceVALVE member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetBindingReferenceVALVE member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDescriptorSetLayoutHostMappingInfoVALVE::Builder& builder, VkDescriptorSetLayoutHostMappingInfoVALVE member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDescriptorOffset((member.descriptorOffset));}();
[&](){return builder.setDescriptorSize((member.descriptorSize));}();
}

    VkDescriptorSetLayoutHostMappingInfoVALVE deserialize_struct(stream::VkDescriptorSetLayoutHostMappingInfoVALVE::Reader reader){
        auto result=VkDescriptorSetLayoutHostMappingInfoVALVE();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.descriptorOffset)=reader.getDescriptorOffset();}();
[&](){(result.descriptorSize)=reader.getDescriptorSize();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDescriptorSetLayoutHostMappingInfoVALVE member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDescriptorSetLayoutHostMappingInfoVALVE member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT::Builder& builder, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderModuleIdentifier((member.shaderModuleIdentifier));}();}();
}

    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderModuleIdentifier)=reader.getShaderModuleIdentifier();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT::Builder& builder, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initShaderModuleIdentifierAlgorithmUUID(VK_UUID_SIZE);
        for(int KnKbJaC=0; KnKbJaC < VK_UUID_SIZE; KnKbJaC++){
            [&](){return proto_arr.set(KnKbJaC,((member.shaderModuleIdentifierAlgorithmUUID)[KnKbJaC]));}();
        }
        }();
}

    VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getShaderModuleIdentifierAlgorithmUUID(VK_UUID_SIZE);
        for(int KnKbJaC=0; KnKbJaC < VK_UUID_SIZE; KnKbJaC++){
            [&](){((result.shaderModuleIdentifierAlgorithmUUID)[KnKbJaC])=proto_arr[KnKbJaC];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineShaderStageModuleIdentifierCreateInfoEXT::Builder& builder, VkPipelineShaderStageModuleIdentifierCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setIdentifierSize((member.identifierSize));}();
[&](){
            if ((member.pIdentifier)==NULL){
                builder.initPIdentifier(0);
            return; }
        auto proto_arr=builder.initPIdentifier(member.identifierSize);
        for(int DmBzRet=0; DmBzRet < member.identifierSize; DmBzRet++){
            [&](){return proto_arr.set(DmBzRet,((member.pIdentifier)[DmBzRet]));}();
        }
        }();
}

    VkPipelineShaderStageModuleIdentifierCreateInfoEXT deserialize_struct(stream::VkPipelineShaderStageModuleIdentifierCreateInfoEXT::Reader reader){
        auto result=VkPipelineShaderStageModuleIdentifierCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.identifierSize)=reader.getIdentifierSize();}();
[&](){ uint8_t* temp_rLkDPhT[&](){
            if (!reader.getPIdentifier().size()==0){
                (result.pIdentifier)=NULL;
            return; }{native_concat()}=(uint8_t*)malloc(result.identifierSize*sizeof(uint8_t));
        auto proto_arr=reader.getPIdentifier(result.identifierSize);
        for(int wMKTMIh=0; wMKTMIh < result.identifierSize; wMKTMIh++){
            [&](){((result.pIdentifier)[wMKTMIh])=proto_arr[wMKTMIh];}();
        }
        }();(result.pIdentifier)=temp_rLkDPhT;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineShaderStageModuleIdentifierCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineShaderStageModuleIdentifierCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkShaderModuleIdentifierEXT::Builder& builder, VkShaderModuleIdentifierEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setIdentifierSize((member.identifierSize));}();
[&](){
        auto proto_arr=builder.initIdentifier(VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT);
        for(int FYYsgLr=0; FYYsgLr < VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT; FYYsgLr++){
            [&](){return proto_arr.set(FYYsgLr,((member.identifier)[FYYsgLr]));}();
        }
        }();
}

    VkShaderModuleIdentifierEXT deserialize_struct(stream::VkShaderModuleIdentifierEXT::Reader reader){
        auto result=VkShaderModuleIdentifierEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.identifierSize)=reader.getIdentifierSize();}();
[&](){
        auto proto_arr=reader.getIdentifier(VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT);
        for(int FYYsgLr=0; FYYsgLr < VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT; FYYsgLr++){
            [&](){((result.identifier)[FYYsgLr])=proto_arr[FYYsgLr];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkShaderModuleIdentifierEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkShaderModuleIdentifierEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageCompressionControlEXT::Builder& builder, VkImageCompressionControlEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setCompressionControlPlaneCount((member.compressionControlPlaneCount));}();
[&](){
            if ((member.pFixedRateFlags)==NULL){
                builder.initPFixedRateFlags(0);
            return; }
        auto proto_arr=builder.initPFixedRateFlags(member.compressionControlPlaneCount);
        for(int YdHtGOk=0; YdHtGOk < member.compressionControlPlaneCount; YdHtGOk++){
            [&](){[&](){[&](){return proto_arr.set(YdHtGOk,((member.pFixedRateFlags)[YdHtGOk]));}();}();}();
        }
        }();
}

    VkImageCompressionControlEXT deserialize_struct(stream::VkImageCompressionControlEXT::Reader reader){
        auto result=VkImageCompressionControlEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.compressionControlPlaneCount)=reader.getCompressionControlPlaneCount();}();
[&](){
            if (!reader.getPFixedRateFlags().size()==0){
                (result.pFixedRateFlags)=NULL;
            return; }{native_concat()}=(VkImageCompressionFixedRateFlagsEXT*)malloc(result.compressionControlPlaneCount*sizeof(VkImageCompressionFixedRateFlagsEXT));
        auto proto_arr=reader.getPFixedRateFlags(result.compressionControlPlaneCount);
        for(int YdHtGOk=0; YdHtGOk < result.compressionControlPlaneCount; YdHtGOk++){
            [&](){[&](){[&](){((result.pFixedRateFlags)[YdHtGOk])=proto_arr[YdHtGOk];}();}();}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageCompressionControlEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageCompressionControlEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageCompressionControlFeaturesEXT::Builder& builder, VkPhysicalDeviceImageCompressionControlFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setImageCompressionControl((member.imageCompressionControl));}();}();
}

    VkPhysicalDeviceImageCompressionControlFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceImageCompressionControlFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceImageCompressionControlFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.imageCompressionControl)=reader.getImageCompressionControl();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageCompressionControlFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageCompressionControlFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageCompressionPropertiesEXT::Builder& builder, VkImageCompressionPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setImageCompressionFlags((member.imageCompressionFlags));}();}();}();
[&](){[&](){[&](){return builder.setImageCompressionFixedRateFlags((member.imageCompressionFixedRateFlags));}();}();}();
}

    VkImageCompressionPropertiesEXT deserialize_struct(stream::VkImageCompressionPropertiesEXT::Reader reader){
        auto result=VkImageCompressionPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.imageCompressionFlags)=reader.getImageCompressionFlags();}();}();}();
[&](){[&](){[&](){(result.imageCompressionFixedRateFlags)=reader.getImageCompressionFixedRateFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageCompressionPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageCompressionPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT::Builder& builder, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setImageCompressionControlSwapchain((member.imageCompressionControlSwapchain));}();}();
}

    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.imageCompressionControlSwapchain)=reader.getImageCompressionControlSwapchain();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageSubresource2KHR::Builder& builder, VkImageSubresource2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initImageSubresource(imageSubresource);
            return serialize_struct(temp, (member.imageSubresource));
            }();
}

    VkImageSubresource2KHR deserialize_struct(stream::VkImageSubresource2KHR::Reader reader){
        auto result=VkImageSubresource2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getImageSubresource();
            (result.imageSubresource)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageSubresource2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageSubresource2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSubresourceLayout2KHR::Builder& builder, VkSubresourceLayout2KHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSubresourceLayout(subresourceLayout);
            return serialize_struct(temp, (member.subresourceLayout));
            }();
}

    VkSubresourceLayout2KHR deserialize_struct(stream::VkSubresourceLayout2KHR::Reader reader){
        auto result=VkSubresourceLayout2KHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getSubresourceLayout();
            (result.subresourceLayout)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSubresourceLayout2KHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSubresourceLayout2KHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassCreationControlEXT::Builder& builder, VkRenderPassCreationControlEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDisallowMerging((member.disallowMerging));}();}();
}

    VkRenderPassCreationControlEXT deserialize_struct(stream::VkRenderPassCreationControlEXT::Reader reader){
        auto result=VkRenderPassCreationControlEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.disallowMerging)=reader.getDisallowMerging();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassCreationControlEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassCreationControlEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassCreationFeedbackInfoEXT::Builder& builder, VkRenderPassCreationFeedbackInfoEXT member){
        
    
[&](){return builder.setPostMergeSubpassCount((member.postMergeSubpassCount));}();
}

    VkRenderPassCreationFeedbackInfoEXT deserialize_struct(stream::VkRenderPassCreationFeedbackInfoEXT::Reader reader){
        auto result=VkRenderPassCreationFeedbackInfoEXT();
    
[&](){(result.postMergeSubpassCount)=reader.getPostMergeSubpassCount();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassCreationFeedbackInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassCreationFeedbackInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassCreationFeedbackCreateInfoEXT::Builder& builder, VkRenderPassCreationFeedbackCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pRenderPassFeedback)==NULL){
                builder.initPRenderPassFeedback(0);
            return; }
        auto proto_arr=builder.initPRenderPassFeedback(1);
        for(int vxiUcYZ=0; vxiUcYZ < 1; vxiUcYZ++){
            [&](){
            auto temp=proto_arr[vxiUcYZ];
            return serialize_struct(temp, ((member.pRenderPassFeedback)[vxiUcYZ]));
            }();
        }
        }();
}

    VkRenderPassCreationFeedbackCreateInfoEXT deserialize_struct(stream::VkRenderPassCreationFeedbackCreateInfoEXT::Reader reader){
        auto result=VkRenderPassCreationFeedbackCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            if (!reader.getPRenderPassFeedback().size()==0){
                (result.pRenderPassFeedback)=NULL;
            return; }{native_concat()}=(VkRenderPassCreationFeedbackInfoEXT*)malloc(1*sizeof(VkRenderPassCreationFeedbackInfoEXT));
        auto proto_arr=reader.getPRenderPassFeedback(1);
        for(int vxiUcYZ=0; vxiUcYZ < 1; vxiUcYZ++){
            [&](){
            auto temp=proto_arr[vxiUcYZ];
            ((result.pRenderPassFeedback)[vxiUcYZ])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassCreationFeedbackCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassCreationFeedbackCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassSubpassFeedbackInfoEXT::Builder& builder, VkRenderPassSubpassFeedbackInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSubpassMergeStatus((member.subpassMergeStatus));}();}();}();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
[&](){return builder.setPostMergeIndex((member.postMergeIndex));}();
}

    VkRenderPassSubpassFeedbackInfoEXT deserialize_struct(stream::VkRenderPassSubpassFeedbackInfoEXT::Reader reader){
        auto result=VkRenderPassSubpassFeedbackInfoEXT();
    
[&](){[&](){[&](){(result.subpassMergeStatus)=reader.getSubpassMergeStatus();}();}();}();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
[&](){(result.postMergeIndex)=reader.getPostMergeIndex();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassSubpassFeedbackInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassSubpassFeedbackInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkRenderPassSubpassFeedbackCreateInfoEXT::Builder& builder, VkRenderPassSubpassFeedbackCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pSubpassFeedback)==NULL){
                builder.initPSubpassFeedback(0);
            return; }
        auto proto_arr=builder.initPSubpassFeedback(1);
        for(int hutaZSO=0; hutaZSO < 1; hutaZSO++){
            [&](){
            auto temp=proto_arr[hutaZSO];
            return serialize_struct(temp, ((member.pSubpassFeedback)[hutaZSO]));
            }();
        }
        }();
}

    VkRenderPassSubpassFeedbackCreateInfoEXT deserialize_struct(stream::VkRenderPassSubpassFeedbackCreateInfoEXT::Reader reader){
        auto result=VkRenderPassSubpassFeedbackCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            if (!reader.getPSubpassFeedback().size()==0){
                (result.pSubpassFeedback)=NULL;
            return; }{native_concat()}=(VkRenderPassSubpassFeedbackInfoEXT*)malloc(1*sizeof(VkRenderPassSubpassFeedbackInfoEXT));
        auto proto_arr=reader.getPSubpassFeedback(1);
        for(int hutaZSO=0; hutaZSO < 1; hutaZSO++){
            [&](){
            auto temp=proto_arr[hutaZSO];
            ((result.pSubpassFeedback)[hutaZSO])=deserialize_struct(temp);
            }();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkRenderPassSubpassFeedbackCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkRenderPassSubpassFeedbackCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT::Builder& builder, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSubpassMergeFeedback((member.subpassMergeFeedback));}();}();
}

    VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.subpassMergeFeedback)=reader.getSubpassMergeFeedback();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMicromapBuildInfoEXT::Builder& builder, VkMicromapBuildInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
[&](){return builder.setDstMicromap(serialize_handle(member.dstMicromap));}();
[&](){return builder.setUsageCountsCount((member.usageCountsCount));}();
[&](){
            if ((member.pUsageCounts)==NULL){
                builder.initPUsageCounts(0);
            return; }
        auto proto_arr=builder.initPUsageCounts(member.usageCountsCount);
        for(int pwlCVvr=0; pwlCVvr < member.usageCountsCount; pwlCVvr++){
            [&](){
            auto temp=proto_arr[pwlCVvr];
            return serialize_struct(temp, ((member.pUsageCounts)[pwlCVvr]));
            }();
        }
        }();
[&](){
            if ((member.ppUsageCounts)==NULL){
                builder.initPpUsageCounts(0);
            return; }
        auto proto_arr=builder.initPpUsageCounts(member.usageCountsCount);
        for(int mENrsNk=0; mENrsNk < member.usageCountsCount; mENrsNk++){
            [&](){
            if (((member.ppUsageCounts)[mENrsNk])==NULL){
                proto_arr[mENrsNk];
            return; }
        auto proto_arr=proto_arr[mENrsNk];
        for(int NPAhOuj=0; NPAhOuj < 1; NPAhOuj++){
            [&](){
            auto temp=proto_arr[NPAhOuj];
            return serialize_struct(temp, (((member.ppUsageCounts)[mENrsNk])[NPAhOuj]));
            }();
        }
        }();
        }
        }();
[&](){
            auto temp=builder.initData(data);
            return serialize_struct(temp, (member.data));
            }();
[&](){
            auto temp=builder.initScratchData(scratchData);
            return serialize_struct(temp, (member.scratchData));
            }();
[&](){
            auto temp=builder.initTriangleArray(triangleArray);
            return serialize_struct(temp, (member.triangleArray));
            }();
[&](){[&](){return builder.setTriangleArrayStride((member.triangleArrayStride));}();}();
}

    VkMicromapBuildInfoEXT deserialize_struct(stream::VkMicromapBuildInfoEXT::Reader reader){
        auto result=VkMicromapBuildInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
[&](){(result.dstMicromap)=deserialize_VkMicromapEXT(reader.getDstMicromap());}();
[&](){(result.usageCountsCount)=reader.getUsageCountsCount();}();
[&](){ VkMicromapUsageEXT* temp_dZUFBkW[&](){
            if (!reader.getPUsageCounts().size()==0){
                (result.pUsageCounts)=NULL;
            return; }{native_concat()}=(VkMicromapUsageEXT*)malloc(result.usageCountsCount*sizeof(VkMicromapUsageEXT));
        auto proto_arr=reader.getPUsageCounts(result.usageCountsCount);
        for(int TeZtOHY=0; TeZtOHY < result.usageCountsCount; TeZtOHY++){
            [&](){
            auto temp=proto_arr[TeZtOHY];
            ((result.pUsageCounts)[TeZtOHY])=deserialize_struct(temp);
            }();
        }
        }();(result.pUsageCounts)=temp_dZUFBkW;}();
[&](){ VkMicromapUsageEXT* * temp_ShrFTLH[&](){
            if (!reader.getPpUsageCounts().size()==0){
                (result.ppUsageCounts)=NULL;
            return; }{native_concat()}=(VkMicromapUsageEXT**)malloc(result.usageCountsCount*sizeof(VkMicromapUsageEXT*));
        auto proto_arr=reader.getPpUsageCounts(result.usageCountsCount);
        for(int MkxskvU=0; MkxskvU < result.usageCountsCount; MkxskvU++){
            [&](){
            if (!proto_arr[MkxskvU].size()==0){
                ((result.ppUsageCounts)[MkxskvU])=NULL;
            return; }{native_concat()}=(VkMicromapUsageEXT*)malloc(1*sizeof(VkMicromapUsageEXT));
        auto proto_arr=proto_arr[MkxskvU];
        for(int hNHlthr=0; hNHlthr < 1; hNHlthr++){
            [&](){
            auto temp=proto_arr[hNHlthr];
            (((result.ppUsageCounts)[MkxskvU])[hNHlthr])=deserialize_struct(temp);
            }();
        }
        }();
        }
        }();(result.ppUsageCounts)=temp_ShrFTLH;}();
[&](){
            auto temp=reader.getData();
            (result.data)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getScratchData();
            (result.scratchData)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getTriangleArray();
            (result.triangleArray)=deserialize_struct(temp);
            }();
[&](){[&](){(result.triangleArrayStride)=reader.getTriangleArrayStride();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMicromapBuildInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMicromapBuildInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMicromapCreateInfoEXT::Builder& builder, VkMicromapCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCreateFlags((member.createFlags));}();}();}();
[&](){return builder.setBuffer(serialize_handle(member.buffer));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){[&](){return builder.setType((member.type));}();}();}();
[&](){[&](){return builder.setDeviceAddress((member.deviceAddress));}();}();
}

    VkMicromapCreateInfoEXT deserialize_struct(stream::VkMicromapCreateInfoEXT::Reader reader){
        auto result=VkMicromapCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.createFlags)=reader.getCreateFlags();}();}();}();
[&](){(result.buffer)=deserialize_VkBuffer(reader.getBuffer());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){[&](){(result.type)=reader.getType();}();}();}();
[&](){[&](){(result.deviceAddress)=reader.getDeviceAddress();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMicromapCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMicromapCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMicromapVersionInfoEXT::Builder& builder, VkMicromapVersionInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pVersionData)==NULL){
                builder.initPVersionData(0);
            return; }
        auto proto_arr=builder.initPVersionData(2*VK_UUID_SIZE);
        for(int UXnQvHZ=0; UXnQvHZ < 2*VK_UUID_SIZE; UXnQvHZ++){
            [&](){return proto_arr.set(UXnQvHZ,((member.pVersionData)[UXnQvHZ]));}();
        }
        }();
}

    VkMicromapVersionInfoEXT deserialize_struct(stream::VkMicromapVersionInfoEXT::Reader reader){
        auto result=VkMicromapVersionInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ uint8_t* temp_kcsYiSk[&](){
            if (!reader.getPVersionData().size()==0){
                (result.pVersionData)=NULL;
            return; }{native_concat()}=(uint8_t*)malloc(2*VK_UUID_SIZE*sizeof(uint8_t));
        auto proto_arr=reader.getPVersionData(2*VK_UUID_SIZE);
        for(int aPYYtKH=0; aPYYtKH < 2*VK_UUID_SIZE; aPYYtKH++){
            [&](){((result.pVersionData)[aPYYtKH])=proto_arr[aPYYtKH];}();
        }
        }();(result.pVersionData)=temp_kcsYiSk;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMicromapVersionInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMicromapVersionInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyMicromapInfoEXT::Builder& builder, VkCopyMicromapInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrc(serialize_handle(member.src));}();
[&](){return builder.setDst(serialize_handle(member.dst));}();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
}

    VkCopyMicromapInfoEXT deserialize_struct(stream::VkCopyMicromapInfoEXT::Reader reader){
        auto result=VkCopyMicromapInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.src)=deserialize_VkMicromapEXT(reader.getSrc());}();
[&](){(result.dst)=deserialize_VkMicromapEXT(reader.getDst());}();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyMicromapInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyMicromapInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyMicromapToMemoryInfoEXT::Builder& builder, VkCopyMicromapToMemoryInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSrc(serialize_handle(member.src));}();
[&](){
            auto temp=builder.initDst(dst);
            return serialize_struct(temp, (member.dst));
            }();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
}

    VkCopyMicromapToMemoryInfoEXT deserialize_struct(stream::VkCopyMicromapToMemoryInfoEXT::Reader reader){
        auto result=VkCopyMicromapToMemoryInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.src)=deserialize_VkMicromapEXT(reader.getSrc());}();
[&](){
            auto temp=reader.getDst();
            (result.dst)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyMicromapToMemoryInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyMicromapToMemoryInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCopyMemoryToMicromapInfoEXT::Builder& builder, VkCopyMemoryToMicromapInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initSrc(src);
            return serialize_struct(temp, (member.src));
            }();
[&](){return builder.setDst(serialize_handle(member.dst));}();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
}

    VkCopyMemoryToMicromapInfoEXT deserialize_struct(stream::VkCopyMemoryToMicromapInfoEXT::Reader reader){
        auto result=VkCopyMemoryToMicromapInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getSrc();
            (result.src)=deserialize_struct(temp);
            }();
[&](){(result.dst)=deserialize_VkMicromapEXT(reader.getDst());}();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCopyMemoryToMicromapInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCopyMemoryToMicromapInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMicromapBuildSizesInfoEXT::Builder& builder, VkMicromapBuildSizesInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMicromapSize((member.micromapSize));}();}();
[&](){[&](){return builder.setBuildScratchSize((member.buildScratchSize));}();}();
[&](){[&](){return builder.setDiscardable((member.discardable));}();}();
}

    VkMicromapBuildSizesInfoEXT deserialize_struct(stream::VkMicromapBuildSizesInfoEXT::Reader reader){
        auto result=VkMicromapBuildSizesInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.micromapSize)=reader.getMicromapSize();}();}();
[&](){[&](){(result.buildScratchSize)=reader.getBuildScratchSize();}();}();
[&](){[&](){(result.discardable)=reader.getDiscardable();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMicromapBuildSizesInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMicromapBuildSizesInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMicromapUsageEXT::Builder& builder, VkMicromapUsageEXT member){
        
    
[&](){return builder.setCount((member.count));}();
[&](){return builder.setSubdivisionLevel((member.subdivisionLevel));}();
[&](){return builder.setFormat((member.format));}();
}

    VkMicromapUsageEXT deserialize_struct(stream::VkMicromapUsageEXT::Reader reader){
        auto result=VkMicromapUsageEXT();
    
[&](){(result.count)=reader.getCount();}();
[&](){(result.subdivisionLevel)=reader.getSubdivisionLevel();}();
[&](){(result.format)=reader.getFormat();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMicromapUsageEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMicromapUsageEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMicromapTriangleEXT::Builder& builder, VkMicromapTriangleEXT member){
        
    
[&](){return builder.setDataOffset((member.dataOffset));}();
[&](){return builder.setSubdivisionLevel((member.subdivisionLevel));}();
[&](){return builder.setFormat((member.format));}();
}

    VkMicromapTriangleEXT deserialize_struct(stream::VkMicromapTriangleEXT::Reader reader){
        auto result=VkMicromapTriangleEXT();
    
[&](){(result.dataOffset)=reader.getDataOffset();}();
[&](){(result.subdivisionLevel)=reader.getSubdivisionLevel();}();
[&](){(result.format)=reader.getFormat();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMicromapTriangleEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMicromapTriangleEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceOpacityMicromapFeaturesEXT::Builder& builder, VkPhysicalDeviceOpacityMicromapFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMicromap((member.micromap));}();}();
[&](){[&](){return builder.setMicromapCaptureReplay((member.micromapCaptureReplay));}();}();
[&](){[&](){return builder.setMicromapHostCommands((member.micromapHostCommands));}();}();
}

    VkPhysicalDeviceOpacityMicromapFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceOpacityMicromapFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceOpacityMicromapFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.micromap)=reader.getMicromap();}();}();
[&](){[&](){(result.micromapCaptureReplay)=reader.getMicromapCaptureReplay();}();}();
[&](){[&](){(result.micromapHostCommands)=reader.getMicromapHostCommands();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceOpacityMicromapFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceOpacityMicromapFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceOpacityMicromapPropertiesEXT::Builder& builder, VkPhysicalDeviceOpacityMicromapPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxOpacity2StateSubdivisionLevel((member.maxOpacity2StateSubdivisionLevel));}();
[&](){return builder.setMaxOpacity4StateSubdivisionLevel((member.maxOpacity4StateSubdivisionLevel));}();
}

    VkPhysicalDeviceOpacityMicromapPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceOpacityMicromapPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceOpacityMicromapPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxOpacity2StateSubdivisionLevel)=reader.getMaxOpacity2StateSubdivisionLevel();}();
[&](){(result.maxOpacity4StateSubdivisionLevel)=reader.getMaxOpacity4StateSubdivisionLevel();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceOpacityMicromapPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceOpacityMicromapPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAccelerationStructureTrianglesOpacityMicromapEXT::Builder& builder, VkAccelerationStructureTrianglesOpacityMicromapEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setIndexType((member.indexType));}();}();}();
[&](){
            auto temp=builder.initIndexBuffer(indexBuffer);
            return serialize_struct(temp, (member.indexBuffer));
            }();
[&](){[&](){return builder.setIndexStride((member.indexStride));}();}();
[&](){return builder.setBaseTriangle((member.baseTriangle));}();
[&](){return builder.setUsageCountsCount((member.usageCountsCount));}();
[&](){
            if ((member.pUsageCounts)==NULL){
                builder.initPUsageCounts(0);
            return; }
        auto proto_arr=builder.initPUsageCounts(member.usageCountsCount);
        for(int pwlCVvr=0; pwlCVvr < member.usageCountsCount; pwlCVvr++){
            [&](){
            auto temp=proto_arr[pwlCVvr];
            return serialize_struct(temp, ((member.pUsageCounts)[pwlCVvr]));
            }();
        }
        }();
[&](){
            if ((member.ppUsageCounts)==NULL){
                builder.initPpUsageCounts(0);
            return; }
        auto proto_arr=builder.initPpUsageCounts(member.usageCountsCount);
        for(int mENrsNk=0; mENrsNk < member.usageCountsCount; mENrsNk++){
            [&](){
            if (((member.ppUsageCounts)[mENrsNk])==NULL){
                proto_arr[mENrsNk];
            return; }
        auto proto_arr=proto_arr[mENrsNk];
        for(int NPAhOuj=0; NPAhOuj < 1; NPAhOuj++){
            [&](){
            auto temp=proto_arr[NPAhOuj];
            return serialize_struct(temp, (((member.ppUsageCounts)[mENrsNk])[NPAhOuj]));
            }();
        }
        }();
        }
        }();
[&](){return builder.setMicromap(serialize_handle(member.micromap));}();
}

    VkAccelerationStructureTrianglesOpacityMicromapEXT deserialize_struct(stream::VkAccelerationStructureTrianglesOpacityMicromapEXT::Reader reader){
        auto result=VkAccelerationStructureTrianglesOpacityMicromapEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.indexType)=reader.getIndexType();}();}();}();
[&](){
            auto temp=reader.getIndexBuffer();
            (result.indexBuffer)=deserialize_struct(temp);
            }();
[&](){[&](){(result.indexStride)=reader.getIndexStride();}();}();
[&](){(result.baseTriangle)=reader.getBaseTriangle();}();
[&](){(result.usageCountsCount)=reader.getUsageCountsCount();}();
[&](){ VkMicromapUsageEXT* temp_dZUFBkW[&](){
            if (!reader.getPUsageCounts().size()==0){
                (result.pUsageCounts)=NULL;
            return; }{native_concat()}=(VkMicromapUsageEXT*)malloc(result.usageCountsCount*sizeof(VkMicromapUsageEXT));
        auto proto_arr=reader.getPUsageCounts(result.usageCountsCount);
        for(int TeZtOHY=0; TeZtOHY < result.usageCountsCount; TeZtOHY++){
            [&](){
            auto temp=proto_arr[TeZtOHY];
            ((result.pUsageCounts)[TeZtOHY])=deserialize_struct(temp);
            }();
        }
        }();(result.pUsageCounts)=temp_dZUFBkW;}();
[&](){ VkMicromapUsageEXT* * temp_ShrFTLH[&](){
            if (!reader.getPpUsageCounts().size()==0){
                (result.ppUsageCounts)=NULL;
            return; }{native_concat()}=(VkMicromapUsageEXT**)malloc(result.usageCountsCount*sizeof(VkMicromapUsageEXT*));
        auto proto_arr=reader.getPpUsageCounts(result.usageCountsCount);
        for(int MkxskvU=0; MkxskvU < result.usageCountsCount; MkxskvU++){
            [&](){
            if (!proto_arr[MkxskvU].size()==0){
                ((result.ppUsageCounts)[MkxskvU])=NULL;
            return; }{native_concat()}=(VkMicromapUsageEXT*)malloc(1*sizeof(VkMicromapUsageEXT));
        auto proto_arr=proto_arr[MkxskvU];
        for(int hNHlthr=0; hNHlthr < 1; hNHlthr++){
            [&](){
            auto temp=proto_arr[hNHlthr];
            (((result.ppUsageCounts)[MkxskvU])[hNHlthr])=deserialize_struct(temp);
            }();
        }
        }();
        }
        }();(result.ppUsageCounts)=temp_ShrFTLH;}();
[&](){(result.micromap)=deserialize_VkMicromapEXT(reader.getMicromap());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAccelerationStructureTrianglesOpacityMicromapEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAccelerationStructureTrianglesOpacityMicromapEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelinePropertiesIdentifierEXT::Builder& builder, VkPipelinePropertiesIdentifierEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initPipelineIdentifier(VK_UUID_SIZE);
        for(int vbeUhnR=0; vbeUhnR < VK_UUID_SIZE; vbeUhnR++){
            [&](){return proto_arr.set(vbeUhnR,((member.pipelineIdentifier)[vbeUhnR]));}();
        }
        }();
}

    VkPipelinePropertiesIdentifierEXT deserialize_struct(stream::VkPipelinePropertiesIdentifierEXT::Reader reader){
        auto result=VkPipelinePropertiesIdentifierEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getPipelineIdentifier(VK_UUID_SIZE);
        for(int vbeUhnR=0; vbeUhnR < VK_UUID_SIZE; vbeUhnR++){
            [&](){((result.pipelineIdentifier)[vbeUhnR])=proto_arr[vbeUhnR];}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelinePropertiesIdentifierEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelinePropertiesIdentifierEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePipelinePropertiesFeaturesEXT::Builder& builder, VkPhysicalDevicePipelinePropertiesFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPipelinePropertiesIdentifier((member.pipelinePropertiesIdentifier));}();}();
}

    VkPhysicalDevicePipelinePropertiesFeaturesEXT deserialize_struct(stream::VkPhysicalDevicePipelinePropertiesFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevicePipelinePropertiesFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pipelinePropertiesIdentifier)=reader.getPipelinePropertiesIdentifier();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePipelinePropertiesFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePipelinePropertiesFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD::Builder& builder, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderEarlyAndLateFragmentTests((member.shaderEarlyAndLateFragmentTests));}();}();
}

    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD deserialize_struct(stream::VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD::Reader reader){
        auto result=VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderEarlyAndLateFragmentTests)=reader.getShaderEarlyAndLateFragmentTests();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkExternalMemoryAcquireUnmodifiedEXT::Builder& builder, VkExternalMemoryAcquireUnmodifiedEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAcquireUnmodifiedMemory((member.acquireUnmodifiedMemory));}();}();
}

    VkExternalMemoryAcquireUnmodifiedEXT deserialize_struct(stream::VkExternalMemoryAcquireUnmodifiedEXT::Reader reader){
        auto result=VkExternalMemoryAcquireUnmodifiedEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){(result.acquireUnmodifiedMemory)=reader.getAcquireUnmodifiedMemory();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkExternalMemoryAcquireUnmodifiedEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkExternalMemoryAcquireUnmodifiedEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT::Builder& builder, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setNonSeamlessCubeMap((member.nonSeamlessCubeMap));}();}();
}

    VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.nonSeamlessCubeMap)=reader.getNonSeamlessCubeMap();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePipelineRobustnessFeaturesEXT::Builder& builder, VkPhysicalDevicePipelineRobustnessFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPipelineRobustness((member.pipelineRobustness));}();}();
}

    VkPhysicalDevicePipelineRobustnessFeaturesEXT deserialize_struct(stream::VkPhysicalDevicePipelineRobustnessFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevicePipelineRobustnessFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pipelineRobustness)=reader.getPipelineRobustness();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePipelineRobustnessFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePipelineRobustnessFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPipelineRobustnessCreateInfoEXT::Builder& builder, VkPipelineRobustnessCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setStorageBuffers((member.storageBuffers));}();}();}();
[&](){[&](){[&](){return builder.setUniformBuffers((member.uniformBuffers));}();}();}();
[&](){[&](){[&](){return builder.setVertexInputs((member.vertexInputs));}();}();}();
[&](){[&](){[&](){return builder.setImages((member.images));}();}();}();
}

    VkPipelineRobustnessCreateInfoEXT deserialize_struct(stream::VkPipelineRobustnessCreateInfoEXT::Reader reader){
        auto result=VkPipelineRobustnessCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.storageBuffers)=reader.getStorageBuffers();}();}();}();
[&](){[&](){[&](){(result.uniformBuffers)=reader.getUniformBuffers();}();}();}();
[&](){[&](){[&](){(result.vertexInputs)=reader.getVertexInputs();}();}();}();
[&](){[&](){[&](){(result.images)=reader.getImages();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPipelineRobustnessCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPipelineRobustnessCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePipelineRobustnessPropertiesEXT::Builder& builder, VkPhysicalDevicePipelineRobustnessPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDefaultRobustnessStorageBuffers((member.defaultRobustnessStorageBuffers));}();}();}();
[&](){[&](){[&](){return builder.setDefaultRobustnessUniformBuffers((member.defaultRobustnessUniformBuffers));}();}();}();
[&](){[&](){[&](){return builder.setDefaultRobustnessVertexInputs((member.defaultRobustnessVertexInputs));}();}();}();
[&](){[&](){[&](){return builder.setDefaultRobustnessImages((member.defaultRobustnessImages));}();}();}();
}

    VkPhysicalDevicePipelineRobustnessPropertiesEXT deserialize_struct(stream::VkPhysicalDevicePipelineRobustnessPropertiesEXT::Reader reader){
        auto result=VkPhysicalDevicePipelineRobustnessPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.defaultRobustnessStorageBuffers)=reader.getDefaultRobustnessStorageBuffers();}();}();}();
[&](){[&](){[&](){(result.defaultRobustnessUniformBuffers)=reader.getDefaultRobustnessUniformBuffers();}();}();}();
[&](){[&](){[&](){(result.defaultRobustnessVertexInputs)=reader.getDefaultRobustnessVertexInputs();}();}();}();
[&](){[&](){[&](){(result.defaultRobustnessImages)=reader.getDefaultRobustnessImages();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePipelineRobustnessPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePipelineRobustnessPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkImageViewSampleWeightCreateInfoQCOM::Builder& builder, VkImageViewSampleWeightCreateInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initFilterCenter(filterCenter);
            return serialize_struct(temp, (member.filterCenter));
            }();
[&](){
            auto temp=builder.initFilterSize(filterSize);
            return serialize_struct(temp, (member.filterSize));
            }();
[&](){return builder.setNumPhases((member.numPhases));}();
}

    VkImageViewSampleWeightCreateInfoQCOM deserialize_struct(stream::VkImageViewSampleWeightCreateInfoQCOM::Reader reader){
        auto result=VkImageViewSampleWeightCreateInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getFilterCenter();
            (result.filterCenter)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getFilterSize();
            (result.filterSize)=deserialize_struct(temp);
            }();
[&](){(result.numPhases)=reader.getNumPhases();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkImageViewSampleWeightCreateInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkImageViewSampleWeightCreateInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageProcessingFeaturesQCOM::Builder& builder, VkPhysicalDeviceImageProcessingFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTextureSampleWeighted((member.textureSampleWeighted));}();}();
[&](){[&](){return builder.setTextureBoxFilter((member.textureBoxFilter));}();}();
[&](){[&](){return builder.setTextureBlockMatch((member.textureBlockMatch));}();}();
}

    VkPhysicalDeviceImageProcessingFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceImageProcessingFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceImageProcessingFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.textureSampleWeighted)=reader.getTextureSampleWeighted();}();}();
[&](){[&](){(result.textureBoxFilter)=reader.getTextureBoxFilter();}();}();
[&](){[&](){(result.textureBlockMatch)=reader.getTextureBlockMatch();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageProcessingFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageProcessingFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageProcessingPropertiesQCOM::Builder& builder, VkPhysicalDeviceImageProcessingPropertiesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMaxWeightFilterPhases((member.maxWeightFilterPhases));}();
[&](){
            auto temp=builder.initMaxWeightFilterDimension(maxWeightFilterDimension);
            return serialize_struct(temp, (member.maxWeightFilterDimension));
            }();
[&](){
            auto temp=builder.initMaxBlockMatchRegion(maxBlockMatchRegion);
            return serialize_struct(temp, (member.maxBlockMatchRegion));
            }();
[&](){
            auto temp=builder.initMaxBoxFilterBlockSize(maxBoxFilterBlockSize);
            return serialize_struct(temp, (member.maxBoxFilterBlockSize));
            }();
}

    VkPhysicalDeviceImageProcessingPropertiesQCOM deserialize_struct(stream::VkPhysicalDeviceImageProcessingPropertiesQCOM::Reader reader){
        auto result=VkPhysicalDeviceImageProcessingPropertiesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.maxWeightFilterPhases)=reader.getMaxWeightFilterPhases();}();
[&](){
            auto temp=reader.getMaxWeightFilterDimension();
            (result.maxWeightFilterDimension)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxBlockMatchRegion();
            (result.maxBlockMatchRegion)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxBoxFilterBlockSize();
            (result.maxBoxFilterBlockSize)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageProcessingPropertiesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageProcessingPropertiesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceTilePropertiesFeaturesQCOM::Builder& builder, VkPhysicalDeviceTilePropertiesFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTileProperties((member.tileProperties));}();}();
}

    VkPhysicalDeviceTilePropertiesFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceTilePropertiesFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceTilePropertiesFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.tileProperties)=reader.getTileProperties();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceTilePropertiesFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceTilePropertiesFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkTilePropertiesQCOM::Builder& builder, VkTilePropertiesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initTileSize(tileSize);
            return serialize_struct(temp, (member.tileSize));
            }();
[&](){
            auto temp=builder.initApronSize(apronSize);
            return serialize_struct(temp, (member.apronSize));
            }();
[&](){
            auto temp=builder.initOrigin(origin);
            return serialize_struct(temp, (member.origin));
            }();
}

    VkTilePropertiesQCOM deserialize_struct(stream::VkTilePropertiesQCOM::Reader reader){
        auto result=VkTilePropertiesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getTileSize();
            (result.tileSize)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getApronSize();
            (result.apronSize)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getOrigin();
            (result.origin)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkTilePropertiesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkTilePropertiesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceAmigoProfilingFeaturesSEC::Builder& builder, VkPhysicalDeviceAmigoProfilingFeaturesSEC member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAmigoProfiling((member.amigoProfiling));}();}();
}

    VkPhysicalDeviceAmigoProfilingFeaturesSEC deserialize_struct(stream::VkPhysicalDeviceAmigoProfilingFeaturesSEC::Reader reader){
        auto result=VkPhysicalDeviceAmigoProfilingFeaturesSEC();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.amigoProfiling)=reader.getAmigoProfiling();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceAmigoProfilingFeaturesSEC member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceAmigoProfilingFeaturesSEC member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkAmigoProfilingSubmitInfoSEC::Builder& builder, VkAmigoProfilingSubmitInfoSEC member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setFirstDrawTimestamp((member.firstDrawTimestamp));}();
[&](){return builder.setSwapBufferTimestamp((member.swapBufferTimestamp));}();
}

    VkAmigoProfilingSubmitInfoSEC deserialize_struct(stream::VkAmigoProfilingSubmitInfoSEC::Reader reader){
        auto result=VkAmigoProfilingSubmitInfoSEC();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.firstDrawTimestamp)=reader.getFirstDrawTimestamp();}();
[&](){(result.swapBufferTimestamp)=reader.getSwapBufferTimestamp();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkAmigoProfilingSubmitInfoSEC member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkAmigoProfilingSubmitInfoSEC member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT::Builder& builder, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setAttachmentFeedbackLoopLayout((member.attachmentFeedbackLoopLayout));}();}();
}

    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.attachmentFeedbackLoopLayout)=reader.getAttachmentFeedbackLoopLayout();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDepthClampZeroOneFeaturesEXT::Builder& builder, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDepthClampZeroOne((member.depthClampZeroOne));}();}();
}

    VkPhysicalDeviceDepthClampZeroOneFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceDepthClampZeroOneFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceDepthClampZeroOneFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.depthClampZeroOne)=reader.getDepthClampZeroOne();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDepthClampZeroOneFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceAddressBindingReportFeaturesEXT::Builder& builder, VkPhysicalDeviceAddressBindingReportFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setReportAddressBinding((member.reportAddressBinding));}();}();
}

    VkPhysicalDeviceAddressBindingReportFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceAddressBindingReportFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceAddressBindingReportFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.reportAddressBinding)=reader.getReportAddressBinding();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceAddressBindingReportFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceAddressBindingReportFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceAddressBindingCallbackDataEXT::Builder& builder, VkDeviceAddressBindingCallbackDataEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){return builder.setBaseAddress((member.baseAddress));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
[&](){[&](){[&](){return builder.setBindingType((member.bindingType));}();}();}();
}

    VkDeviceAddressBindingCallbackDataEXT deserialize_struct(stream::VkDeviceAddressBindingCallbackDataEXT::Reader reader){
        auto result=VkDeviceAddressBindingCallbackDataEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){(result.baseAddress)=reader.getBaseAddress();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
[&](){[&](){[&](){(result.bindingType)=reader.getBindingType();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceAddressBindingCallbackDataEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceAddressBindingCallbackDataEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceOpticalFlowFeaturesNV::Builder& builder, VkPhysicalDeviceOpticalFlowFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setOpticalFlow((member.opticalFlow));}();}();
}

    VkPhysicalDeviceOpticalFlowFeaturesNV deserialize_struct(stream::VkPhysicalDeviceOpticalFlowFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceOpticalFlowFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.opticalFlow)=reader.getOpticalFlow();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceOpticalFlowFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceOpticalFlowFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceOpticalFlowPropertiesNV::Builder& builder, VkPhysicalDeviceOpticalFlowPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSupportedOutputGridSizes((member.supportedOutputGridSizes));}();}();}();
[&](){[&](){[&](){return builder.setSupportedHintGridSizes((member.supportedHintGridSizes));}();}();}();
[&](){[&](){return builder.setHintSupported((member.hintSupported));}();}();
[&](){[&](){return builder.setCostSupported((member.costSupported));}();}();
[&](){[&](){return builder.setBidirectionalFlowSupported((member.bidirectionalFlowSupported));}();}();
[&](){[&](){return builder.setGlobalFlowSupported((member.globalFlowSupported));}();}();
[&](){return builder.setMinWidth((member.minWidth));}();
[&](){return builder.setMinHeight((member.minHeight));}();
[&](){return builder.setMaxWidth((member.maxWidth));}();
[&](){return builder.setMaxHeight((member.maxHeight));}();
[&](){return builder.setMaxNumRegionsOfInterest((member.maxNumRegionsOfInterest));}();
}

    VkPhysicalDeviceOpticalFlowPropertiesNV deserialize_struct(stream::VkPhysicalDeviceOpticalFlowPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceOpticalFlowPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.supportedOutputGridSizes)=reader.getSupportedOutputGridSizes();}();}();}();
[&](){[&](){[&](){(result.supportedHintGridSizes)=reader.getSupportedHintGridSizes();}();}();}();
[&](){[&](){(result.hintSupported)=reader.getHintSupported();}();}();
[&](){[&](){(result.costSupported)=reader.getCostSupported();}();}();
[&](){[&](){(result.bidirectionalFlowSupported)=reader.getBidirectionalFlowSupported();}();}();
[&](){[&](){(result.globalFlowSupported)=reader.getGlobalFlowSupported();}();}();
[&](){(result.minWidth)=reader.getMinWidth();}();
[&](){(result.minHeight)=reader.getMinHeight();}();
[&](){(result.maxWidth)=reader.getMaxWidth();}();
[&](){(result.maxHeight)=reader.getMaxHeight();}();
[&](){(result.maxNumRegionsOfInterest)=reader.getMaxNumRegionsOfInterest();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceOpticalFlowPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceOpticalFlowPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOpticalFlowImageFormatInfoNV::Builder& builder, VkOpticalFlowImageFormatInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setUsage((member.usage));}();}();}();
}

    VkOpticalFlowImageFormatInfoNV deserialize_struct(stream::VkOpticalFlowImageFormatInfoNV::Reader reader){
        auto result=VkOpticalFlowImageFormatInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.usage)=reader.getUsage();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOpticalFlowImageFormatInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOpticalFlowImageFormatInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOpticalFlowImageFormatPropertiesNV::Builder& builder, VkOpticalFlowImageFormatPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFormat((member.format));}();}();}();
}

    VkOpticalFlowImageFormatPropertiesNV deserialize_struct(stream::VkOpticalFlowImageFormatPropertiesNV::Reader reader){
        auto result=VkOpticalFlowImageFormatPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.format)=reader.getFormat();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOpticalFlowImageFormatPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOpticalFlowImageFormatPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOpticalFlowSessionCreateInfoNV::Builder& builder, VkOpticalFlowSessionCreateInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setWidth((member.width));}();
[&](){return builder.setHeight((member.height));}();
[&](){[&](){[&](){return builder.setImageFormat((member.imageFormat));}();}();}();
[&](){[&](){[&](){return builder.setFlowVectorFormat((member.flowVectorFormat));}();}();}();
[&](){[&](){[&](){return builder.setCostFormat((member.costFormat));}();}();}();
[&](){[&](){[&](){return builder.setOutputGridSize((member.outputGridSize));}();}();}();
[&](){[&](){[&](){return builder.setHintGridSize((member.hintGridSize));}();}();}();
[&](){[&](){[&](){return builder.setPerformanceLevel((member.performanceLevel));}();}();}();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
}

    VkOpticalFlowSessionCreateInfoNV deserialize_struct(stream::VkOpticalFlowSessionCreateInfoNV::Reader reader){
        auto result=VkOpticalFlowSessionCreateInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.width)=reader.getWidth();}();
[&](){(result.height)=reader.getHeight();}();
[&](){[&](){[&](){(result.imageFormat)=reader.getImageFormat();}();}();}();
[&](){[&](){[&](){(result.flowVectorFormat)=reader.getFlowVectorFormat();}();}();}();
[&](){[&](){[&](){(result.costFormat)=reader.getCostFormat();}();}();}();
[&](){[&](){[&](){(result.outputGridSize)=reader.getOutputGridSize();}();}();}();
[&](){[&](){[&](){(result.hintGridSize)=reader.getHintGridSize();}();}();}();
[&](){[&](){[&](){(result.performanceLevel)=reader.getPerformanceLevel();}();}();}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOpticalFlowSessionCreateInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOpticalFlowSessionCreateInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOpticalFlowSessionCreatePrivateDataInfoNV::Builder& builder, VkOpticalFlowSessionCreatePrivateDataInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setId((member.id));}();
[&](){return builder.setSize((member.size));}();
[&](){
            if ((member.pPrivateData)==NULL){
                builder.initPPrivateData(0);
            return; }[&](){
            if (((char*)(member.pPrivateData).pPrivateData)==NULL){
                builder.initPPrivateData(0);
            return; }
        auto proto_arr=builder.initPPrivateData(strlen(((char*)(member.pPrivateData).pPrivateData))+1);
        for(int apNwuhR=0; apNwuhR < strlen(((char*)(member.pPrivateData).pPrivateData))+1; apNwuhR++){
            [&](){return proto_arr.set(apNwuhR,(((char*)(member.pPrivateData).pPrivateData)[apNwuhR]));}();
        }
        }();}();
}

    VkOpticalFlowSessionCreatePrivateDataInfoNV deserialize_struct(stream::VkOpticalFlowSessionCreatePrivateDataInfoNV::Reader reader){
        auto result=VkOpticalFlowSessionCreatePrivateDataInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.id)=reader.getId();}();
[&](){(result.size)=reader.getSize();}();
[&](){ void* temp_ghjOvll[&](){
            if (!reader.getPPrivateData().size()==0){
                (result.pPrivateData)=NULL;
            return; }char* temp_lfGIRIt;[&](){
            if (!reader.getPPrivateData().size()==0){
                (temp_lfGIRIt.pPrivateData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPPrivateData().size();*sizeof(char));
        auto proto_arr=reader.getPPrivateData(reader.getPPrivateData().size(););
        for(int JoEHaqb=0; JoEHaqb < reader.getPPrivateData().size();; JoEHaqb++){
            [&](){((temp_lfGIRIt.pPrivateData)[JoEHaqb])=proto_arr[JoEHaqb];}();
        }
        }();(result.pPrivateData)=temp_lfGIRIt;}();(result.pPrivateData)=temp_ghjOvll;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOpticalFlowSessionCreatePrivateDataInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOpticalFlowSessionCreatePrivateDataInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkOpticalFlowExecuteInfoNV::Builder& builder, VkOpticalFlowExecuteInfoNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setRegionCount((member.regionCount));}();
[&](){
            if ((member.pRegions)==NULL){
                builder.initPRegions(0);
            return; }
        auto proto_arr=builder.initPRegions(member.regionCount);
        for(int OlhHmnZ=0; OlhHmnZ < member.regionCount; OlhHmnZ++){
            [&](){
            auto temp=proto_arr[OlhHmnZ];
            return serialize_struct(temp, ((member.pRegions)[OlhHmnZ]));
            }();
        }
        }();
}

    VkOpticalFlowExecuteInfoNV deserialize_struct(stream::VkOpticalFlowExecuteInfoNV::Reader reader){
        auto result=VkOpticalFlowExecuteInfoNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.regionCount)=reader.getRegionCount();}();
[&](){ VkRect2D* temp_PTyTFgc[&](){
            if (!reader.getPRegions().size()==0){
                (result.pRegions)=NULL;
            return; }{native_concat()}=(VkRect2D*)malloc(result.regionCount*sizeof(VkRect2D));
        auto proto_arr=reader.getPRegions(result.regionCount);
        for(int JAOechs=0; JAOechs < result.regionCount; JAOechs++){
            [&](){
            auto temp=proto_arr[JAOechs];
            ((result.pRegions)[JAOechs])=deserialize_struct(temp);
            }();
        }
        }();(result.pRegions)=temp_PTyTFgc;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkOpticalFlowExecuteInfoNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkOpticalFlowExecuteInfoNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFaultFeaturesEXT::Builder& builder, VkPhysicalDeviceFaultFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDeviceFault((member.deviceFault));}();}();
[&](){[&](){return builder.setDeviceFaultVendorBinary((member.deviceFaultVendorBinary));}();}();
}

    VkPhysicalDeviceFaultFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceFaultFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceFaultFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.deviceFault)=reader.getDeviceFault();}();}();
[&](){[&](){(result.deviceFaultVendorBinary)=reader.getDeviceFaultVendorBinary();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFaultFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFaultFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceFaultAddressInfoEXT::Builder& builder, VkDeviceFaultAddressInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setAddressType((member.addressType));}();}();}();
[&](){[&](){return builder.setReportedAddress((member.reportedAddress));}();}();
[&](){[&](){return builder.setAddressPrecision((member.addressPrecision));}();}();
}

    VkDeviceFaultAddressInfoEXT deserialize_struct(stream::VkDeviceFaultAddressInfoEXT::Reader reader){
        auto result=VkDeviceFaultAddressInfoEXT();
    
[&](){[&](){[&](){(result.addressType)=reader.getAddressType();}();}();}();
[&](){[&](){(result.reportedAddress)=reader.getReportedAddress();}();}();
[&](){[&](){(result.addressPrecision)=reader.getAddressPrecision();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceFaultAddressInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceFaultAddressInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceFaultVendorInfoEXT::Builder& builder, VkDeviceFaultVendorInfoEXT member){
        
    
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
[&](){return builder.setVendorFaultCode((member.vendorFaultCode));}();
[&](){return builder.setVendorFaultData((member.vendorFaultData));}();
}

    VkDeviceFaultVendorInfoEXT deserialize_struct(stream::VkDeviceFaultVendorInfoEXT::Reader reader){
        auto result=VkDeviceFaultVendorInfoEXT();
    
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
[&](){(result.vendorFaultCode)=reader.getVendorFaultCode();}();
[&](){(result.vendorFaultData)=reader.getVendorFaultData();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceFaultVendorInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceFaultVendorInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceFaultCountsEXT::Builder& builder, VkDeviceFaultCountsEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setAddressInfoCount((member.addressInfoCount));}();
[&](){return builder.setVendorInfoCount((member.vendorInfoCount));}();
[&](){[&](){return builder.setVendorBinarySize((member.vendorBinarySize));}();}();
}

    VkDeviceFaultCountsEXT deserialize_struct(stream::VkDeviceFaultCountsEXT::Reader reader){
        auto result=VkDeviceFaultCountsEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.addressInfoCount)=reader.getAddressInfoCount();}();
[&](){(result.vendorInfoCount)=reader.getVendorInfoCount();}();
[&](){[&](){(result.vendorBinarySize)=reader.getVendorBinarySize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceFaultCountsEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceFaultCountsEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceFaultInfoEXT::Builder& builder, VkDeviceFaultInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){return proto_arr.set(oakWTIB,((member.description)[oakWTIB]));}();
        }
        }();
[&](){
            if ((member.pAddressInfos)==NULL){
                builder.initPAddressInfos(0);
            return; }
        auto proto_arr=builder.initPAddressInfos(1);
        for(int QjEnqIT=0; QjEnqIT < 1; QjEnqIT++){
            [&](){
            auto temp=proto_arr[QjEnqIT];
            return serialize_struct(temp, ((member.pAddressInfos)[QjEnqIT]));
            }();
        }
        }();
[&](){
            if ((member.pVendorInfos)==NULL){
                builder.initPVendorInfos(0);
            return; }
        auto proto_arr=builder.initPVendorInfos(1);
        for(int fZmZSvT=0; fZmZSvT < 1; fZmZSvT++){
            [&](){
            auto temp=proto_arr[fZmZSvT];
            return serialize_struct(temp, ((member.pVendorInfos)[fZmZSvT]));
            }();
        }
        }();
[&](){
            if ((member.pVendorBinaryData)==NULL){
                builder.initPVendorBinaryData(0);
            return; }[&](){
            if (((char*)(member.pVendorBinaryData).pVendorBinaryData)==NULL){
                builder.initPVendorBinaryData(0);
            return; }
        auto proto_arr=builder.initPVendorBinaryData(strlen(((char*)(member.pVendorBinaryData).pVendorBinaryData))+1);
        for(int uBxoxYh=0; uBxoxYh < strlen(((char*)(member.pVendorBinaryData).pVendorBinaryData))+1; uBxoxYh++){
            [&](){return proto_arr.set(uBxoxYh,(((char*)(member.pVendorBinaryData).pVendorBinaryData)[uBxoxYh]));}();
        }
        }();}();
}

    VkDeviceFaultInfoEXT deserialize_struct(stream::VkDeviceFaultInfoEXT::Reader reader){
        auto result=VkDeviceFaultInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getDescription(VK_MAX_DESCRIPTION_SIZE);
        for(int oakWTIB=0; oakWTIB < VK_MAX_DESCRIPTION_SIZE; oakWTIB++){
            [&](){((result.description)[oakWTIB])=proto_arr[oakWTIB];}();
        }
        }();
[&](){
            if (!reader.getPAddressInfos().size()==0){
                (result.pAddressInfos)=NULL;
            return; }{native_concat()}=(VkDeviceFaultAddressInfoEXT*)malloc(1*sizeof(VkDeviceFaultAddressInfoEXT));
        auto proto_arr=reader.getPAddressInfos(1);
        for(int QjEnqIT=0; QjEnqIT < 1; QjEnqIT++){
            [&](){
            auto temp=proto_arr[QjEnqIT];
            ((result.pAddressInfos)[QjEnqIT])=deserialize_struct(temp);
            }();
        }
        }();
[&](){
            if (!reader.getPVendorInfos().size()==0){
                (result.pVendorInfos)=NULL;
            return; }{native_concat()}=(VkDeviceFaultVendorInfoEXT*)malloc(1*sizeof(VkDeviceFaultVendorInfoEXT));
        auto proto_arr=reader.getPVendorInfos(1);
        for(int fZmZSvT=0; fZmZSvT < 1; fZmZSvT++){
            [&](){
            auto temp=proto_arr[fZmZSvT];
            ((result.pVendorInfos)[fZmZSvT])=deserialize_struct(temp);
            }();
        }
        }();
[&](){
            if (!reader.getPVendorBinaryData().size()==0){
                (result.pVendorBinaryData)=NULL;
            return; }char* temp_uwlkinv;[&](){
            if (!reader.getPVendorBinaryData().size()==0){
                (temp_uwlkinv.pVendorBinaryData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPVendorBinaryData().size();*sizeof(char));
        auto proto_arr=reader.getPVendorBinaryData(reader.getPVendorBinaryData().size(););
        for(int uBxoxYh=0; uBxoxYh < reader.getPVendorBinaryData().size();; uBxoxYh++){
            [&](){((temp_uwlkinv.pVendorBinaryData)[uBxoxYh])=proto_arr[uBxoxYh];}();
        }
        }();(result.pVendorBinaryData)=temp_uwlkinv;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceFaultInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceFaultInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceFaultVendorBinaryHeaderVersionOneEXT::Builder& builder, VkDeviceFaultVendorBinaryHeaderVersionOneEXT member){
        
    
[&](){return builder.setHeaderSize((member.headerSize));}();
[&](){[&](){[&](){return builder.setHeaderVersion((member.headerVersion));}();}();}();
[&](){return builder.setVendorID((member.vendorID));}();
[&](){return builder.setDeviceID((member.deviceID));}();
[&](){return builder.setDriverVersion((member.driverVersion));}();
[&](){
        auto proto_arr=builder.initPipelineCacheUUID(VK_UUID_SIZE);
        for(int pKnzMjr=0; pKnzMjr < VK_UUID_SIZE; pKnzMjr++){
            [&](){return proto_arr.set(pKnzMjr,((member.pipelineCacheUUID)[pKnzMjr]));}();
        }
        }();
[&](){return builder.setApplicationNameOffset((member.applicationNameOffset));}();
[&](){return builder.setApplicationVersion((member.applicationVersion));}();
[&](){return builder.setEngineNameOffset((member.engineNameOffset));}();
[&](){return builder.setEngineVersion((member.engineVersion));}();
[&](){return builder.setApiVersion((member.apiVersion));}();
}

    VkDeviceFaultVendorBinaryHeaderVersionOneEXT deserialize_struct(stream::VkDeviceFaultVendorBinaryHeaderVersionOneEXT::Reader reader){
        auto result=VkDeviceFaultVendorBinaryHeaderVersionOneEXT();
    
[&](){(result.headerSize)=reader.getHeaderSize();}();
[&](){[&](){[&](){(result.headerVersion)=reader.getHeaderVersion();}();}();}();
[&](){(result.vendorID)=reader.getVendorID();}();
[&](){(result.deviceID)=reader.getDeviceID();}();
[&](){(result.driverVersion)=reader.getDriverVersion();}();
[&](){
        auto proto_arr=reader.getPipelineCacheUUID(VK_UUID_SIZE);
        for(int pKnzMjr=0; pKnzMjr < VK_UUID_SIZE; pKnzMjr++){
            [&](){((result.pipelineCacheUUID)[pKnzMjr])=proto_arr[pKnzMjr];}();
        }
        }();
[&](){(result.applicationNameOffset)=reader.getApplicationNameOffset();}();
[&](){(result.applicationVersion)=reader.getApplicationVersion();}();
[&](){(result.engineNameOffset)=reader.getEngineNameOffset();}();
[&](){(result.engineVersion)=reader.getEngineVersion();}();
[&](){(result.apiVersion)=reader.getApiVersion();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceFaultVendorBinaryHeaderVersionOneEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceFaultVendorBinaryHeaderVersionOneEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT::Builder& builder, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setPipelineLibraryGroupHandles((member.pipelineLibraryGroupHandles));}();}();
}

    VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT deserialize_struct(stream::VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT::Reader reader){
        auto result=VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.pipelineLibraryGroupHandles)=reader.getPipelineLibraryGroupHandles();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDepthBiasInfoEXT::Builder& builder, VkDepthBiasInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setDepthBiasConstantFactor((member.depthBiasConstantFactor));}();
[&](){return builder.setDepthBiasClamp((member.depthBiasClamp));}();
[&](){return builder.setDepthBiasSlopeFactor((member.depthBiasSlopeFactor));}();
}

    VkDepthBiasInfoEXT deserialize_struct(stream::VkDepthBiasInfoEXT::Reader reader){
        auto result=VkDepthBiasInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.depthBiasConstantFactor)=reader.getDepthBiasConstantFactor();}();
[&](){(result.depthBiasClamp)=reader.getDepthBiasClamp();}();
[&](){(result.depthBiasSlopeFactor)=reader.getDepthBiasSlopeFactor();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDepthBiasInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDepthBiasInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDepthBiasRepresentationInfoEXT::Builder& builder, VkDepthBiasRepresentationInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setDepthBiasRepresentation((member.depthBiasRepresentation));}();}();}();
[&](){[&](){return builder.setDepthBiasExact((member.depthBiasExact));}();}();
}

    VkDepthBiasRepresentationInfoEXT deserialize_struct(stream::VkDepthBiasRepresentationInfoEXT::Reader reader){
        auto result=VkDepthBiasRepresentationInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.depthBiasRepresentation)=reader.getDepthBiasRepresentation();}();}();}();
[&](){[&](){(result.depthBiasExact)=reader.getDepthBiasExact();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDepthBiasRepresentationInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDepthBiasRepresentationInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDecompressMemoryRegionNV::Builder& builder, VkDecompressMemoryRegionNV member){
        
    
[&](){[&](){return builder.setSrcAddress((member.srcAddress));}();}();
[&](){[&](){return builder.setDstAddress((member.dstAddress));}();}();
[&](){[&](){return builder.setCompressedSize((member.compressedSize));}();}();
[&](){[&](){return builder.setDecompressedSize((member.decompressedSize));}();}();
[&](){[&](){[&](){return builder.setDecompressionMethod((member.decompressionMethod));}();}();}();
}

    VkDecompressMemoryRegionNV deserialize_struct(stream::VkDecompressMemoryRegionNV::Reader reader){
        auto result=VkDecompressMemoryRegionNV();
    
[&](){[&](){(result.srcAddress)=reader.getSrcAddress();}();}();
[&](){[&](){(result.dstAddress)=reader.getDstAddress();}();}();
[&](){[&](){(result.compressedSize)=reader.getCompressedSize();}();}();
[&](){[&](){(result.decompressedSize)=reader.getDecompressedSize();}();}();
[&](){[&](){[&](){(result.decompressionMethod)=reader.getDecompressionMethod();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDecompressMemoryRegionNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDecompressMemoryRegionNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::Builder& builder, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setShaderCoreMask((member.shaderCoreMask));}();
[&](){return builder.setShaderCoreCount((member.shaderCoreCount));}();
[&](){return builder.setShaderWarpsPerCore((member.shaderWarpsPerCore));}();
}

    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM deserialize_struct(stream::VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::Reader reader){
        auto result=VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.shaderCoreMask)=reader.getShaderCoreMask();}();
[&](){(result.shaderCoreCount)=reader.getShaderCoreCount();}();
[&](){(result.shaderWarpsPerCore)=reader.getShaderWarpsPerCore();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM::Builder& builder, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderCoreBuiltins((member.shaderCoreBuiltins));}();}();
}

    VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM deserialize_struct(stream::VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM::Reader reader){
        auto result=VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderCoreBuiltins)=reader.getShaderCoreBuiltins();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkFrameBoundaryEXT::Builder& builder, VkFrameBoundaryEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setFrameID((member.frameID));}();
[&](){return builder.setImageCount((member.imageCount));}();
[&](){
            if ((member.pImages)==NULL){
                builder.initPImages(0);
            return; }
        auto proto_arr=builder.initPImages(member.imageCount);
        for(int bDkiYkB=0; bDkiYkB < member.imageCount; bDkiYkB++){
            [&](){return proto_arr.set(bDkiYkB,serialize_handle((member.pImages)[bDkiYkB]));}();
        }
        }();
[&](){return builder.setBufferCount((member.bufferCount));}();
[&](){
            if ((member.pBuffers)==NULL){
                builder.initPBuffers(0);
            return; }
        auto proto_arr=builder.initPBuffers(member.bufferCount);
        for(int dnzUVcs=0; dnzUVcs < member.bufferCount; dnzUVcs++){
            [&](){return proto_arr.set(dnzUVcs,serialize_handle((member.pBuffers)[dnzUVcs]));}();
        }
        }();
[&](){return builder.setTagName((member.tagName));}();
[&](){return builder.setTagSize((member.tagSize));}();
[&](){
            if ((member.pTag)==NULL){
                builder.initPTag(0);
            return; }[&](){
            if (((char*)(member.pTag).pTag)==NULL){
                builder.initPTag(0);
            return; }
        auto proto_arr=builder.initPTag(strlen(((char*)(member.pTag).pTag))+1);
        for(int RyqFIjd=0; RyqFIjd < strlen(((char*)(member.pTag).pTag))+1; RyqFIjd++){
            [&](){return proto_arr.set(RyqFIjd,(((char*)(member.pTag).pTag)[RyqFIjd]));}();
        }
        }();}();
}

    VkFrameBoundaryEXT deserialize_struct(stream::VkFrameBoundaryEXT::Reader reader){
        auto result=VkFrameBoundaryEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.frameID)=reader.getFrameID();}();
[&](){(result.imageCount)=reader.getImageCount();}();
[&](){ VkImage* temp_BqRJDpW[&](){
            if (!reader.getPImages().size()==0){
                (result.pImages)=NULL;
            return; }{native_concat()}=(VkImage*)malloc(result.imageCount*sizeof(VkImage));
        auto proto_arr=reader.getPImages(result.imageCount);
        for(int FpSGybG=0; FpSGybG < result.imageCount; FpSGybG++){
            [&](){((result.pImages)[FpSGybG])=deserialize_VkImage(proto_arr[FpSGybG]);}();
        }
        }();(result.pImages)=temp_BqRJDpW;}();
[&](){(result.bufferCount)=reader.getBufferCount();}();
[&](){ VkBuffer* temp_rIfWorL[&](){
            if (!reader.getPBuffers().size()==0){
                (result.pBuffers)=NULL;
            return; }{native_concat()}=(VkBuffer*)malloc(result.bufferCount*sizeof(VkBuffer));
        auto proto_arr=reader.getPBuffers(result.bufferCount);
        for(int bCTiDDG=0; bCTiDDG < result.bufferCount; bCTiDDG++){
            [&](){((result.pBuffers)[bCTiDDG])=deserialize_VkBuffer(proto_arr[bCTiDDG]);}();
        }
        }();(result.pBuffers)=temp_rIfWorL;}();
[&](){(result.tagName)=reader.getTagName();}();
[&](){(result.tagSize)=reader.getTagSize();}();
[&](){ void* temp_xlgiUqt[&](){
            if (!reader.getPTag().size()==0){
                (result.pTag)=NULL;
            return; }char* temp_wOnqPmD;[&](){
            if (!reader.getPTag().size()==0){
                (temp_wOnqPmD.pTag)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPTag().size();*sizeof(char));
        auto proto_arr=reader.getPTag(reader.getPTag().size(););
        for(int lxDYfsn=0; lxDYfsn < reader.getPTag().size();; lxDYfsn++){
            [&](){((temp_wOnqPmD.pTag)[lxDYfsn])=proto_arr[lxDYfsn];}();
        }
        }();(result.pTag)=temp_wOnqPmD;}();(result.pTag)=temp_xlgiUqt;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkFrameBoundaryEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkFrameBoundaryEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceFrameBoundaryFeaturesEXT::Builder& builder, VkPhysicalDeviceFrameBoundaryFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setFrameBoundary((member.frameBoundary));}();}();
}

    VkPhysicalDeviceFrameBoundaryFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceFrameBoundaryFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceFrameBoundaryFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.frameBoundary)=reader.getFrameBoundary();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceFrameBoundaryFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceFrameBoundaryFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT::Builder& builder, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDynamicRenderingUnusedAttachments((member.dynamicRenderingUnusedAttachments));}();}();
}

    VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.dynamicRenderingUnusedAttachments)=reader.getDynamicRenderingUnusedAttachments();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfacePresentModeEXT::Builder& builder, VkSurfacePresentModeEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setPresentMode((member.presentMode));}();}();}();
}

    VkSurfacePresentModeEXT deserialize_struct(stream::VkSurfacePresentModeEXT::Reader reader){
        auto result=VkSurfacePresentModeEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.presentMode)=reader.getPresentMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfacePresentModeEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfacePresentModeEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfacePresentScalingCapabilitiesEXT::Builder& builder, VkSurfacePresentScalingCapabilitiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setSupportedPresentScaling((member.supportedPresentScaling));}();}();}();
[&](){[&](){[&](){return builder.setSupportedPresentGravityX((member.supportedPresentGravityX));}();}();}();
[&](){[&](){[&](){return builder.setSupportedPresentGravityY((member.supportedPresentGravityY));}();}();}();
[&](){
            auto temp=builder.initMinScaledImageExtent(minScaledImageExtent);
            return serialize_struct(temp, (member.minScaledImageExtent));
            }();
[&](){
            auto temp=builder.initMaxScaledImageExtent(maxScaledImageExtent);
            return serialize_struct(temp, (member.maxScaledImageExtent));
            }();
}

    VkSurfacePresentScalingCapabilitiesEXT deserialize_struct(stream::VkSurfacePresentScalingCapabilitiesEXT::Reader reader){
        auto result=VkSurfacePresentScalingCapabilitiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.supportedPresentScaling)=reader.getSupportedPresentScaling();}();}();}();
[&](){[&](){[&](){(result.supportedPresentGravityX)=reader.getSupportedPresentGravityX();}();}();}();
[&](){[&](){[&](){(result.supportedPresentGravityY)=reader.getSupportedPresentGravityY();}();}();}();
[&](){
            auto temp=reader.getMinScaledImageExtent();
            (result.minScaledImageExtent)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxScaledImageExtent();
            (result.maxScaledImageExtent)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfacePresentScalingCapabilitiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfacePresentScalingCapabilitiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSurfacePresentModeCompatibilityEXT::Builder& builder, VkSurfacePresentModeCompatibilityEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPresentModeCount((member.presentModeCount));}();
[&](){
            if ((member.pPresentModes)==NULL){
                builder.initPPresentModes(0);
            return; }
        auto proto_arr=builder.initPPresentModes(member.presentModeCount);
        for(int GuPZwgH=0; GuPZwgH < member.presentModeCount; GuPZwgH++){
            [&](){[&](){[&](){return proto_arr.set(GuPZwgH,((member.pPresentModes)[GuPZwgH]));}();}();}();
        }
        }();
}

    VkSurfacePresentModeCompatibilityEXT deserialize_struct(stream::VkSurfacePresentModeCompatibilityEXT::Reader reader){
        auto result=VkSurfacePresentModeCompatibilityEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.presentModeCount)=reader.getPresentModeCount();}();
[&](){
            if (!reader.getPPresentModes().size()==0){
                (result.pPresentModes)=NULL;
            return; }{native_concat()}=(VkPresentModeKHR*)malloc(result.presentModeCount*sizeof(VkPresentModeKHR));
        auto proto_arr=reader.getPPresentModes(result.presentModeCount);
        for(int GuPZwgH=0; GuPZwgH < result.presentModeCount; GuPZwgH++){
            [&](){[&](){[&](){((result.pPresentModes)[GuPZwgH])=proto_arr[GuPZwgH];}();}();}();
        }
        }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSurfacePresentModeCompatibilityEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSurfacePresentModeCompatibilityEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT::Builder& builder, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSwapchainMaintenance1((member.swapchainMaintenance1));}();}();
}

    VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT deserialize_struct(stream::VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.swapchainMaintenance1)=reader.getSwapchainMaintenance1();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainPresentFenceInfoEXT::Builder& builder, VkSwapchainPresentFenceInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchainCount((member.swapchainCount));}();
[&](){
            if ((member.pFences)==NULL){
                builder.initPFences(0);
            return; }
        auto proto_arr=builder.initPFences(member.swapchainCount);
        for(int ocOiHLH=0; ocOiHLH < member.swapchainCount; ocOiHLH++){
            [&](){return proto_arr.set(ocOiHLH,serialize_handle((member.pFences)[ocOiHLH]));}();
        }
        }();
}

    VkSwapchainPresentFenceInfoEXT deserialize_struct(stream::VkSwapchainPresentFenceInfoEXT::Reader reader){
        auto result=VkSwapchainPresentFenceInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchainCount)=reader.getSwapchainCount();}();
[&](){ VkFence* temp_BaHTyXG[&](){
            if (!reader.getPFences().size()==0){
                (result.pFences)=NULL;
            return; }{native_concat()}=(VkFence*)malloc(result.swapchainCount*sizeof(VkFence));
        auto proto_arr=reader.getPFences(result.swapchainCount);
        for(int iQgYhvq=0; iQgYhvq < result.swapchainCount; iQgYhvq++){
            [&](){((result.pFences)[iQgYhvq])=deserialize_VkFence(proto_arr[iQgYhvq]);}();
        }
        }();(result.pFences)=temp_BaHTyXG;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainPresentFenceInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainPresentFenceInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainPresentModesCreateInfoEXT::Builder& builder, VkSwapchainPresentModesCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPresentModeCount((member.presentModeCount));}();
[&](){
            if ((member.pPresentModes)==NULL){
                builder.initPPresentModes(0);
            return; }
        auto proto_arr=builder.initPPresentModes(member.presentModeCount);
        for(int uqvLxPC=0; uqvLxPC < member.presentModeCount; uqvLxPC++){
            [&](){[&](){[&](){return proto_arr.set(uqvLxPC,((member.pPresentModes)[uqvLxPC]));}();}();}();
        }
        }();
}

    VkSwapchainPresentModesCreateInfoEXT deserialize_struct(stream::VkSwapchainPresentModesCreateInfoEXT::Reader reader){
        auto result=VkSwapchainPresentModesCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.presentModeCount)=reader.getPresentModeCount();}();
[&](){ VkPresentModeKHR* temp_dznRqNd[&](){
            if (!reader.getPPresentModes().size()==0){
                (result.pPresentModes)=NULL;
            return; }{native_concat()}=(VkPresentModeKHR*)malloc(result.presentModeCount*sizeof(VkPresentModeKHR));
        auto proto_arr=reader.getPPresentModes(result.presentModeCount);
        for(int nDYklWI=0; nDYklWI < result.presentModeCount; nDYklWI++){
            [&](){[&](){[&](){((result.pPresentModes)[nDYklWI])=proto_arr[nDYklWI];}();}();}();
        }
        }();(result.pPresentModes)=temp_dznRqNd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainPresentModesCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainPresentModesCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainPresentModeInfoEXT::Builder& builder, VkSwapchainPresentModeInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchainCount((member.swapchainCount));}();
[&](){
            if ((member.pPresentModes)==NULL){
                builder.initPPresentModes(0);
            return; }
        auto proto_arr=builder.initPPresentModes(member.swapchainCount);
        for(int uqvLxPC=0; uqvLxPC < member.swapchainCount; uqvLxPC++){
            [&](){[&](){[&](){return proto_arr.set(uqvLxPC,((member.pPresentModes)[uqvLxPC]));}();}();}();
        }
        }();
}

    VkSwapchainPresentModeInfoEXT deserialize_struct(stream::VkSwapchainPresentModeInfoEXT::Reader reader){
        auto result=VkSwapchainPresentModeInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchainCount)=reader.getSwapchainCount();}();
[&](){ VkPresentModeKHR* temp_gGcJNqc[&](){
            if (!reader.getPPresentModes().size()==0){
                (result.pPresentModes)=NULL;
            return; }{native_concat()}=(VkPresentModeKHR*)malloc(result.swapchainCount*sizeof(VkPresentModeKHR));
        auto proto_arr=reader.getPPresentModes(result.swapchainCount);
        for(int nDYklWI=0; nDYklWI < result.swapchainCount; nDYklWI++){
            [&](){[&](){[&](){((result.pPresentModes)[nDYklWI])=proto_arr[nDYklWI];}();}();}();
        }
        }();(result.pPresentModes)=temp_gGcJNqc;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainPresentModeInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainPresentModeInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSwapchainPresentScalingCreateInfoEXT::Builder& builder, VkSwapchainPresentScalingCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setScalingBehavior((member.scalingBehavior));}();}();}();
[&](){[&](){[&](){return builder.setPresentGravityX((member.presentGravityX));}();}();}();
[&](){[&](){[&](){return builder.setPresentGravityY((member.presentGravityY));}();}();}();
}

    VkSwapchainPresentScalingCreateInfoEXT deserialize_struct(stream::VkSwapchainPresentScalingCreateInfoEXT::Reader reader){
        auto result=VkSwapchainPresentScalingCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.scalingBehavior)=reader.getScalingBehavior();}();}();}();
[&](){[&](){[&](){(result.presentGravityX)=reader.getPresentGravityX();}();}();}();
[&](){[&](){[&](){(result.presentGravityY)=reader.getPresentGravityY();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSwapchainPresentScalingCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSwapchainPresentScalingCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkReleaseSwapchainImagesInfoEXT::Builder& builder, VkReleaseSwapchainImagesInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setSwapchain(serialize_handle(member.swapchain));}();
[&](){return builder.setImageIndexCount((member.imageIndexCount));}();
[&](){
            if ((member.pImageIndices)==NULL){
                builder.initPImageIndices(0);
            return; }
        auto proto_arr=builder.initPImageIndices(member.imageIndexCount);
        for(int uFkTWYN=0; uFkTWYN < member.imageIndexCount; uFkTWYN++){
            [&](){return proto_arr.set(uFkTWYN,((member.pImageIndices)[uFkTWYN]));}();
        }
        }();
}

    VkReleaseSwapchainImagesInfoEXT deserialize_struct(stream::VkReleaseSwapchainImagesInfoEXT::Reader reader){
        auto result=VkReleaseSwapchainImagesInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.swapchain)=deserialize_VkSwapchainKHR(reader.getSwapchain());}();
[&](){(result.imageIndexCount)=reader.getImageIndexCount();}();
[&](){ uint32_t* temp_eqjbEhr[&](){
            if (!reader.getPImageIndices().size()==0){
                (result.pImageIndices)=NULL;
            return; }{native_concat()}=(uint32_t*)malloc(result.imageIndexCount*sizeof(uint32_t));
        auto proto_arr=reader.getPImageIndices(result.imageIndexCount);
        for(int daliJoD=0; daliJoD < result.imageIndexCount; daliJoD++){
            [&](){((result.pImageIndices)[daliJoD])=proto_arr[daliJoD];}();
        }
        }();(result.pImageIndices)=temp_eqjbEhr;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkReleaseSwapchainImagesInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkReleaseSwapchainImagesInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDepthBiasControlFeaturesEXT::Builder& builder, VkPhysicalDeviceDepthBiasControlFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDepthBiasControl((member.depthBiasControl));}();}();
[&](){[&](){return builder.setLeastRepresentableValueForceUnormRepresentation((member.leastRepresentableValueForceUnormRepresentation));}();}();
[&](){[&](){return builder.setFloatRepresentation((member.floatRepresentation));}();}();
[&](){[&](){return builder.setDepthBiasExact((member.depthBiasExact));}();}();
}

    VkPhysicalDeviceDepthBiasControlFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceDepthBiasControlFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceDepthBiasControlFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.depthBiasControl)=reader.getDepthBiasControl();}();}();
[&](){[&](){(result.leastRepresentableValueForceUnormRepresentation)=reader.getLeastRepresentableValueForceUnormRepresentation();}();}();
[&](){[&](){(result.floatRepresentation)=reader.getFloatRepresentation();}();}();
[&](){[&](){(result.depthBiasExact)=reader.getDepthBiasExact();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDepthBiasControlFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDepthBiasControlFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV::Builder& builder, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRayTracingInvocationReorder((member.rayTracingInvocationReorder));}();}();
}

    VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV deserialize_struct(stream::VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rayTracingInvocationReorder)=reader.getRayTracingInvocationReorder();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV::Builder& builder, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setRayTracingInvocationReorderReorderingHint((member.rayTracingInvocationReorderReorderingHint));}();}();}();
}

    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV deserialize_struct(stream::VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV::Reader reader){
        auto result=VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.rayTracingInvocationReorderReorderingHint)=reader.getRayTracingInvocationReorderReorderingHint();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDirectDriverLoadingInfoLUNARG::Builder& builder, VkDirectDriverLoadingInfoLUNARG member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){
            auto temp=builder.initPfnGetInstanceProcAddr(pfnGetInstanceProcAddr);
            return serialize_funcpointer(temp, (member.pfnGetInstanceProcAddr));
            }();
}

    VkDirectDriverLoadingInfoLUNARG deserialize_struct(stream::VkDirectDriverLoadingInfoLUNARG::Reader reader){
        auto result=VkDirectDriverLoadingInfoLUNARG();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){
#ifndef CLIENT
            auto temp=reader.getPfnGetInstanceProcAddr();
            (result.pfnGetInstanceProcAddr)=deserialize_funcpointer(temp);
            #endif
}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDirectDriverLoadingInfoLUNARG member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
builder.setPFN_vkGetInstanceProcAddrLUNARG((uintptr_t)(member.pfnGetInstanceProcAddr));
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDirectDriverLoadingInfoLUNARG member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();
result.pfnGetInstanceProcAddr=reader.getPFN_vkGetInstanceProcAddrLUNARG();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDirectDriverLoadingListLUNARG::Builder& builder, VkDirectDriverLoadingListLUNARG member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setMode((member.mode));}();}();}();
[&](){return builder.setDriverCount((member.driverCount));}();
[&](){
            if ((member.pDrivers)==NULL){
                builder.initPDrivers(0);
            return; }
        auto proto_arr=builder.initPDrivers(member.driverCount);
        for(int QRMHLjh=0; QRMHLjh < member.driverCount; QRMHLjh++){
            [&](){
            auto temp=proto_arr[QRMHLjh];
            return serialize_struct(temp, ((member.pDrivers)[QRMHLjh]));
            }();
        }
        }();
}

    VkDirectDriverLoadingListLUNARG deserialize_struct(stream::VkDirectDriverLoadingListLUNARG::Reader reader){
        auto result=VkDirectDriverLoadingListLUNARG();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.mode)=reader.getMode();}();}();}();
[&](){(result.driverCount)=reader.getDriverCount();}();
[&](){ VkDirectDriverLoadingInfoLUNARG* temp_vSplIIz[&](){
            if (!reader.getPDrivers().size()==0){
                (result.pDrivers)=NULL;
            return; }{native_concat()}=(VkDirectDriverLoadingInfoLUNARG*)malloc(result.driverCount*sizeof(VkDirectDriverLoadingInfoLUNARG));
        auto proto_arr=reader.getPDrivers(result.driverCount);
        for(int auWfUrZ=0; auWfUrZ < result.driverCount; auWfUrZ++){
            [&](){
            auto temp=proto_arr[auWfUrZ];
            ((result.pDrivers)[auWfUrZ])=deserialize_struct(temp);
            }();
        }
        }();(result.pDrivers)=temp_vSplIIz;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDirectDriverLoadingListLUNARG member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDirectDriverLoadingListLUNARG member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM::Builder& builder, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMultiviewPerViewViewports((member.multiviewPerViewViewports));}();}();
}

    VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.multiviewPerViewViewports)=reader.getMultiviewPerViewViewports();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR::Builder& builder, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setRayTracingPositionFetch((member.rayTracingPositionFetch));}();}();
}

    VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.rayTracingPositionFetch)=reader.getRayTracingPositionFetch();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkDeviceImageSubresourceInfoKHR::Builder& builder, VkDeviceImageSubresourceInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pCreateInfo)==NULL){
                builder.initPCreateInfo(0);
            return; }
        auto proto_arr=builder.initPCreateInfo(1);
        for(int pUPULkH=0; pUPULkH < 1; pUPULkH++){
            [&](){
            auto temp=proto_arr[pUPULkH];
            return serialize_struct(temp, ((member.pCreateInfo)[pUPULkH]));
            }();
        }
        }();
[&](){
            if ((member.pSubresource)==NULL){
                builder.initPSubresource(0);
            return; }
        auto proto_arr=builder.initPSubresource(1);
        for(int iRoNHuq=0; iRoNHuq < 1; iRoNHuq++){
            [&](){
            auto temp=proto_arr[iRoNHuq];
            return serialize_struct(temp, ((member.pSubresource)[iRoNHuq]));
            }();
        }
        }();
}

    VkDeviceImageSubresourceInfoKHR deserialize_struct(stream::VkDeviceImageSubresourceInfoKHR::Reader reader){
        auto result=VkDeviceImageSubresourceInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){ VkImageCreateInfo* temp_GaGgIvU[&](){
            if (!reader.getPCreateInfo().size()==0){
                (result.pCreateInfo)=NULL;
            return; }{native_concat()}=(VkImageCreateInfo*)malloc(1*sizeof(VkImageCreateInfo));
        auto proto_arr=reader.getPCreateInfo(1);
        for(int OCzXYbh=0; OCzXYbh < 1; OCzXYbh++){
            [&](){
            auto temp=proto_arr[OCzXYbh];
            ((result.pCreateInfo)[OCzXYbh])=deserialize_struct(temp);
            }();
        }
        }();(result.pCreateInfo)=temp_GaGgIvU;}();
[&](){ VkImageSubresource2KHR* temp_bPPrxdS[&](){
            if (!reader.getPSubresource().size()==0){
                (result.pSubresource)=NULL;
            return; }{native_concat()}=(VkImageSubresource2KHR*)malloc(1*sizeof(VkImageSubresource2KHR));
        auto proto_arr=reader.getPSubresource(1);
        for(int palwAFi=0; palwAFi < 1; palwAFi++){
            [&](){
            auto temp=proto_arr[palwAFi];
            ((result.pSubresource)[palwAFi])=deserialize_struct(temp);
            }();
        }
        }();(result.pSubresource)=temp_bPPrxdS;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkDeviceImageSubresourceInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkDeviceImageSubresourceInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderCorePropertiesARM::Builder& builder, VkPhysicalDeviceShaderCorePropertiesARM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPixelRate((member.pixelRate));}();
[&](){return builder.setTexelRate((member.texelRate));}();
[&](){return builder.setFmaRate((member.fmaRate));}();
}

    VkPhysicalDeviceShaderCorePropertiesARM deserialize_struct(stream::VkPhysicalDeviceShaderCorePropertiesARM::Reader reader){
        auto result=VkPhysicalDeviceShaderCorePropertiesARM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.pixelRate)=reader.getPixelRate();}();
[&](){(result.texelRate)=reader.getTexelRate();}();
[&](){(result.fmaRate)=reader.getFmaRate();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderCorePropertiesARM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderCorePropertiesARM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM::Builder& builder, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setMultiviewPerViewRenderAreas((member.multiviewPerViewRenderAreas));}();}();
}

    VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.multiviewPerViewRenderAreas)=reader.getMultiviewPerViewRenderAreas();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM::Builder& builder, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setPerViewRenderAreaCount((member.perViewRenderAreaCount));}();
[&](){
            if ((member.pPerViewRenderAreas)==NULL){
                builder.initPPerViewRenderAreas(0);
            return; }
        auto proto_arr=builder.initPPerViewRenderAreas(member.perViewRenderAreaCount);
        for(int BKTmmXF=0; BKTmmXF < member.perViewRenderAreaCount; BKTmmXF++){
            [&](){
            auto temp=proto_arr[BKTmmXF];
            return serialize_struct(temp, ((member.pPerViewRenderAreas)[BKTmmXF]));
            }();
        }
        }();
}

    VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM deserialize_struct(stream::VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM::Reader reader){
        auto result=VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){(result.perViewRenderAreaCount)=reader.getPerViewRenderAreaCount();}();
[&](){ VkRect2D* temp_zZPIkNd[&](){
            if (!reader.getPPerViewRenderAreas().size()==0){
                (result.pPerViewRenderAreas)=NULL;
            return; }{native_concat()}=(VkRect2D*)malloc(result.perViewRenderAreaCount*sizeof(VkRect2D));
        auto proto_arr=reader.getPPerViewRenderAreas(result.perViewRenderAreaCount);
        for(int MYXytcc=0; MYXytcc < result.perViewRenderAreaCount; MYXytcc++){
            [&](){
            auto temp=proto_arr[MYXytcc];
            ((result.pPerViewRenderAreas)[MYXytcc])=deserialize_struct(temp);
            }();
        }
        }();(result.pPerViewRenderAreas)=temp_zZPIkNd;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkQueryLowLatencySupportNV::Builder& builder, VkQueryLowLatencySupportNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            if ((member.pQueriedLowLatencyData)==NULL){
                builder.initPQueriedLowLatencyData(0);
            return; }[&](){
            if (((char*)(member.pQueriedLowLatencyData).pQueriedLowLatencyData)==NULL){
                builder.initPQueriedLowLatencyData(0);
            return; }
        auto proto_arr=builder.initPQueriedLowLatencyData(strlen(((char*)(member.pQueriedLowLatencyData).pQueriedLowLatencyData))+1);
        for(int uSAhzUM=0; uSAhzUM < strlen(((char*)(member.pQueriedLowLatencyData).pQueriedLowLatencyData))+1; uSAhzUM++){
            [&](){return proto_arr.set(uSAhzUM,(((char*)(member.pQueriedLowLatencyData).pQueriedLowLatencyData)[uSAhzUM]));}();
        }
        }();}();
}

    VkQueryLowLatencySupportNV deserialize_struct(stream::VkQueryLowLatencySupportNV::Reader reader){
        auto result=VkQueryLowLatencySupportNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            if (!reader.getPQueriedLowLatencyData().size()==0){
                (result.pQueriedLowLatencyData)=NULL;
            return; }char* temp_dLmkgMg;[&](){
            if (!reader.getPQueriedLowLatencyData().size()==0){
                (temp_dLmkgMg.pQueriedLowLatencyData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPQueriedLowLatencyData().size();*sizeof(char));
        auto proto_arr=reader.getPQueriedLowLatencyData(reader.getPQueriedLowLatencyData().size(););
        for(int uSAhzUM=0; uSAhzUM < reader.getPQueriedLowLatencyData().size();; uSAhzUM++){
            [&](){((temp_dLmkgMg.pQueriedLowLatencyData)[uSAhzUM])=proto_arr[uSAhzUM];}();
        }
        }();(result.pQueriedLowLatencyData)=temp_dLmkgMg;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkQueryLowLatencySupportNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkQueryLowLatencySupportNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryMapInfoKHR::Builder& builder, VkMemoryMapInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
[&](){[&](){return builder.setOffset((member.offset));}();}();
[&](){[&](){return builder.setSize((member.size));}();}();
}

    VkMemoryMapInfoKHR deserialize_struct(stream::VkMemoryMapInfoKHR::Reader reader){
        auto result=VkMemoryMapInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
[&](){[&](){(result.offset)=reader.getOffset();}();}();
[&](){[&](){(result.size)=reader.getSize();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryMapInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryMapInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkMemoryUnmapInfoKHR::Builder& builder, VkMemoryUnmapInfoKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){return builder.setMemory(serialize_handle(member.memory));}();
}

    VkMemoryUnmapInfoKHR deserialize_struct(stream::VkMemoryUnmapInfoKHR::Reader reader){
        auto result=VkMemoryUnmapInfoKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){(result.memory)=deserialize_VkDeviceMemory(reader.getMemory());}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkMemoryUnmapInfoKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkMemoryUnmapInfoKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderObjectFeaturesEXT::Builder& builder, VkPhysicalDeviceShaderObjectFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderObject((member.shaderObject));}();}();
}

    VkPhysicalDeviceShaderObjectFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceShaderObjectFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderObjectFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderObject)=reader.getShaderObject();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderObjectFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderObjectFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderObjectPropertiesEXT::Builder& builder, VkPhysicalDeviceShaderObjectPropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
        auto proto_arr=builder.initShaderBinaryUUID(VK_UUID_SIZE);
        for(int ECztgMK=0; ECztgMK < VK_UUID_SIZE; ECztgMK++){
            [&](){return proto_arr.set(ECztgMK,((member.shaderBinaryUUID)[ECztgMK]));}();
        }
        }();
[&](){return builder.setShaderBinaryVersion((member.shaderBinaryVersion));}();
}

    VkPhysicalDeviceShaderObjectPropertiesEXT deserialize_struct(stream::VkPhysicalDeviceShaderObjectPropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderObjectPropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
        auto proto_arr=reader.getShaderBinaryUUID(VK_UUID_SIZE);
        for(int ECztgMK=0; ECztgMK < VK_UUID_SIZE; ECztgMK++){
            [&](){((result.shaderBinaryUUID)[ECztgMK])=proto_arr[ECztgMK];}();
        }
        }();
[&](){(result.shaderBinaryVersion)=reader.getShaderBinaryVersion();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderObjectPropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderObjectPropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkShaderCreateInfoEXT::Builder& builder, VkShaderCreateInfoEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setFlags((member.flags));}();}();}();
[&](){[&](){[&](){return builder.setStage((member.stage));}();}();}();
[&](){[&](){[&](){return builder.setNextStage((member.nextStage));}();}();}();
[&](){[&](){[&](){return builder.setCodeType((member.codeType));}();}();}();
[&](){return builder.setCodeSize((member.codeSize));}();
[&](){
            if ((member.pCode)==NULL){
                builder.initPCode(0);
            return; }[&](){
            if (((char*)(member.pCode).pCode)==NULL){
                builder.initPCode(0);
            return; }
        auto proto_arr=builder.initPCode(member.codeSize);
        for(int LndDMvv=0; LndDMvv < member.codeSize; LndDMvv++){
            [&](){return proto_arr.set(LndDMvv,(((char*)(member.pCode).pCode)[LndDMvv]));}();
        }
        }();}();
[&](){
            if ((member.pName)==NULL){
                builder.initPName(0);
            return; }
        auto proto_arr=builder.initPName(strlen((member.pName))+1);
        for(int opTkazg=0; opTkazg < strlen((member.pName))+1; opTkazg++){
            [&](){return proto_arr.set(opTkazg,((member.pName)[opTkazg]));}();
        }
        }();
[&](){return builder.setSetLayoutCount((member.setLayoutCount));}();
[&](){
            if ((member.pSetLayouts)==NULL){
                builder.initPSetLayouts(0);
            return; }
        auto proto_arr=builder.initPSetLayouts(member.setLayoutCount);
        for(int gfILRjy=0; gfILRjy < member.setLayoutCount; gfILRjy++){
            [&](){return proto_arr.set(gfILRjy,serialize_handle((member.pSetLayouts)[gfILRjy]));}();
        }
        }();
[&](){return builder.setPushConstantRangeCount((member.pushConstantRangeCount));}();
[&](){
            if ((member.pPushConstantRanges)==NULL){
                builder.initPPushConstantRanges(0);
            return; }
        auto proto_arr=builder.initPPushConstantRanges(member.pushConstantRangeCount);
        for(int fStWwBo=0; fStWwBo < member.pushConstantRangeCount; fStWwBo++){
            [&](){
            auto temp=proto_arr[fStWwBo];
            return serialize_struct(temp, ((member.pPushConstantRanges)[fStWwBo]));
            }();
        }
        }();
[&](){
            if ((member.pSpecializationInfo)==NULL){
                builder.initPSpecializationInfo(0);
            return; }
        auto proto_arr=builder.initPSpecializationInfo(1);
        for(int xbxpxgP=0; xbxpxgP < 1; xbxpxgP++){
            [&](){
            auto temp=proto_arr[xbxpxgP];
            return serialize_struct(temp, ((member.pSpecializationInfo)[xbxpxgP]));
            }();
        }
        }();
}

    VkShaderCreateInfoEXT deserialize_struct(stream::VkShaderCreateInfoEXT::Reader reader){
        auto result=VkShaderCreateInfoEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(result.stage)=reader.getStage();}();}();}();
[&](){[&](){[&](){(result.nextStage)=reader.getNextStage();}();}();}();
[&](){[&](){[&](){(result.codeType)=reader.getCodeType();}();}();}();
[&](){(result.codeSize)=reader.getCodeSize();}();
[&](){ void* temp_pjzuZBN[&](){
            if (!reader.getPCode().size()==0){
                (result.pCode)=NULL;
            return; }char* temp_rTytZvZ;[&](){
            if (!reader.getPCode().size()==0){
                (temp_rTytZvZ.pCode)=NULL;
            return; }{native_concat()}=(char*)malloc(result.codeSize*sizeof(char));
        auto proto_arr=reader.getPCode(result.codeSize);
        for(int NLBJMlE=0; NLBJMlE < result.codeSize; NLBJMlE++){
            [&](){((temp_rTytZvZ.pCode)[NLBJMlE])=proto_arr[NLBJMlE];}();
        }
        }();(result.pCode)=temp_rTytZvZ;}();(result.pCode)=temp_pjzuZBN;}();
[&](){ char* temp_xDKNBiw[&](){
            if (!reader.getPName().size()==0){
                (result.pName)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPName().size();*sizeof(char));
        auto proto_arr=reader.getPName(reader.getPName().size(););
        for(int zzMOHXu=0; zzMOHXu < reader.getPName().size();; zzMOHXu++){
            [&](){((result.pName)[zzMOHXu])=proto_arr[zzMOHXu];}();
        }
        }();(result.pName)=temp_xDKNBiw;}();
[&](){(result.setLayoutCount)=reader.getSetLayoutCount();}();
[&](){ VkDescriptorSetLayout* temp_BHNAemT[&](){
            if (!reader.getPSetLayouts().size()==0){
                (result.pSetLayouts)=NULL;
            return; }{native_concat()}=(VkDescriptorSetLayout*)malloc(result.setLayoutCount*sizeof(VkDescriptorSetLayout));
        auto proto_arr=reader.getPSetLayouts(result.setLayoutCount);
        for(int kjCEeqP=0; kjCEeqP < result.setLayoutCount; kjCEeqP++){
            [&](){((result.pSetLayouts)[kjCEeqP])=deserialize_VkDescriptorSetLayout(proto_arr[kjCEeqP]);}();
        }
        }();(result.pSetLayouts)=temp_BHNAemT;}();
[&](){(result.pushConstantRangeCount)=reader.getPushConstantRangeCount();}();
[&](){ VkPushConstantRange* temp_HDcMeFk[&](){
            if (!reader.getPPushConstantRanges().size()==0){
                (result.pPushConstantRanges)=NULL;
            return; }{native_concat()}=(VkPushConstantRange*)malloc(result.pushConstantRangeCount*sizeof(VkPushConstantRange));
        auto proto_arr=reader.getPPushConstantRanges(result.pushConstantRangeCount);
        for(int xSoqBwb=0; xSoqBwb < result.pushConstantRangeCount; xSoqBwb++){
            [&](){
            auto temp=proto_arr[xSoqBwb];
            ((result.pPushConstantRanges)[xSoqBwb])=deserialize_struct(temp);
            }();
        }
        }();(result.pPushConstantRanges)=temp_HDcMeFk;}();
[&](){ VkSpecializationInfo* temp_mZLjDhf[&](){
            if (!reader.getPSpecializationInfo().size()==0){
                (result.pSpecializationInfo)=NULL;
            return; }{native_concat()}=(VkSpecializationInfo*)malloc(1*sizeof(VkSpecializationInfo));
        auto proto_arr=reader.getPSpecializationInfo(1);
        for(int ZWKvpYr=0; ZWKvpYr < 1; ZWKvpYr++){
            [&](){
            auto temp=proto_arr[ZWKvpYr];
            ((result.pSpecializationInfo)[ZWKvpYr])=deserialize_struct(temp);
            }();
        }
        }();(result.pSpecializationInfo)=temp_mZLjDhf;}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkShaderCreateInfoEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkShaderCreateInfoEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderTileImageFeaturesEXT::Builder& builder, VkPhysicalDeviceShaderTileImageFeaturesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderTileImageColorReadAccess((member.shaderTileImageColorReadAccess));}();}();
[&](){[&](){return builder.setShaderTileImageDepthReadAccess((member.shaderTileImageDepthReadAccess));}();}();
[&](){[&](){return builder.setShaderTileImageStencilReadAccess((member.shaderTileImageStencilReadAccess));}();}();
}

    VkPhysicalDeviceShaderTileImageFeaturesEXT deserialize_struct(stream::VkPhysicalDeviceShaderTileImageFeaturesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderTileImageFeaturesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderTileImageColorReadAccess)=reader.getShaderTileImageColorReadAccess();}();}();
[&](){[&](){(result.shaderTileImageDepthReadAccess)=reader.getShaderTileImageDepthReadAccess();}();}();
[&](){[&](){(result.shaderTileImageStencilReadAccess)=reader.getShaderTileImageStencilReadAccess();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderTileImageFeaturesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderTileImageFeaturesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceShaderTileImagePropertiesEXT::Builder& builder, VkPhysicalDeviceShaderTileImagePropertiesEXT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setShaderTileImageCoherentReadAccelerated((member.shaderTileImageCoherentReadAccelerated));}();}();
[&](){[&](){return builder.setShaderTileImageReadSampleFromPixelRateInvocation((member.shaderTileImageReadSampleFromPixelRateInvocation));}();}();
[&](){[&](){return builder.setShaderTileImageReadFromHelperInvocation((member.shaderTileImageReadFromHelperInvocation));}();}();
}

    VkPhysicalDeviceShaderTileImagePropertiesEXT deserialize_struct(stream::VkPhysicalDeviceShaderTileImagePropertiesEXT::Reader reader){
        auto result=VkPhysicalDeviceShaderTileImagePropertiesEXT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.shaderTileImageCoherentReadAccelerated)=reader.getShaderTileImageCoherentReadAccelerated();}();}();
[&](){[&](){(result.shaderTileImageReadSampleFromPixelRateInvocation)=reader.getShaderTileImageReadSampleFromPixelRateInvocation();}();}();
[&](){[&](){(result.shaderTileImageReadFromHelperInvocation)=reader.getShaderTileImageReadFromHelperInvocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceShaderTileImagePropertiesEXT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceShaderTileImagePropertiesEXT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCooperativeMatrixFeaturesKHR::Builder& builder, VkPhysicalDeviceCooperativeMatrixFeaturesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCooperativeMatrix((member.cooperativeMatrix));}();}();
[&](){[&](){return builder.setCooperativeMatrixRobustBufferAccess((member.cooperativeMatrixRobustBufferAccess));}();}();
}

    VkPhysicalDeviceCooperativeMatrixFeaturesKHR deserialize_struct(stream::VkPhysicalDeviceCooperativeMatrixFeaturesKHR::Reader reader){
        auto result=VkPhysicalDeviceCooperativeMatrixFeaturesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.cooperativeMatrix)=reader.getCooperativeMatrix();}();}();
[&](){[&](){(result.cooperativeMatrixRobustBufferAccess)=reader.getCooperativeMatrixRobustBufferAccess();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCooperativeMatrixFeaturesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCooperativeMatrixFeaturesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkCooperativeMatrixPropertiesKHR::Builder& builder, VkCooperativeMatrixPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){return builder.setMSize((member.MSize));}();
[&](){return builder.setNSize((member.NSize));}();
[&](){return builder.setKSize((member.KSize));}();
[&](){[&](){[&](){return builder.setAType((member.AType));}();}();}();
[&](){[&](){[&](){return builder.setBType((member.BType));}();}();}();
[&](){[&](){[&](){return builder.setCType((member.CType));}();}();}();
[&](){[&](){[&](){return builder.setResultType((member.ResultType));}();}();}();
[&](){[&](){return builder.setSaturatingAccumulation((member.saturatingAccumulation));}();}();
[&](){[&](){[&](){return builder.setScope((member.scope));}();}();}();
}

    VkCooperativeMatrixPropertiesKHR deserialize_struct(stream::VkCooperativeMatrixPropertiesKHR::Reader reader){
        auto result=VkCooperativeMatrixPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){(result.MSize)=reader.getMSize();}();
[&](){(result.NSize)=reader.getNSize();}();
[&](){(result.KSize)=reader.getKSize();}();
[&](){[&](){[&](){(result.AType)=reader.getAType();}();}();}();
[&](){[&](){[&](){(result.BType)=reader.getBType();}();}();}();
[&](){[&](){[&](){(result.CType)=reader.getCType();}();}();}();
[&](){[&](){[&](){(result.ResultType)=reader.getResultType();}();}();}();
[&](){[&](){(result.saturatingAccumulation)=reader.getSaturatingAccumulation();}();}();
[&](){[&](){[&](){(result.scope)=reader.getScope();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkCooperativeMatrixPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkCooperativeMatrixPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCooperativeMatrixPropertiesKHR::Builder& builder, VkPhysicalDeviceCooperativeMatrixPropertiesKHR member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCooperativeMatrixSupportedStages((member.cooperativeMatrixSupportedStages));}();}();}();
}

    VkPhysicalDeviceCooperativeMatrixPropertiesKHR deserialize_struct(stream::VkPhysicalDeviceCooperativeMatrixPropertiesKHR::Reader reader){
        auto result=VkPhysicalDeviceCooperativeMatrixPropertiesKHR();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.cooperativeMatrixSupportedStages)=reader.getCooperativeMatrixSupportedStages();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCooperativeMatrixPropertiesKHR member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCooperativeMatrixPropertiesKHR member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCubicClampFeaturesQCOM::Builder& builder, VkPhysicalDeviceCubicClampFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setCubicRangeClamp((member.cubicRangeClamp));}();}();
}

    VkPhysicalDeviceCubicClampFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceCubicClampFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceCubicClampFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.cubicRangeClamp)=reader.getCubicRangeClamp();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCubicClampFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCubicClampFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceYcbcrDegammaFeaturesQCOM::Builder& builder, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setYcbcrDegamma((member.ycbcrDegamma));}();}();
}

    VkPhysicalDeviceYcbcrDegammaFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceYcbcrDegammaFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceYcbcrDegammaFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.ycbcrDegamma)=reader.getYcbcrDegamma();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM::Builder& builder, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setEnableYDegamma((member.enableYDegamma));}();}();
[&](){[&](){return builder.setEnableCbCrDegamma((member.enableCbCrDegamma));}();}();
}

    VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM deserialize_struct(stream::VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM::Reader reader){
        auto result=VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.enableYDegamma)=reader.getEnableYDegamma();}();}();
[&](){[&](){(result.enableCbCrDegamma)=reader.getEnableCbCrDegamma();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceCubicWeightsFeaturesQCOM::Builder& builder, VkPhysicalDeviceCubicWeightsFeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setSelectableCubicWeights((member.selectableCubicWeights));}();}();
}

    VkPhysicalDeviceCubicWeightsFeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceCubicWeightsFeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceCubicWeightsFeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.selectableCubicWeights)=reader.getSelectableCubicWeights();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceCubicWeightsFeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceCubicWeightsFeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerCubicWeightsCreateInfoQCOM::Builder& builder, VkSamplerCubicWeightsCreateInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCubicWeights((member.cubicWeights));}();}();}();
}

    VkSamplerCubicWeightsCreateInfoQCOM deserialize_struct(stream::VkSamplerCubicWeightsCreateInfoQCOM::Reader reader){
        auto result=VkSamplerCubicWeightsCreateInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.cubicWeights)=reader.getCubicWeights();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerCubicWeightsCreateInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerCubicWeightsCreateInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkBlitImageCubicWeightsInfoQCOM::Builder& builder, VkBlitImageCubicWeightsInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setCubicWeights((member.cubicWeights));}();}();}();
}

    VkBlitImageCubicWeightsInfoQCOM deserialize_struct(stream::VkBlitImageCubicWeightsInfoQCOM::Reader reader){
        auto result=VkBlitImageCubicWeightsInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){[&](){[&](){(result.cubicWeights)=reader.getCubicWeights();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkBlitImageCubicWeightsInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkBlitImageCubicWeightsInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageProcessing2FeaturesQCOM::Builder& builder, VkPhysicalDeviceImageProcessing2FeaturesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setTextureBlockMatch2((member.textureBlockMatch2));}();}();
}

    VkPhysicalDeviceImageProcessing2FeaturesQCOM deserialize_struct(stream::VkPhysicalDeviceImageProcessing2FeaturesQCOM::Reader reader){
        auto result=VkPhysicalDeviceImageProcessing2FeaturesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.textureBlockMatch2)=reader.getTextureBlockMatch2();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageProcessing2FeaturesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageProcessing2FeaturesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceImageProcessing2PropertiesQCOM::Builder& builder, VkPhysicalDeviceImageProcessing2PropertiesQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initMaxBlockMatchWindow(maxBlockMatchWindow);
            return serialize_struct(temp, (member.maxBlockMatchWindow));
            }();
}

    VkPhysicalDeviceImageProcessing2PropertiesQCOM deserialize_struct(stream::VkPhysicalDeviceImageProcessing2PropertiesQCOM::Reader reader){
        auto result=VkPhysicalDeviceImageProcessing2PropertiesQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){
            auto temp=reader.getMaxBlockMatchWindow();
            (result.maxBlockMatchWindow)=deserialize_struct(temp);
            }();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceImageProcessing2PropertiesQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceImageProcessing2PropertiesQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkSamplerBlockMatchWindowCreateInfoQCOM::Builder& builder, VkSamplerBlockMatchWindowCreateInfoQCOM member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){
            auto temp=builder.initWindowExtent(windowExtent);
            return serialize_struct(temp, (member.windowExtent));
            }();
[&](){[&](){[&](){return builder.setWindowCompareMode((member.windowCompareMode));}();}();}();
}

    VkSamplerBlockMatchWindowCreateInfoQCOM deserialize_struct(stream::VkSamplerBlockMatchWindowCreateInfoQCOM::Reader reader){
        auto result=VkSamplerBlockMatchWindowCreateInfoQCOM();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){ void* temp_pBVSXDo[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();(result.pNext)=temp_pBVSXDo;}();
[&](){
            auto temp=reader.getWindowExtent();
            (result.windowExtent)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.windowCompareMode)=reader.getWindowCompareMode();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkSamplerBlockMatchWindowCreateInfoQCOM member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkSamplerBlockMatchWindowCreateInfoQCOM member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV::Builder& builder, VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){return builder.setDescriptorPoolOverallocation((member.descriptorPoolOverallocation));}();}();
}

    VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV deserialize_struct(stream::VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV::Reader reader){
        auto result=VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){(result.descriptorPoolOverallocation)=reader.getDescriptorPoolOverallocation();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    

    void serialize_struct(stream::VkPhysicalDeviceLayeredDriverPropertiesMSFT::Builder& builder, VkPhysicalDeviceLayeredDriverPropertiesMSFT member){
        
    
[&](){[&](){[&](){return builder.setSType((member.sType));}();}();}();
[&](){
            auto temp=builder.initPNext(pNext);
            return serialize_struct(temp, (member.pNext));
            }();
[&](){[&](){[&](){return builder.setUnderlyingAPI((member.underlyingAPI));}();}();}();
}

    VkPhysicalDeviceLayeredDriverPropertiesMSFT deserialize_struct(stream::VkPhysicalDeviceLayeredDriverPropertiesMSFT::Reader reader){
        auto result=VkPhysicalDeviceLayeredDriverPropertiesMSFT();
    
[&](){[&](){[&](){(result.sType)=reader.getSType();}();}();}();
[&](){
            auto temp=reader.getPNext();
            (result.pNext)=deserialize_struct(temp);
            }();
[&](){[&](){[&](){(result.underlyingAPI)=reader.getUnderlyingAPI();}();}();}();
return result;}

    void serialize_pUserData(stream::PUserData::Builder builder, VkPhysicalDeviceLayeredDriverPropertiesMSFT member){
    
[&](){
            if ((member.pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(member.pUserData).pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(member.pUserData).pUserData))+1);
        for(int lQswvtW=0; lQswvtW < strlen(((char*)(member.pUserData).pUserData))+1; lQswvtW++){
            [&](){return proto_arr.set(lQswvtW,(((char*)(member.pUserData).pUserData)[lQswvtW]));}();
        }
        }();}();
}

    void* deserialize_pUserData(stream::PUserData::Reader& reader, VkPhysicalDeviceLayeredDriverPropertiesMSFT member){
        #ifdef CLIENT
           void* pUserData;
           [&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_HQAruTK;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_HQAruTKpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int ytILVhn=0; ytILVhn < reader.getPUserData().size();; ytILVhn++){
            [&](){((temp_HQAruTKpUserData)[ytILVhn])=proto_arr[ytILVhn];}();
        }
        }();(pUserData)=temp_HQAruTK;}();
           return pUserData;
        #else
            auto result = new pUserData();
    
[&](){
            if (!reader.getPUserData().size()==0){
                (result.pUserData)=NULL;
            return; }char* temp_VSFonfu;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_VSFonfu.pUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int lQswvtW=0; lQswvtW < reader.getPUserData().size();; lQswvtW++){
            [&](){((temp_VSFonfu.pUserData)[lQswvtW])=proto_arr[lQswvtW];}();
        }
        }();(result.pUserData)=temp_VSFonfu;}();

    return result;
    #endif
    }
    
std::map<uintptr_t,PFN_vkInternalAllocationNotification> id_to_PFN_vkInternalAllocationNotification;

    void serialize_funcpointer(stream::PFNvkInternalAllocationNotification::Builder builder, PFN_vkInternalAllocationNotification build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkInternalAllocationNotification_wrapper( void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkInternalAllocationNotification();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){[&](){[&](){return builder.setAllocationType((allocationType));}();}();}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkInternalAllocationNotification );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkInternalAllocationNotification(); //Recieve response
        void result;
        
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
[&](){(size)=reader.getSize();}();
[&](){[&](){[&](){(allocationType)=reader.getAllocationType();}();}();}();
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();


        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkInternalAllocationNotification();
        
builder.setMem(0);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

        PFN_vkInternalAllocationNotification deserialize_funcpointer(stream::PFNvkInternalAllocationNotification::Reader reader){
            //Will only be called by the server
            
            return PFN_vkInternalAllocationNotification_wrapper;
            };
        

            void handle_PFN_vkInternalAllocationNotification_request(stream::PFNvkInternalAllocationNotification::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkInternalAllocationNotification wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkInternalAllocationNotification[reader.getId()];
        
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
size_t size;
[&](){(size)=reader.getSize();}();
VkInternalAllocationType allocationType;
[&](){[&](){[&](){(allocationType)=reader.getAllocationType();}();}();}();
VkSystemAllocationScope allocationScope;
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();
funcpointer(pUserData,size,allocationType,allocationScope);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkInternalAllocationNotification();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){[&](){[&](){return builder.setAllocationType((allocationType));}();}();}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();

writeToConn(m);
};
std::map<uintptr_t,PFN_vkInternalFreeNotification> id_to_PFN_vkInternalFreeNotification;

    void serialize_funcpointer(stream::PFNvkInternalFreeNotification::Builder builder, PFN_vkInternalFreeNotification build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkInternalFreeNotification_wrapper( void* pUserData, size_t size, VkInternalAllocationType allocationType, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkInternalFreeNotification();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){[&](){[&](){return builder.setAllocationType((allocationType));}();}();}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkInternalFreeNotification );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkInternalFreeNotification(); //Recieve response
        void result;
        
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
[&](){(size)=reader.getSize();}();
[&](){[&](){[&](){(allocationType)=reader.getAllocationType();}();}();}();
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();


        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkInternalFreeNotification();
        
builder.setMem(0);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

        PFN_vkInternalFreeNotification deserialize_funcpointer(stream::PFNvkInternalFreeNotification::Reader reader){
            //Will only be called by the server
            
            return PFN_vkInternalFreeNotification_wrapper;
            };
        

            void handle_PFN_vkInternalFreeNotification_request(stream::PFNvkInternalFreeNotification::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkInternalFreeNotification wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkInternalFreeNotification[reader.getId()];
        
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
size_t size;
[&](){(size)=reader.getSize();}();
VkInternalAllocationType allocationType;
[&](){[&](){[&](){(allocationType)=reader.getAllocationType();}();}();}();
VkSystemAllocationScope allocationScope;
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();
funcpointer(pUserData,size,allocationType,allocationScope);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkInternalFreeNotification();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){[&](){[&](){return builder.setAllocationType((allocationType));}();}();}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();

writeToConn(m);
};
std::map<uintptr_t,PFN_vkReallocationFunction> id_to_PFN_vkReallocationFunction;

    void serialize_funcpointer(stream::PFNvkReallocationFunction::Builder builder, PFN_vkReallocationFunction build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkReallocationFunction_wrapper( void* pUserData, void* pOriginal, size_t size, size_t alignment, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkReallocationFunction();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){
            if ((pOriginal)==NULL){
                builder.initPOriginal(0);
            return; }[&](){
            if (((char*)(pOriginal)pOriginal)==NULL){
                builder.initPOriginal(0);
            return; }
        auto proto_arr=builder.initPOriginal(strlen(((char*)(pOriginal)pOriginal))+1);
        for(int CPzsPmw=0; CPzsPmw < strlen(((char*)(pOriginal)pOriginal))+1; CPzsPmw++){
            [&](){return proto_arr.set(CPzsPmw,(((char*)(pOriginal)pOriginal)[CPzsPmw]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){return builder.setAlignment((alignment));}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkReallocationFunction );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkReallocationFunction(); //Recieve response
        void* result;
        
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
[&](){
            if (!reader.getPOriginal().size()==0){
                (pOriginal)=NULL;
            return; }char* temp_BtUlbYk;[&](){
            if (!reader.getPOriginal().size()==0){
                (temp_BtUlbYkpOriginal)=NULL;
            return; }
        auto proto_arr=reader.getPOriginal(reader.getPOriginal().size(););
        for(int CPzsPmw=0; CPzsPmw < reader.getPOriginal().size();; CPzsPmw++){
            [&](){((temp_BtUlbYkpOriginal)[CPzsPmw])=proto_arr[CPzsPmw];}();
        }
        }();(pOriginal)=temp_BtUlbYk;}();
[&](){(size)=reader.getSize();}();
[&](){(alignment)=reader.getAlignment();}();
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();
[&](){
            if (!reader.getResult().size()==0){
                (result)=NULL;
            return; }char* temp_GeEjtBo;[&](){
            if (!reader.getResult().size()==0){
                (temp_GeEjtBoresult)=NULL;
            return; }
        auto proto_arr=reader.getResult(reader.getResult().size(););
        for(int OCljRPK=0; OCljRPK < reader.getResult().size();; OCljRPK++){
            [&](){((temp_GeEjtBoresult)[OCljRPK])=proto_arr[OCljRPK];}();
        }
        }();(result)=temp_GeEjtBo;}();

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkReallocationFunction();
        
registerAllocatedMem(result,size);
builder.setMem((uintptr_t)result);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

        PFN_vkReallocationFunction deserialize_funcpointer(stream::PFNvkReallocationFunction::Reader reader){
            //Will only be called by the server
            
            return PFN_vkReallocationFunction_wrapper;
            };
        

            void handle_PFN_vkReallocationFunction_request(stream::PFNvkReallocationFunction::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkReallocationFunction wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkReallocationFunction[reader.getId()];
        
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
void* pOriginal;
[&](){
            if (!reader.getPOriginal().size()==0){
                (pOriginal)=NULL;
            return; }char* temp_BtUlbYk;[&](){
            if (!reader.getPOriginal().size()==0){
                (temp_BtUlbYkpOriginal)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPOriginal().size();*sizeof(char));
        auto proto_arr=reader.getPOriginal(reader.getPOriginal().size(););
        for(int CPzsPmw=0; CPzsPmw < reader.getPOriginal().size();; CPzsPmw++){
            [&](){((temp_BtUlbYkpOriginal)[CPzsPmw])=proto_arr[CPzsPmw];}();
        }
        }();(pOriginal)=temp_BtUlbYk;}();
size_t size;
[&](){(size)=reader.getSize();}();
size_t alignment;
[&](){(alignment)=reader.getAlignment();}();
VkSystemAllocationScope allocationScope;
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();
auto result=funcpointer(pUserData,pOriginal,size,alignment,allocationScope);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkReallocationFunction();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){
            if ((pOriginal)==NULL){
                builder.initPOriginal(0);
            return; }[&](){
            if (((char*)(pOriginal)pOriginal)==NULL){
                builder.initPOriginal(0);
            return; }
        auto proto_arr=builder.initPOriginal(strlen(((char*)(pOriginal)pOriginal))+1);
        for(int CPzsPmw=0; CPzsPmw < strlen(((char*)(pOriginal)pOriginal))+1; CPzsPmw++){
            [&](){return proto_arr.set(CPzsPmw,(((char*)(pOriginal)pOriginal)[CPzsPmw]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){return builder.setAlignment((alignment));}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();
[&](){
            if (!builder.getResult().size()==0){
                (result)=NULL;
            return; }char* temp_GeEjtBo;[&](){
            if (!builder.getResult().size()==0){
                (temp_GeEjtBoresult)=NULL;
            return; }
        auto proto_arr=builder.getResult(builder.getResult().size(););
        for(int OCljRPK=0; OCljRPK < builder.getResult().size();; OCljRPK++){
            [&](){((temp_GeEjtBoresult)[OCljRPK])=proto_arr[OCljRPK];}();
        }
        }();(result)=temp_GeEjtBo;}();
writeToConn(m);

            auto reader=readFromConn().getPFN_vkReallocationFunction();
            registerClientServerMemoryMapping((uintptr_t)result, (uintptr_t)(reader.getId()) );
            
            MallocMessageBuilder m;
            auto message=m.initRoot<Message>();
            auto builder=message.initPFN_vkReallocationFunction();
            writeConn(m); //Send empty message to signal to the server the mapping is done.
            
};
std::map<uintptr_t,PFN_vkAllocationFunction> id_to_PFN_vkAllocationFunction;

    void serialize_funcpointer(stream::PFNvkAllocationFunction::Builder builder, PFN_vkAllocationFunction build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkAllocationFunction_wrapper( void* pUserData, size_t size, size_t alignment, VkSystemAllocationScope allocationScope){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkAllocationFunction();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){return builder.setAlignment((alignment));}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkAllocationFunction );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkAllocationFunction(); //Recieve response
        void* result;
        
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
[&](){(size)=reader.getSize();}();
[&](){(alignment)=reader.getAlignment();}();
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();
[&](){
            if (!reader.getResult().size()==0){
                (result)=NULL;
            return; }char* temp_RzbVuEQ;[&](){
            if (!reader.getResult().size()==0){
                (temp_RzbVuEQresult)=NULL;
            return; }
        auto proto_arr=reader.getResult(size);
        for(int xALmVrM=0; xALmVrM < size; xALmVrM++){
            [&](){((temp_RzbVuEQresult)[xALmVrM])=proto_arr[xALmVrM];}();
        }
        }();(result)=temp_RzbVuEQ;}();

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkAllocationFunction();
        
registerAllocatedMem(result,size);
builder.setMem((uintptr_t)result);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

        PFN_vkAllocationFunction deserialize_funcpointer(stream::PFNvkAllocationFunction::Reader reader){
            //Will only be called by the server
            
            return PFN_vkAllocationFunction_wrapper;
            };
        

            void handle_PFN_vkAllocationFunction_request(stream::PFNvkAllocationFunction::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkAllocationFunction wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkAllocationFunction[reader.getId()];
        
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
size_t size;
[&](){(size)=reader.getSize();}();
size_t alignment;
[&](){(alignment)=reader.getAlignment();}();
VkSystemAllocationScope allocationScope;
[&](){[&](){[&](){(allocationScope)=reader.getAllocationScope();}();}();}();
auto result=funcpointer(pUserData,size,alignment,allocationScope);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkAllocationFunction();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){return builder.setSize((size));}();
[&](){return builder.setAlignment((alignment));}();
[&](){[&](){[&](){return builder.setAllocationScope((allocationScope));}();}();}();
[&](){
            if (!builder.getResult().size()==0){
                (result)=NULL;
            return; }char* temp_RzbVuEQ;[&](){
            if (!builder.getResult().size()==0){
                (temp_RzbVuEQresult)=NULL;
            return; }
        auto proto_arr=builder.getResult(size);
        for(int xALmVrM=0; xALmVrM < size; xALmVrM++){
            [&](){((temp_RzbVuEQresult)[xALmVrM])=proto_arr[xALmVrM];}();
        }
        }();(result)=temp_RzbVuEQ;}();
writeToConn(m);

            auto reader=readFromConn().getPFN_vkAllocationFunction();
            registerClientServerMemoryMapping((uintptr_t)result, (uintptr_t)(reader.getId()) );
            
            MallocMessageBuilder m;
            auto message=m.initRoot<Message>();
            auto builder=message.initPFN_vkAllocationFunction();
            writeConn(m); //Send empty message to signal to the server the mapping is done.
            
};
std::map<uintptr_t,PFN_vkFreeFunction> id_to_PFN_vkFreeFunction;

    void serialize_funcpointer(stream::PFNvkFreeFunction::Builder builder, PFN_vkFreeFunction build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkFreeFunction_wrapper( void* pUserData, void* pMemory){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkFreeFunction();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){
            if ((pMemory)==NULL){
                builder.initPMemory(0);
            return; }[&](){
            if (((char*)(pMemory)pMemory)==NULL){
                builder.initPMemory(0);
            return; }
        auto proto_arr=builder.initPMemory(strlen(((char*)(pMemory)pMemory))+1);
        for(int jqNEFTO=0; jqNEFTO < strlen(((char*)(pMemory)pMemory))+1; jqNEFTO++){
            [&](){return proto_arr.set(jqNEFTO,(((char*)(pMemory)pMemory)[jqNEFTO]));}();
        }
        }();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkFreeFunction );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkFreeFunction(); //Recieve response
        void result;
        
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
[&](){
            if (!reader.getPMemory().size()==0){
                (pMemory)=NULL;
            return; }char* temp_FMDOOHC;[&](){
            if (!reader.getPMemory().size()==0){
                (temp_FMDOOHCpMemory)=NULL;
            return; }
        auto proto_arr=reader.getPMemory(reader.getPMemory().size(););
        for(int jqNEFTO=0; jqNEFTO < reader.getPMemory().size();; jqNEFTO++){
            [&](){((temp_FMDOOHCpMemory)[jqNEFTO])=proto_arr[jqNEFTO];}();
        }
        }();(pMemory)=temp_FMDOOHC;}();


        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkFreeFunction();
        
builder.setMem(0);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

        PFN_vkFreeFunction deserialize_funcpointer(stream::PFNvkFreeFunction::Reader reader){
            //Will only be called by the server
            
            return PFN_vkFreeFunction_wrapper;
            };
        

            void handle_PFN_vkFreeFunction_request(stream::PFNvkFreeFunction::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkFreeFunction wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkFreeFunction[reader.getId()];
        
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
void* pMemory;
[&](){
            if (!reader.getPMemory().size()==0){
                (pMemory)=NULL;
            return; }char* temp_FMDOOHC;[&](){
            if (!reader.getPMemory().size()==0){
                (temp_FMDOOHCpMemory)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPMemory().size();*sizeof(char));
        auto proto_arr=reader.getPMemory(reader.getPMemory().size(););
        for(int jqNEFTO=0; jqNEFTO < reader.getPMemory().size();; jqNEFTO++){
            [&](){((temp_FMDOOHCpMemory)[jqNEFTO])=proto_arr[jqNEFTO];}();
        }
        }();(pMemory)=temp_FMDOOHC;}();
funcpointer(pUserData,pMemory);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkFreeFunction();
        
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){
            if ((pMemory)==NULL){
                builder.initPMemory(0);
            return; }[&](){
            if (((char*)(pMemory)pMemory)==NULL){
                builder.initPMemory(0);
            return; }
        auto proto_arr=builder.initPMemory(strlen(((char*)(pMemory)pMemory))+1);
        for(int jqNEFTO=0; jqNEFTO < strlen(((char*)(pMemory)pMemory))+1; jqNEFTO++){
            [&](){return proto_arr.set(jqNEFTO,(((char*)(pMemory)pMemory)[jqNEFTO]));}();
        }
        }();}();

writeToConn(m);
};
std::map<uintptr_t,PFN_vkDebugReportCallbackEXT> id_to_PFN_vkDebugReportCallbackEXT;

    void serialize_funcpointer(stream::PFNvkDebugReportCallbackEXT::Builder builder, PFN_vkDebugReportCallbackEXT build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkDebugReportCallbackEXT_wrapper( VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage, void* pUserData){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDebugReportCallbackEXT();
        
[&](){[&](){[&](){return builder.setFlags((flags));}();}();}();
[&](){[&](){[&](){return builder.setObjectType((objectType));}();}();}();
[&](){return builder.setObject((object));}();
[&](){return builder.setLocation((location));}();
[&](){return builder.setMessageCode((messageCode));}();
[&](){
            if ((pLayerPrefix)==NULL){
                builder.initPLayerPrefix(0);
            return; }
        auto proto_arr=builder.initPLayerPrefix(strlen((pLayerPrefix))+1);
        for(int EvbekCn=0; EvbekCn < strlen((pLayerPrefix))+1; EvbekCn++){
            [&](){return proto_arr.set(EvbekCn,((pLayerPrefix)[EvbekCn]));}();
        }
        }();
[&](){
            if ((pMessage)==NULL){
                builder.initPMessage(0);
            return; }
        auto proto_arr=builder.initPMessage(strlen((pMessage))+1);
        for(int zqBMvjH=0; zqBMvjH < strlen((pMessage))+1; zqBMvjH++){
            [&](){return proto_arr.set(zqBMvjH,((pMessage)[zqBMvjH]));}();
        }
        }();
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkDebugReportCallbackEXT );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkDebugReportCallbackEXT(); //Recieve response
        VkBool32 result;
        
[&](){[&](){[&](){(flags)=reader.getFlags();}();}();}();
[&](){[&](){[&](){(objectType)=reader.getObjectType();}();}();}();
[&](){(object)=reader.getObject();}();
[&](){(location)=reader.getLocation();}();
[&](){(messageCode)=reader.getMessageCode();}();


[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
[&](){[&](){(result)=reader.getResult();}();}();

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDebugReportCallbackEXT();
        
builder.setMem(0);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

        PFN_vkDebugReportCallbackEXT deserialize_funcpointer(stream::PFNvkDebugReportCallbackEXT::Reader reader){
            //Will only be called by the server
            
            return PFN_vkDebugReportCallbackEXT_wrapper;
            };
        

            void handle_PFN_vkDebugReportCallbackEXT_request(stream::PFNvkDebugReportCallbackEXT::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkDebugReportCallbackEXT wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkDebugReportCallbackEXT[reader.getId()];
        
VkDebugReportFlagsEXT flags;
[&](){[&](){[&](){(flags)=reader.getFlags();}();}();}();
VkDebugReportObjectTypeEXT objectType;
[&](){[&](){[&](){(objectType)=reader.getObjectType();}();}();}();
uint64_t object;
[&](){(object)=reader.getObject();}();
size_t location;
[&](){(location)=reader.getLocation();}();
int32_t messageCode;
[&](){(messageCode)=reader.getMessageCode();}();
const char* pLayerPrefix;
[&](){ char* temp_QPuseiC[&](){
            if (!reader.getPLayerPrefix().size()==0){
                (pLayerPrefix)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPLayerPrefix().size();*sizeof(char));
        auto proto_arr=reader.getPLayerPrefix(reader.getPLayerPrefix().size(););
        for(int pFiaGQG=0; pFiaGQG < reader.getPLayerPrefix().size();; pFiaGQG++){
            [&](){((pLayerPrefix)[pFiaGQG])=proto_arr[pFiaGQG];}();
        }
        }();(pLayerPrefix)=temp_QPuseiC;}();
const char* pMessage;
[&](){ char* temp_apslgql[&](){
            if (!reader.getPMessage().size()==0){
                (pMessage)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPMessage().size();*sizeof(char));
        auto proto_arr=reader.getPMessage(reader.getPMessage().size(););
        for(int oUIcmMP=0; oUIcmMP < reader.getPMessage().size();; oUIcmMP++){
            [&](){((pMessage)[oUIcmMP])=proto_arr[oUIcmMP];}();
        }
        }();(pMessage)=temp_apslgql;}();
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
auto result=funcpointer(flags,objectType,object,location,messageCode,pLayerPrefix,pMessage,pUserData);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDebugReportCallbackEXT();
        
[&](){[&](){[&](){return builder.setFlags((flags));}();}();}();
[&](){[&](){[&](){return builder.setObjectType((objectType));}();}();}();
[&](){return builder.setObject((object));}();
[&](){return builder.setLocation((location));}();
[&](){return builder.setMessageCode((messageCode));}();
[&](){
            if ((pLayerPrefix)==NULL){
                builder.initPLayerPrefix(0);
            return; }
        auto proto_arr=builder.initPLayerPrefix(strlen((pLayerPrefix))+1);
        for(int EvbekCn=0; EvbekCn < strlen((pLayerPrefix))+1; EvbekCn++){
            [&](){return proto_arr.set(EvbekCn,((pLayerPrefix)[EvbekCn]));}();
        }
        }();
[&](){
            if ((pMessage)==NULL){
                builder.initPMessage(0);
            return; }
        auto proto_arr=builder.initPMessage(strlen((pMessage))+1);
        for(int zqBMvjH=0; zqBMvjH < strlen((pMessage))+1; zqBMvjH++){
            [&](){return proto_arr.set(zqBMvjH,((pMessage)[zqBMvjH]));}();
        }
        }();
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){[&](){(result)=builder.getResult();}();}();
writeToConn(m);
};
std::map<uintptr_t,PFN_vkDebugUtilsMessengerCallbackEXT> id_to_PFN_vkDebugUtilsMessengerCallbackEXT;

    void serialize_funcpointer(stream::PFNvkDebugUtilsMessengerCallbackEXT::Builder builder, PFN_vkDebugUtilsMessengerCallbackEXT build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkDebugUtilsMessengerCallbackEXT_wrapper( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDebugUtilsMessengerCallbackEXT();
        
[&](){[&](){[&](){return builder.setMessageSeverity((messageSeverity));}();}();}();
[&](){[&](){[&](){return builder.setMessageTypes((messageTypes));}();}();}();
[&](){
            if ((pCallbackData)==NULL){
                builder.initPCallbackData(0);
            return; }
        auto proto_arr=builder.initPCallbackData(1);
        for(int SAnJMKd=0; SAnJMKd < 1; SAnJMKd++){
            [&](){
            auto temp=proto_arr[SAnJMKd];
            return serialize_struct(temp, ((pCallbackData)[SAnJMKd]));
            }();
        }
        }();
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkDebugUtilsMessengerCallbackEXT );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkDebugUtilsMessengerCallbackEXT(); //Recieve response
        VkBool32 result;
        
[&](){[&](){[&](){(messageSeverity)=reader.getMessageSeverity();}();}();}();
[&](){[&](){[&](){(messageTypes)=reader.getMessageTypes();}();}();}();

[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
[&](){[&](){(result)=reader.getResult();}();}();

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDebugUtilsMessengerCallbackEXT();
        
builder.setMem(0);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return result;
}

        PFN_vkDebugUtilsMessengerCallbackEXT deserialize_funcpointer(stream::PFNvkDebugUtilsMessengerCallbackEXT::Reader reader){
            //Will only be called by the server
            
            return PFN_vkDebugUtilsMessengerCallbackEXT_wrapper;
            };
        

            void handle_PFN_vkDebugUtilsMessengerCallbackEXT_request(stream::PFNvkDebugUtilsMessengerCallbackEXT::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkDebugUtilsMessengerCallbackEXT wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkDebugUtilsMessengerCallbackEXT[reader.getId()];
        
VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
[&](){[&](){[&](){(messageSeverity)=reader.getMessageSeverity();}();}();}();
VkDebugUtilsMessageTypeFlagsEXT messageTypes;
[&](){[&](){[&](){(messageTypes)=reader.getMessageTypes();}();}();}();
const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData;
[&](){ VkDebugUtilsMessengerCallbackDataEXT* temp_IuzNdgl[&](){
            if (!reader.getPCallbackData().size()==0){
                (pCallbackData)=NULL;
            return; }{native_concat()}=(VkDebugUtilsMessengerCallbackDataEXT*)malloc(1*sizeof(VkDebugUtilsMessengerCallbackDataEXT));
        auto proto_arr=reader.getPCallbackData(1);
        for(int JIoxlDg=0; JIoxlDg < 1; JIoxlDg++){
            [&](){
            auto temp=proto_arr[JIoxlDg];
            ((pCallbackData)[JIoxlDg])=deserialize_struct(temp);
            }();
        }
        }();(pCallbackData)=temp_IuzNdgl;}();
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
auto result=funcpointer(messageSeverity,messageTypes,pCallbackData,pUserData);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDebugUtilsMessengerCallbackEXT();
        
[&](){[&](){[&](){return builder.setMessageSeverity((messageSeverity));}();}();}();
[&](){[&](){[&](){return builder.setMessageTypes((messageTypes));}();}();}();
[&](){
            if ((pCallbackData)==NULL){
                builder.initPCallbackData(0);
            return; }
        auto proto_arr=builder.initPCallbackData(1);
        for(int SAnJMKd=0; SAnJMKd < 1; SAnJMKd++){
            [&](){
            auto temp=proto_arr[SAnJMKd];
            return serialize_struct(temp, ((pCallbackData)[SAnJMKd]));
            }();
        }
        }();
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();
[&](){[&](){(result)=builder.getResult();}();}();
writeToConn(m);
};
std::map<uintptr_t,PFN_vkDeviceMemoryReportCallbackEXT> id_to_PFN_vkDeviceMemoryReportCallbackEXT;

    void serialize_funcpointer(stream::PFNvkDeviceMemoryReportCallbackEXT::Builder builder, PFN_vkDeviceMemoryReportCallbackEXT build){
        //Will only be called by the client
        return;
    }
    

        auto PFN_vkDeviceMemoryReportCallbackEXT_wrapper( const VkDeviceMemoryReportCallbackDataEXT* pCallbackData, void* pUserData){
        //Will only be called by the server
        
        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDeviceMemoryReportCallbackEXT();
        
[&](){
            if ((pCallbackData)==NULL){
                builder.initPCallbackData(0);
            return; }
        auto proto_arr=builder.initPCallbackData(1);
        for(int visaHGl=0; visaHGl < 1; visaHGl++){
            [&](){
            auto temp=proto_arr[visaHGl];
            return serialize_struct(temp, ((pCallbackData)[visaHGl]));
            }();
        }
        }();
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();

        builder.setId( ((pUserData*)pUserData)->PFN_vkDeviceMemoryReportCallbackEXT );
        writeToConn(m); //Send request
        auto reader=readFromConn().getPFN_vkDeviceMemoryReportCallbackEXT(); //Recieve response
        void result;
        

[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();


        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDeviceMemoryReportCallbackEXT();
        
builder.setMem(0);

        writeToConn(m); //Send (possible) memory to client so it can store it
        readFromConn(); //Get the confirmation that the client has registered the memory
        
SyncAllocations();
return;
}

        PFN_vkDeviceMemoryReportCallbackEXT deserialize_funcpointer(stream::PFNvkDeviceMemoryReportCallbackEXT::Reader reader){
            //Will only be called by the server
            
            return PFN_vkDeviceMemoryReportCallbackEXT_wrapper;
            };
        

            void handle_PFN_vkDeviceMemoryReportCallbackEXT_request(stream::PFNvkDeviceMemoryReportCallbackEXT::Reader reader){
            //Will only be called by the client
            // Recieved data from server's PFN_vkDeviceMemoryReportCallbackEXT wrapper, and will execute the actual function
            auto funcpointer=id_to_PFN_vkDeviceMemoryReportCallbackEXT[reader.getId()];
        
const VkDeviceMemoryReportCallbackDataEXT* pCallbackData;
[&](){ VkDeviceMemoryReportCallbackDataEXT* temp_fgmmfZS[&](){
            if (!reader.getPCallbackData().size()==0){
                (pCallbackData)=NULL;
            return; }{native_concat()}=(VkDeviceMemoryReportCallbackDataEXT*)malloc(1*sizeof(VkDeviceMemoryReportCallbackDataEXT));
        auto proto_arr=reader.getPCallbackData(1);
        for(int bZjeYjg=0; bZjeYjg < 1; bZjeYjg++){
            [&](){
            auto temp=proto_arr[bZjeYjg];
            ((pCallbackData)[bZjeYjg])=deserialize_struct(temp);
            }();
        }
        }();(pCallbackData)=temp_fgmmfZS;}();
void* pUserData;
[&](){
            if (!reader.getPUserData().size()==0){
                (pUserData)=NULL;
            return; }char* temp_jKUCByC;[&](){
            if (!reader.getPUserData().size()==0){
                (temp_jKUCByCpUserData)=NULL;
            return; }{native_concat()}=(char*)malloc(reader.getPUserData().size();*sizeof(char));
        auto proto_arr=reader.getPUserData(reader.getPUserData().size(););
        for(int GzbOwAQ=0; GzbOwAQ < reader.getPUserData().size();; GzbOwAQ++){
            [&](){((temp_jKUCByCpUserData)[GzbOwAQ])=proto_arr[GzbOwAQ];}();
        }
        }();(pUserData)=temp_jKUCByC;}();
funcpointer(pCallbackData,pUserData);

        MallocMessageBuilder m;
        auto message=m.initRoot<Message>();
        auto builder=message.initPFN_vkDeviceMemoryReportCallbackEXT();
        
[&](){
            if ((pCallbackData)==NULL){
                builder.initPCallbackData(0);
            return; }
        auto proto_arr=builder.initPCallbackData(1);
        for(int visaHGl=0; visaHGl < 1; visaHGl++){
            [&](){
            auto temp=proto_arr[visaHGl];
            return serialize_struct(temp, ((pCallbackData)[visaHGl]));
            }();
        }
        }();
[&](){
            if ((pUserData)==NULL){
                builder.initPUserData(0);
            return; }[&](){
            if (((char*)(pUserData)pUserData)==NULL){
                builder.initPUserData(0);
            return; }
        auto proto_arr=builder.initPUserData(strlen(((char*)(pUserData)pUserData))+1);
        for(int GzbOwAQ=0; GzbOwAQ < strlen(((char*)(pUserData)pUserData))+1; GzbOwAQ++){
            [&](){return proto_arr.set(GzbOwAQ,(((char*)(pUserData)pUserData)[GzbOwAQ]));}();
        }
        }();}();

writeToConn(m);
};
std::map<uintptr_t,PFN_vkGetInstanceProcAddrLUNARG> id_to_PFN_vkGetInstanceProcAddrLUNARG;

    void serialize_funcpointer(stream::PFNvkGetInstanceProcAddrLUNARG::Builder builder, PFN_vkGetInstanceProcAddrLUNARG build){
        //Will only be called by the client
        return;
    }
    

        PFN_vkGetInstanceProcAddrLUNARG deserialize_funcpointer(stream::PFNvkGetInstanceProcAddrLUNARG::Reader reader){
            //Will only be called by the server
            
            return vkGetInstanceProcAddr;
            };
        

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkInstance_to_server_VkInstance;
            std::map<uintptr_t,uintptr_t> server_VkInstance_to_client_VkInstance;
            
        #endif
        

        uintptr_t serialize_handle(VkInstance data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkInstance_to_server_VkInstance.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkInstance %p not found!\n",data);
                    }
                     debug_printf("Serializing VkInstance %p...\n",(VkInstance)client_VkInstance_to_server_VkInstance[(uintptr_t)data]);
                    result=client_VkInstance_to_server_VkInstance[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkInstance deserialize_VkInstance(uintptr_t data){
                VkInstance result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkInstance)data);
                    if (server_VkInstance_to_client_VkInstance.contains(data)){
                        result=(VkInstance)server_VkInstance_to_client_VkInstance[data];
                        debug_printf("Deserializing to VkInstance %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkInstance));
                        debug_printf("Mapping to VkInstance %p...\n",handle);
                        server_VkInstance_to_client_VkInstance[data]=(uintptr_t)handle;
                        client_VkInstance_to_server_VkInstance[(uintptr_t)handle]=data;
                        
                        result=(VkInstance)handle; //This is highly dangerous -- I'm basically casting VkInstance* to VkInstance. I should do *((VkInstance*)alloc_icd_object())
                    }
                #else
                    result=(VkInstance)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPhysicalDevice_to_server_VkPhysicalDevice;
            std::map<uintptr_t,uintptr_t> server_VkPhysicalDevice_to_client_VkPhysicalDevice;
            
        #endif
        

        uintptr_t serialize_handle(VkPhysicalDevice data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPhysicalDevice_to_server_VkPhysicalDevice.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPhysicalDevice %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPhysicalDevice %p...\n",(VkPhysicalDevice)client_VkPhysicalDevice_to_server_VkPhysicalDevice[(uintptr_t)data]);
                    result=client_VkPhysicalDevice_to_server_VkPhysicalDevice[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkPhysicalDevice deserialize_VkPhysicalDevice(uintptr_t data){
                VkPhysicalDevice result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPhysicalDevice)data);
                    if (server_VkPhysicalDevice_to_client_VkPhysicalDevice.contains(data)){
                        result=(VkPhysicalDevice)server_VkPhysicalDevice_to_client_VkPhysicalDevice[data];
                        debug_printf("Deserializing to VkPhysicalDevice %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPhysicalDevice));
                        debug_printf("Mapping to VkPhysicalDevice %p...\n",handle);
                        server_VkPhysicalDevice_to_client_VkPhysicalDevice[data]=(uintptr_t)handle;
                        client_VkPhysicalDevice_to_server_VkPhysicalDevice[(uintptr_t)handle]=data;
                        
                        result=(VkPhysicalDevice)handle; //This is highly dangerous -- I'm basically casting VkPhysicalDevice* to VkPhysicalDevice. I should do *((VkPhysicalDevice*)alloc_icd_object())
                    }
                #else
                    result=(VkPhysicalDevice)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDevice_to_server_VkDevice;
            std::map<uintptr_t,uintptr_t> server_VkDevice_to_client_VkDevice;
            
        #endif
        

        uintptr_t serialize_handle(VkDevice data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDevice_to_server_VkDevice.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDevice %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDevice %p...\n",(VkDevice)client_VkDevice_to_server_VkDevice[(uintptr_t)data]);
                    result=client_VkDevice_to_server_VkDevice[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDevice deserialize_VkDevice(uintptr_t data){
                VkDevice result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDevice)data);
                    if (server_VkDevice_to_client_VkDevice.contains(data)){
                        result=(VkDevice)server_VkDevice_to_client_VkDevice[data];
                        debug_printf("Deserializing to VkDevice %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDevice));
                        debug_printf("Mapping to VkDevice %p...\n",handle);
                        server_VkDevice_to_client_VkDevice[data]=(uintptr_t)handle;
                        client_VkDevice_to_server_VkDevice[(uintptr_t)handle]=data;
                        
                        result=(VkDevice)handle; //This is highly dangerous -- I'm basically casting VkDevice* to VkDevice. I should do *((VkDevice*)alloc_icd_object())
                    }
                #else
                    result=(VkDevice)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkQueue_to_server_VkQueue;
            std::map<uintptr_t,uintptr_t> server_VkQueue_to_client_VkQueue;
            
        #endif
        

        uintptr_t serialize_handle(VkQueue data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkQueue_to_server_VkQueue.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkQueue %p not found!\n",data);
                    }
                     debug_printf("Serializing VkQueue %p...\n",(VkQueue)client_VkQueue_to_server_VkQueue[(uintptr_t)data]);
                    result=client_VkQueue_to_server_VkQueue[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkQueue deserialize_VkQueue(uintptr_t data){
                VkQueue result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkQueue)data);
                    if (server_VkQueue_to_client_VkQueue.contains(data)){
                        result=(VkQueue)server_VkQueue_to_client_VkQueue[data];
                        debug_printf("Deserializing to VkQueue %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkQueue));
                        debug_printf("Mapping to VkQueue %p...\n",handle);
                        server_VkQueue_to_client_VkQueue[data]=(uintptr_t)handle;
                        client_VkQueue_to_server_VkQueue[(uintptr_t)handle]=data;
                        
                        result=(VkQueue)handle; //This is highly dangerous -- I'm basically casting VkQueue* to VkQueue. I should do *((VkQueue*)alloc_icd_object())
                    }
                #else
                    result=(VkQueue)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCommandBuffer_to_server_VkCommandBuffer;
            std::map<uintptr_t,uintptr_t> server_VkCommandBuffer_to_client_VkCommandBuffer;
            
        #endif
        

        uintptr_t serialize_handle(VkCommandBuffer data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCommandBuffer_to_server_VkCommandBuffer.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCommandBuffer %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCommandBuffer %p...\n",(VkCommandBuffer)client_VkCommandBuffer_to_server_VkCommandBuffer[(uintptr_t)data]);
                    result=client_VkCommandBuffer_to_server_VkCommandBuffer[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkCommandBuffer deserialize_VkCommandBuffer(uintptr_t data){
                VkCommandBuffer result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCommandBuffer)data);
                    if (server_VkCommandBuffer_to_client_VkCommandBuffer.contains(data)){
                        result=(VkCommandBuffer)server_VkCommandBuffer_to_client_VkCommandBuffer[data];
                        debug_printf("Deserializing to VkCommandBuffer %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCommandBuffer));
                        debug_printf("Mapping to VkCommandBuffer %p...\n",handle);
                        server_VkCommandBuffer_to_client_VkCommandBuffer[data]=(uintptr_t)handle;
                        client_VkCommandBuffer_to_server_VkCommandBuffer[(uintptr_t)handle]=data;
                        
                        result=(VkCommandBuffer)handle; //This is highly dangerous -- I'm basically casting VkCommandBuffer* to VkCommandBuffer. I should do *((VkCommandBuffer*)alloc_icd_object())
                    }
                #else
                    result=(VkCommandBuffer)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDeviceMemory_to_server_VkDeviceMemory;
            std::map<uintptr_t,uintptr_t> server_VkDeviceMemory_to_client_VkDeviceMemory;
            
        #endif
        

        uintptr_t serialize_handle(VkDeviceMemory data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDeviceMemory_to_server_VkDeviceMemory.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDeviceMemory %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDeviceMemory %p...\n",(VkDeviceMemory)client_VkDeviceMemory_to_server_VkDeviceMemory[(uintptr_t)data]);
                    result=client_VkDeviceMemory_to_server_VkDeviceMemory[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDeviceMemory deserialize_VkDeviceMemory(uintptr_t data){
                VkDeviceMemory result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDeviceMemory)data);
                    if (server_VkDeviceMemory_to_client_VkDeviceMemory.contains(data)){
                        result=(VkDeviceMemory)server_VkDeviceMemory_to_client_VkDeviceMemory[data];
                        debug_printf("Deserializing to VkDeviceMemory %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDeviceMemory));
                        debug_printf("Mapping to VkDeviceMemory %p...\n",handle);
                        server_VkDeviceMemory_to_client_VkDeviceMemory[data]=(uintptr_t)handle;
                        client_VkDeviceMemory_to_server_VkDeviceMemory[(uintptr_t)handle]=data;
                        
                        result=(VkDeviceMemory)handle; //This is highly dangerous -- I'm basically casting VkDeviceMemory* to VkDeviceMemory. I should do *((VkDeviceMemory*)alloc_icd_object())
                    }
                #else
                    result=(VkDeviceMemory)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCommandPool_to_server_VkCommandPool;
            std::map<uintptr_t,uintptr_t> server_VkCommandPool_to_client_VkCommandPool;
            
        #endif
        

        uintptr_t serialize_handle(VkCommandPool data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCommandPool_to_server_VkCommandPool.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCommandPool %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCommandPool %p...\n",(VkCommandPool)client_VkCommandPool_to_server_VkCommandPool[(uintptr_t)data]);
                    result=client_VkCommandPool_to_server_VkCommandPool[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkCommandPool deserialize_VkCommandPool(uintptr_t data){
                VkCommandPool result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCommandPool)data);
                    if (server_VkCommandPool_to_client_VkCommandPool.contains(data)){
                        result=(VkCommandPool)server_VkCommandPool_to_client_VkCommandPool[data];
                        debug_printf("Deserializing to VkCommandPool %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCommandPool));
                        debug_printf("Mapping to VkCommandPool %p...\n",handle);
                        server_VkCommandPool_to_client_VkCommandPool[data]=(uintptr_t)handle;
                        client_VkCommandPool_to_server_VkCommandPool[(uintptr_t)handle]=data;
                        
                        result=(VkCommandPool)handle; //This is highly dangerous -- I'm basically casting VkCommandPool* to VkCommandPool. I should do *((VkCommandPool*)alloc_icd_object())
                    }
                #else
                    result=(VkCommandPool)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkBuffer_to_server_VkBuffer;
            std::map<uintptr_t,uintptr_t> server_VkBuffer_to_client_VkBuffer;
            
        #endif
        

        uintptr_t serialize_handle(VkBuffer data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkBuffer_to_server_VkBuffer.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkBuffer %p not found!\n",data);
                    }
                     debug_printf("Serializing VkBuffer %p...\n",(VkBuffer)client_VkBuffer_to_server_VkBuffer[(uintptr_t)data]);
                    result=client_VkBuffer_to_server_VkBuffer[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkBuffer deserialize_VkBuffer(uintptr_t data){
                VkBuffer result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkBuffer)data);
                    if (server_VkBuffer_to_client_VkBuffer.contains(data)){
                        result=(VkBuffer)server_VkBuffer_to_client_VkBuffer[data];
                        debug_printf("Deserializing to VkBuffer %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkBuffer));
                        debug_printf("Mapping to VkBuffer %p...\n",handle);
                        server_VkBuffer_to_client_VkBuffer[data]=(uintptr_t)handle;
                        client_VkBuffer_to_server_VkBuffer[(uintptr_t)handle]=data;
                        
                        result=(VkBuffer)handle; //This is highly dangerous -- I'm basically casting VkBuffer* to VkBuffer. I should do *((VkBuffer*)alloc_icd_object())
                    }
                #else
                    result=(VkBuffer)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkBufferView_to_server_VkBufferView;
            std::map<uintptr_t,uintptr_t> server_VkBufferView_to_client_VkBufferView;
            
        #endif
        

        uintptr_t serialize_handle(VkBufferView data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkBufferView_to_server_VkBufferView.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkBufferView %p not found!\n",data);
                    }
                     debug_printf("Serializing VkBufferView %p...\n",(VkBufferView)client_VkBufferView_to_server_VkBufferView[(uintptr_t)data]);
                    result=client_VkBufferView_to_server_VkBufferView[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkBufferView deserialize_VkBufferView(uintptr_t data){
                VkBufferView result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkBufferView)data);
                    if (server_VkBufferView_to_client_VkBufferView.contains(data)){
                        result=(VkBufferView)server_VkBufferView_to_client_VkBufferView[data];
                        debug_printf("Deserializing to VkBufferView %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkBufferView));
                        debug_printf("Mapping to VkBufferView %p...\n",handle);
                        server_VkBufferView_to_client_VkBufferView[data]=(uintptr_t)handle;
                        client_VkBufferView_to_server_VkBufferView[(uintptr_t)handle]=data;
                        
                        result=(VkBufferView)handle; //This is highly dangerous -- I'm basically casting VkBufferView* to VkBufferView. I should do *((VkBufferView*)alloc_icd_object())
                    }
                #else
                    result=(VkBufferView)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkImage_to_server_VkImage;
            std::map<uintptr_t,uintptr_t> server_VkImage_to_client_VkImage;
            
        #endif
        

        uintptr_t serialize_handle(VkImage data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkImage_to_server_VkImage.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkImage %p not found!\n",data);
                    }
                     debug_printf("Serializing VkImage %p...\n",(VkImage)client_VkImage_to_server_VkImage[(uintptr_t)data]);
                    result=client_VkImage_to_server_VkImage[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkImage deserialize_VkImage(uintptr_t data){
                VkImage result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkImage)data);
                    if (server_VkImage_to_client_VkImage.contains(data)){
                        result=(VkImage)server_VkImage_to_client_VkImage[data];
                        debug_printf("Deserializing to VkImage %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkImage));
                        debug_printf("Mapping to VkImage %p...\n",handle);
                        server_VkImage_to_client_VkImage[data]=(uintptr_t)handle;
                        client_VkImage_to_server_VkImage[(uintptr_t)handle]=data;
                        
                        result=(VkImage)handle; //This is highly dangerous -- I'm basically casting VkImage* to VkImage. I should do *((VkImage*)alloc_icd_object())
                    }
                #else
                    result=(VkImage)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkImageView_to_server_VkImageView;
            std::map<uintptr_t,uintptr_t> server_VkImageView_to_client_VkImageView;
            
        #endif
        

        uintptr_t serialize_handle(VkImageView data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkImageView_to_server_VkImageView.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkImageView %p not found!\n",data);
                    }
                     debug_printf("Serializing VkImageView %p...\n",(VkImageView)client_VkImageView_to_server_VkImageView[(uintptr_t)data]);
                    result=client_VkImageView_to_server_VkImageView[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkImageView deserialize_VkImageView(uintptr_t data){
                VkImageView result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkImageView)data);
                    if (server_VkImageView_to_client_VkImageView.contains(data)){
                        result=(VkImageView)server_VkImageView_to_client_VkImageView[data];
                        debug_printf("Deserializing to VkImageView %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkImageView));
                        debug_printf("Mapping to VkImageView %p...\n",handle);
                        server_VkImageView_to_client_VkImageView[data]=(uintptr_t)handle;
                        client_VkImageView_to_server_VkImageView[(uintptr_t)handle]=data;
                        
                        result=(VkImageView)handle; //This is highly dangerous -- I'm basically casting VkImageView* to VkImageView. I should do *((VkImageView*)alloc_icd_object())
                    }
                #else
                    result=(VkImageView)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkShaderModule_to_server_VkShaderModule;
            std::map<uintptr_t,uintptr_t> server_VkShaderModule_to_client_VkShaderModule;
            
        #endif
        

        uintptr_t serialize_handle(VkShaderModule data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkShaderModule_to_server_VkShaderModule.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkShaderModule %p not found!\n",data);
                    }
                     debug_printf("Serializing VkShaderModule %p...\n",(VkShaderModule)client_VkShaderModule_to_server_VkShaderModule[(uintptr_t)data]);
                    result=client_VkShaderModule_to_server_VkShaderModule[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkShaderModule deserialize_VkShaderModule(uintptr_t data){
                VkShaderModule result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkShaderModule)data);
                    if (server_VkShaderModule_to_client_VkShaderModule.contains(data)){
                        result=(VkShaderModule)server_VkShaderModule_to_client_VkShaderModule[data];
                        debug_printf("Deserializing to VkShaderModule %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkShaderModule));
                        debug_printf("Mapping to VkShaderModule %p...\n",handle);
                        server_VkShaderModule_to_client_VkShaderModule[data]=(uintptr_t)handle;
                        client_VkShaderModule_to_server_VkShaderModule[(uintptr_t)handle]=data;
                        
                        result=(VkShaderModule)handle; //This is highly dangerous -- I'm basically casting VkShaderModule* to VkShaderModule. I should do *((VkShaderModule*)alloc_icd_object())
                    }
                #else
                    result=(VkShaderModule)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPipeline_to_server_VkPipeline;
            std::map<uintptr_t,uintptr_t> server_VkPipeline_to_client_VkPipeline;
            
        #endif
        

        uintptr_t serialize_handle(VkPipeline data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPipeline_to_server_VkPipeline.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPipeline %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPipeline %p...\n",(VkPipeline)client_VkPipeline_to_server_VkPipeline[(uintptr_t)data]);
                    result=client_VkPipeline_to_server_VkPipeline[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkPipeline deserialize_VkPipeline(uintptr_t data){
                VkPipeline result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPipeline)data);
                    if (server_VkPipeline_to_client_VkPipeline.contains(data)){
                        result=(VkPipeline)server_VkPipeline_to_client_VkPipeline[data];
                        debug_printf("Deserializing to VkPipeline %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPipeline));
                        debug_printf("Mapping to VkPipeline %p...\n",handle);
                        server_VkPipeline_to_client_VkPipeline[data]=(uintptr_t)handle;
                        client_VkPipeline_to_server_VkPipeline[(uintptr_t)handle]=data;
                        
                        result=(VkPipeline)handle; //This is highly dangerous -- I'm basically casting VkPipeline* to VkPipeline. I should do *((VkPipeline*)alloc_icd_object())
                    }
                #else
                    result=(VkPipeline)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPipelineLayout_to_server_VkPipelineLayout;
            std::map<uintptr_t,uintptr_t> server_VkPipelineLayout_to_client_VkPipelineLayout;
            
        #endif
        

        uintptr_t serialize_handle(VkPipelineLayout data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPipelineLayout_to_server_VkPipelineLayout.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPipelineLayout %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPipelineLayout %p...\n",(VkPipelineLayout)client_VkPipelineLayout_to_server_VkPipelineLayout[(uintptr_t)data]);
                    result=client_VkPipelineLayout_to_server_VkPipelineLayout[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkPipelineLayout deserialize_VkPipelineLayout(uintptr_t data){
                VkPipelineLayout result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPipelineLayout)data);
                    if (server_VkPipelineLayout_to_client_VkPipelineLayout.contains(data)){
                        result=(VkPipelineLayout)server_VkPipelineLayout_to_client_VkPipelineLayout[data];
                        debug_printf("Deserializing to VkPipelineLayout %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPipelineLayout));
                        debug_printf("Mapping to VkPipelineLayout %p...\n",handle);
                        server_VkPipelineLayout_to_client_VkPipelineLayout[data]=(uintptr_t)handle;
                        client_VkPipelineLayout_to_server_VkPipelineLayout[(uintptr_t)handle]=data;
                        
                        result=(VkPipelineLayout)handle; //This is highly dangerous -- I'm basically casting VkPipelineLayout* to VkPipelineLayout. I should do *((VkPipelineLayout*)alloc_icd_object())
                    }
                #else
                    result=(VkPipelineLayout)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSampler_to_server_VkSampler;
            std::map<uintptr_t,uintptr_t> server_VkSampler_to_client_VkSampler;
            
        #endif
        

        uintptr_t serialize_handle(VkSampler data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSampler_to_server_VkSampler.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSampler %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSampler %p...\n",(VkSampler)client_VkSampler_to_server_VkSampler[(uintptr_t)data]);
                    result=client_VkSampler_to_server_VkSampler[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkSampler deserialize_VkSampler(uintptr_t data){
                VkSampler result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSampler)data);
                    if (server_VkSampler_to_client_VkSampler.contains(data)){
                        result=(VkSampler)server_VkSampler_to_client_VkSampler[data];
                        debug_printf("Deserializing to VkSampler %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSampler));
                        debug_printf("Mapping to VkSampler %p...\n",handle);
                        server_VkSampler_to_client_VkSampler[data]=(uintptr_t)handle;
                        client_VkSampler_to_server_VkSampler[(uintptr_t)handle]=data;
                        
                        result=(VkSampler)handle; //This is highly dangerous -- I'm basically casting VkSampler* to VkSampler. I should do *((VkSampler*)alloc_icd_object())
                    }
                #else
                    result=(VkSampler)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorSet_to_server_VkDescriptorSet;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorSet_to_client_VkDescriptorSet;
            
        #endif
        

        uintptr_t serialize_handle(VkDescriptorSet data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorSet_to_server_VkDescriptorSet.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorSet %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorSet %p...\n",(VkDescriptorSet)client_VkDescriptorSet_to_server_VkDescriptorSet[(uintptr_t)data]);
                    result=client_VkDescriptorSet_to_server_VkDescriptorSet[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDescriptorSet deserialize_VkDescriptorSet(uintptr_t data){
                VkDescriptorSet result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorSet)data);
                    if (server_VkDescriptorSet_to_client_VkDescriptorSet.contains(data)){
                        result=(VkDescriptorSet)server_VkDescriptorSet_to_client_VkDescriptorSet[data];
                        debug_printf("Deserializing to VkDescriptorSet %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorSet));
                        debug_printf("Mapping to VkDescriptorSet %p...\n",handle);
                        server_VkDescriptorSet_to_client_VkDescriptorSet[data]=(uintptr_t)handle;
                        client_VkDescriptorSet_to_server_VkDescriptorSet[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorSet)handle; //This is highly dangerous -- I'm basically casting VkDescriptorSet* to VkDescriptorSet. I should do *((VkDescriptorSet*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorSet)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout;
            
        #endif
        

        uintptr_t serialize_handle(VkDescriptorSetLayout data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorSetLayout %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorSetLayout %p...\n",(VkDescriptorSetLayout)client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout[(uintptr_t)data]);
                    result=client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDescriptorSetLayout deserialize_VkDescriptorSetLayout(uintptr_t data){
                VkDescriptorSetLayout result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorSetLayout)data);
                    if (server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout.contains(data)){
                        result=(VkDescriptorSetLayout)server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout[data];
                        debug_printf("Deserializing to VkDescriptorSetLayout %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorSetLayout));
                        debug_printf("Mapping to VkDescriptorSetLayout %p...\n",handle);
                        server_VkDescriptorSetLayout_to_client_VkDescriptorSetLayout[data]=(uintptr_t)handle;
                        client_VkDescriptorSetLayout_to_server_VkDescriptorSetLayout[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorSetLayout)handle; //This is highly dangerous -- I'm basically casting VkDescriptorSetLayout* to VkDescriptorSetLayout. I should do *((VkDescriptorSetLayout*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorSetLayout)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorPool_to_server_VkDescriptorPool;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorPool_to_client_VkDescriptorPool;
            
        #endif
        

        uintptr_t serialize_handle(VkDescriptorPool data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorPool_to_server_VkDescriptorPool.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorPool %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorPool %p...\n",(VkDescriptorPool)client_VkDescriptorPool_to_server_VkDescriptorPool[(uintptr_t)data]);
                    result=client_VkDescriptorPool_to_server_VkDescriptorPool[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDescriptorPool deserialize_VkDescriptorPool(uintptr_t data){
                VkDescriptorPool result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorPool)data);
                    if (server_VkDescriptorPool_to_client_VkDescriptorPool.contains(data)){
                        result=(VkDescriptorPool)server_VkDescriptorPool_to_client_VkDescriptorPool[data];
                        debug_printf("Deserializing to VkDescriptorPool %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorPool));
                        debug_printf("Mapping to VkDescriptorPool %p...\n",handle);
                        server_VkDescriptorPool_to_client_VkDescriptorPool[data]=(uintptr_t)handle;
                        client_VkDescriptorPool_to_server_VkDescriptorPool[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorPool)handle; //This is highly dangerous -- I'm basically casting VkDescriptorPool* to VkDescriptorPool. I should do *((VkDescriptorPool*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorPool)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkFence_to_server_VkFence;
            std::map<uintptr_t,uintptr_t> server_VkFence_to_client_VkFence;
            
        #endif
        

        uintptr_t serialize_handle(VkFence data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkFence_to_server_VkFence.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkFence %p not found!\n",data);
                    }
                     debug_printf("Serializing VkFence %p...\n",(VkFence)client_VkFence_to_server_VkFence[(uintptr_t)data]);
                    result=client_VkFence_to_server_VkFence[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkFence deserialize_VkFence(uintptr_t data){
                VkFence result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkFence)data);
                    if (server_VkFence_to_client_VkFence.contains(data)){
                        result=(VkFence)server_VkFence_to_client_VkFence[data];
                        debug_printf("Deserializing to VkFence %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkFence));
                        debug_printf("Mapping to VkFence %p...\n",handle);
                        server_VkFence_to_client_VkFence[data]=(uintptr_t)handle;
                        client_VkFence_to_server_VkFence[(uintptr_t)handle]=data;
                        
                        result=(VkFence)handle; //This is highly dangerous -- I'm basically casting VkFence* to VkFence. I should do *((VkFence*)alloc_icd_object())
                    }
                #else
                    result=(VkFence)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSemaphore_to_server_VkSemaphore;
            std::map<uintptr_t,uintptr_t> server_VkSemaphore_to_client_VkSemaphore;
            
        #endif
        

        uintptr_t serialize_handle(VkSemaphore data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSemaphore_to_server_VkSemaphore.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSemaphore %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSemaphore %p...\n",(VkSemaphore)client_VkSemaphore_to_server_VkSemaphore[(uintptr_t)data]);
                    result=client_VkSemaphore_to_server_VkSemaphore[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkSemaphore deserialize_VkSemaphore(uintptr_t data){
                VkSemaphore result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSemaphore)data);
                    if (server_VkSemaphore_to_client_VkSemaphore.contains(data)){
                        result=(VkSemaphore)server_VkSemaphore_to_client_VkSemaphore[data];
                        debug_printf("Deserializing to VkSemaphore %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSemaphore));
                        debug_printf("Mapping to VkSemaphore %p...\n",handle);
                        server_VkSemaphore_to_client_VkSemaphore[data]=(uintptr_t)handle;
                        client_VkSemaphore_to_server_VkSemaphore[(uintptr_t)handle]=data;
                        
                        result=(VkSemaphore)handle; //This is highly dangerous -- I'm basically casting VkSemaphore* to VkSemaphore. I should do *((VkSemaphore*)alloc_icd_object())
                    }
                #else
                    result=(VkSemaphore)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkEvent_to_server_VkEvent;
            std::map<uintptr_t,uintptr_t> server_VkEvent_to_client_VkEvent;
            
        #endif
        

        uintptr_t serialize_handle(VkEvent data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkEvent_to_server_VkEvent.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkEvent %p not found!\n",data);
                    }
                     debug_printf("Serializing VkEvent %p...\n",(VkEvent)client_VkEvent_to_server_VkEvent[(uintptr_t)data]);
                    result=client_VkEvent_to_server_VkEvent[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkEvent deserialize_VkEvent(uintptr_t data){
                VkEvent result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkEvent)data);
                    if (server_VkEvent_to_client_VkEvent.contains(data)){
                        result=(VkEvent)server_VkEvent_to_client_VkEvent[data];
                        debug_printf("Deserializing to VkEvent %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkEvent));
                        debug_printf("Mapping to VkEvent %p...\n",handle);
                        server_VkEvent_to_client_VkEvent[data]=(uintptr_t)handle;
                        client_VkEvent_to_server_VkEvent[(uintptr_t)handle]=data;
                        
                        result=(VkEvent)handle; //This is highly dangerous -- I'm basically casting VkEvent* to VkEvent. I should do *((VkEvent*)alloc_icd_object())
                    }
                #else
                    result=(VkEvent)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkQueryPool_to_server_VkQueryPool;
            std::map<uintptr_t,uintptr_t> server_VkQueryPool_to_client_VkQueryPool;
            
        #endif
        

        uintptr_t serialize_handle(VkQueryPool data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkQueryPool_to_server_VkQueryPool.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkQueryPool %p not found!\n",data);
                    }
                     debug_printf("Serializing VkQueryPool %p...\n",(VkQueryPool)client_VkQueryPool_to_server_VkQueryPool[(uintptr_t)data]);
                    result=client_VkQueryPool_to_server_VkQueryPool[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkQueryPool deserialize_VkQueryPool(uintptr_t data){
                VkQueryPool result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkQueryPool)data);
                    if (server_VkQueryPool_to_client_VkQueryPool.contains(data)){
                        result=(VkQueryPool)server_VkQueryPool_to_client_VkQueryPool[data];
                        debug_printf("Deserializing to VkQueryPool %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkQueryPool));
                        debug_printf("Mapping to VkQueryPool %p...\n",handle);
                        server_VkQueryPool_to_client_VkQueryPool[data]=(uintptr_t)handle;
                        client_VkQueryPool_to_server_VkQueryPool[(uintptr_t)handle]=data;
                        
                        result=(VkQueryPool)handle; //This is highly dangerous -- I'm basically casting VkQueryPool* to VkQueryPool. I should do *((VkQueryPool*)alloc_icd_object())
                    }
                #else
                    result=(VkQueryPool)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkFramebuffer_to_server_VkFramebuffer;
            std::map<uintptr_t,uintptr_t> server_VkFramebuffer_to_client_VkFramebuffer;
            
        #endif
        

        uintptr_t serialize_handle(VkFramebuffer data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkFramebuffer_to_server_VkFramebuffer.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkFramebuffer %p not found!\n",data);
                    }
                     debug_printf("Serializing VkFramebuffer %p...\n",(VkFramebuffer)client_VkFramebuffer_to_server_VkFramebuffer[(uintptr_t)data]);
                    result=client_VkFramebuffer_to_server_VkFramebuffer[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkFramebuffer deserialize_VkFramebuffer(uintptr_t data){
                VkFramebuffer result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkFramebuffer)data);
                    if (server_VkFramebuffer_to_client_VkFramebuffer.contains(data)){
                        result=(VkFramebuffer)server_VkFramebuffer_to_client_VkFramebuffer[data];
                        debug_printf("Deserializing to VkFramebuffer %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkFramebuffer));
                        debug_printf("Mapping to VkFramebuffer %p...\n",handle);
                        server_VkFramebuffer_to_client_VkFramebuffer[data]=(uintptr_t)handle;
                        client_VkFramebuffer_to_server_VkFramebuffer[(uintptr_t)handle]=data;
                        
                        result=(VkFramebuffer)handle; //This is highly dangerous -- I'm basically casting VkFramebuffer* to VkFramebuffer. I should do *((VkFramebuffer*)alloc_icd_object())
                    }
                #else
                    result=(VkFramebuffer)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkRenderPass_to_server_VkRenderPass;
            std::map<uintptr_t,uintptr_t> server_VkRenderPass_to_client_VkRenderPass;
            
        #endif
        

        uintptr_t serialize_handle(VkRenderPass data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkRenderPass_to_server_VkRenderPass.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkRenderPass %p not found!\n",data);
                    }
                     debug_printf("Serializing VkRenderPass %p...\n",(VkRenderPass)client_VkRenderPass_to_server_VkRenderPass[(uintptr_t)data]);
                    result=client_VkRenderPass_to_server_VkRenderPass[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkRenderPass deserialize_VkRenderPass(uintptr_t data){
                VkRenderPass result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkRenderPass)data);
                    if (server_VkRenderPass_to_client_VkRenderPass.contains(data)){
                        result=(VkRenderPass)server_VkRenderPass_to_client_VkRenderPass[data];
                        debug_printf("Deserializing to VkRenderPass %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkRenderPass));
                        debug_printf("Mapping to VkRenderPass %p...\n",handle);
                        server_VkRenderPass_to_client_VkRenderPass[data]=(uintptr_t)handle;
                        client_VkRenderPass_to_server_VkRenderPass[(uintptr_t)handle]=data;
                        
                        result=(VkRenderPass)handle; //This is highly dangerous -- I'm basically casting VkRenderPass* to VkRenderPass. I should do *((VkRenderPass*)alloc_icd_object())
                    }
                #else
                    result=(VkRenderPass)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPipelineCache_to_server_VkPipelineCache;
            std::map<uintptr_t,uintptr_t> server_VkPipelineCache_to_client_VkPipelineCache;
            
        #endif
        

        uintptr_t serialize_handle(VkPipelineCache data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPipelineCache_to_server_VkPipelineCache.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPipelineCache %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPipelineCache %p...\n",(VkPipelineCache)client_VkPipelineCache_to_server_VkPipelineCache[(uintptr_t)data]);
                    result=client_VkPipelineCache_to_server_VkPipelineCache[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkPipelineCache deserialize_VkPipelineCache(uintptr_t data){
                VkPipelineCache result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPipelineCache)data);
                    if (server_VkPipelineCache_to_client_VkPipelineCache.contains(data)){
                        result=(VkPipelineCache)server_VkPipelineCache_to_client_VkPipelineCache[data];
                        debug_printf("Deserializing to VkPipelineCache %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPipelineCache));
                        debug_printf("Mapping to VkPipelineCache %p...\n",handle);
                        server_VkPipelineCache_to_client_VkPipelineCache[data]=(uintptr_t)handle;
                        client_VkPipelineCache_to_server_VkPipelineCache[(uintptr_t)handle]=data;
                        
                        result=(VkPipelineCache)handle; //This is highly dangerous -- I'm basically casting VkPipelineCache* to VkPipelineCache. I should do *((VkPipelineCache*)alloc_icd_object())
                    }
                #else
                    result=(VkPipelineCache)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV;
            std::map<uintptr_t,uintptr_t> server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV;
            
        #endif
        

        uintptr_t serialize_handle(VkIndirectCommandsLayoutNV data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkIndirectCommandsLayoutNV %p not found!\n",data);
                    }
                     debug_printf("Serializing VkIndirectCommandsLayoutNV %p...\n",(VkIndirectCommandsLayoutNV)client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV[(uintptr_t)data]);
                    result=client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkIndirectCommandsLayoutNV deserialize_VkIndirectCommandsLayoutNV(uintptr_t data){
                VkIndirectCommandsLayoutNV result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkIndirectCommandsLayoutNV)data);
                    if (server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV.contains(data)){
                        result=(VkIndirectCommandsLayoutNV)server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV[data];
                        debug_printf("Deserializing to VkIndirectCommandsLayoutNV %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkIndirectCommandsLayoutNV));
                        debug_printf("Mapping to VkIndirectCommandsLayoutNV %p...\n",handle);
                        server_VkIndirectCommandsLayoutNV_to_client_VkIndirectCommandsLayoutNV[data]=(uintptr_t)handle;
                        client_VkIndirectCommandsLayoutNV_to_server_VkIndirectCommandsLayoutNV[(uintptr_t)handle]=data;
                        
                        result=(VkIndirectCommandsLayoutNV)handle; //This is highly dangerous -- I'm basically casting VkIndirectCommandsLayoutNV* to VkIndirectCommandsLayoutNV. I should do *((VkIndirectCommandsLayoutNV*)alloc_icd_object())
                    }
                #else
                    result=(VkIndirectCommandsLayoutNV)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate;
            
        #endif
        

        uintptr_t serialize_handle(VkDescriptorUpdateTemplate data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorUpdateTemplate %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorUpdateTemplate %p...\n",(VkDescriptorUpdateTemplate)client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate[(uintptr_t)data]);
                    result=client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDescriptorUpdateTemplate deserialize_VkDescriptorUpdateTemplate(uintptr_t data){
                VkDescriptorUpdateTemplate result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorUpdateTemplate)data);
                    if (server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate.contains(data)){
                        result=(VkDescriptorUpdateTemplate)server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate[data];
                        debug_printf("Deserializing to VkDescriptorUpdateTemplate %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorUpdateTemplate));
                        debug_printf("Mapping to VkDescriptorUpdateTemplate %p...\n",handle);
                        server_VkDescriptorUpdateTemplate_to_client_VkDescriptorUpdateTemplate[data]=(uintptr_t)handle;
                        client_VkDescriptorUpdateTemplate_to_server_VkDescriptorUpdateTemplate[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorUpdateTemplate)handle; //This is highly dangerous -- I'm basically casting VkDescriptorUpdateTemplate* to VkDescriptorUpdateTemplate. I should do *((VkDescriptorUpdateTemplate*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorUpdateTemplate)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR;
            std::map<uintptr_t,uintptr_t> server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkDescriptorUpdateTemplateKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDescriptorUpdateTemplateKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDescriptorUpdateTemplateKHR %p...\n",(VkDescriptorUpdateTemplateKHR)client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR[(uintptr_t)data]);
                    result=client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDescriptorUpdateTemplateKHR deserialize_VkDescriptorUpdateTemplateKHR(uintptr_t data){
                VkDescriptorUpdateTemplateKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDescriptorUpdateTemplateKHR)data);
                    if (server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR.contains(data)){
                        result=(VkDescriptorUpdateTemplateKHR)server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR[data];
                        debug_printf("Deserializing to VkDescriptorUpdateTemplateKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDescriptorUpdateTemplateKHR));
                        debug_printf("Mapping to VkDescriptorUpdateTemplateKHR %p...\n",handle);
                        server_VkDescriptorUpdateTemplateKHR_to_client_VkDescriptorUpdateTemplateKHR[data]=(uintptr_t)handle;
                        client_VkDescriptorUpdateTemplateKHR_to_server_VkDescriptorUpdateTemplateKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDescriptorUpdateTemplateKHR)handle; //This is highly dangerous -- I'm basically casting VkDescriptorUpdateTemplateKHR* to VkDescriptorUpdateTemplateKHR. I should do *((VkDescriptorUpdateTemplateKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDescriptorUpdateTemplateKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion;
            std::map<uintptr_t,uintptr_t> server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion;
            
        #endif
        

        uintptr_t serialize_handle(VkSamplerYcbcrConversion data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSamplerYcbcrConversion %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSamplerYcbcrConversion %p...\n",(VkSamplerYcbcrConversion)client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion[(uintptr_t)data]);
                    result=client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkSamplerYcbcrConversion deserialize_VkSamplerYcbcrConversion(uintptr_t data){
                VkSamplerYcbcrConversion result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSamplerYcbcrConversion)data);
                    if (server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion.contains(data)){
                        result=(VkSamplerYcbcrConversion)server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion[data];
                        debug_printf("Deserializing to VkSamplerYcbcrConversion %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSamplerYcbcrConversion));
                        debug_printf("Mapping to VkSamplerYcbcrConversion %p...\n",handle);
                        server_VkSamplerYcbcrConversion_to_client_VkSamplerYcbcrConversion[data]=(uintptr_t)handle;
                        client_VkSamplerYcbcrConversion_to_server_VkSamplerYcbcrConversion[(uintptr_t)handle]=data;
                        
                        result=(VkSamplerYcbcrConversion)handle; //This is highly dangerous -- I'm basically casting VkSamplerYcbcrConversion* to VkSamplerYcbcrConversion. I should do *((VkSamplerYcbcrConversion*)alloc_icd_object())
                    }
                #else
                    result=(VkSamplerYcbcrConversion)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR;
            std::map<uintptr_t,uintptr_t> server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkSamplerYcbcrConversionKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSamplerYcbcrConversionKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSamplerYcbcrConversionKHR %p...\n",(VkSamplerYcbcrConversionKHR)client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR[(uintptr_t)data]);
                    result=client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkSamplerYcbcrConversionKHR deserialize_VkSamplerYcbcrConversionKHR(uintptr_t data){
                VkSamplerYcbcrConversionKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSamplerYcbcrConversionKHR)data);
                    if (server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR.contains(data)){
                        result=(VkSamplerYcbcrConversionKHR)server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR[data];
                        debug_printf("Deserializing to VkSamplerYcbcrConversionKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSamplerYcbcrConversionKHR));
                        debug_printf("Mapping to VkSamplerYcbcrConversionKHR %p...\n",handle);
                        server_VkSamplerYcbcrConversionKHR_to_client_VkSamplerYcbcrConversionKHR[data]=(uintptr_t)handle;
                        client_VkSamplerYcbcrConversionKHR_to_server_VkSamplerYcbcrConversionKHR[(uintptr_t)handle]=data;
                        
                        result=(VkSamplerYcbcrConversionKHR)handle; //This is highly dangerous -- I'm basically casting VkSamplerYcbcrConversionKHR* to VkSamplerYcbcrConversionKHR. I should do *((VkSamplerYcbcrConversionKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkSamplerYcbcrConversionKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkValidationCacheEXT_to_server_VkValidationCacheEXT;
            std::map<uintptr_t,uintptr_t> server_VkValidationCacheEXT_to_client_VkValidationCacheEXT;
            
        #endif
        

        uintptr_t serialize_handle(VkValidationCacheEXT data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkValidationCacheEXT_to_server_VkValidationCacheEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkValidationCacheEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkValidationCacheEXT %p...\n",(VkValidationCacheEXT)client_VkValidationCacheEXT_to_server_VkValidationCacheEXT[(uintptr_t)data]);
                    result=client_VkValidationCacheEXT_to_server_VkValidationCacheEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkValidationCacheEXT deserialize_VkValidationCacheEXT(uintptr_t data){
                VkValidationCacheEXT result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkValidationCacheEXT)data);
                    if (server_VkValidationCacheEXT_to_client_VkValidationCacheEXT.contains(data)){
                        result=(VkValidationCacheEXT)server_VkValidationCacheEXT_to_client_VkValidationCacheEXT[data];
                        debug_printf("Deserializing to VkValidationCacheEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkValidationCacheEXT));
                        debug_printf("Mapping to VkValidationCacheEXT %p...\n",handle);
                        server_VkValidationCacheEXT_to_client_VkValidationCacheEXT[data]=(uintptr_t)handle;
                        client_VkValidationCacheEXT_to_server_VkValidationCacheEXT[(uintptr_t)handle]=data;
                        
                        result=(VkValidationCacheEXT)handle; //This is highly dangerous -- I'm basically casting VkValidationCacheEXT* to VkValidationCacheEXT. I should do *((VkValidationCacheEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkValidationCacheEXT)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR;
            std::map<uintptr_t,uintptr_t> server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkAccelerationStructureKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkAccelerationStructureKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkAccelerationStructureKHR %p...\n",(VkAccelerationStructureKHR)client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR[(uintptr_t)data]);
                    result=client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkAccelerationStructureKHR deserialize_VkAccelerationStructureKHR(uintptr_t data){
                VkAccelerationStructureKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkAccelerationStructureKHR)data);
                    if (server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR.contains(data)){
                        result=(VkAccelerationStructureKHR)server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR[data];
                        debug_printf("Deserializing to VkAccelerationStructureKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkAccelerationStructureKHR));
                        debug_printf("Mapping to VkAccelerationStructureKHR %p...\n",handle);
                        server_VkAccelerationStructureKHR_to_client_VkAccelerationStructureKHR[data]=(uintptr_t)handle;
                        client_VkAccelerationStructureKHR_to_server_VkAccelerationStructureKHR[(uintptr_t)handle]=data;
                        
                        result=(VkAccelerationStructureKHR)handle; //This is highly dangerous -- I'm basically casting VkAccelerationStructureKHR* to VkAccelerationStructureKHR. I should do *((VkAccelerationStructureKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkAccelerationStructureKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV;
            std::map<uintptr_t,uintptr_t> server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV;
            
        #endif
        

        uintptr_t serialize_handle(VkAccelerationStructureNV data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkAccelerationStructureNV %p not found!\n",data);
                    }
                     debug_printf("Serializing VkAccelerationStructureNV %p...\n",(VkAccelerationStructureNV)client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV[(uintptr_t)data]);
                    result=client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkAccelerationStructureNV deserialize_VkAccelerationStructureNV(uintptr_t data){
                VkAccelerationStructureNV result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkAccelerationStructureNV)data);
                    if (server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV.contains(data)){
                        result=(VkAccelerationStructureNV)server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV[data];
                        debug_printf("Deserializing to VkAccelerationStructureNV %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkAccelerationStructureNV));
                        debug_printf("Mapping to VkAccelerationStructureNV %p...\n",handle);
                        server_VkAccelerationStructureNV_to_client_VkAccelerationStructureNV[data]=(uintptr_t)handle;
                        client_VkAccelerationStructureNV_to_server_VkAccelerationStructureNV[(uintptr_t)handle]=data;
                        
                        result=(VkAccelerationStructureNV)handle; //This is highly dangerous -- I'm basically casting VkAccelerationStructureNV* to VkAccelerationStructureNV. I should do *((VkAccelerationStructureNV*)alloc_icd_object())
                    }
                #else
                    result=(VkAccelerationStructureNV)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL;
            std::map<uintptr_t,uintptr_t> server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL;
            
        #endif
        

        uintptr_t serialize_handle(VkPerformanceConfigurationINTEL data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPerformanceConfigurationINTEL %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPerformanceConfigurationINTEL %p...\n",(VkPerformanceConfigurationINTEL)client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL[(uintptr_t)data]);
                    result=client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkPerformanceConfigurationINTEL deserialize_VkPerformanceConfigurationINTEL(uintptr_t data){
                VkPerformanceConfigurationINTEL result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPerformanceConfigurationINTEL)data);
                    if (server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL.contains(data)){
                        result=(VkPerformanceConfigurationINTEL)server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL[data];
                        debug_printf("Deserializing to VkPerformanceConfigurationINTEL %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPerformanceConfigurationINTEL));
                        debug_printf("Mapping to VkPerformanceConfigurationINTEL %p...\n",handle);
                        server_VkPerformanceConfigurationINTEL_to_client_VkPerformanceConfigurationINTEL[data]=(uintptr_t)handle;
                        client_VkPerformanceConfigurationINTEL_to_server_VkPerformanceConfigurationINTEL[(uintptr_t)handle]=data;
                        
                        result=(VkPerformanceConfigurationINTEL)handle; //This is highly dangerous -- I'm basically casting VkPerformanceConfigurationINTEL* to VkPerformanceConfigurationINTEL. I should do *((VkPerformanceConfigurationINTEL*)alloc_icd_object())
                    }
                #else
                    result=(VkPerformanceConfigurationINTEL)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR;
            std::map<uintptr_t,uintptr_t> server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkDeferredOperationKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDeferredOperationKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDeferredOperationKHR %p...\n",(VkDeferredOperationKHR)client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR[(uintptr_t)data]);
                    result=client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDeferredOperationKHR deserialize_VkDeferredOperationKHR(uintptr_t data){
                VkDeferredOperationKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDeferredOperationKHR)data);
                    if (server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR.contains(data)){
                        result=(VkDeferredOperationKHR)server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR[data];
                        debug_printf("Deserializing to VkDeferredOperationKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDeferredOperationKHR));
                        debug_printf("Mapping to VkDeferredOperationKHR %p...\n",handle);
                        server_VkDeferredOperationKHR_to_client_VkDeferredOperationKHR[data]=(uintptr_t)handle;
                        client_VkDeferredOperationKHR_to_server_VkDeferredOperationKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDeferredOperationKHR)handle; //This is highly dangerous -- I'm basically casting VkDeferredOperationKHR* to VkDeferredOperationKHR. I should do *((VkDeferredOperationKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDeferredOperationKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPrivateDataSlot_to_server_VkPrivateDataSlot;
            std::map<uintptr_t,uintptr_t> server_VkPrivateDataSlot_to_client_VkPrivateDataSlot;
            
        #endif
        

        uintptr_t serialize_handle(VkPrivateDataSlot data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPrivateDataSlot_to_server_VkPrivateDataSlot.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPrivateDataSlot %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPrivateDataSlot %p...\n",(VkPrivateDataSlot)client_VkPrivateDataSlot_to_server_VkPrivateDataSlot[(uintptr_t)data]);
                    result=client_VkPrivateDataSlot_to_server_VkPrivateDataSlot[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkPrivateDataSlot deserialize_VkPrivateDataSlot(uintptr_t data){
                VkPrivateDataSlot result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPrivateDataSlot)data);
                    if (server_VkPrivateDataSlot_to_client_VkPrivateDataSlot.contains(data)){
                        result=(VkPrivateDataSlot)server_VkPrivateDataSlot_to_client_VkPrivateDataSlot[data];
                        debug_printf("Deserializing to VkPrivateDataSlot %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPrivateDataSlot));
                        debug_printf("Mapping to VkPrivateDataSlot %p...\n",handle);
                        server_VkPrivateDataSlot_to_client_VkPrivateDataSlot[data]=(uintptr_t)handle;
                        client_VkPrivateDataSlot_to_server_VkPrivateDataSlot[(uintptr_t)handle]=data;
                        
                        result=(VkPrivateDataSlot)handle; //This is highly dangerous -- I'm basically casting VkPrivateDataSlot* to VkPrivateDataSlot. I should do *((VkPrivateDataSlot*)alloc_icd_object())
                    }
                #else
                    result=(VkPrivateDataSlot)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT;
            std::map<uintptr_t,uintptr_t> server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT;
            
        #endif
        

        uintptr_t serialize_handle(VkPrivateDataSlotEXT data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkPrivateDataSlotEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkPrivateDataSlotEXT %p...\n",(VkPrivateDataSlotEXT)client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT[(uintptr_t)data]);
                    result=client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkPrivateDataSlotEXT deserialize_VkPrivateDataSlotEXT(uintptr_t data){
                VkPrivateDataSlotEXT result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkPrivateDataSlotEXT)data);
                    if (server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT.contains(data)){
                        result=(VkPrivateDataSlotEXT)server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT[data];
                        debug_printf("Deserializing to VkPrivateDataSlotEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkPrivateDataSlotEXT));
                        debug_printf("Mapping to VkPrivateDataSlotEXT %p...\n",handle);
                        server_VkPrivateDataSlotEXT_to_client_VkPrivateDataSlotEXT[data]=(uintptr_t)handle;
                        client_VkPrivateDataSlotEXT_to_server_VkPrivateDataSlotEXT[(uintptr_t)handle]=data;
                        
                        result=(VkPrivateDataSlotEXT)handle; //This is highly dangerous -- I'm basically casting VkPrivateDataSlotEXT* to VkPrivateDataSlotEXT. I should do *((VkPrivateDataSlotEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkPrivateDataSlotEXT)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCuModuleNVX_to_server_VkCuModuleNVX;
            std::map<uintptr_t,uintptr_t> server_VkCuModuleNVX_to_client_VkCuModuleNVX;
            
        #endif
        

        uintptr_t serialize_handle(VkCuModuleNVX data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCuModuleNVX_to_server_VkCuModuleNVX.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCuModuleNVX %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCuModuleNVX %p...\n",(VkCuModuleNVX)client_VkCuModuleNVX_to_server_VkCuModuleNVX[(uintptr_t)data]);
                    result=client_VkCuModuleNVX_to_server_VkCuModuleNVX[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkCuModuleNVX deserialize_VkCuModuleNVX(uintptr_t data){
                VkCuModuleNVX result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCuModuleNVX)data);
                    if (server_VkCuModuleNVX_to_client_VkCuModuleNVX.contains(data)){
                        result=(VkCuModuleNVX)server_VkCuModuleNVX_to_client_VkCuModuleNVX[data];
                        debug_printf("Deserializing to VkCuModuleNVX %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCuModuleNVX));
                        debug_printf("Mapping to VkCuModuleNVX %p...\n",handle);
                        server_VkCuModuleNVX_to_client_VkCuModuleNVX[data]=(uintptr_t)handle;
                        client_VkCuModuleNVX_to_server_VkCuModuleNVX[(uintptr_t)handle]=data;
                        
                        result=(VkCuModuleNVX)handle; //This is highly dangerous -- I'm basically casting VkCuModuleNVX* to VkCuModuleNVX. I should do *((VkCuModuleNVX*)alloc_icd_object())
                    }
                #else
                    result=(VkCuModuleNVX)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkCuFunctionNVX_to_server_VkCuFunctionNVX;
            std::map<uintptr_t,uintptr_t> server_VkCuFunctionNVX_to_client_VkCuFunctionNVX;
            
        #endif
        

        uintptr_t serialize_handle(VkCuFunctionNVX data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkCuFunctionNVX_to_server_VkCuFunctionNVX.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkCuFunctionNVX %p not found!\n",data);
                    }
                     debug_printf("Serializing VkCuFunctionNVX %p...\n",(VkCuFunctionNVX)client_VkCuFunctionNVX_to_server_VkCuFunctionNVX[(uintptr_t)data]);
                    result=client_VkCuFunctionNVX_to_server_VkCuFunctionNVX[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkCuFunctionNVX deserialize_VkCuFunctionNVX(uintptr_t data){
                VkCuFunctionNVX result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkCuFunctionNVX)data);
                    if (server_VkCuFunctionNVX_to_client_VkCuFunctionNVX.contains(data)){
                        result=(VkCuFunctionNVX)server_VkCuFunctionNVX_to_client_VkCuFunctionNVX[data];
                        debug_printf("Deserializing to VkCuFunctionNVX %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkCuFunctionNVX));
                        debug_printf("Mapping to VkCuFunctionNVX %p...\n",handle);
                        server_VkCuFunctionNVX_to_client_VkCuFunctionNVX[data]=(uintptr_t)handle;
                        client_VkCuFunctionNVX_to_server_VkCuFunctionNVX[(uintptr_t)handle]=data;
                        
                        result=(VkCuFunctionNVX)handle; //This is highly dangerous -- I'm basically casting VkCuFunctionNVX* to VkCuFunctionNVX. I should do *((VkCuFunctionNVX*)alloc_icd_object())
                    }
                #else
                    result=(VkCuFunctionNVX)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV;
            std::map<uintptr_t,uintptr_t> server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV;
            
        #endif
        

        uintptr_t serialize_handle(VkOpticalFlowSessionNV data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkOpticalFlowSessionNV %p not found!\n",data);
                    }
                     debug_printf("Serializing VkOpticalFlowSessionNV %p...\n",(VkOpticalFlowSessionNV)client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV[(uintptr_t)data]);
                    result=client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkOpticalFlowSessionNV deserialize_VkOpticalFlowSessionNV(uintptr_t data){
                VkOpticalFlowSessionNV result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkOpticalFlowSessionNV)data);
                    if (server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV.contains(data)){
                        result=(VkOpticalFlowSessionNV)server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV[data];
                        debug_printf("Deserializing to VkOpticalFlowSessionNV %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkOpticalFlowSessionNV));
                        debug_printf("Mapping to VkOpticalFlowSessionNV %p...\n",handle);
                        server_VkOpticalFlowSessionNV_to_client_VkOpticalFlowSessionNV[data]=(uintptr_t)handle;
                        client_VkOpticalFlowSessionNV_to_server_VkOpticalFlowSessionNV[(uintptr_t)handle]=data;
                        
                        result=(VkOpticalFlowSessionNV)handle; //This is highly dangerous -- I'm basically casting VkOpticalFlowSessionNV* to VkOpticalFlowSessionNV. I should do *((VkOpticalFlowSessionNV*)alloc_icd_object())
                    }
                #else
                    result=(VkOpticalFlowSessionNV)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkMicromapEXT_to_server_VkMicromapEXT;
            std::map<uintptr_t,uintptr_t> server_VkMicromapEXT_to_client_VkMicromapEXT;
            
        #endif
        

        uintptr_t serialize_handle(VkMicromapEXT data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkMicromapEXT_to_server_VkMicromapEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkMicromapEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkMicromapEXT %p...\n",(VkMicromapEXT)client_VkMicromapEXT_to_server_VkMicromapEXT[(uintptr_t)data]);
                    result=client_VkMicromapEXT_to_server_VkMicromapEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkMicromapEXT deserialize_VkMicromapEXT(uintptr_t data){
                VkMicromapEXT result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkMicromapEXT)data);
                    if (server_VkMicromapEXT_to_client_VkMicromapEXT.contains(data)){
                        result=(VkMicromapEXT)server_VkMicromapEXT_to_client_VkMicromapEXT[data];
                        debug_printf("Deserializing to VkMicromapEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkMicromapEXT));
                        debug_printf("Mapping to VkMicromapEXT %p...\n",handle);
                        server_VkMicromapEXT_to_client_VkMicromapEXT[data]=(uintptr_t)handle;
                        client_VkMicromapEXT_to_server_VkMicromapEXT[(uintptr_t)handle]=data;
                        
                        result=(VkMicromapEXT)handle; //This is highly dangerous -- I'm basically casting VkMicromapEXT* to VkMicromapEXT. I should do *((VkMicromapEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkMicromapEXT)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkShaderEXT_to_server_VkShaderEXT;
            std::map<uintptr_t,uintptr_t> server_VkShaderEXT_to_client_VkShaderEXT;
            
        #endif
        

        uintptr_t serialize_handle(VkShaderEXT data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkShaderEXT_to_server_VkShaderEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkShaderEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkShaderEXT %p...\n",(VkShaderEXT)client_VkShaderEXT_to_server_VkShaderEXT[(uintptr_t)data]);
                    result=client_VkShaderEXT_to_server_VkShaderEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkShaderEXT deserialize_VkShaderEXT(uintptr_t data){
                VkShaderEXT result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkShaderEXT)data);
                    if (server_VkShaderEXT_to_client_VkShaderEXT.contains(data)){
                        result=(VkShaderEXT)server_VkShaderEXT_to_client_VkShaderEXT[data];
                        debug_printf("Deserializing to VkShaderEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkShaderEXT));
                        debug_printf("Mapping to VkShaderEXT %p...\n",handle);
                        server_VkShaderEXT_to_client_VkShaderEXT[data]=(uintptr_t)handle;
                        client_VkShaderEXT_to_server_VkShaderEXT[(uintptr_t)handle]=data;
                        
                        result=(VkShaderEXT)handle; //This is highly dangerous -- I'm basically casting VkShaderEXT* to VkShaderEXT. I should do *((VkShaderEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkShaderEXT)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDisplayKHR_to_server_VkDisplayKHR;
            std::map<uintptr_t,uintptr_t> server_VkDisplayKHR_to_client_VkDisplayKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkDisplayKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDisplayKHR_to_server_VkDisplayKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDisplayKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDisplayKHR %p...\n",(VkDisplayKHR)client_VkDisplayKHR_to_server_VkDisplayKHR[(uintptr_t)data]);
                    result=client_VkDisplayKHR_to_server_VkDisplayKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDisplayKHR deserialize_VkDisplayKHR(uintptr_t data){
                VkDisplayKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDisplayKHR)data);
                    if (server_VkDisplayKHR_to_client_VkDisplayKHR.contains(data)){
                        result=(VkDisplayKHR)server_VkDisplayKHR_to_client_VkDisplayKHR[data];
                        debug_printf("Deserializing to VkDisplayKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDisplayKHR));
                        debug_printf("Mapping to VkDisplayKHR %p...\n",handle);
                        server_VkDisplayKHR_to_client_VkDisplayKHR[data]=(uintptr_t)handle;
                        client_VkDisplayKHR_to_server_VkDisplayKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDisplayKHR)handle; //This is highly dangerous -- I'm basically casting VkDisplayKHR* to VkDisplayKHR. I should do *((VkDisplayKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDisplayKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDisplayModeKHR_to_server_VkDisplayModeKHR;
            std::map<uintptr_t,uintptr_t> server_VkDisplayModeKHR_to_client_VkDisplayModeKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkDisplayModeKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDisplayModeKHR_to_server_VkDisplayModeKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDisplayModeKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDisplayModeKHR %p...\n",(VkDisplayModeKHR)client_VkDisplayModeKHR_to_server_VkDisplayModeKHR[(uintptr_t)data]);
                    result=client_VkDisplayModeKHR_to_server_VkDisplayModeKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDisplayModeKHR deserialize_VkDisplayModeKHR(uintptr_t data){
                VkDisplayModeKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDisplayModeKHR)data);
                    if (server_VkDisplayModeKHR_to_client_VkDisplayModeKHR.contains(data)){
                        result=(VkDisplayModeKHR)server_VkDisplayModeKHR_to_client_VkDisplayModeKHR[data];
                        debug_printf("Deserializing to VkDisplayModeKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDisplayModeKHR));
                        debug_printf("Mapping to VkDisplayModeKHR %p...\n",handle);
                        server_VkDisplayModeKHR_to_client_VkDisplayModeKHR[data]=(uintptr_t)handle;
                        client_VkDisplayModeKHR_to_server_VkDisplayModeKHR[(uintptr_t)handle]=data;
                        
                        result=(VkDisplayModeKHR)handle; //This is highly dangerous -- I'm basically casting VkDisplayModeKHR* to VkDisplayModeKHR. I should do *((VkDisplayModeKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkDisplayModeKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSurfaceKHR_to_server_VkSurfaceKHR;
            std::map<uintptr_t,uintptr_t> server_VkSurfaceKHR_to_client_VkSurfaceKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkSurfaceKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSurfaceKHR_to_server_VkSurfaceKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSurfaceKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSurfaceKHR %p...\n",(VkSurfaceKHR)client_VkSurfaceKHR_to_server_VkSurfaceKHR[(uintptr_t)data]);
                    result=client_VkSurfaceKHR_to_server_VkSurfaceKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkSurfaceKHR deserialize_VkSurfaceKHR(uintptr_t data){
                VkSurfaceKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSurfaceKHR)data);
                    if (server_VkSurfaceKHR_to_client_VkSurfaceKHR.contains(data)){
                        result=(VkSurfaceKHR)server_VkSurfaceKHR_to_client_VkSurfaceKHR[data];
                        debug_printf("Deserializing to VkSurfaceKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSurfaceKHR));
                        debug_printf("Mapping to VkSurfaceKHR %p...\n",handle);
                        server_VkSurfaceKHR_to_client_VkSurfaceKHR[data]=(uintptr_t)handle;
                        client_VkSurfaceKHR_to_server_VkSurfaceKHR[(uintptr_t)handle]=data;
                        
                        result=(VkSurfaceKHR)handle; //This is highly dangerous -- I'm basically casting VkSurfaceKHR* to VkSurfaceKHR. I should do *((VkSurfaceKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkSurfaceKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkSwapchainKHR_to_server_VkSwapchainKHR;
            std::map<uintptr_t,uintptr_t> server_VkSwapchainKHR_to_client_VkSwapchainKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkSwapchainKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkSwapchainKHR_to_server_VkSwapchainKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkSwapchainKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkSwapchainKHR %p...\n",(VkSwapchainKHR)client_VkSwapchainKHR_to_server_VkSwapchainKHR[(uintptr_t)data]);
                    result=client_VkSwapchainKHR_to_server_VkSwapchainKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkSwapchainKHR deserialize_VkSwapchainKHR(uintptr_t data){
                VkSwapchainKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkSwapchainKHR)data);
                    if (server_VkSwapchainKHR_to_client_VkSwapchainKHR.contains(data)){
                        result=(VkSwapchainKHR)server_VkSwapchainKHR_to_client_VkSwapchainKHR[data];
                        debug_printf("Deserializing to VkSwapchainKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkSwapchainKHR));
                        debug_printf("Mapping to VkSwapchainKHR %p...\n",handle);
                        server_VkSwapchainKHR_to_client_VkSwapchainKHR[data]=(uintptr_t)handle;
                        client_VkSwapchainKHR_to_server_VkSwapchainKHR[(uintptr_t)handle]=data;
                        
                        result=(VkSwapchainKHR)handle; //This is highly dangerous -- I'm basically casting VkSwapchainKHR* to VkSwapchainKHR. I should do *((VkSwapchainKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkSwapchainKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT;
            std::map<uintptr_t,uintptr_t> server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT;
            
        #endif
        

        uintptr_t serialize_handle(VkDebugReportCallbackEXT data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDebugReportCallbackEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDebugReportCallbackEXT %p...\n",(VkDebugReportCallbackEXT)client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT[(uintptr_t)data]);
                    result=client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDebugReportCallbackEXT deserialize_VkDebugReportCallbackEXT(uintptr_t data){
                VkDebugReportCallbackEXT result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDebugReportCallbackEXT)data);
                    if (server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT.contains(data)){
                        result=(VkDebugReportCallbackEXT)server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT[data];
                        debug_printf("Deserializing to VkDebugReportCallbackEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDebugReportCallbackEXT));
                        debug_printf("Mapping to VkDebugReportCallbackEXT %p...\n",handle);
                        server_VkDebugReportCallbackEXT_to_client_VkDebugReportCallbackEXT[data]=(uintptr_t)handle;
                        client_VkDebugReportCallbackEXT_to_server_VkDebugReportCallbackEXT[(uintptr_t)handle]=data;
                        
                        result=(VkDebugReportCallbackEXT)handle; //This is highly dangerous -- I'm basically casting VkDebugReportCallbackEXT* to VkDebugReportCallbackEXT. I should do *((VkDebugReportCallbackEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkDebugReportCallbackEXT)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT;
            std::map<uintptr_t,uintptr_t> server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT;
            
        #endif
        

        uintptr_t serialize_handle(VkDebugUtilsMessengerEXT data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkDebugUtilsMessengerEXT %p not found!\n",data);
                    }
                     debug_printf("Serializing VkDebugUtilsMessengerEXT %p...\n",(VkDebugUtilsMessengerEXT)client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT[(uintptr_t)data]);
                    result=client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkDebugUtilsMessengerEXT deserialize_VkDebugUtilsMessengerEXT(uintptr_t data){
                VkDebugUtilsMessengerEXT result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkDebugUtilsMessengerEXT)data);
                    if (server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT.contains(data)){
                        result=(VkDebugUtilsMessengerEXT)server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT[data];
                        debug_printf("Deserializing to VkDebugUtilsMessengerEXT %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkDebugUtilsMessengerEXT));
                        debug_printf("Mapping to VkDebugUtilsMessengerEXT %p...\n",handle);
                        server_VkDebugUtilsMessengerEXT_to_client_VkDebugUtilsMessengerEXT[data]=(uintptr_t)handle;
                        client_VkDebugUtilsMessengerEXT_to_server_VkDebugUtilsMessengerEXT[(uintptr_t)handle]=data;
                        
                        result=(VkDebugUtilsMessengerEXT)handle; //This is highly dangerous -- I'm basically casting VkDebugUtilsMessengerEXT* to VkDebugUtilsMessengerEXT. I should do *((VkDebugUtilsMessengerEXT*)alloc_icd_object())
                    }
                #else
                    result=(VkDebugUtilsMessengerEXT)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkVideoSessionKHR_to_server_VkVideoSessionKHR;
            std::map<uintptr_t,uintptr_t> server_VkVideoSessionKHR_to_client_VkVideoSessionKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkVideoSessionKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkVideoSessionKHR_to_server_VkVideoSessionKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkVideoSessionKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkVideoSessionKHR %p...\n",(VkVideoSessionKHR)client_VkVideoSessionKHR_to_server_VkVideoSessionKHR[(uintptr_t)data]);
                    result=client_VkVideoSessionKHR_to_server_VkVideoSessionKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkVideoSessionKHR deserialize_VkVideoSessionKHR(uintptr_t data){
                VkVideoSessionKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkVideoSessionKHR)data);
                    if (server_VkVideoSessionKHR_to_client_VkVideoSessionKHR.contains(data)){
                        result=(VkVideoSessionKHR)server_VkVideoSessionKHR_to_client_VkVideoSessionKHR[data];
                        debug_printf("Deserializing to VkVideoSessionKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkVideoSessionKHR));
                        debug_printf("Mapping to VkVideoSessionKHR %p...\n",handle);
                        server_VkVideoSessionKHR_to_client_VkVideoSessionKHR[data]=(uintptr_t)handle;
                        client_VkVideoSessionKHR_to_server_VkVideoSessionKHR[(uintptr_t)handle]=data;
                        
                        result=(VkVideoSessionKHR)handle; //This is highly dangerous -- I'm basically casting VkVideoSessionKHR* to VkVideoSessionKHR. I should do *((VkVideoSessionKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkVideoSessionKHR)data;
                #endif
                
                return result;
       }

        #ifdef CLIENT
            std::map<uintptr_t,uintptr_t> client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR;
            std::map<uintptr_t,uintptr_t> server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR;
            
        #endif
        

        uintptr_t serialize_handle(VkVideoSessionParametersKHR data){
            uintptr_t result;
            #ifdef CLIENT
                if (data==NULL){
                    result=(uintptr_t)NULL;
                    debug_printf("Handle is NULL, serializing to %p...\n",result);
                }else{
                    if(!(client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR.contains( (uintptr_t)data ))){
                        debug_printf("Panic: VkVideoSessionParametersKHR %p not found!\n",data);
                    }
                     debug_printf("Serializing VkVideoSessionParametersKHR %p...\n",(VkVideoSessionParametersKHR)client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR[(uintptr_t)data]);
                    result=client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR[(uintptr_t)data];
                }
            #else
                result=(uintptr_t)data;
            #endif
        

            return result;
        }
       

       VkVideoSessionParametersKHR deserialize_VkVideoSessionParametersKHR(uintptr_t data){
                VkVideoSessionParametersKHR result;
                #ifdef CLIENT
                    debug_printf("Handling server pointer %p:\n",(VkVideoSessionParametersKHR)data);
                    if (server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR.contains(data)){
                        result=(VkVideoSessionParametersKHR)server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR[data];
                        debug_printf("Deserializing to VkVideoSessionParametersKHR %p...\n",result);
                    }else{
                        auto handle=malloc(sizeof(VkVideoSessionParametersKHR));
                        debug_printf("Mapping to VkVideoSessionParametersKHR %p...\n",handle);
                        server_VkVideoSessionParametersKHR_to_client_VkVideoSessionParametersKHR[data]=(uintptr_t)handle;
                        client_VkVideoSessionParametersKHR_to_server_VkVideoSessionParametersKHR[(uintptr_t)handle]=data;
                        
                        result=(VkVideoSessionParametersKHR)handle; //This is highly dangerous -- I'm basically casting VkVideoSessionParametersKHR* to VkVideoSessionParametersKHR. I should do *((VkVideoSessionParametersKHR*)alloc_icd_object())
                    }
                #else
                    result=(VkVideoSessionParametersKHR)data;
                #endif
                
                return result;
       }
